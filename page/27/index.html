<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/page/27/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/page/27/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/07/10/TIME_WAIT存在的作用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/10/TIME_WAIT存在的作用/" itemprop="url">TIME_WAIT存在的作用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-10T12:12:57+08:00">
                2019-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/Linux/Tcp/" itemprop="url" rel="index">
                    <span itemprop="name">Tcp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="TIME-WAIT存在的作用"><a href="#TIME-WAIT存在的作用" class="headerlink" title="TIME_WAIT存在的作用"></a>TIME_WAIT存在的作用</h1><p>主动关闭方: A 被动关闭方: B</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A在发送完对于B的FIN报文的确认报文<code>ACK</code>之后, 会进入<code>TIME_WAIT</code>状态; 但是网络环境会存在丢包的情况, 那么当主动关闭一方对于<strong>被动关闭一方的<code>FIN</code>确认报文<code>ACK</code>在网络中丢失</strong>的时候。为了能够让客户机 服务器两边的连接最终都处于<code>CLOSED</code>状态来释放文件数以及网络连接标识资源, 就需要有<code>TIME_WAIT</code>这种机制来保证。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么我们看一下<code>TIME_WAIT</code>是如何保证两边都能够进入<code>CLOSED</code>状态的; 我们从四个场景来看:</p>
<p><strong>场景一、A发送给B的ACK确认报文正确到达B</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个时候没有什么问题, 处于<code>LAST_ACK</code>状态的B收到A的确认报文之后, 直接进入<code>CLOSED</code>状态, 而 A经过 <code>2MSL</code>的等待之后, 进入<code>CLOSED</code>状态</p>
<p><strong>场景二、A发送给B的ACK确认报文没有到达B, A处于TIME_WAIT状态</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个时候B经过一段时间(这个一段时间应该是<code>1MSL</code>, 待确认)没有收到A的确认报文<code>ACK,</code> 那么B会重新发送FIN报文给A, 这个时候因为A的<code>TIME_WAIT</code>状态会持续 <code>2MSL</code>, 所以后面也会有两种情况:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、在TIME_WAIT时间范围内, A收到了B重发的FIN报文, 那么A会回一个ACK给到B, 并不确保ACK一定到B; 等到TIME_WAIT超时之后, 进入CLOSED状态.</span><br><span class="line"></span><br><span class="line">2、在TIME_WAIT时间范围内, A并没有收到B重发的FIN报文, 那么A就进入CLOSED状态, 但是B还处于LAST_ACK状态, 那么经过 2个MSL之后(这里为什么是两个MSL, 理论上应该是自己发送的FIN + A返回的ACK报文 在网络中存在的最大时长, 待确认), 会再发送FIN给A, 因为此时A已经处于CLOSED状态, 所以A会发送给B一个RST报文, 来表示我已经断开连接了, 你也断开吧; 如果B一直收不到任何反馈, 那么会一直定时发送FIN给A 直到TCP的重传超时, B会由LAST_ACK状态进入CLOSED状态;</span><br><span class="line"></span><br><span class="line">3、在TIME_WAIT时间范围内, A并没有收到B重发的FIN报文, 那么A就进入CLOSED状态, 但是B还处于LAST_ACK状态, 如果这时候A又发起了SNY连接, 使用了上一次的端口号, 那么B收到SYN连接请求之后, 发现该连接处于LAST_ACK状态, 那么会发送RST给客户端, 导致三次握手失败;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注: 1、对于网上某一篇博客的思考,博客中提到:当客户端开启<code>net.ipv4.tcp_tw_reuse</code>这个属性的时候, 会出现服务端发送的FIN报文, 被新的连接接收到从而导致断开连接, 这种情况看来是不存在的; 因为服务器处于<code>LAST_ACK</code>的时候, 即使开启<code>tw_reuse</code>, 也会被服务器给<code>reset</code>掉, 并不会重新建立连接的.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注: 2、对于上面思考的重新思考: 当B在超时时间内没有收到<code>ACK</code>的时候, 那么B会重新发送FIN, 那么此时的<code>LAST_ACK</code>会不会重新开始计算超时时间? 如果重新开始计算超时时间, 那么注①的理解就是正确的, 如果不会重新开始计算<code>LAST_ACK</code>状态的超时时间, 确实有可能B发送完FIN之后, B马上<code>LAST_ACK</code>超时, B的状态变为了<code>CLOSED</code>状态, 此时客户端重新再同一端口上面发起<code>SYN</code>请求, B接受请求并建立连接; 如果此时<code>FIN</code>才到达A端, 那么A端会如何处理呢?</p>
<p>1、根本不存在这种情况 </p>
<p>2、如果丢弃, 是依托与什么判断机制来丢弃的</p>
<p>3、如果断开新的连接, 那么<code>TCP</code>就是不可靠的传输协议了. 显然后面种是不可能的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/07/10/开发上线代码流程规范/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/10/开发上线代码流程规范/" itemprop="url">开发上线代码流程规范</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-10T12:12:57+08:00">
                2019-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/Git/Git工作流/" itemprop="url" rel="index">
                    <span itemprop="name">Git工作流</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/Git/Git工作流/Git分支模型/" itemprop="url" rel="index">
                    <span itemprop="name">Git分支模型</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/Git/Git工作流/Git分支模型/工作流/" itemprop="url" rel="index">
                    <span itemprop="name">工作流</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="开发上线代码流程规范"><a href="#开发上线代码流程规范" class="headerlink" title="开发上线代码流程规范"></a>开发上线代码流程规范</h1><h2 id="Git分支说明"><a href="#Git分支说明" class="headerlink" title="Git分支说明"></a>Git分支说明</h2><h3 id="master分支"><a href="#master分支" class="headerlink" title="master分支"></a>master分支</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不直接使用的分支，保持随时可上线状态。(所有代码<strong>上线完成验证无误</strong>后才会合并到该分支)</p>
<h3 id="develop分支"><a href="#develop分支" class="headerlink" title="develop分支"></a>develop分支</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开发主要使用分支。</p>
<h3 id="feature系列分支"><a href="#feature系列分支" class="headerlink" title="feature系列分支"></a>feature系列分支</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;各基础项目使用分支。<strong>所有<code>feature</code>分支必须从<code>develop</code>分支中迁出。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>命名方式：</strong> <code>feature/20171012_项目名</code>，时间为项目分支迁出时间。</p>
<h3 id="hotfix系列分支"><a href="#hotfix系列分支" class="headerlink" title="hotfix系列分支"></a>hotfix系列分支</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发现紧急<code>bug</code>时所使用分支。<strong>所有<code>hotfix</code>分支必须从<code>master</code>分支中迁出。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>命名方式：</strong> <code>hotfix/20171012_项目名</code></p>
<h3 id="release系列分支"><a href="#release系列分支" class="headerlink" title="release系列分支"></a>release系列分支</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正式发版前使用分支。从需要上线的<code>feature</code>或者<code>hotfix</code>分支中迁出。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;打<code>release</code>分支之前，应先将<code>master</code>分支代码合并到对应的<code>feature</code>或者<code>hotfix</code>分支，保证代码保持最新，且代码与其它代码不会出现冲突。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>命名方式：</strong> <code>release/20171012_项目名</code></p>
<h2 id="功能开发-amp-BUG修复流程"><a href="#功能开发-amp-BUG修复流程" class="headerlink" title="功能开发 &amp; BUG修复流程"></a>功能开发 &amp; BUG修复流程</h2><h3 id="分支迁出"><a href="#分支迁出" class="headerlink" title="分支迁出"></a>分支迁出</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;功能开发从<code>develop</code>迁出<code>feature/**</code>分支。（其实个人觉得都可以从<code>master</code>迁出，<code>develop</code>在这个流程中没有多大意义）</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>BUG</code>修复从<code>master</code>迁出<code>hotfix/**</code>分支。</p>
<h3 id="提测前代码合并"><a href="#提测前代码合并" class="headerlink" title="提测前代码合并"></a>提测前代码合并</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为尽量保证测试代码与最终上线代码贴近，避免其它代码合并后产生的问题。<strong>在每轮测试前，测试人员要求开发人员将<code>master</code>分支合并到功能或者BUG修复分支</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all -p</span><br><span class="line">git checkout master</span><br><span class="line">git merge origin/master //合并远程分支</span><br><span class="line">git checkout feature/****</span><br><span class="line">git merge master</span><br><span class="line">git push</span><br><span class="line">//....</span><br></pre></td></tr></table></figure>
<h3 id="测试人员统一确认当天上线项目"><a href="#测试人员统一确认当天上线项目" class="headerlink" title="测试人员统一确认当天上线项目"></a>测试人员统一确认当天上线项目</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试人员统计当天需要上线项目，包含<code>hotfix</code>项目。临时<code>hotfix</code>项目与其它项目一起重新统计。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>发送邮件给上线项目责任人</strong>,将<code>master</code>分支合并到<code>feature</code>或者<code>bug</code>分支。(保证当天上线项目代码起点相同，避免某些项目因意外，即使上线合并代码到<code>master</code>后，但临时发现代码有问题，其它项目无法继续上线)</p>
<h3 id="上线项目排序上线"><a href="#上线项目排序上线" class="headerlink" title="上线项目排序上线"></a>上线项目排序上线</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试人员统一确认当天上线项目顺序，排队上线。</p>
<p>以单个项目排序为例:</p>
<ol>
<li>测试人员发送上线准备邮件：合并<code>master</code>到功能或者<code>bug</code>修复分支并打<code>release</code>。(如果<code>master</code>被污染，可不必合并<code>master</code>，但需包括<code>leader</code>在内各方确认)</li>
<li>开发人员回复合并且打<code>release</code>分支完成。</li>
<li>测试人员验证功能正常。(小<code>bug</code>在<code>release</code>分支持续修改，如修改过多，合并<code>release</code>到<code>feature</code>分支修改，删除<code>release</code>分支，重新排队走流程上线，其它项目优先上线)</li>
<li>测试人员验证完成，发送上线通知。（必须包含<code>release</code>分支号)</li>
<li>上线人员完成上线，发送上线完成通知。</li>
<li>测试人员收到通知后验证线上功能，完成后发送验证完成通知。</li>
<li>研发人员收到验证完成通知后，将<code>release</code>分支分别合并到<code>develop</code>与<code>master</code>分支。</li>
<li>测试人员最终发送测试报告。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中间流程可先行进行口头或者消息沟通加快进度，但后续必须有邮件正式回复确保流程都走完，避免线上代码遗漏。</p>
<h2 id="Git-命令-仅做参考，根据情况执行"><a href="#Git-命令-仅做参考，根据情况执行" class="headerlink" title="Git 命令(仅做参考，根据情况执行)"></a>Git 命令(仅做参考，根据情况执行)</h2><h3 id="更新本地代码仓库缓存"><a href="#更新本地代码仓库缓存" class="headerlink" title="更新本地代码仓库缓存"></a>更新本地代码仓库缓存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all -p</span><br></pre></td></tr></table></figure>
<h3 id="切换到本地分支"><a href="#切换到本地分支" class="headerlink" title="切换到本地分支"></a>切换到本地分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout **</span><br></pre></td></tr></table></figure>
<h3 id="更新本地分支到最新"><a href="#更新本地分支到最新" class="headerlink" title="更新本地分支到最新"></a>更新本地分支到最新</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge origin/**</span><br></pre></td></tr></table></figure>
<p>(采用fork仓库开发的, 使用 <code>git merge upstream/**</code> 进行合并)</p>
<h3 id="开发分支更新最新代码，解决冲突"><a href="#开发分支更新最新代码，解决冲突" class="headerlink" title="开发分支更新最新代码，解决冲突"></a>开发分支更新最新代码，解决冲突</h3><p>同时, 需要在此处解决合并冲突.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all -p</span><br><span class="line">git checkout master</span><br><span class="line">git merge origin/master //合并远程分支</span><br><span class="line">git checkout feature/****</span><br><span class="line">git merge master</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<p><strong>定期更新本地代码，保持develop与master一致</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/07/10/Composer各大厂商镜像地址/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/10/Composer各大厂商镜像地址/" itemprop="url">Composer各大厂商镜像地址</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-10T12:12:57+08:00">
                2019-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/PHP/" itemprop="url" rel="index">
                    <span itemprop="name">PHP</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/PHP/Composer/" itemprop="url" rel="index">
                    <span itemprop="name">Composer</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Composer各大厂商镜像地址"><a href="#Composer各大厂商镜像地址" class="headerlink" title="Composer各大厂商镜像地址"></a>Composer各大厂商镜像地址</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://blog.thinkphp.cn/1147952" target="_blank" rel="noopener">https://blog.thinkphp.cn/1147952</a></p>
</blockquote>
<p><br></p>
<h2 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h2><p>使用说明：<a href="https://mirrors.aliyun.com/composer/" target="_blank" rel="noopener">https://mirrors.aliyun.com/composer/</a></p>
<p><strong>全局配置</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/</span><br></pre></td></tr></table></figure>
<h2 id="华为云"><a href="#华为云" class="headerlink" title="华为云"></a>华为云</h2><p><strong>全局配置</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g repo.packagist composer https://mirrors.huaweicloud.com/repository/php/</span><br></pre></td></tr></table></figure>
<h2 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a>腾讯云</h2><p><strong>全局配置</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g repos.packagist composer https://mirrors.cloud.tencent.com/composer/</span><br></pre></td></tr></table></figure>
<h2 id="laravel-china"><a href="#laravel-china" class="headerlink" title="laravel-china"></a>laravel-china</h2><p>使用说明：<a href="https://packagist.laravel-china.org/" target="_blank" rel="noopener">https://packagist.laravel-china.org/</a></p>
<p><strong>全局配置</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g repos.packagist composer  https://packagist.laravel-china.org</span><br></pre></td></tr></table></figure>
<h2 id="cnpkg"><a href="#cnpkg" class="headerlink" title="cnpkg"></a>cnpkg</h2><p><strong>全局配置</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g repos.packagist composer https://php.cnpkg.org](https://php.cnpkg.org</span><br></pre></td></tr></table></figure>
<h2 id="phpcomposer"><a href="#phpcomposer" class="headerlink" title="phpcomposer"></a>phpcomposer</h2><p>Composer官方镜像，速度较慢</p>
<p><strong>全局配置</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g repo.packagist composer https://packagist.phpcomposer.com</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/07/09/API版本控制的几种思路/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/09/API版本控制的几种思路/" itemprop="url">API版本控制的几种思路</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-09T12:12:57+08:00">
                2019-07-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/API设计/" itemprop="url" rel="index">
                    <span itemprop="name">API设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="API版本控制的几种思路"><a href="#API版本控制的几种思路" class="headerlink" title="API版本控制的几种思路"></a>API版本控制的几种思路</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://blog.thinkphp.cn/825788" target="_blank" rel="noopener">https://blog.thinkphp.cn/825788</a></p>
</blockquote>
<p>我们假设API接口的域名名为<code>api.tp5.com</code>，并且以两个版本<code>v1</code>和<code>v2</code>为例（注意，版本号仅为主版本，小版本应该是直接升级，不应该存在共存情况，所以<code>v1.1</code>或者<code>v2.0</code>这种版本号不应该设计在URL里面），来说明下API版本的不同控制方式，以及应该如何进行开发的规划。</p>
<h2 id="通过子域名（或子目录）"><a href="#通过子域名（或子目录）" class="headerlink" title="通过子域名（或子目录）"></a>通过子域名（或子目录）</h2><p>第一个办法，是直接使用两个模块（或者应用）来实现，对于架构改变比较大的API版本（尤其是不同版本之间基本没法共用、更改框架甚至采用不同的语言实现）通常会这样选择。</p>
<p>目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">api</span><br><span class="line">├─application           </span><br><span class="line">│  ├─v1  </span><br><span class="line">│  │  ├─controller </span><br><span class="line">│  │  ├─model </span><br><span class="line">│  │  ├─config</span><br><span class="line">│  │  └─ ...            </span><br><span class="line">│  ├─v2</span><br><span class="line">│  │  ├─controller</span><br><span class="line">│  │  ├─model           </span><br><span class="line">│  │  ├─config  </span><br><span class="line">│  │  └─ ...     </span><br><span class="line">│   ...</span><br></pre></td></tr></table></figure>
<p>请求方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET https://api.tp5.com/v1/user/1</span><br><span class="line">GET https://api.tp5.com/v2/user/1</span><br></pre></td></tr></table></figure>
<p>当然，你也可以通过子域名绑定模块实现下面的方式访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET https://v1.api.tp5.com/user/1</span><br><span class="line">GET https://v2.api.tp5.com/user/1</span><br></pre></td></tr></table></figure>
<h2 id="通过请求参数"><a href="#通过请求参数" class="headerlink" title="通过请求参数"></a>通过请求参数</h2><p>对于刚开始没有做好版本规划，后期迭代维护过程中增加了新的版本，考虑到架构的改造成本，可能会考虑下面的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET https://api.tp5.com/user/1</span><br><span class="line">GET https://api.tp5.com/user/1?version=v2</span><br></pre></td></tr></table></figure>
<p>由于缺乏很好的路径和类库目录规范，如果频繁更新版本的话，建议把版本的架构设计升级成后面的两种方式。</p>
<h2 id="通过路由"><a href="#通过路由" class="headerlink" title="通过路由"></a>通过路由</h2><p>可能大多数接口在设计的时候已经考虑到了版本控制的问题，那么通常会选择在URL地址中增加版本标识参数，这种方式便于调试。</p>
<p>对于API应用来说，更建议采用<strong>单模块设计+多级控制器</strong>，目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">api</span><br><span class="line">├─application          </span><br><span class="line">│  ├─controller</span><br><span class="line">│  │  ├─v1</span><br><span class="line">│  │  ├─v2</span><br><span class="line">│  │  └─ ...            </span><br><span class="line">│  ├─model</span><br><span class="line">│   ...</span><br></pre></td></tr></table></figure>
<p>路由规则定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&apos;:version/user/:id&apos;,&apos;:version.User/read&apos;);</span><br><span class="line">GET https://api.tp5.com/v1/user/1</span><br><span class="line">GET https://api.tp5.com/v2/user/1</span><br></pre></td></tr></table></figure>
<p>由于使用了多级控制器，需要注意控制器的命名空间。</p>
<p>通过命令行可以快速的创建控制器文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php think make:controller v1/User</span><br></pre></td></tr></table></figure>
<h2 id="通过头信息"><a href="#通过头信息" class="headerlink" title="通过头信息"></a>通过头信息</h2><p>最新的规范趋向于通过头信息来定义版本，优势在于从历史版本迭代更新的时候不需要改变URL地址，改变请求头信息即可，主要分为两种。</p>
<p>第一种是使用自定义请求头例如<code>api-version</code>控制版本（同理你还可以用其它头信息控制其它）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET https://api.tp5.com/user/1</span><br><span class="line">api-version:v2</span><br></pre></td></tr></table></figure>
<p>头信息的方式，路由规则的定义略微做下调整即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use think\facade\Request;</span><br><span class="line">use think\facade\Route;</span><br><span class="line"></span><br><span class="line">$version = Request::header(&apos;api-version&apos;) ? : &apos;v1&apos;;</span><br><span class="line">Route::get(&apos;user/:id&apos;, $version . &apos;.User/read&apos;);</span><br></pre></td></tr></table></figure>
<p>也有很多采用了<code>Accept</code>头信息来处理（好处是可以设置接口输出格式），通常的规范是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET https://api.tp5.com/user/1</span><br><span class="line">Accept: application/vnd.tp5.v2+json</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于API接口开发，尽量事先做好版本控制规划，确保你的应用能兼容新老版本的访问。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/07/08/Feed流系统设计总纲/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/08/Feed流系统设计总纲/" itemprop="url">Feed流系统设计总纲</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-08T12:12:57+08:00">
                2019-07-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/feed/" itemprop="url" rel="index">
                    <span itemprop="name">feed</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/feed/业务设计/" itemprop="url" rel="index">
                    <span itemprop="name">业务设计</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/feed/业务设计/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Feed流系统设计总纲"><a href="#Feed流系统设计总纲" class="headerlink" title="Feed流系统设计总纲"></a>Feed流系统设计总纲</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s/vRjLfVHyKGX35N_mYjDD7A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/vRjLfVHyKGX35N_mYjDD7A</a></p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;差不多十年前，随着功能机的淘汰和智能机的普及，互联网开始进入移动互联网时代，最具代表性的产品就是微博、微信，以及后来的今日头条、快手等。这些移动化联网时代的新产品在过去几年间借着智能手机的风高速成长。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些产品都是<code>Feed</code>流类型产品，由于<code>Feed</code>流一般是按照时间“从上往下流动”，非常适合在移动设备端浏览，最终这一类应用就脱颖而出，迅速抢占了上一代产品的市场空间。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Feed</code>流是<code>Feed + 流</code>，<code>Feed</code>的本意是饲料，<code>Feed</code>流的本意就是有人一直在往一个地方投递新鲜的饲料，如果需要饲料，只需要盯着投递点就可以了，这样就能源源不断获取到新鲜的饲料。 在信息学里面，Feed其实是一个信息单元，比如一条朋友圈状态、一条微博、一条咨询或一条短视频等，所以<strong>Feed流就是不停更新的信息单元，只要关注某些发布者就能获取到源源不断的新鲜信息，我们的用户也就可以在移动设备上逐条去浏览这些信息单元</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当前最流行的<code>Feed</code>流产品有微博、微信朋友圈、头条的资讯推荐、快手抖音的视频推荐等，还有一些变种，比如私信、通知等，这些系统都是<code>Feed</code>流系统。</p>
<h2 id="Feed流系统特点"><a href="#Feed流系统特点" class="headerlink" title="Feed流系统特点"></a>Feed流系统特点</h2><p><strong>Feed流本质上是一个数据流，是将 “N个发布者的信息单元” 通过 “关注关系” 传送给 “M个接收者”</strong>。<br><img src="//blog.com/2019/07/08/Feed流系统设计总纲/018dbb07c19dd25d7707304e9b7a67b66b81cfdd.png" alt="syncserver8001"></p>
<p><code>Feed</code>流系统是一个数据流系统，所以我们核心要看数据。从数据层面看，数据分为三类，分别是：</p>
<ul>
<li><strong>发布者的数据</strong>：发布者产生数据，然后数据需要按照发布者组织，需要根据发布者查到所有数据，比如微博的个人页面、朋友圈的个人相册等。</li>
<li><strong>关注关系</strong>：系统中个体间的关系，微博中是关注，是单向流，朋友圈是好友，是双向流。不管是单向还是双向，当发布者发布一条信息时，该条信息的流动永远是单向的。</li>
<li><strong>接收者的数据</strong>：从不同发布者那里获取到的数据，然后通过某种顺序（一般为时间）组织在一起，比如微博的首页、朋友圈首页等。这些数据具有时间热度属性，越新的数据越有价值，越新的数据就要排在最前面。</li>
</ul>
<p>针对这三类数据，我们可以有如下定义：</p>
<ul>
<li><strong>存储库</strong>：存储发布者的数据，永久保存。</li>
<li><strong>关注表</strong>：用户关系表，永久保存。</li>
<li><strong>同步库</strong>：存储接收者的时间热度数据，只需要保留最近一段时间的数据即可。</li>
</ul>
<p>设计<code>Feed</code>流系统时最核心的是确定清楚产品层面的定义，需要考虑的因素包括：</p>
<ul>
<li><strong>产品用户规模</strong>：用户规模在十万、千万、十亿级时，设计难度和侧重点会不同。</li>
<li><strong>关注关系（单向、双写）</strong>：如果是双向，那么就不会有大V，否则会有大V存在。<br>上述是选择数据存储系统最核心的几个考虑点，除此之外，还有一些需要考虑的：</li>
<li><strong>如何实现<code>Meta</code>和<code>Feed</code>内容搜索？</strong><ul>
<li>虽然Feed流系统本身可以不需要搜索，但是一个Feed流产品必须要有搜索，否则信息发现难度会加大，用户留存率会大幅下降。</li>
</ul>
</li>
<li><strong>Feed流的顺序是时间还是其他分数，比如个人的喜好程度？</strong><ul>
<li>双向关系时由于关系很紧密，一定是按时间排序，就算一个关系很紧密的人发了一条空消息或者低价值消息，那我们也会需要关注了解的。</li>
<li>单向关系时，那么可能就会存在大V，大V的粉丝数量理论极限就是整个系统的用户数，有一些产品会让所有用户都默认关注产品负责人，这种产品中，该负责人就是最大的大V，粉丝数就是用户规模。</li>
</ul>
</li>
</ul>
<h2 id="Feed流系统设计"><a href="#Feed流系统设计" class="headerlink" title="Feed流系统设计"></a>Feed流系统设计</h2><h3 id="1-产品定义"><a href="#1-产品定义" class="headerlink" title="1. 产品定义"></a>1. 产品定义</h3><p>第一步，我们首先需要定义产品，我们要做的产品是哪一种类型，常见的类型有：</p>
<ul>
<li>微博类</li>
<li>朋友圈类</li>
<li>抖音类</li>
<li>私信类</li>
</ul>
<p>接着，再详细看一下这几类产品的异同：</p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">关注关系</th>
<th style="text-align:center">是否有大V</th>
<th style="text-align:center">时效性</th>
<th style="text-align:center">排序</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">微博类</td>
<td style="text-align:center">单向</td>
<td style="text-align:center">有</td>
<td style="text-align:center">秒~分</td>
<td style="text-align:center">时间</td>
</tr>
<tr>
<td style="text-align:center">抖音类</td>
<td style="text-align:center">单向/无</td>
<td style="text-align:center">有</td>
<td style="text-align:center">秒~分</td>
<td style="text-align:center">推荐</td>
</tr>
<tr>
<td style="text-align:center">朋友圈类</td>
<td style="text-align:center">双向</td>
<td style="text-align:center">无</td>
<td style="text-align:center">秒</td>
<td style="text-align:center">时间</td>
</tr>
<tr>
<td style="text-align:center">私信类</td>
<td style="text-align:center">双向</td>
<td style="text-align:center">无</td>
<td style="text-align:center">秒</td>
<td style="text-align:center">时间</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述对比中，只对比各类产品最核心、或者最根本特点，其他次要的不考虑。比如微博中互相关注后就是双向关注了，但是这个不是微博的立命之本，只是补充，无法撼动根本。</p>
<p>从上面表格可以看出来，主要分为两种区分：</p>
<ul>
<li><strong>关注关系是单向还是双向</strong>：<ul>
<li><strong>如果是单向，那么可能就会存在大V效应，同时时效性可以低一些，比如到分钟级别</strong>。</li>
<li>如果是双向，那就是好友，好友的数量有限，那么就不会有大V，因为每个人的精力有限，他不可能主动加几千万的好友，这时候因为关系更精密，时效性要求会更高，需要都秒级别。</li>
</ul>
</li>
<li><strong>排序是时间还是推荐</strong>：<ul>
<li><strong>用户对feed流最容易接受的就是时间，目前大部分都是时间</strong>。</li>
<li>但是有一些场景，是从全网数据里面根据用户的喜好给用户推荐和用户喜好度最匹配的内容，这个时候就需要用推荐了，这种情况一般也会省略掉关注了，相对于关注了全网所有用户，比如抖音、头条等。<br>确定了产品类型后，还需要继续确定的是系统设计目标：需要支持的最大用户数是多少？十万、百万、千万还是亿？</li>
</ul>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户数很少的时候，就比较简单，这里我们主要考虑 亿级用户 的情况，因为如果系统能支持亿级，那么其他量级也能支持。为了支持亿级规模的用户，主要子系统选型时需要考虑水平扩展能力以及一些子系统的可用性和可靠性了，因为系统大了后，任何一个子系统的不稳定都很容易波及整个系统。</p>
<h3 id="2-存储"><a href="#2-存储" class="headerlink" title="2. 存储"></a>2. 存储</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们先来看看最重要的存储，不管是哪种同步模式，在存储上都是一样的，我们定义用户消息的存储为存储库。存储库主要满足三个需求：</p>
<ul>
<li><strong>可靠存储用户发送的消息，不能丢失</strong>。否则就找不到自己曾经发布到朋友圈状态了。</li>
<li><strong>读取某个人发布过的所有消息</strong>，比如个人主页等。</li>
<li><strong>数据永久保存</strong>。</li>
</ul>
<p>所以，存储库最重要的特征就是两点：</p>
<ul>
<li>数据可靠、不丢失。</li>
<li>由于数据要永久保存，数据会一直增长，所以要易于水平扩展。</li>
</ul>
<p>综上，可以选为存储库的系统大概有两类：</p>
<table>
<thead>
<tr>
<th style="text-align:left">特点</th>
<th style="text-align:center">分布式NoSQL</th>
<th style="text-align:center">关系型数据库（分库分表）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">可靠性</td>
<td style="text-align:center">极高</td>
<td style="text-align:center">高</td>
</tr>
<tr>
<td style="text-align:left">水平扩展能力</td>
<td style="text-align:center">线性</td>
<td style="text-align:center">需要改造</td>
</tr>
<tr>
<td style="text-align:left">水平扩展速度</td>
<td style="text-align:center">毫秒</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:left">常见系统</td>
<td style="text-align:center">Tablestore、Bigtable</td>
<td style="text-align:center">MySQL、PostgreSQL</td>
</tr>
</tbody>
</table>
<ul>
<li>对于<strong>可靠性</strong>，分布式<code>NoSQL</code>的可靠性要高于关系型数据库，这个可能有违很多人的认知。主要是关系型数据库发展很长时间了，且很成熟了，数据放在上面大家放心，而分布式<code>NoSQL</code>数据库发展晚，使用的并不多，不太信任。但是，<strong>分布式<code>NoSQL</code>需要存储的数据量更多，对数据可靠性的要求也加严格</strong>，所以<strong>一般都是存储三份，可靠性会更高</strong>。目前在一些云厂商中的关系型数据库因为采用了和分布式<code>NoSQL</code>类似的方式，所以可靠性也得到了大幅提高。</li>
<li><strong>水平扩展能力</strong>：对于分布式<code>NoSQL</code>数据库，数据天然是分布在多台机器上，当一台机器上的数据量增大后，可以通过自动分裂两部分，然后将其中一半的数据迁移到另一台机器上去，这样就做到了线性扩展。而关系型数据库需要在扩容时再次分库分表。</li>
</ul>
<p>所以，结论是：</p>
<ul>
<li><p>如果是自建系统，且不具备分布式<code>NoSQL</code>数据库运维能力，且数据规模不大，那么可以使用<code>MySQL</code>，这样可以撑一段时间。</p>
</li>
<li><p>如果是基于云服务，那么就用分布式<code>NoSQL</code>，比如<code>Tablestore</code>或<code>Bigtable</code>。</p>
</li>
<li><p>如果数据规模很大，那么也要用分布式<code>NoSQL</code>，否则就是走上一条不归路。</p>
</li>
</ul>
<p>如果使用<code>Tablestore</code>，那么存储库表设计结构如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">主键列</th>
<th style="text-align:center">第一列主键</th>
<th style="text-align:center">第二列主键</th>
<th style="text-align:center">属性列</th>
<th style="text-align:center">属性列</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">列名</td>
<td style="text-align:center">user_id</td>
<td style="text-align:center">message_id</td>
<td style="text-align:center">content</td>
<td style="text-align:center">other</td>
</tr>
<tr>
<td style="text-align:left">解释</td>
<td style="text-align:center">消息发送者用户ID</td>
<td style="text-align:center">消息顺序ID，可以使用timestamp。</td>
<td style="text-align:center">内容</td>
<td style="text-align:center">其他内容</td>
</tr>
</tbody>
</table>
<p>到此，我们确定了存储库的选型，那么系统架构的轮廓有了：<br><img src="//blog.com/2019/07/08/Feed流系统设计总纲/754844f7d9e8eb6fa06f6c1704f927dd9203f2d0.png" alt="_"></p>
<h3 id="3-同步"><a href="#3-同步" class="headerlink" title="3. 同步"></a>3. 同步</h3><p>系统规模和产品类型，以及存储系统确定后，我们可以确定同步方式，常见的方式有三种：</p>
<h4 id="推模式"><a href="#推模式" class="headerlink" title="推模式"></a>推模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;推模式（也叫写扩散）：和名字一样，就是一种推的方式，发送者发送了一个消息后，立即将这个消息推送给接收者，但是接收者此时不一定在线，那么就需要有一个地方存储这个数据，这个存储的地方我们称为：同步库。推模式也叫写扩散的原因是，<strong>一个消息需要发送个多个粉丝，那么这条消息就会复制多份，写放大，所以也叫写扩散</strong>。这种模式下，<strong>对同步库的要求就是写入能力极强和稳定</strong>。读取的时候因为消息已经发到接收者的收件箱了，只需要读一次自己的收件箱即可，读请求的量极小，所以对读的<code>QPS</code>需求不大。归纳下，<strong>推模式中对同步库的要求只有一个：写入能力强</strong>。</p>
<h4 id="拉模式"><a href="#拉模式" class="headerlink" title="拉模式"></a>拉模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;拉模式（也叫读扩散）：这种是一种拉的方式，发送者发送了一条消息后，这条消息不会立即推送给粉丝，而是写入自己的发件箱，<strong>当粉丝上线后再去自己关注者的发件箱里面去读取，一条消息的写入只有一次，但是读取最多会和粉丝数一样，读会放大，所以也叫读扩散</strong>。拉模式的读写比例刚好和写扩散相反，那么<strong>对系统的要求是：读取能力强</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外这里还有一个误区，很多人在最开始设计<code>feed</code>流系统时，首先想到的是拉模式，因为这种和用户的使用体感是一样的，但是在系统设计上这种方式有不少痛点，<strong>最大的是每个粉丝需要记录自己上次读到了关注者的哪条消息</strong>，如果有1000个关注者，那么这个人需要记录1000个位置信息，这个量和关注量成正比的，远比用户数要大的多，这里要特别注意，虽然在产品前期数据量少的时候这种方式可以应付，但是量大了后就会事倍功半，得不偿失，切记切记。</p>
<h4 id="推拉结合模式"><a href="#推拉结合模式" class="headerlink" title="推拉结合模式"></a>推拉结合模式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;推拉结合模式：推模式在单向关系中，因为存在大V，那么一条消息可能会扩散几百万次，但是这些用户中可能有一半多是僵尸，永远不会上线，那么就存在资源浪费。而拉模式下，在系统架构上会很复杂，同时需要记录的位置信息是天量，不好解决，尤其是用户量多了后会成为第一个故障点。基于此，所以有了<strong>推拉结合模式，大部分用户的消息都是写扩散，只有大V是读扩散</strong>，这样既控制了资源浪费，又减少了系统设计复杂度。但是整体设计复杂度还是要比推模式复杂。</p>
<h4 id="三种模式对比"><a href="#三种模式对比" class="headerlink" title="三种模式对比"></a>三种模式对比</h4><p>用图表对比：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:center">推模式</th>
<th style="text-align:center">拉模式</th>
<th style="text-align:center">推拉结合模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">写放大</td>
<td style="text-align:center">高</td>
<td style="text-align:center">无</td>
<td style="text-align:center">中</td>
</tr>
<tr>
<td style="text-align:left">读放大</td>
<td style="text-align:center">无</td>
<td style="text-align:center">高</td>
<td style="text-align:center">中</td>
</tr>
<tr>
<td style="text-align:left">用户读取延时</td>
<td style="text-align:center">毫秒</td>
<td style="text-align:center">秒</td>
<td style="text-align:center">秒</td>
</tr>
<tr>
<td style="text-align:left">读写比例</td>
<td style="text-align:center">1:99</td>
<td style="text-align:center">99:1</td>
<td style="text-align:center">~50:50</td>
</tr>
<tr>
<td style="text-align:left">系统要求</td>
<td style="text-align:center">写能力强</td>
<td style="text-align:center">读能力强</td>
<td style="text-align:center">读写都适中</td>
</tr>
<tr>
<td style="text-align:left">常见系统</td>
<td style="text-align:center">Tablestore、Bigtable等LSM架构的分布式NoSQL</td>
<td style="text-align:center">Redis、memcache等缓存系统或搜索系统(推荐排序场景)</td>
<td style="text-align:center">两者结合</td>
</tr>
<tr>
<td style="text-align:left">架构复杂度</td>
<td style="text-align:center">简单</td>
<td style="text-align:center">复杂</td>
<td style="text-align:center">更复杂</td>
</tr>
</tbody>
</table>
<p>介绍完同步模式中所有场景和模式后，我们归纳下：</p>
<ul>
<li><p><strong>如果产品中是双向关系，那么就采用推模式</strong>。</p>
</li>
<li><p>如果产品中是单向关系，且用户数少于1000万，那么也采用推模式，足够了。</p>
</li>
<li><p>如果产品是单向关系，单用户数大于1000万，那么采用推拉结合模式，这时候可以从推模式演进过来，不需要额外重新推翻重做。</p>
</li>
<li><p><strong>永远不要只用拉模式</strong>。</p>
</li>
<li><p>如果是一个初创企业，先用推模式，快速把系统设计出来，然后让产品去验证、迭代，等客户数大幅上涨到1000万后，再考虑升级为推拉集合模式。</p>
</li>
<li><p>如果是按推荐排序，那么是另外的考虑了，架构会完全不一样。</p>
</li>
</ul>
<p>如果选择了<code>Tablestore</code>，那么同步库表设计结构如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">主键列</th>
<th style="text-align:left">第一列主键</th>
<th style="text-align:left">第二列主键</th>
<th style="text-align:left">属性列</th>
<th style="text-align:left">属性列</th>
<th style="text-align:left">属性列</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">列名</td>
<td style="text-align:left">user_id</td>
<td style="text-align:left">sequence_id</td>
<td style="text-align:left">sender_id</td>
<td style="text-align:left">message_id</td>
<td style="text-align:left">other</td>
</tr>
<tr>
<td style="text-align:left">解释</td>
<td style="text-align:left">消息接收者用户ID</td>
<td style="text-align:left">消息顺序ID，可以使用timestamp + send_user_id，也可以直接使用Tablestore的自增列。</td>
<td style="text-align:left">发送者的用户ID</td>
<td style="text-align:left">store_table中的message_id列的值，也就是消息ID。通过sender_id和message_id可以到store_table中查询到消息内容</td>
<td style="text-align:left">其他内容，同步库中不需要包括消息内容。</td>
</tr>
</tbody>
</table>
<p>确定了同步库的架构如下：</p>
<p><img src="//blog.com/2019/07/08/Feed流系统设计总纲/fe16180ed09eae8ac4bf4174e8aa3b9b60987218.png" alt="_"></p>
<h3 id="4-元数据"><a href="#4-元数据" class="headerlink" title="4. 元数据"></a>4. 元数据</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面介绍了同步和存储后，整个<code>Feed</code>流系统的基础功能完成了，但是对于一个完整<code>Feed</code>流产品而言，还缺元数据部分，接下来，我们看元数据如何处理：</p>
<p><code>Feed</code>流系统中的元数据主要包括：</p>
<ul>
<li>用户详情和列表。</li>
<li>关注或好友关系。</li>
<li>推送<code>session</code>池。</li>
</ul>
<h4 id="4-1-用户详情和列表"><a href="#4-1-用户详情和列表" class="headerlink" title="4.1 用户详情和列表"></a>4.1 用户详情和列表</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主要是用户的详情，包括用户的各种自定义属性和系统附加的属性，<strong>这部分的要求只需要根据用户ID查询到就可以了</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以采用的分布式<code>NoSQL</code>系统或者关系型数据库都可以。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果使用<code>NoSQL</code>数据库<code>Tablestore</code>，那么用户详情表设计结构如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">主键顺序</th>
<th style="text-align:center">第一列主键</th>
<th style="text-align:center">属性列-1</th>
<th style="text-align:center">属性列-2</th>
<th style="text-align:center">……</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">字段名</td>
<td style="text-align:center">user_id</td>
<td style="text-align:center">nick_name</td>
<td style="text-align:center">gender</td>
<td style="text-align:center">other</td>
</tr>
<tr>
<td style="text-align:left">备注</td>
<td style="text-align:center">主键列，用于唯一确定一个用户</td>
<td style="text-align:center">用户昵称，用户自定义属性</td>
<td style="text-align:center">用户性别，用户自定义属性</td>
<td style="text-align:center">其他属性，包括用户自定义属性列和系统附加属性列。Tablestore是FreeSchema类型的，可以随时在任何一行增加新列而不影响原有数据。</td>
</tr>
</tbody>
</table>
<h4 id="4-2-关注或好友关系"><a href="#4-2-关注或好友关系" class="headerlink" title="4.2 关注或好友关系"></a>4.2 关注或好友关系</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这部分是存储关系，查询的时候需要支持查询关注列表或者粉丝列表，或者直接好友列表，这里就<strong>需要根据多个属性列查询需要索引能力</strong>，这里，存储系统也可以采用两类，关系型、分布式<code>NoSQL</code>数据库。</p>
<ul>
<li><p>如果已经有了关系型数据库了，且数据量较少，则选择关系型数据库，比如<code>MySQL</code>等。</p>
</li>
<li><p>如果数据量比较大，这个时候就有两种选择：</p>
<ul>
<li><ol>
<li>需要分布式事务，可以采用支持分布式事务的系统，比如分布式关系型数据库。</li>
</ol>
</li>
<li><ol>
<li>使用具有索引的系统，比如云上的<code>Tablestore</code>，更简单，吞吐更高，扩容能力也一并解决了。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>如果使用<code>Tablestore</code>，那么关注关系表设计结构如下：</p>
<p><code>Table：user_relation_table</code></p>
<table>
<thead>
<tr>
<th style="text-align:left">主键顺序</th>
<th style="text-align:left">第一列主键</th>
<th style="text-align:left">第一列主键</th>
<th style="text-align:left">属性列</th>
<th style="text-align:left">属性列</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Table字段名</td>
<td style="text-align:left">user_id</td>
<td style="text-align:left">follow_user_id</td>
<td style="text-align:left">timestamp</td>
<td style="text-align:left">other</td>
</tr>
<tr>
<td style="text-align:left">备注</td>
<td style="text-align:left">用户ID</td>
<td style="text-align:left">粉丝用户ID</td>
<td style="text-align:left">关注时间</td>
<td style="text-align:left">其他属性列</td>
</tr>
</tbody>
</table>
<p>多元索引的索引结构：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Table字段名</th>
<th style="text-align:center">user_id</th>
<th style="text-align:left">follow_user_id</th>
<th style="text-align:left">timestamp</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">是否Index</td>
<td style="text-align:center">是</td>
<td style="text-align:left">是</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">是否enableSortAndAgg</td>
<td style="text-align:center">是</td>
<td style="text-align:left">是</td>
<td style="text-align:left">是</td>
</tr>
<tr>
<td style="text-align:left">是否store</td>
<td style="text-align:center">是</td>
<td style="text-align:left">是</td>
<td style="text-align:left">是</td>
</tr>
</tbody>
</table>
<p>查询的时候：</p>
<ul>
<li>如果需要查询某个人的粉丝列表：使用<code>TermQuery</code>查询固定<code>user_id</code>，且按照<code>timestamp</code>排序。</li>
<li>如果需要查询某个人的关注列表：使用<code>TermQuery</code>查询固定<code>follow_user_id</code>，且按照<code>timestamp</code>排序。</li>
<li>当前数据写入Table后，需要5~10秒钟延迟后会在多元索引中查询到，未来会优化到2秒以内。</li>
</ul>
<blockquote>
<p>除了使用多元索引外，还可以使用GlobalIndex。</p>
</blockquote>
<h4 id="4-3-推送session池"><a href="#4-3-推送session池" class="headerlink" title="4.3 推送session池"></a>4.3 推送session池</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;思考一个问题，<strong>发送者将消息发送后，接收者如何知道自己有新消息来了？客户端周期性去刷新？</strong>如果是这样子，那么系统的读请求压力会随着客户端增长而增长，这时候就会有一个风险，比如平时的设备在线率是20%~30%，突然某天平台爆发了一个热点消息，大量休眠设备登陆，这个时候就会出现“查询风暴”，一下子就把系统打垮了，所有的用户都不能用了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决这个问题的一个思路是，<strong>在服务端维护一个推送<code>session</code>池，这个里面记录哪些用户在线，然后当用户A发送了一条消息给用户B后，服务端在写入存储库和同步库后，再通知一下<code>session</code>池中的用户B的<code>session</code>，告诉他：你有新消息了</strong>。<strong>然后<code>session-B</code>再去读消息，然后有消息后将消息推送给客户端</strong>。或者有消息后给客户端推送一下有消息了，客户端再去拉。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个<code>session</code>池使用在同步中，但是本质还是一个元数据，一般只需要存在于内存中即可，但是考虑到<code>failover</code>情况，那就需要持久化，这部分数据由于只需要指定单<code>Key</code>查询，用分布式<code>NoSQL</code>或关系型数据库都可以，一般复用当前的系统即可。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果使用<code>Tablestore</code>，那么<code>session</code>表设计结构如下：</p>
<table>
<thead>
<tr>
<th>主键列顺序</th>
<th style="text-align:center">第一列主键</th>
<th style="text-align:center">第二列主键</th>
<th style="text-align:center">属性列</th>
</tr>
</thead>
<tbody>
<tr>
<td>列名</td>
<td style="text-align:center">user_id</td>
<td style="text-align:center">device_id</td>
<td style="text-align:center">last_sequence_id</td>
</tr>
<tr>
<td>备注</td>
<td style="text-align:center">接收者用户ID</td>
<td style="text-align:center">设备ID，同一个用户可能会有多个设备，不同设备的读取位置可能不一致，所以这里需要一个设备ID。如果不需要支持多终端，则这一列可以省略。</td>
<td style="text-align:center">该接收者已经推送给客户端的最新的顺序ID</td>
</tr>
</tbody>
</table>
<h3 id="5-评论"><a href="#5-评论" class="headerlink" title="5. 评论"></a>5. 评论</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了私信类型外，其他的<code>feed</code>流类型中，都有评论功能，评论的属性和存储库差不多，但是<strong>多了一层关系：被评论的消息，所以只要将评论按照被被评论消息分组组织即可</strong>，然后查询时也是一个范围查询就行。这种查询方式很简单，用不到关系型数据库中复杂的事务、<code>join</code>等功能，很适合用分布式<code>NoSQL</code>数据库来存储。</p>
<p>所以，一般的选择方式就是：</p>
<ul>
<li>如果系统中已经有了分布式<code>NoSQL</code>数据库，比如<code>Tablestore</code>、<code>Bigtable</code>等，那么直接用这些即可。</li>
<li>如果没有上述系统，那么如果有<code>MySQL</code>等关系型数据库，那就选关系型数据库即可。</li>
<li>如果选择了<code>Tablestore</code>，那么“评论表”设计结构如下：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">主键列顺序</th>
<th style="text-align:left">第一列主键</th>
<th style="text-align:left">第二列主键</th>
<th style="text-align:left">属性列</th>
<th style="text-align:left">属性列</th>
<th style="text-align:left">属性列</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">字段名</td>
<td style="text-align:left">message_id</td>
<td style="text-align:left">comment_id</td>
<td style="text-align:left">comment_content</td>
<td style="text-align:left">reply_to</td>
<td style="text-align:left">other</td>
</tr>
<tr>
<td style="text-align:left">备注</td>
<td style="text-align:left">微博ID或朋友圈ID等消息的ID</td>
<td style="text-align:left">这一条评论的ID</td>
<td style="text-align:left">评论内容</td>
<td style="text-align:left">回复给哪个用户</td>
<td style="text-align:left">其他</td>
</tr>
</tbody>
</table>
<p>如果需要搜索评论内容，那么对这张表建立多元索引即可。</p>
<h3 id="6-赞"><a href="#6-赞" class="headerlink" title="6. 赞"></a>6. 赞</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近几年，“赞”或“like”功能很流行，赞功能的实现和评论类似，只是比评论少了一个内容，所以选择方式和评论一样。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果选择了<code>Tablestore</code>，那么“赞表”设计结构同评论表，这里就不再赘述了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统架构中加了元数据系统后的架构如下：<br><img src="//blog.com/2019/07/08/Feed流系统设计总纲/febf7df5da4ae1fafbff37539f3c11e4668dfb79.png" alt="meta"></p>
<h3 id="7-搜索"><a href="#7-搜索" class="headerlink" title="7. 搜索"></a>7. 搜索</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到此，我们已经介绍完了<code>Feed</code>流系统的主题架构，<code>Feed</code>流系统算是完成了。但是<code>Feed</code>流产品上还未结束，对于所有的<code>feed</code>流产品都需要有搜索能力，比如下面场景：</p>
<ul>
<li>微博中的搜索用户。</li>
<li>搜索微博内容。</li>
<li>微信中搜索好友等。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些内容搜索只需要字符匹配到即可，不需要非常复杂的相关性算法，所以只需要有能支持分词的检索功能即可，所以一般有两种做法：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 使用搜索引擎，将存储库的内容和用户信息表内容推送给搜索系统，搜索的时候直接访问搜索系统。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 使用具备全文检索能力的数据库，比如最新版的<code>MySQL</code>、<code>MongoDB</code>或者<code>Tablestore</code>。</p>
<p>所以，选择的原则如下：</p>
<ul>
<li>如果存储库使用了<code>MySQL</code>或者<code>Tablestore</code>，那么直接选择这两个系统就可以了。</li>
<li>如果整个系统都没使用<code>MySQL</code>、<code>Tablestore</code>，且已经使用了搜索系统，那么可以直接复用搜索系统，其他场景都不应该再额外加一个搜索系统进来，徒添复杂度。</li>
</ul>
<p>如果使用<code>Tablestore</code>，那么只需要在相应表上建立多元索引即可：</p>
<ul>
<li>如果需要对用户名支持搜索，那么需要对<code>user_table</code>建立多元索引，其中的<code>nick_name</code>需要是<code>Text</code>类型，且单字分词。</li>
<li>如果需要对<code>Feed</code>流内容支持搜索，那么需要对存储库表：<code>store_table</code>建立多元索引，这样就能直接对<code>Feed</code>流内容进行各种复杂查询了，包括多条件筛选、全文检索等。</li>
</ul>
<p>系统架构中加了搜索功能后的架构如下：<br><img src="//blog.com/2019/07/08/Feed流系统设计总纲/76c5777cb3d0b266aeaff4eb6ef9ddb9c0a7343d.png" alt="_"></p>
<h3 id="8-排序"><a href="#8-排序" class="headerlink" title="8. 排序"></a>8. 排序</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前的<code>Feed</code>流系统中的排序方式有两种，一种是时间，一种是分数。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们常用的微博、朋友圈、私信这些都是时间线类型的，因为这些产品定义中，需要我们主动关注某些人后才会看到这些人发表的内容，这个时候，最重要的是实时性，而不是发布质量，就算关注人发布了一条垃圾信息，我们也会被动看到。这种类型的产品适用于按照时间线排序。这一篇我们介绍的架构都是基于时间类型的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外一种是不需要关注任何人，我们能看到的都是系统希望我们看到的，系统在后台会分析我们的每个人的爱好，然后给每个人推送差异化的、各自喜欢的内容，这一种的架构和基于时间的完全不一样，我们在后续的推荐类型中专门介绍。</p>
<h3 id="9-删除Feed内容"><a href="#9-删除Feed内容" class="headerlink" title="9. 删除Feed内容"></a>9. 删除Feed内容</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>Feed</code>流应用中有一个问题，就是如果用户删除了之前发表的内容，系统该如何处理？因为系统里面有写扩散，那么删除的时候是不是也要写扩散一遍？这样的话，删除就不及时了，很难应对法律法规要求的快速删除。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对这个问题，我们在之前设计的时候，<strong>同步表中只有消息ID，没有消息内容，在用户读取的时候需要到存储库中去读消息内容，那么我们可以直接删除存储库中的这一条消息，这样用户读取的时候使用消息ID是读不到数据的，也就相当于删除的内容，而且删除速度会很快</strong>。除了直接删除外，另外一种办法是逻辑删除，对于删除的<code>feed</code>内容，只做标记，当查询到带有标记的数据时就认为删除了。</p>
<h3 id="10-更新Feed内容"><a href="#10-更新Feed内容" class="headerlink" title="10. 更新Feed内容"></a>10. 更新Feed内容</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更新和删除<code>Feed</code>处理逻辑一样，如果使用了支持多版本的存储系统，比如<code>Tablestore</code>，那么也可以支持编辑版本，和现在的微博一样。</p>
<h3 id="11-总结"><a href="#11-总结" class="headerlink" title="11. 总结"></a>11. 总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面介绍了不同子功能的特点和系统要求，能满足需求的系统主要有两类，一类是阿里云的<code>Tablestore</code>单系统，一类是开源组件组成的组合系统。</p>
<ul>
<li><p>开源组件组成的组合系统：包括<code>MySQL</code>、<code>Redis</code>、<code>HBase</code>等，这些系统单个都不能解决<code>Feed</code>流系统中遇到的问题，需要组合在一起，各司其职才能完成一个<code>Feed</code>流系统，适用于热衷开源系统，人多且喜欢运维操作的团队。</p>
</li>
<li><p><code>Tablestore</code>单系统：只使用<code>Tablestore</code>单个系统就能解决上述的所有问题，这时候肯定有人要问？你是不是在吹牛？ 这里不是吹牛，<code>Tablestore</code>在三年前就已经开始重视<code>Feed</code>流类型业务，之前也发表过多篇文章介绍，功能上也在专门为Feed流系统特别定制设计，所以到今天，只使用<code>Tablestore</code>一款产品，是可以满足上述需求的。选择<code>Tablestore</code>做<code>Feed</code>流系统的用户具有以下一些特征：</p>
<ul>
<li>产品设计目标规模大，千万级或亿级。</li>
<li>不喜欢运维，喜欢专注于开发。</li>
<li>高效率团队，希望尽快将产品实现落地。</li>
<li>希望一劳永逸，未来系统随着用户规模增长可以自动扩容。</li>
<li>希望能按量付费，用户少的时候费用低，等用户增长起来后费用在跟随用户数增长。<br>如果具有上述四个特征的任何一个，那么都是适合于用<code>Tablestore</code>。</li>
</ul>
</li>
</ul>
<h2 id="架构实践"><a href="#架构实践" class="headerlink" title="架构实践"></a>架构实践</h2><h3 id="朋友圈"><a href="#朋友圈" class="headerlink" title="朋友圈"></a>朋友圈</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;朋友圈是一种典型的<code>Feed</code>流系统，关系是双写关系，关系有上限，排序按照时间，如果有个人持续产生垃圾内容，那就只能屏蔽掉TA，这一种类型就是典型的<strong>写扩散模型</strong>。</p>
<h3 id="微博"><a href="#微博" class="headerlink" title="微博"></a>微博</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微博也是一种非常典型的<code>Feed</code>流系统，但不同于朋友圈，关系是单向的，那么也就会产生大V，这个时候就需要读写扩散模式，用读扩散解决大V问题。同时，微博也是主动关注类型的产品，所以排序也只能是时间，如果按照推荐排序，那么效果就会比较差。</p>
<h3 id="头条"><a href="#头条" class="headerlink" title="头条"></a>头条</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;头条是最近几年快速崛起的一款应用，在原有微博的<code>Feed</code>流系统上产生了进化，用户不需要主动关注其他人，只要初始浏览一些内容后，系统就会自动判断出你的喜好，然后后面再根据你的喜好给你推荐你可能会喜好的内容，训练时间长了后，推送的内容都会是你最喜欢看的。</p>
<h3 id="私信"><a href="#私信" class="headerlink" title="私信"></a>私信</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;私信也算是一种简单的<code>Feed</code>流系统，或者也可以认为是一种变相的<code>IM</code>，都是单对单的，没有群。</p>
<h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Feed</code>类型的系统架构和<code>IM</code>（即时聊天）类型的系统架构非常类似，自从<code>Tablestore</code>从2016年开始优化此类系统，我们研发了<code>Feed</code>流和<code>IM</code>的通用底层框架-<code>Timeline</code>，目前已经演进到了<code>V2</code>版本，一体化支持存储、同步和搜索功能，我们已经有文章做了介绍：</p>
<p>《<a href="https://yq.aliyun.com/articles/692900" target="_blank" rel="noopener">亿级消息系统的核心存储：Tablestore发布Timeline 2.0模型</a>》<br>《<a href="https://yq.aliyun.com/articles/698301" target="_blank" rel="noopener">现代IM系统中的消息系统架构 - 架构篇</a>》<br>《<a href="https://yq.aliyun.com/articles/701593" target="_blank" rel="noopener">现代IM系统中的消息系统架构 - 模型篇</a>》<br>《<a href="https://yq.aliyun.com/articles/699676" target="_blank" rel="noopener">Tablestore权威指南</a>》</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/26/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><span class="page-number current">27</span><a class="page-number" href="/page/28/">28</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/28/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
