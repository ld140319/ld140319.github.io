<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/page/107/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/page/107/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/03/31/三次握手与四次挥手/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/31/三次握手与四次挥手/" itemprop="url">三次握手与四次挥手</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-31T12:12:57+08:00">
                2019-03-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/Linux/Tcp/" itemprop="url" rel="index">
                    <span itemprop="name">Tcp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h1><h2 id="TCP-的特性"><a href="#TCP-的特性" class="headerlink" title="TCP 的特性"></a>TCP 的特性</h2><ul>
<li>TCP 提供一种<strong>面向连接的、可靠的</strong>字节流服务</li>
<li>在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP</li>
<li>TCP 使用校验和，确认和重传机制来保证可靠传输</li>
<li>TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复</li>
<li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li>
</ul>
<p><strong>注意</strong>：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。</p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。</p>
<p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 <code>connect()</code> 时。将触发三次握手。</p>
<ul>
<li><p>第一次握手(SYN=1, seq=x):</p>
<p>客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。</p>
<p>发送完毕后，客户端进入 <code>SYN_SEND</code> 状态。</p>
</li>
<li><p>第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):</p>
<p>服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 <code>SYN_RCVD</code> 状态。</p>
</li>
<li><p>第三次握手(ACK=1，ACKnum=y+1)</p>
<p>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1</p>
<p>发送完毕后，客户端进入 <code>ESTABLISHED</code> 状态，当服务器端接收到这个包时，也进入 <code>ESTABLISHED</code> 状态，TCP 握手结束。</p>
</li>
</ul>
<p>三次握手的过程的示意图如下：</p>
<p><img src="//blog.com/2019/03/31/三次握手与四次挥手/tcp-connection-closed-four-way-handshake.png" alt="three-way-handshake"></p>
<h2 id="为什么要进行三次握手，而不是两次呢？"><a href="#为什么要进行三次握手，而不是两次呢？" class="headerlink" title="为什么要进行三次握手，而不是两次呢？"></a>为什么要进行三次握手，而不是两次呢？</h2><h3 id="解释1"><a href="#解释1" class="headerlink" title="解释1"></a>解释1</h3><p><strong>防止因为网络延迟问题，建立很多无效连接，消耗服务端资源</strong></p>
<blockquote>
<p>​      主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送的第一个请求连接并且没有丢失，只是因为在网络中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时之前滞留的那一次请求连接，因为网络通畅了, 到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。 </p>
<p>​     如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
</blockquote>
<p><img src="//blog.com/2019/03/31/三次握手与四次挥手/1350985432_2318.jpg" alt=""></p>
<h3 id="解释2"><a href="#解释2" class="headerlink" title="解释2"></a>解释2</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>TCP 需要 seq 序列号来做可靠重传或接收，而避免连接复用时无法分辨出 seq 是延迟或者是旧链接的 seq，因此需要三次握手来约定确定双方的 ISN（初始 seq 序列号）</strong></p>
<p>下面给出详细的 RFC 解读说明：（数据分组称为分段（Segment），国内通常用包来称呼）</p>
<hr>
<p>我们首先要知道到一点就是， <strong>TCP 的可靠连接是靠  seq（ sequence numbers 序列号）来达成的</strong>。</p>
<blockquote>
<p>A fundamental notion in the design is that every octet of data sent over a TCP connection has a sequence number.  Since every octet is sequenced, each of them can be acknowledged.  The acknowledgment mechanism employed is cumulative so that an acknowledgment of sequence number X indicates that all octets up to but not including X have been received. </p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;TCP 设计中一个基本设定就是，<strong>通过TCP 连接发送的每一个包，都有一个sequence number</strong>。而因为每个包都是有序列号的，所以都能被确认收到这些包。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>确认机制是累计的，所以一个对sequence number X 的确认，意味着 X 序列号之前(不包括 X) 包都是被确认接收到的</strong>。</p>
<blockquote>
<p>The protocol places no restriction on a particular connection being used over and over again.<br>The problem that arises from this is  – “how does the TCP identify duplicate segments from previous incarnations of the connection?”  This problem becomes apparent if the connection is being opened and closed in quick succession, or if the connection breaks with loss of memory and is then reestablished.</p>
<p>​    该协议对连接重复使用没有限制。由此产生的问题是 - “TCP如何识别以前连接发送的重复段？” 如果快速连续打开和关闭连接，或者连接因内存丢失而中断然后重新建立，则此问题变得明显。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>TCP 协议是不限制一个特定的连接（两端 socket 一样）被重复使用的</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;所以这样就有一个问题：这条连接突然断开重连后，TCP 怎么样识别之前旧链接重发的包？——这就需要独一无二的  ISN（初始序列号）机制。</p>
<blockquote>
<p>​        When new connections are created, an initial sequence number (ISN) generator is employed which selects a new 32 bit ISN.  The generator is bound to a (possibly fictitious) 32 bit clock whose low order bit is incremented roughly every 4 microseconds.  Thus, the ISN cycles approximately every 4.55 hours. Since we assume that segments will stay in the network no more than the Maximum Segment Lifetime (MSL) and that the MSL is less than 4.55 hours we can reasonably assume that ISN’s will be unique.</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>当一个新连接建立时，<code>初始序列号（ initial sequence number ISN）生成器</code>会生成一个新的32位的 ISN</strong>。</p>
<p>这个生成器会用一个32位长的时钟，差不多<code>4µs</code> 增长一次，因此 ISN 会在大约 4.55 小时循环一次</p>
<p>（<code>2^32</code>位的计数器，需要<code>2^32*4 µs</code>才能自增完，除以1小时共有多少µs便可算出<code>2^32*4 /(1*60*60*1000*1000)=4.772185884</code> ）</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;而一个段在网络中并不会比最大分段寿命（Maximum Segment Lifetime (MSL) ，默认使用2分钟）长，MSL 比4.55小时要短，所以我们可以认为 ISN 会是唯一的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;发送方与接收方都会有自己的 ISN （下面的例子中就是 X 与 Y）来做双方互发通信，具体的描述如下：</p>
<blockquote>
<p>1) A –&gt; B  SYN my sequence number is X </p>
<p>2) A &lt;– B  ACK your sequence number is X </p>
<p>3) A &lt;– B  SYN my sequence number is Y </p>
<p>4) A –&gt; B  ACK your sequence number is Y</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;2与3都是 B 发送给 A，因此可以合并在一起，因此成为<code>three way (or three message) handshake</code>（其实翻译为三步握手，或者是三次通信握手更为准确）</p>
<p>因此最终可以得出，三次握手是必须的：</p>
<blockquote>
<p>A three way handshake is necessary because sequence numbers are not tied to a global clock in the network, and TCPs may have different mechanisms for picking the ISN’s. The receiver of the first SYN has no way of knowing whether the segment was an old delayed one or not, unless it remembers the last sequence number used on the connection (which is not always possible), and so it must ask the sender to verify this SYN. The three way handshake and the advantages of a clock-driven scheme are discussed in [3].</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>三次握手（A three way handshake）是必须的， 因为 sequence numbers（序列号）没有绑定到整个网络的全局时钟（全部统一使用一个时钟，就可以确定这个包是不是延迟到的）以及 TCPs 可能有不同的机制来选择 ISN（初始序列号）</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;接收方接收到第一个 SYN 时，没有办法知道这个 SYN 是是否延迟了很久了，除非他有办法记住在这条连接中，最后接收到的那个sequence numbers（然而这不总是可行的）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这句话的意思是：一个 seq 过来了，跟现在记住的 seq 不一样，我怎么知道他是上条延迟的，还是上上条延迟的呢？</p>
<p>所以，<strong>接收方一定需要跟发送方确认 SYN</strong>。</p>
<p>假设不确认 SYN 中的 SEQ，那么就只有：</p>
<blockquote>
<p>1) A –&gt; B  SYN my sequence number is X </p>
<p>2) A &lt;– B  ACK your sequence number is X  SYN my sequence number is Y</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;只有B确认了收到了 A 的 SEQ， A 无法确认收到  B 的。也就是说，只有 A 发送给 B 的包都是可靠的， 而 <strong>B 发送给 A 的则不是</strong>，所以这不是可靠的连接。这种情况如果只需要 A 发送给 B ，B 无需回应，则可以不做三次握手。</p>
<hr>
<p><strong>一个正确的类比</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;所以，正确的类比应该是这样的：TCP 传递信息可以理解为美国与中国用货船来传货物，但因为一首轮船穿放不下，货物要分开一只只轮船来发货。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;所以需要一个序列号来识别该货物是第几个，以便到达后将其拼接回原来的货物。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>因为同一条航道（也就是 tcp连接）上，可能会有多批货物发送（复用 tcp 连接）。发货时，双方需要通知对方这个序列号是从哪里开始（init seq）的，这样才能辨识过来的是不是一个对的货物，以及能拼接成完整的货物</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;货物运输拼接（tcp）最重要的是可靠性，如果没有用三次握手来确认双方都可以获得对方的 序列号（seq）的话，就无法知道当前航班（连接）中，对的货物序号是怎么样的了。</p>
<p><strong>三次握手详细过程</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    TCP A                                                TCP B</span><br><span class="line"></span><br><span class="line">1.  CLOSED                                               LISTEN</span><br><span class="line"></span><br><span class="line">2.  SYN-SENT    --&gt; &lt;SEQ=100&gt;&lt;CTL=SYN&gt;               --&gt; SYN-RECEIVED</span><br><span class="line"></span><br><span class="line">3.  ESTABLISHED &lt;-- &lt;SEQ=300&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;  &lt;-- SYN-RECEIVED</span><br><span class="line"></span><br><span class="line">4.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;       --&gt; ESTABLISHED</span><br><span class="line"></span><br><span class="line">5.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=301&gt;&lt;CTL=ACK&gt;&lt;DATA&gt; --&gt; ESTABLISHED</span><br><span class="line"></span><br><span class="line">        Basic 3-Way Handshake for Connection Synchronization</span><br></pre></td></tr></table></figure>
<ul>
<li>第二行中， A 发送了 SEQ 100，标志位是 SYN；</li>
<li>第三行，B 发回了 ACK 101 与 SEQ 300，标志位是 SYN 与 ACK（两个过程合并了）。注意，ACK 是101意味着，B 希望接收到 101序列号开始的数据段。</li>
<li>第四行，A 返回了空的数据，SEQ 101， ACK 301，标志位为 ACK。至此，双方的开始 SEQ （也就是 ISN）号100与300都被确认接收到了。</li>
<li>第五行，开始正式发送数据包，注意的是 ACK 依旧是第四行的301，因为没有需要 ACK 的 SYN 了（第四行已经 ACK 完）。</li>
</ul>
<p>以上，4 最后这个确认的过程，是可以带上数据的。</p>
<p><strong>一个http请求</strong></p>
<p><img src="/2019/03/31/三次握手与四次挥手/http.png" alt="http"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">The principle reason for the three-way handshake is to prevent old</span><br><span class="line">duplicate connection initiations from causing confusion.  To deal with</span><br><span class="line">this, a special control message, reset, has been devised.  If the</span><br><span class="line">receiving TCP is in a  non-synchronized state (i.e., SYN-SENT,</span><br><span class="line">SYN-RECEIVED), it returns to LISTEN on receiving an acceptable reset.</span><br><span class="line">If the TCP is in one of the synchronized states (ESTABLISHED,</span><br><span class="line">FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT), it</span><br><span class="line">aborts the connection and informs its user.  We discuss this latter</span><br><span class="line">case under &quot;half-open&quot; connections below.</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>三次握手的原则设计是防止旧复用链接的初始化导致问题，为了解决此问题，我们设计了<code>reset</code>这个特别的控制信号来处理</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果接收中的 TCP 在一个未同步状态如 <code>SYN-SENT, SYN-RECEIVED</code>，它会返回 <code>reset</code> 给对方。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果 TCP 是同步状态中如<code>(ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, LAST-ACK, TIME-WAIT)</code>，他会终止此连接并通知用户。</p>
<p>我们举个图例看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   TCP A                                                TCP B</span><br><span class="line"></span><br><span class="line">1.  CLOSED                                               LISTEN</span><br><span class="line"></span><br><span class="line">2.  SYN-SENT    --&gt; &lt;SEQ=100&gt;&lt;CTL=SYN&gt;               ...</span><br><span class="line"></span><br><span class="line">3.  (duplicate) ... &lt;SEQ=90&gt;&lt;CTL=SYN&gt;               --&gt; SYN-RECEIVED</span><br><span class="line"></span><br><span class="line">4.  SYN-SENT    &lt;-- &lt;SEQ=300&gt;&lt;ACK=91&gt;&lt;CTL=SYN,ACK&gt;  &lt;-- SYN-RECEIVED</span><br><span class="line"></span><br><span class="line">5.  SYN-SENT    --&gt; &lt;SEQ=91&gt;&lt;CTL=RST&gt;               --&gt; LISTEN</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6.              ... &lt;SEQ=100&gt;&lt;CTL=SYN&gt;               --&gt; SYN-RECEIVED</span><br><span class="line"></span><br><span class="line">7.  SYN-SENT    &lt;-- &lt;SEQ=400&gt;&lt;ACK=101&gt;&lt;CTL=SYN,ACK&gt;  &lt;-- SYN-RECEIVED</span><br><span class="line"></span><br><span class="line">8.  ESTABLISHED --&gt; &lt;SEQ=101&gt;&lt;ACK=401&gt;&lt;CTL=ACK&gt;      --&gt; ESTABLISHED</span><br><span class="line"></span><br><span class="line">                  Recovery from Old Duplicate SYN</span><br></pre></td></tr></table></figure>
<p>这是复用连接时，旧在途包发往新连接中的例子。</p>
<ul>
<li>3中，一个旧的重复的 <code>SYN</code>到达 <code>B</code>。 </li>
<li>4中， <code>B</code>分别不出是否旧的，照样子正常回包。</li>
<li>5中，<strong><code>A</code>检测到 <code>B</code> 返回的<code>ACK</code>不正确，所以返回 <code>RST(reset)</code></strong></li>
<li>6中，<strong><code>B</code>接收到  <code>RST(reset)</code>信号，于是变成 <code>LISTEN</code> 状态</strong>。</li>
<li>7中，新连接正常的 <code>SYN</code>终于到达了，三次握手正常进行。</li>
</ul>
<p>这种是简化的情况，但是可以看出 TCP 是如何处理复用旧链接的包到达的。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 <code>close()</code> 操作即可产生挥手操作。</p>
<ul>
<li><p>第一次挥手(FIN=1，seq=x)</p>
<p>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p>
<p>发送完毕后，客户端进入 <code>FIN_WAIT_1</code> 状态。</p>
</li>
<li><p>第二次挥手(ACK=1，ACKnum=x+1)</p>
<p>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p>
<p>发送完毕后，服务器端进入 <code>CLOSE_WAIT</code> 状态，客户端接收到这个确认包之后，进入 <code>FIN_WAIT_2</code> 状态，等待服务器端关闭连接。</p>
</li>
<li><p>第三次挥手(FIN=1，seq=y)</p>
<p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。</p>
<p>发送完毕后，服务器端进入 <code>LAST_ACK</code> 状态，等待来自客户端的最后一个ACK。</p>
</li>
<li><p>第四次挥手(ACK=1，ACKnum=y+1)</p>
<p>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 <code>TIME_WAIT</code>状态，等待可能出现的要求重传的 ACK 包。</p>
<p>服务器端接收到这个确认包之后，关闭连接，进入 <code>CLOSED</code> 状态。</p>
<p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 <code>CLOSED</code> 状态。</p>
</li>
</ul>
<p>四次挥手的示意图如下：</p>
<p><img src="//blog.com/2019/03/31/三次握手与四次挥手/tcp-connection-closed-four-way-handshake.png" alt="four-way-handshake"></p>
<h2 id="为什么最后客户端还要等待-2-MSL的时间呢"><a href="#为什么最后客户端还要等待-2-MSL的时间呢" class="headerlink" title="为什么最后客户端还要等待 2*MSL的时间呢?"></a>为什么最后客户端还要等待 2*MSL的时间呢?</h2><p>MSL（Maximum Segment Lifetime）最大分段寿命，TCP允许不同的实现可以设置不同的MSL值。</p>
<p>MSL最大段寿命是一个TCP分段可以存在于互联网系统中的最大时间，它通常被定义为两分钟长。保持2MSL的Time Wait State保证了这个连接的杂散数据能够被正确传递到并且连接相关的资源被正确释放。</p>
<p>第一，<strong>保证客户端发送的最后一个ACK报文能够到达服务器</strong>，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>
<p>第二，<strong>防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中</strong>。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
<h2 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而<strong>关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送</strong>。</p>
<h2 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h2><ul>
<li><p>什么是 SYN 攻击（SYN Flood）？</p>
<p>在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态.</p>
<p>SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p>
<p>SYN 攻击是一种典型的 DoS/DDoS 攻击。</p>
</li>
<li><p>如何检测 SYN 攻击？</p>
<p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p>
</li>
<li><p>如何防御 SYN 攻击？</p>
<p>SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：</p>
<ul>
<li>缩短超时（SYN Timeout）时间</li>
<li>增加最大半连接数</li>
<li>过滤网关防护</li>
<li>SYN cookies技术</li>
</ul>
</li>
</ul>
<h2 id="TCP-KeepAlive"><a href="#TCP-KeepAlive" class="headerlink" title="TCP KeepAlive"></a>TCP KeepAlive</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;TCP 的连接，实际上是一种纯软件层面的概念，在物理层面并没有“连接”这种概念。TCP 通信双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会。在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制实现来实现。主流的操作系统基本都在内核里支持了这个特性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;首先 TCP KeepAlive 监测的方式是发送一个 probe 包，会给网络带来额外的流量，另外 TCP KeepAlive 只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用。例如当一个服务器 CPU 进程服务器占用达到 100%，已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。需要做连接保活的应用层程序，例如 QQ，往往会在应用层实现自己的心跳功能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/03/30/使用Redis有序集合实现投票排行榜系统/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/30/使用Redis有序集合实现投票排行榜系统/" itemprop="url">使用Redis有序集合实现投票排行榜系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-30T12:12:57+08:00">
                2019-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/投票/" itemprop="url" rel="index">
                    <span itemprop="name">投票</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/投票/排行榜/" itemprop="url" rel="index">
                    <span itemprop="name">排行榜</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用Redis有序集合实现投票排行榜系统"><a href="#使用Redis有序集合实现投票排行榜系统" class="headerlink" title="使用Redis有序集合实现投票排行榜系统"></a>使用Redis有序集合实现投票排行榜系统</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5ODIxODE2Ng==&amp;mid=2651137190&amp;idx=1&amp;sn=22c9fa81a44a83dfac0ec15683c35366&amp;chksm=8b657d7fbc12f469ab3f49a456e0ec704b175aac91720df759cec356725b03fd7460c2a9baaa&amp;mpshare=1&amp;scene=1&amp;srcid=0329RMQu70oA5NfKtkzmqW1C&amp;key=d1ef9b0fa6e6abd4f4ce0079cd33966eaa6ccff66340729c411398b6f6368201513198d824f6991db4635d87252228d700d9b830e2fa9abaab9241b865801b1c3b21cefdafe78799d7a6560ac53382e7&amp;ascene=1&amp;uin=MTEzMDAzMjAyMg%3D%3D&amp;devicetype=Windows+10&amp;version=62060739&amp;lang=zh_CN&amp;pass_ticket=H1WxZReImXNHtiO%2BKxobmLL7Jvin76os6q8Snc43pIytzZ19%2FgV8nzQizhHbxeND" target="_blank" rel="noopener">使用Redis有序集合实现投票排行榜系统</a></p>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;业务开发中多多少少会遇到这种需求，需要一个排行榜，它需要对列表中成员的票数进行排序。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>在一个排行榜中，成员的名次是要根据当前票数动态变化的</strong>，如果使用Mysql，将会造成频繁的修改，Mysql的性能将得不到满足。其实成员的数据结构特别简单： <code>[成员名：分数]</code>，如果了解过Redis的有序集合( <code>ZSet</code>)，那你将发现Redis的有序集合非常适合做排行榜。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;简单介绍一下Redis的有序集合，它的存储结构抽象一下可以理解为以下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key[score1 member1][score2 member2][score3 member3][......]</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;其中 <code>key</code>就是Redis的key，而 <strong><code>score</code> 和 <code>member</code>总是成对出现， <code>score</code>是 <code>member</code>的分数，这里可以理解为获取的票数</strong>。</p>
<p>有序集合提供了很多方法，如</p>
<ul>
<li><p><code>ZADD key score member[[score member][score member]…]</code> </p>
<p>为 <code>key</code>添加名为 <code>member</code>的选项并设置它的分数为 <code>score</code>；</p>
<blockquote>
<p>添加某个成员并初始化票数</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><code>ZSCORE key member</code>                                            </p>
<p>获取某个 <code>key</code>下成员 <code>member</code>的分数；</p>
<blockquote>
<p>获取某个成员的票数</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><code>ZINCRBY key increment member</code>                   </p>
<p>  给 <code>member</code>的分数增加 <code>increment</code></p>
<blockquote>
<p>增加某个成员的票数</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><code>ZRANGE key start stop [WITHSCORES]</code></p>
<p>返回从 <code>start</code>到 <code>stop</code>名次的成员， <code>[WITHSCORES]</code>是可选项，添加后将一并返回成员的分数。这个命令是根据成员的 <code>score</code>从小到大排名，还有一个命令 <code>ZREVRANGE key start stop[WITHSCORES]</code>是按照 <code>score</code>从大到小排名。</p>
<blockquote>
<p>获取排名某个区间的成员</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><code>ZRANK key member</code> </p>
<p>返回某个 <code>key</code> 下成员名为 <code>member</code>的排名，分数按照从小到大，相对应的有个 <code>ZREVRANK key member</code></p>
<blockquote>
<p>获取某个成员的排名</p>
</blockquote>
</li>
</ul>
<p>最后，我们梳理下投票系统需要的功能，需要实现下几点：</p>
<ul>
<li>可以投票</li>
<li>获取排行榜</li>
<li>获取成员的排名和分数</li>
<li>参与人数统计</li>
<li>需要一个后台对选项进行配置以及数据展示</li>
</ul>
<p><strong>一个通用的投票系统，通过HTTP接口调用的方式进行接入</strong>。</p>
<h2 id="排行榜"><a href="#排行榜" class="headerlink" title="排行榜"></a>排行榜</h2><h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;先说最简单的排行榜。其实之前我们有个用于投票的系统，但是他没有用有序集合，他是这样做的：用redis最基本的 <code>key-value</code>结构中记录票数， <code>key</code>是选项， <code>value</code>是票数，然后每个月的后三天不能再进行投票，因为需要一个定时任务，将票数统计出来持久存储，作为本月的排行榜。可以看到有好多缺点：</p>
<ol>
<li><strong>不能实时计算榜单</strong>，只能每个月跑脚本最后计算出来；</li>
<li><strong>每个月都有几天用户不能投票，损失一大波流量</strong>；</li>
<li><strong>只能支持月榜</strong>；</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在系统中设计了<strong>多个周期的排行榜</strong>，有小时榜、日榜、周榜、月榜、总榜。解释一下 <code>小时榜</code>就是所有列表成员，在一个小时内获取票数的排行榜，其他榜单以此类推。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在设计到多个周期的排行榜时，为了保证对多个key操作的原子性，可以采用redis lua script或者redis事务来实现。投票/取消投票均需要通过lua script或者事务来实现	</span><br><span class="line"></span><br><span class="line">其实这里也可以不使用lua script, 因为这里采用redis incr/decr的执行顺序对排行榜的结果没有影响，但是要注意一点：所有的排行榜key操作均需要通过incr/decr来进行，如果第一次set但没有加分布式锁控制的话，会存在并发问题。</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;能做到不同排行榜主要是<strong>在于ZSet的 <code>key</code>的设置，一个 <code>key</code>就是一个排行榜，向不同 <code>key</code>对 <code>member</code>的 <code>score</code>进行增加，ZSet会帮助我们进行排序，而我们只需要调用 <code>ZRANGE</code>或者 <code>ZREVRANGE</code>即可返回排行榜</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这样设计的好处就是所有的数据都会被保存下来、<strong>榜单是完全实时的、不需要脚本、不需要暂停投票</strong>。投票时只要根据用户点击投票的时间，计算这个投票时间属于哪个小时、哪一天、哪一周、哪一月，计算对应榜单 <code>key</code>，给对应的 <code>member</code>增加票数就可以了。</p>
<h3 id="排行榜key设计"><a href="#排行榜key设计" class="headerlink" title="排行榜key设计"></a>排行榜key设计</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;看到下面几组key，我觉得大家就会一目了然，其中<strong><code>{voteId}</code>是系统中不同投票列表的ID，如男星榜和女星榜的 <code>voteId</code>是不同的</strong>。</p>
<p>小时榜：</p>
<ul>
<li>2019年3月17日11点排行榜： <code>vote:{voteId}:hour:2019031711</code></li>
<li>2019年3月17日12点排行榜： <code>vote:{voteId}:hour:2019031712</code></li>
</ul>
<p>日榜：</p>
<ul>
<li>2019年3月17日排行榜： <code>vote:{voteId}:day:20190317</code></li>
<li>2019年3月18日排行榜： <code>vote:{voteId}:day:20190318</code></li>
</ul>
<p>周榜：</p>
<ul>
<li>2019年第12周排行榜： <code>vote:{voteId}:week:201912</code></li>
<li>2019年第13周排行榜： <code>vote:{voteId}:week:201913</code></li>
</ul>
<p>月榜：</p>
<ul>
<li>2019年1月排行榜： <code>vote:{voteId}:week:201901</code></li>
<li>2019年2月排行榜： <code>vote:{voteId}:week:201902</code></li>
</ul>
<p>总榜： <code>vote:{voteId}:total</code></p>
<h2 id="投票功能"><a href="#投票功能" class="headerlink" title="投票功能"></a>投票功能</h2><ul>
<li><strong>多维度的频率限制</strong></li>
<li><strong>灵活的票数增加</strong></li>
<li><strong>HyperLogLog实现的人数统计</strong></li>
</ul>
<h3 id="频率限制"><a href="#频率限制" class="headerlink" title="频率限制"></a>频率限制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;首先是频率限制，对于一个完善的投票系统，不可能让用户无限制的进行投票。除了基本的IP限制之外，我们在系统中实现了更<strong>多维度的频率限制</strong>。</p>
<ul>
<li><strong>对单个用户的频率限制</strong>，如一分钟单个用户能投5票，一小时只能投10票，甚至在整个投票周期内，限制单个用户只能投一次票；</li>
<li><strong>对被投票成员的限制</strong>，这种情况是为了避免恶意刷票而导致某个投票项票数增加太快而导致数据不好看，如在明星榜中，为了防止易烊千玺票数突然被刷爆，可以设置他每秒只能被投票1000次，每小时100000次等。</li>
<li><strong>对不同渠道来源的频率限制</strong>，比如和某公司合作，从他渠道过来的流量，我们可以给他额外增加5票的限制，可以激励用户到他的平台进行投票，实现导流目的；</li>
<li><strong>对不同终端进行频率限制</strong>，如PC端投了5票达到上限后，用户还可以在移动端再进行投票，从而能提高整个投票活动的活跃度；</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这几个维度的配置在后台实现，配置也十分灵活，因为上面每个维度都支持多个时间周期的设置，周期可以是秒、分钟、小时、星期、月，而且可以多个频率限制进行组合。</p>
<h3 id="票数增加"><a href="#票数增加" class="headerlink" title="票数增加"></a>票数增加</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;其次是票数增加，票数增加也没有想象的那么简单，并不是调用一个 <code>ZINCRBY key increment member</code>就能完事了的，因为票数加完了之后，这个是为了产出排行榜的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;从产品经理的维度来看，他可能并不能满足当前用户投票的真实增长速度，因为往往在推广前期，用户量并没有这么多，如果看着排行榜里面十几、几十的票数是非常难看的，因此我们设计了一些功能</p>
<ul>
<li><p><strong>初始化票数</strong>：直接通过后台修改某个选项的投票数量。当要修改的人太多的话，运营将是很崩溃的，因此后台在初始化导入的时候，允许选项有一个初始的票数；</p>
</li>
<li><p><strong>多个周期排行榜</strong>：上面说了，一组成员，可能会有多个周期的排行榜，如小时榜、周榜、月榜等；</p>
</li>
<li><p><strong>投1票加N票</strong>：支持对某个选项设置，只要他被投1次票，可以增加N票，这个N可以在后台进行设置，这样会增快票数增长速度，让票数增加更快更好看；</p>
</li>
<li><p><strong>票数在周期间继承</strong>：<code>对于周期性的排行榜，每个周期的开始，往往票数会归为0</code>，比如周榜，周一票数就会变为0。这会引起两个问题，第一，<code>所有成员票数都是0，排行榜是完全随机的，你不知道谁在前面，就会导致热度很高的明星排在后面</code>，这样用户来投票得花功夫去找他想投的明星；第二就是刚说的那个问题，票数不好看，其中一个有个解决方案，就是<code>根据当初导入时初始化的票数对每个周期的票数重新设置，但这样每次周期开始都是一样的</code>。那对于一个成熟的系统来说，他要自己学会<strong><code>初始化票数，因此我们可以将上一个周期的票数继承到下个周期的开始</code></strong>。</p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;我这里挑选几点详细说明一下：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>多个周期排行榜：</strong>列表具体要统计哪个周期的榜单，可以在后台设置。如女星榜设置要只要统计小时榜和日榜，某个用户在 2019年3月17日 12:33 点击给 <code>迪丽热巴</code>投票，那么会根据 <code>2019年3月17日12:33</code>这个时间计算出两个榜单的Key：小时榜 <code>vote:actress:2019031712</code>、日榜 <code>vote:actress:20190317</code>，需要同时给这两个 <code>key</code>中的成员 <code>迪丽热巴</code>进行加票。这样就同时有了小时榜和日榜。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>投1票加N票：</strong>这里需要记录到两个不同的排行榜，那其实最后还要在 <code>key</code>中加一个维度，形如： <code>vote:actress:20190317:true</code>和 <code>vote:actress:20190317:false</code>，姑且称为 <code>True排行榜</code>和 <code>False排行榜</code>，用户点击一次投1票，在 <code>True排行榜</code>中给那个选项增加1票，然后从配置中获取后台设置N，再在 <code>False排行榜</code>中给同样的选项增加N票。最后展示给用户的，可以用 <code>False排行榜</code>进行展示。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>票数在周期间继承：</strong>一开始想的是，在每个周期结束的时候，跑一个自动的脚本，把票数统计加入到下个周期的排行榜，但是我们后来发现逻辑复杂而且不容易维护，还有就是要跑多久才能跑完，周期结束前什么时候开始跑呢，一大堆问题。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在说解决方案之前，我先说一下有序集合 <code>key[score1 member1][score2 member2][......]</code>中， <code>score</code>并不是整数，是一个浮点数。那这样的话，我们就可以<strong>在用户投一票的时候，程序同时给下个周期加 <code>1</code>票这样子，下个周期的开始票数是完全根据上个周期的票数计算的，完全实时，没有必要跑脚本之类</strong>。而能这样做的原因是<strong>因为周期长度都是固定的，完全可以根据点击投票的时间计算出下个周期的 <code>key</code></strong>。对于滚动排行榜，如最近n天，这种方案是没有用的。</p>
<blockquote>
<p>这里有一个细节我觉得需要注意：</p>
<p>​     如果在排行榜中要展示真实的票数，每个周期总数要减去上一个周期总数，原因在于为了排名统计时，加上了上一周期总数</p>
</blockquote>
<h3 id="人数统计"><a href="#人数统计" class="headerlink" title="人数统计"></a>人数统计</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>人数统计不同于人次统计</strong>，如果说人次统计和PV类似，那么人数统计就是UV。我借助Redis的数据结构 <code>HyperLogLog</code>进行统计，因为我们只要一个最后<strong>总参与人数</strong>的大概数字，而我们也不需要知道到底是谁什么时候来投票了。这个时候 <code>HyperLogLog</code>就能满足需求，同时占用空间特别小（每个 <code>HyperLogLog</code> 只需使用 12k 字节内存，以及几个字节的内存来储存键本身）。 本系统中我分别统计了某个选项的参与人数和整个投票的参与人数。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;可以看到，一个投票接口，需要做好多工作：<strong>多个周期榜单票数增加、真假排行榜票数增加、下一周期票数增加、人数统计</strong>。同时也可以发现，这几个操作之间并没有任何关联，所以我们可以<strong>并行写入，降低接口的响应时间</strong>。那实际在做的时候，投票接口通过频率限制检查之后，这几个接口我就直接用<strong>go协程</strong>处理了，因为不需要我返回投票后的票数，这个完全可以在前端+1。</p>
<h2 id="获取某成员的排名和分数"><a href="#获取某成员的排名和分数" class="headerlink" title="获取某成员的排名和分数"></a>获取某成员的排名和分数</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;了解了排行榜和投票功能之后，这个功能理解起来就特别简单了，接口通过参数传入想要获取哪个榜单的成员名称，计算得到 <code>key</code>，通过调用 <code>ZRANK key member</code>和 <code>ZREVRANK key member</code>即可。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;但其实也处理了一些复杂逻辑，比如<strong>能支持返回他的前一名，这样可以获取到他和前一名的差距；还支持获取他上个周期的排名和分数，这样能看到他本周期和上个周期相比票数上升了还是下降了</strong>。</p>
<blockquote>
<p>这里的复杂逻辑操作，均需要使用redis lua script来实现，才能保证结果的准确性</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;同时这几个接口都是支持批量操作的，<strong>投票接口支持对多个榜单多个选项同时投票，排行榜接口支持同时获取多个排行榜，获取成员排名和分数的时候也支持同时获取多个成员的信息</strong>。这些都多亏了golang的goroutine，从而接口性能得以保证。</p>
<h2 id="系统配置后台"><a href="#系统配置后台" class="headerlink" title="系统配置后台"></a>系统配置后台</h2><h3 id="频率限制-1"><a href="#频率限制-1" class="headerlink" title="频率限制"></a>频率限制</h3><p><img src="//blog.com/2019/03/30/使用Redis有序集合实现投票排行榜系统/1.jpg" alt="img"></p>
<h3 id="投票列表"><a href="#投票列表" class="headerlink" title="投票列表"></a>投票列表</h3><p><img src="//blog.com/2019/03/30/使用Redis有序集合实现投票排行榜系统/2.jpg" alt="img"></p>
<h3 id="投票统计"><a href="#投票统计" class="headerlink" title="投票统计"></a>投票统计</h3><p><img src="//blog.com/2019/03/30/使用Redis有序集合实现投票排行榜系统/4.jpg" alt="img"></p>
<h2 id="测试报告"><a href="#测试报告" class="headerlink" title="测试报告"></a>测试报告</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;一方面得益于golang的goroutine，另一方面<strong>在启动程序时将投票信息从mysql写入到内存中【缓存预热】，接口只对redis进行读写操作</strong>，所以接口性能和稳定性表现都十分不错。下面是对几个接口的测试报告：</p>
<h3 id="投票接口"><a href="#投票接口" class="headerlink" title="投票接口"></a>投票接口</h3><p><img src="//blog.com/2019/03/30/使用Redis有序集合实现投票排行榜系统/5.jpg" alt="img"></p>
<h3 id="获取排行榜接口"><a href="#获取排行榜接口" class="headerlink" title="获取排行榜接口"></a>获取排行榜接口</h3><p><img src="//blog.com/2019/03/30/使用Redis有序集合实现投票排行榜系统/6.jpg" alt="img"></p>
<h3 id="获取某成员的排名和分数接口"><a href="#获取某成员的排名和分数接口" class="headerlink" title="获取某成员的排名和分数接口"></a>获取某成员的排名和分数接口</h3><p><img src="//blog.com/2019/03/30/使用Redis有序集合实现投票排行榜系统/7.jpg" alt="img"></p>
<h2 id="示例产品"><a href="#示例产品" class="headerlink" title="示例产品"></a>示例产品</h2><h3 id="360人气榜"><a href="#360人气榜" class="headerlink" title="360人气榜"></a>360人气榜</h3><p><img src="//blog.com/2019/03/30/使用Redis有序集合实现投票排行榜系统/2.png" alt=""></p>
<h3 id="2018公益活动榜"><a href="#2018公益活动榜" class="headerlink" title="2018公益活动榜"></a>2018公益活动榜</h3><p><img src="//blog.com/2019/03/30/使用Redis有序集合实现投票排行榜系统/3.png" alt=""></p>
<h3 id="校园好声音专题"><a href="#校园好声音专题" class="headerlink" title="校园好声音专题"></a>校园好声音专题</h3><p><img src="//blog.com/2019/03/30/使用Redis有序集合实现投票排行榜系统/1.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/03/30/秒杀系统设计/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/30/秒杀系统设计/" itemprop="url">秒杀系统设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-30T12:12:57+08:00">
                2019-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/秒杀/" itemprop="url" rel="index">
                    <span itemprop="name">秒杀</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="秒杀系统设计"><a href="#秒杀系统设计" class="headerlink" title="秒杀系统设计"></a>秒杀系统设计</h1><h2 id="一、大规模并发带来的挑战"><a href="#一、大规模并发带来的挑战" class="headerlink" title="一、大规模并发带来的挑战"></a>一、大规模并发带来的挑战</h2><p>在过去的工作中，我曾经面对过5w每秒的高并发秒杀功能，在这个过程中，整个Web系统遇到了很多的问题和挑战。如果Web系统不做针对性的优化，会轻而易举地陷入到异常状态。我们现在一起来讨论下，优化的思路和方法哈。</p>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul>
<li>不要整个系统宕机。</li>
<li>即使系统故障，也不要将错误数据展示出来。</li>
<li>尽量保持公平公正。</li>
</ul>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><ul>
<li>秒杀开始前，抢购按钮为活动未开始。</li>
<li>秒杀开始时，抢购按钮可以点击下单。</li>
<li>秒杀结束后，按钮按钮变成秒杀已结束。</li>
</ul>
<h3 id="技术攻关"><a href="#技术攻关" class="headerlink" title="技术攻关"></a>技术攻关</h3><ul>
<li><p>短时间内的大访问量对现有网站业务造成的冲击。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">秒杀是一个网站营销的一个附加活动，时间短，并发量大。</span><br><span class="line">  </span><br><span class="line">如果和网站原有应用部署在一起，必然会对现有业务造成冲击，稍有不慎可能导致整个网站瘫痪。</span><br></pre></td></tr></table></figure>
</li>
<li><p>高并发下对服务器数据库造成的极大负载压力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用户秒杀开始前，通过不断刷新浏览器来保证不会错过秒杀活动。</span><br><span class="line">  </span><br><span class="line">频繁的访问程序、数据库会对应用服务器和数据库服务器造成负载压力。</span><br></pre></td></tr></table></figure>
</li>
<li><p>网络带宽的问题比超过平时好多倍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果秒杀页面的大小为200K，如果最大并发数为10000次，那么需要的网络和服务器带宽是2G（200K×10000）。</span><br><span class="line">  </span><br><span class="line">这些网络带宽是因为秒杀活动新增的，超过网站平时使用的带宽。</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免直接下单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">秒杀的游戏规则是到了秒杀才能开始对商品下单购买，在此时间点之前，只能浏览信息不可下单。</span><br><span class="line">  </span><br><span class="line">而下单页面也是一个普通的URL，如果得到这个URL，不用等到秒杀开始就可以下单了。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="应对策略"><a href="#应对策略" class="headerlink" title="应对策略"></a>应对策略</h3><ul>
<li><p>秒杀系统独立部署</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">为了避免短时间内的大访问量对现有网站业务造成的冲击，可以将秒杀系统独立部署。</span><br><span class="line">  </span><br><span class="line">如果需要还可以使用独立域名，使其与网站完全隔离。</span><br><span class="line">  </span><br><span class="line">即使秒杀系统崩溃了，也不会对网站造成影响。</span><br></pre></td></tr></table></figure>
</li>
<li><p>秒杀商品页面静态化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将商品描述、参数、详情，全部写到一个静态页面，不用进行程序的逻辑处理，不需访问数据库。</span><br><span class="line">  </span><br><span class="line">不用部署动态的服务器和数据库服务器。</span><br></pre></td></tr></table></figure>
</li>
<li><p>租借秒杀活动的网络带宽</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">因为秒杀新增的网络带宽，必须和运营商重新购买或租借带宽。</span><br><span class="line">  </span><br><span class="line">为了减轻服务器的压力，需要将秒杀商品页面缓存在CDN,同样CDN服务器也需要临时租借带宽。</span><br></pre></td></tr></table></figure>
</li>
<li><p>动态生成随机下单页面的URL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了避免用户直接访问下单URL,需要将URL动态化，用随机数作为参数，只能秒杀开始的时候才生成。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><ul>
<li><p>如何控制秒杀商品页面抢购按钮的可用/禁用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">购买按钮只有在秒杀开始的时候才能点亮，在此之前是灰色的，显示活动未开始。</span><br><span class="line">  </span><br><span class="line">如果页面是动态生成的，每次刷新都要请求服务器，那么势必造成服务端的负载压力。</span><br><span class="line">  </span><br><span class="line">如果页面是静态页面的话，可以将页面缓存在CDN，反向代理服务器上，甚至用户浏览器上。</span><br><span class="line">  </span><br><span class="line">但是这样，秒杀开始时，用户刷新页面，根本请求不到应用服务器。</span><br><span class="line">  </span><br><span class="line">解决方案：</span><br><span class="line">  </span><br><span class="line">使用JS脚本控制，在页面中引用一个JS文件(文件极小)，但是该文件不要被缓存。</span><br><span class="line">  </span><br><span class="line">该JS的作用是，包含秒杀开始标志，修改样式，生成下单页面的URL及随机参数。</span><br><span class="line">  </span><br><span class="line">该JS文件不被缓存的做法：xxx.js?v=随机数。</span><br><span class="line">  </span><br><span class="line">会有一台服务器进行监控(定时上下架)：</span><br><span class="line">  </span><br><span class="line">当秒杀活动开始时推送该文件。</span><br><span class="line">  </span><br><span class="line">当秒杀活动结束时推送文件，标示结束标志，修改样式。</span><br><span class="line">  </span><br><span class="line">如下图。</span><br></pre></td></tr></table></figure>
<p><img src="//blog.com/2019/03/30/秒杀系统设计/464038810-580deed0a2f20_articlex.png" alt="浅谈秒杀系统架构设计-1"></p>
</li>
<li><p>如何只允许，第一个提交的单进入订单系统。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">由于秒杀到商品的用户只有一个，因此需要在提交订单时，进行下单前置检查。</span><br><span class="line">  </span><br><span class="line">如果已经有订单提交成功，表示活动结束，进入秒杀结束页面。</span><br><span class="line">  </span><br><span class="line">事实上，订单数只能有一个，为了减轻下单页面服务器的负载压力，可以控制进入下单页面的入口。</span><br><span class="line">  </span><br><span class="line">只有少数用户能进入下单页面，其他用户直接进入秒杀结束页面。</span><br><span class="line">  </span><br><span class="line">（前置检查逻辑）检查本机已处理的下单请求数目：</span><br><span class="line">  </span><br><span class="line">  如果超过10条，直接返回已结束页面给用户。</span><br><span class="line">  </span><br><span class="line">  如果未超过10条，则用户可进入填写订单及确认页面。</span><br><span class="line">  </span><br><span class="line">（前置检查逻辑）检查全局已提交订单数目：</span><br><span class="line">  </span><br><span class="line">  已超过秒杀商品总数，返回秒杀结束页面。</span><br><span class="line">  </span><br><span class="line">  未超过秒杀商品总数，提交到子订单系统。</span><br><span class="line">  </span><br><span class="line">  如下图。</span><br></pre></td></tr></table></figure>
<p><img src="//blog.com/2019/03/30/秒杀系统设计/2040539983-580deee8b0995_articlex.png" alt="浅谈秒杀系统架构设计-2"></p>
</li>
<li><p>减库存的操作</p>
</li>
</ul>
<p>拍下减库存(用户体验好)</p>
<p>付款减库存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下订单尽可能简单，购买数据为1且不可编辑，送货地址和付款方式为空或用户默认，允许订单提交后修改。</span><br></pre></td></tr></table></figure>
<h4 id="请求接口的合理设计"><a href="#请求接口的合理设计" class="headerlink" title="请求接口的合理设计"></a>请求接口的合理设计</h4><p>一个秒杀或者抢购页面，通常分为2个部分，一个是静态的HTML等内容，另一个就是参与秒杀的Web后台请求接口。</p>
<p>通常静态HTML等内容，是通过CDN的部署，一般压力不大，核心瓶颈实际上在后台请求接口上。这个后端接口，必须能够支持高并发请求，同时，非常重要的一点，必须尽可能“快”，在最短的时间里返回用户的请求结果。为了实现尽可能快这一点，接口的后端存储使用内存级别的操作会更好一点。仍然直接面向 MySQL之类的存储是不合适的，如果有这种复杂业务的需求，都建议采用异步写入。</p>
<p><img src="//blog.com/2019/03/30/秒杀系统设计/547821ba53d6d_middle.jpg" alt="Web系统大规模并发——电商秒杀与抢购 - 徐汉彬Hansion - 技术行者"></p>
<p>当然，也有一些秒杀和抢购采用“滞后反馈”，就是说秒杀当下不知道结果，一段时间后才可以从页面中看到用户是否秒杀成功。但是，这种属于“偷懒”行为，同时给用户的体验也不好，容易被用户认为是“暗箱操作”。</p>
<h4 id="高并发的挑战：一定要“快”"><a href="#高并发的挑战：一定要“快”" class="headerlink" title="高并发的挑战：一定要“快”"></a>高并发的挑战：一定要“快”</h4><p>我们通常衡量一个Web系统的吞吐率的指标是QPS（Query Per Second，每秒处理请求数），解决每秒数万次的高并发场景，这个指标非常关键。举个例子，我们假设处理一个业务请求平均响应时间为100ms，同时， 系统内有20台Apache的Web服务器，配置MaxClients为500个（表示Apache的最大连接数目）。</p>
<p>那么，我们的Web系统的理论峰值QPS为（理想化的计算方式）：</p>
<p>20*500/0.1 = 100000 （10万QPS）</p>
<p>咦？我们的系统似乎很强大，1秒钟可以处理完10万的请求，5w/s的秒杀似乎是“纸老虎”哈。实际情况，当然没有这么理想。在高并发的实际场景下，机器都处于高负载的状态，在这个时候平均响应时间会被大大增加。</p>
<p>就Web服务器而言，Apache打开了越多的连接进程，CPU需要处理的上下文切换也越多，额外增加了CPU的消耗，然后就直接导致平均响应时间 增加。因此上述的MaxClient数目，要根据CPU、内存等硬件因素综合考虑，绝对不是越多越好。可以通过Apache自带的abench来测试一 下，取一个合适的值。然后，我们选择内存操作级别的存储的Redis，在高并发的状态下，存储的响应时间至关重要。网络带宽虽然也是一个因素，不过，这种 请求数据包一般比较小，一般很少成为请求的瓶颈。负载均衡成为系统瓶颈的情况比较少，在这里不做讨论哈。</p>
<p>那么问题来了，假设我们的系统，在5w/s的高并发状态下，平均响应时间从100ms变为250ms（实际情况，甚至更多）：</p>
<p>20*500/0.25 = 40000 （4万QPS）</p>
<p>于是，我们的系统剩下了4w的QPS，面对5w每秒的请求，中间相差了1w。</p>
<p>然后，这才是真正的恶梦开始。举个例子，高速路口，1秒钟来5部车，每秒通过5部车，高速路口运作正常。突然，这个路口1秒钟只能通过4部车，车流量仍然依旧，结果必定出现大塞车。（5条车道忽然变成4条车道的感觉）</p>
<p>同理，某一个秒内，20*500个可用连接进程都在满负荷工作中，却仍然有1万个新来请求，没有连接进程可用，系统陷入到异常状态也是预期之内。</p>
<p><img src="//blog.com/2019/03/30/秒杀系统设计/547821ee2d1ee_middle.jpg" alt="Web系统大规模并发——电商秒杀与抢购 - 徐汉彬Hansion - 技术行者"></p>
<p>其实在正常的非高并发的业务场景中，也有类似的情况出现，某个业务请求接口出现问题，响应时间极慢，将整个Web请求响应时间拉得很长，逐渐将Web服务器的可用连接数占满，其他正常的业务请求，无连接进程可用。</p>
<p>更可怕的问题是，是用户的行为特点，系统越是不可用，用户的点击越频繁，恶性循环最终导致“雪崩”（其中一台Web机器挂了，导致流量分散到其他正常工作的机器上，再导致正常的机器也挂，然后恶性循环），将整个Web系统拖垮。</p>
<h4 id="重启与过载保护"><a href="#重启与过载保护" class="headerlink" title="重启与过载保护"></a>重启与过载保护</h4><p>如果系统发生“雪崩”，贸然重启服务，是无法解决问题的。最常见的现象是，启动起来后，立刻挂掉。这个时候，最好在入口层将流量拒绝，然后再将重启。如果是redis/memcache这种服务也挂了，重启的时候需要注意“预热”，并且很可能需要比较长的时间。</p>
<p>秒杀和抢购的场景，流量往往是超乎我们系统的准备和想象的。这个时候，过载保护是必要的。如果检测到系统满负载状态，拒绝请求也是一种保护措施。在前端设置过滤是最简单的方式，但是，这种做法是被用户“千夫所指”的行为。更合适一点的是，将过载保护设置在CGI入口层，快速将客户的直接请求返回。</p>
<h2 id="二、作弊的手段：进攻与防守"><a href="#二、作弊的手段：进攻与防守" class="headerlink" title="二、作弊的手段：进攻与防守"></a>二、作弊的手段：进攻与防守</h2><p>秒杀和抢购收到了“海量”的请求，实际上里面的水分是很大的。不少用户，为了“抢“到商品，会使用“刷票工具”等类型的辅助工具，帮助他们发送尽可 能多的请求到服务器。还有一部分高级用户，制作强大的自动请求脚本。这种做法的理由也很简单，就是在参与秒杀和抢购的请求中，自己的请求数目占比越多，成功的概率越高。</p>
<p>这些都是属于“作弊的手段”，不过，有“进攻”就有“防守”，这是一场没有硝烟的战斗哈。</p>
<h3 id="1-同一个账号，一次性发出多个请求"><a href="#1-同一个账号，一次性发出多个请求" class="headerlink" title="1. 同一个账号，一次性发出多个请求"></a>1. 同一个账号，一次性发出多个请求</h3><p>部分用户通过浏览器的插件或者其他工具，在秒杀开始的时间里，以自己的账号，一次发送上百甚至更多的请求。实际上，这样的用户破坏了秒杀和抢购的公平性。</p>
<p>这种请求在某些没有做数据安全处理的系统里，也可能造成另外一种破坏，导致某些判断条件被绕过。例如一个简单的领取逻辑，先判断用户是否有参与记 录，如果没有则领取成功，最后写入到参与记录中。这是个非常简单的逻辑，但是，在高并发的场景下，存在深深的漏洞。多个并发请求通过负载均衡服务器，分配到内网的多台Web服务器，它们首先向存储发送查询请求，然后，在某个请求成功写入参与记录的时间差内，其他的请求获查询到的结果都是“没有参与记录”。 这里，就存在逻辑判断被绕过的风险。</p>
<p><img src="//blog.com/2019/03/30/秒杀系统设计/5478221b71722_middle.jpg" alt="Web系统大规模并发——电商秒杀与抢购 - 徐汉彬Hansion - 技术行者"></p>
<p>应对方案：</p>
<p>在程序入口处，一个账号只允许接受1个请求，其他请求过滤。不仅解决了同一个账号，发送N个请求的问题，还保证了后续的逻辑流程的安全。实现方案， 可以通过Redis这种内存缓存服务，写入一个标志位（只允许1个请求写成功，结合watch的乐观锁的特性），成功写入的则可以继续参加。</p>
<p><img src="//blog.com/2019/03/30/秒杀系统设计/547822508a00b_middle.jpg" alt="Web系统大规模并发——电商秒杀与抢购 - 徐汉彬Hansion - 技术行者"></p>
<p>或者，自己实现一个服务，将同一个账号的请求放入一个队列中，处理完一个，再处理下一个。</p>
<h3 id="2-多个账号，一次性发送多个请求"><a href="#2-多个账号，一次性发送多个请求" class="headerlink" title="2. 多个账号，一次性发送多个请求"></a>2. 多个账号，一次性发送多个请求</h3><p>很多公司的账号注册功能，在发展早期几乎是没有限制的，很容易就可以注册很多个账号。因此，也导致了出现了一些特殊的工作室，通过编写自动注册脚 本，积累了一大批“僵尸账号”，数量庞大，几万甚至几十万的账号不等，专门做各种刷的行为（这就是微博中的“僵尸粉“的来源）。举个例子，例如微博中有转 发抽奖的活动，如果我们使用几万个“僵尸号”去混进去转发，这样就可以大大提升我们中奖的概率。</p>
<p>这种账号，使用在秒杀和抢购里，也是同一个道理。例如，iPhone官网的抢购，火车票黄牛党。</p>
<p><img src="//blog.com/2019/03/30/秒杀系统设计/547822740404f_middle.jpg" alt="Web系统大规模并发——电商秒杀与抢购 - 徐汉彬Hansion - 技术行者"></p>
<p>应对方案：</p>
<p>这种场景，可以通过检测指定机器IP请求频率就可以解决，如果发现某个IP请求频率很高，可以给它弹出一个验证码或者直接禁止它的请求：</p>
<ol>
<li>弹出验证码，最核心的追求，就是分辨出真实用户。因此，大家可能经常发现，网站弹出的验证码，有些是“鬼神乱舞”的样子， 有时让我们根本无法看清。他们这样做的原因，其实也是为了让验证码的图片不被轻易识别，因为强大的“自动脚本”可以通过图片识别里面的字符，然后让脚本自 动填写验证码。实际上，有一些非常创新的验证码，效果会比较好，例如给你一个简单问题让你回答，或者让你完成某些简单操作（例如百度贴吧的验证码）。</li>
<li>直接禁止IP，实际上是有些粗暴的，因为有些真实用户的网络场景恰好是同一出口IP的，可能会有“误伤“。但是这一个做法简单高效，根据实际场景使用可以获得很好的效果。</li>
</ol>
<h3 id="3-多个账号，不同IP发送不同请求"><a href="#3-多个账号，不同IP发送不同请求" class="headerlink" title="3. 多个账号，不同IP发送不同请求"></a>3. 多个账号，不同IP发送不同请求</h3><p>所谓道高一尺，魔高一丈。有进攻，就会有防守，永不休止。这些“工作室”，发现你对单机IP请求频率有控制之后，他们也针对这种场景，想出了他们的“新进攻方案”，就是不断改变IP。</p>
<p><img src="//blog.com/2019/03/30/秒杀系统设计/5478229f6aa52_middle.jpg" alt="Web系统大规模并发——电商秒杀与抢购 - 徐汉彬Hansion - 技术行者"></p>
<p>有同学会好奇，这些随机IP服务怎么来的。有一些是某些机构自己占据一批独立IP，然后做成一个随机代理IP的服务，有偿提供给这些“工作 室”使用。还有一些更为黑暗一点的，就是通过木马黑掉普通用户的电脑，这个木马也不破坏用户电脑的正常运作，只做一件事情，就是转发IP包，普通用户的电 脑被变成了IP代理出口。通过这种做法，黑客就拿到了大量的独立IP，然后搭建为随机IP服务，就是为了挣钱。</p>
<p>应对方案：</p>
<p>说实话，这种场景下的请求，和真实用户的行为，已经基本相同了，想做分辨很困难。再做进一步的限制很容易“误伤“真实用户，这个时候，通常只能通过设置业务门槛高来限制这种请求了，或者通过账号行为的”数据挖掘“来提前清理掉它们。</p>
<p>僵尸账号也还是有一些共同特征的，例如账号很可能属于同一个号码段甚至是连号的，活跃度不高，等级低，资料不全等等。根据这些特点，适当设置参与门槛，例如限制参与秒杀的账号等级。通过这些业务手段，也是可以过滤掉一些僵尸号。</p>
<h3 id="4-火车票的抢购"><a href="#4-火车票的抢购" class="headerlink" title="4. 火车票的抢购"></a>4. 火车票的抢购</h3><p>看到这里，同学们是否明白你为什么抢不到火车票？如果你只是老老实实地去抢票，真的很难。通过多账号的方式，火车票的黄牛将很多车票的名额占据，部分强大的黄牛，在处理验证码方面，更是“技高一筹“。</p>
<p>高级的黄牛刷票时，在识别验证码的时候使用真实的人，中间搭建一个展示验证码图片的中转软件服务，真人浏览图片并填写下真实验证码，返回给中转软件。对于这种方式，验证码的保护限制作用被废除了，目前也没有很好的解决方案。</p>
<p><img src="//blog.com/2019/03/30/秒杀系统设计/547822ce2f038.jpg" alt="Web系统大规模并发——电商秒杀与抢购 - 徐汉彬Hansion - 技术行者"></p>
<p>因为火车票是根据身份证实名制的，这里还有一个火车票的转让操作方式。大致的操作方式，是先用买家的身份证开启一个抢票工具，持续发送请 求，黄牛账号选择退票，然后黄牛买家成功通过自己的身份证购票成功。当一列车厢没有票了的时候，是没有很多人盯着看的，况且黄牛们的抢票工具也很强大，即 使让我们看见有退票，我们也不一定能抢得过他们哈。</p>
<p><img src="//blog.com/2019/03/30/秒杀系统设计/547822fbe13a0.jpg" alt="Web系统大规模并发——电商秒杀与抢购 - 徐汉彬Hansion - 技术行者"></p>
<p>最终，黄牛顺利将火车票转移到买家的身份证下。</p>
<p>解决方案：</p>
<p>并没有很好的解决方案，唯一可以动心思的也许是对账号数据进行“数据挖掘”，这些黄牛账号也是有一些共同特征的，例如经常抢票和退票，节假日异常活跃等等。将它们分析出来，再做进一步处理和甄别。</p>
<h2 id="三、高并发下的数据安全"><a href="#三、高并发下的数据安全" class="headerlink" title="三、高并发下的数据安全"></a>三、高并发下的数据安全</h2><p>我们知道在多线程写入同一个文件的时候，会存现“线程安全”的问题（多个线程同时运行同一段代码，如果每次运行结果和单线程运行的结果是一 样的，结果和预期相同，就是线程安全的）。如果是MySQL数据库，可以使用它自带的锁机制很好的解决问题，但是，在大规模并发的场景中，是不推荐使用 MySQL的。秒杀和抢购的场景中，还有另外一个问题，就是“超发”，如果在这方面控制不慎，会产生发送过多的情况。我们也曾经听说过，某些电商搞抢购活动，买家成功拍下后，商家却不承认订单有效，拒绝发货。这里的问题，也许并不一定是商家奸诈，而是系统技术层面存在超发风险导致的。</p>
<h3 id="1-超发的原因"><a href="#1-超发的原因" class="headerlink" title="1. 超发的原因"></a>1. 超发的原因</h3><p>假设某个抢购场景中，我们一共只有100个商品，在最后一刻，我们已经消耗了99个商品，仅剩最后一个。这个时候，系统发来多个并发请求，这批请求读取到的商品余量都是99个，然后都通过了这一个余量判断，最终导致超发。（同文章前面说的场景）</p>
<p><img src="//blog.com/2019/03/30/秒杀系统设计/54782328bb155_middle.jpg" alt="Web系统大规模并发——电商秒杀与抢购 - 徐汉彬Hansion - 技术行者"></p>
<p>在上面的这个图中，就导致了并发用户B也“抢购成功”，多让一个人获得了商品。这种场景，在高并发的情况下非常容易出现。</p>
<h3 id="2-悲观锁思路"><a href="#2-悲观锁思路" class="headerlink" title="2. 悲观锁思路"></a>2. 悲观锁思路</h3><p>解决线程安全的思路很多，可以从“悲观锁”的方向开始讨论。</p>
<p>悲观锁，也就是在修改数据的时候，采用锁定状态，排斥外部请求的修改。遇到加锁的状态，就必须等待。</p>
<p><img src="//blog.com/2019/03/30/秒杀系统设计/5478234d530bf_middle.jpg" alt="Web系统大规模并发——电商秒杀与抢购 - 徐汉彬Hansion - 技术行者"></p>
<p>虽然上述的方案的确解决了线程安全的问题，但是，别忘记，我们的场景是“高并发”。也就是说，会很多这样的修改请求，每个请求都需要等待 “锁”，某些线程可能永远都没有机会抢到这个“锁”，这种请求就会死在那里。同时，这种请求会很多，瞬间增大系统的平均响应时间，结果是可用连接数被耗 尽，系统陷入异常。</p>
<p><strong>商品id索引</strong></p>
<p><strong>事务隔离级别：可重复读</strong></p>
<p><strong>select……for update</strong></p>
<h3 id="3-FIFO队列思路"><a href="#3-FIFO队列思路" class="headerlink" title="3. FIFO队列思路"></a>3. FIFO队列思路</h3><p>那好，那么我们稍微修改一下上面的场景，我们直接将请求放入队列中的，采用FIFO（First Input First Output，先进先出），这样的话，我们就不会导致某些请求永远获取不到锁。看到这里，是不是有点强行将多线程变成单线程的感觉哈。</p>
<p>然后，我们现在解决了锁的问题，全部请求采用“先进先出”的队列方式来处理。那么新的问题来了，高并发的场景下，因为请求很多，很可能一瞬 间将队列内存“撑爆”，然后系统又陷入到了异常状态。或者设计一个极大的内存队列，也是一种方案，但是，系统处理完一个队列内请求的速度根本无法和疯狂涌 入队列中的数目相比。也就是说，队列内的请求会越积累越多，最终Web系统平均响应时候还是会大幅下降，系统还是陷入异常。</p>
<h3 id="4-乐观锁思路"><a href="#4-乐观锁思路" class="headerlink" title="4. 乐观锁思路"></a>4. 乐观锁思路</h3><p>这个时候，我们就可以讨论一下“乐观锁”的思路了。乐观锁，是相对于“悲观锁”采用更为宽松的加锁机制，大都是采用带版本号 （Version）更新。实现就是，这个数据所有请求都有资格去修改，但会获得一个该数据的版本号，只有版本号符合的才能更新成功，其他的返回抢购失败。 这样的话，我们就不需要考虑队列的问题，不过，它会增大CPU的计算开销。但是，综合来说，这是一个比较好的解决方案。</p>
<p><img src="//blog.com/2019/03/30/秒杀系统设计/547823d8e0db8_middle.jpg" alt="Web系统大规模并发——电商秒杀与抢购 - 徐汉彬Hansion - 技术行者"></p>
<p>有很多软件和服务都“乐观锁”功能的支持，例如Redis中的watch就是其中之一。通过这个实现，我们保证了数据的安全。</p>
<h3 id="5-redis计数器-控制库存"><a href="#5-redis计数器-控制库存" class="headerlink" title="5. redis计数器-控制库存"></a>5. redis计数器-控制库存</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">incr/decr原子性操作，incr增加，decr减少</span><br><span class="line"><span class="comment">//此处不可以取出后放入php变量判断库存,否则会出现幻读,导致超卖</span></span><br><span class="line"><span class="keyword">if</span> ($redis_client-&gt;decrby($key, $parmas[<span class="string">'num'</span>]) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">//减库存</span></span><br><span class="line">        $goods = <span class="keyword">new</span> Goods();</span><br><span class="line">        $parmas[<span class="string">'version'</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> $goods-&gt;subInventory($parmas);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//购买多个时,如库存不足,需要把数量加回去,否则会出现库减库存,商品并没有卖出去</span></span><br><span class="line">    $redis_client-&gt;incrby($key, $parmas[<span class="string">'num'</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">使用redis测试时，每次修改完库存需要删除KEY：DEL goods_1</span><br></pre></td></tr></table></figure>
<h2 id="四、参考链接"><a href="#四、参考链接" class="headerlink" title="四、参考链接"></a>四、参考链接</h2><p><a href="https://www.awaimai.com/348.html" target="_blank" rel="noopener">1.网站大规模并发处理方案：电商秒杀与抢购</a></p>
<p><a href="https://segmentfault.com/a/1190000007264809" target="_blank" rel="noopener">2.浅谈秒杀系统架构设计</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/03/30/基于Redis实现滚动排行榜【最近N期榜】/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/30/基于Redis实现滚动排行榜【最近N期榜】/" itemprop="url">基于Redis实现滚动排行榜【最近N期榜】</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-30T12:12:57+08:00">
                2019-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/投票/" itemprop="url" rel="index">
                    <span itemprop="name">投票</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/投票/排行榜/" itemprop="url" rel="index">
                    <span itemprop="name">排行榜</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/投票/排行榜/Reids/" itemprop="url" rel="index">
                    <span itemprop="name">Reids</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基于Redis实现排行榜周期榜与最近N期榜"><a href="#基于Redis实现排行榜周期榜与最近N期榜" class="headerlink" title="基于Redis实现排行榜周期榜与最近N期榜"></a>基于Redis实现排行榜周期榜与最近N期榜</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://cloud.tencent.com/developer/article/1370111" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1370111</a></p>
</blockquote>
<p><br></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;业务已基于<code>Redis</code>实现了一个高可用的排行榜服务，长期以来相安无事。有一天，产品说：我要一个按周排名的排行榜，以反映本周内用户的活跃情况。于是周榜（按周重置更新的榜单）诞生了。为了满足产品多变的需求，我们一并实现了小时榜、日榜、周榜、月榜几种周期榜。本以为可长治久安了，又有一天，产品体验业务后说：我想要一个最近7天榜，反映最近一段时间的用户活跃情况，不想让历史的高分用户长期占据榜首，可否？于是，<strong>滚动榜（最近N期榜）</strong>的需求诞生了。  </p>
<h2 id="周期榜"><a href="#周期榜" class="headerlink" title="周期榜"></a>周期榜</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;周期榜实现还是很容易的，<strong>给每个周期算出一个序号，作为榜单名后缀，进入新的周期自然切换读写新榜单，平滑过度</strong>。</p>
<blockquote>
<p>以日榜为例，根据时间戳<code>ts</code>计算每日序号<code>s=ts/86400</code>，以日序号<code>s</code>作为后缀即可实现零点后自动读写新日榜。小时榜与此雷同，不再赘述。  </p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于周榜，可以选定某一个周一（或周日，看需求）的时间戳为基准，计算基准到当前经过的周数为周序号，以此作为榜单后缀。  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于月榜，稍有不同，因为月份天数不固定，所以不能按照上述方法计算。但我们<strong>可以根据时间戳取得年、月信息，以年月做标志（如<code>201810</code>）后缀，即可实现月榜</strong>。</p>
<h2 id="滚动榜"><a href="#滚动榜" class="headerlink" title="滚动榜"></a>滚动榜</h2><h3 id="方案探讨"><a href="#方案探讨" class="headerlink" title="方案探讨"></a>方案探讨</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;滚动榜需要考虑多个周期榜数据的聚合与自动迭代更新，实现起来就没那么容易了。下面分析几个方案。</p>
<h4 id="方案1：每日一个滚动榜，当日离线补齐数据"><a href="#方案1：每日一个滚动榜，当日离线补齐数据" class="headerlink" title="方案1：每日一个滚动榜，当日离线补齐数据"></a>方案1：每日一个滚动榜，当日离线补齐数据</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还以日榜为例，<strong>最近<code>N</code>天榜就是把前<code>N-1</code>天到当天的每一个日榜榜单累加即可</strong>，比如最近7天榜，就是前6天到当天的每一个日榜中相同元素数据累加。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，最直观的一个方案是：首先记录每天的排行榜R，那么第i天的最近N天榜<img src="//blog.com/2019/03/30/基于Redis实现滚动排行榜【最近N期榜】/1.png" alt="">，其中，<img src="//blog.com/2019/03/30/基于Redis实现滚动排行榜【最近N期榜】/2.png" alt="">表示第<code>i</code>天的前<code>n</code>天的日榜。实现上，<strong>可以每日生成一个滚动榜S和当天日榜R，加分时同时写入S和R，每日零点后跑工具将前N-1天数据累加写入当日滚动榜S</strong>。  </p>
<blockquote>
<p><code>S3 = R1 + R2 + R3</code></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方案的优点是直观，实现简单。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但缺点也很明显：</p>
<ol>
<li><strong>每日一个滚动榜，消耗内存较多</strong>；</li>
<li><strong>数据更新不实时，需要等待离线作业完成累加后S中的数据才完全正确</strong>；</li>
<li><strong>时间复杂度高</strong>，7天榜还好，只需要读过去6天数据，如果是100天榜，该方案需要读过去99天榜，显然不可接受。  </li>
</ol>
<h4 id="方案2：全局一个滚动榜，当日离线补齐数据"><a href="#方案2：全局一个滚动榜，当日离线补齐数据" class="headerlink" title="方案2：全局一个滚动榜，当日离线补齐数据"></a>方案2：全局一个滚动榜，当日离线补齐数据</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于方案1，如果业务无需查询历史的S，可以只使用全局一个<code>S</code>，无需每日创建一个<img src="//blog.com/2019/03/30/基于Redis实现滚动排行榜【最近N期榜】/4.png" alt="">。加分操作还是同时加当日的<img src="//blog.com/2019/03/30/基于Redis实现滚动排行榜【最近N期榜】/5.png" alt="">和全局唯一的<code>S</code>，但每日零点的离线作业改为从<code>S</code>中减去<img src="//blog.com/2019/03/30/基于Redis实现滚动排行榜【最近N期榜】/3.png" alt="">的数据（即<strong>将最早一天的数据淘汰</strong>，从而实现<code>S</code>的计数滚动）。  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此方案减少了<strong>内存使用</strong>，同时离线任务每次只需读取一个日榜做减法，<strong>时间复杂度为<code>O(1)</code></strong>；但仍需要离线作业完成才能保证数据正确性，还是<strong>无法做到平滑过渡</strong>。  </p>
<h4 id="方案3：每日一个滚动榜，实时更新"><a href="#方案3：每日一个滚动榜，实时更新" class="headerlink" title="方案3：每日一个滚动榜，实时更新"></a>方案3：每日一个滚动榜，实时更新</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要做到每日零点后榜单实时生效，而不需要等待离线作业的完成，一种方案是<strong>预写未来的榜单</strong>。不难得出，<strong>当日分数会计入往后<code>N-1</code>天的滚动榜中</strong>。因此，可以写当天的滚动榜<img src="//blog.com/2019/03/30/基于Redis实现滚动排行榜【最近N期榜】/4.png" alt="">的同时，写往后<code>N-1</code>天的榜单<img src="//blog.com/2019/03/30/基于Redis实现滚动排行榜【最近N期榜】/6.png" alt="">到<img src="//blog.com/2019/03/30/基于Redis实现滚动排行榜【最近N期榜】/7.png" alt="">。  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该方案不仅能脱离离线作业做到<strong>实时更新，且可以省略每天的日榜</strong>。但缺点也不难看出，对于7天滚动榜，每次写操作需要更新7个榜单，<strong>写入量</strong>小时还勉强能接受，如果写操作量大或者需要的是30天、60天滚动榜，此方案可行性几乎为零。</p>
<h4 id="方案4：实时更新，常数次写操作"><a href="#方案4：实时更新，常数次写操作" class="headerlink" title="方案4：实时更新，常数次写操作"></a>方案4：实时更新，常数次写操作</h4><p>有不有办法做到既能实时更新，写榜数量也不随N的增加而增加呢？</p>
<p>第i天滚动榜<img src="//blog.com/2019/03/30/基于Redis实现滚动排行榜【最近N期榜】/8.png" alt=""></p>
<p>第<code>i+1</code>天的滚动榜<img src="//blog.com/2019/03/30/基于Redis实现滚动排行榜【最近N期榜】/9.png" alt="">。</p>
<p>显然，<img src="//blog.com/2019/03/30/基于Redis实现滚动排行榜【最近N期榜】/10.png" alt="">。</p>
<p><strong>由于<img src="//blog.com/2019/03/30/基于Redis实现滚动排行榜【最近N期榜】/11.png" alt="">在刚达到零点时必然为空且可以在次日实时加到<img src="//blog.com/2019/03/30/基于Redis实现滚动排行榜【最近N期榜】/12.png" alt="">上</strong>，因此如果我们能提前准备好<img src="//blog.com/2019/03/30/基于Redis实现滚动排行榜【最近N期榜】/13.png" alt="">这部分数据，那么在零点进入<code>i+1</code>天后，<img src="//blog.com/2019/03/30/基于Redis实现滚动排行榜【最近N期榜】/11.png" alt="">自然就是可用状态了。</p>
<blockquote>
<p><code>S3 = R1 + R2 + R3</code></p>
<p><code>S4 = R1 + R2 + R3 + R4</code></p>
<p><code>S4 = S3 + R4 - R1</code></p>
</blockquote>
<p>举例说明：</p>
<blockquote>
<p><code>s4</code> 第4天的滚动榜</p>
<p><code>s3</code> 第3天的滚动榜</p>
<p><code>r4</code> 第4天的日榜</p>
<p><code>r1</code>第1天的滚动榜</p>
<p><code>s4 = s3 + r4 - s1</code></p>
</blockquote>
<p>如果计数历史小于<code>n</code>天，则直接比较总数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">以<span class="number">3</span>天滚动榜为例，次日滚动榜初始态为当日滚动榜减去n<span class="number">-2</span>天的日榜数据。</span><br><span class="line">     +-------------------------------------------+</span><br><span class="line">     |                                           |</span><br><span class="line">+----+---+   +--------+   +--------+             |</span><br><span class="line">|        |   |        |   |        |             |</span><br><span class="line">| R(i<span class="number">-2</span>) |   | R(i<span class="number">-1</span>) |   |  R(i)  |             |</span><br><span class="line">|        |   |        |   |        |             |</span><br><span class="line">+----+---+   +----+---+   +---+----+             |</span><br><span class="line">     |            |           |                  |</span><br><span class="line">     |            |           |                  |</span><br><span class="line">     |            |           |                  |</span><br><span class="line">     |            |           v+                 v-</span><br><span class="line">     |            |</span><br><span class="line">     |            |    +  +--------+        +--------+</span><br><span class="line">     |            +-----&gt; |        |     +  |        |</span><br><span class="line">     |                 +  |  S(i)  | +---+&gt; | S(i+<span class="number">1</span>) |</span><br><span class="line">     +-----------------+&gt; |        |        |        |</span><br><span class="line">                          +--------+        +--------+</span><br></pre></td></tr></table></figure>
<p>那么，如何提前准备好<img src="//blog.com/2019/03/30/基于Redis实现滚动排行榜【最近N期榜】/13.png" alt="">这部分数据呢？可以如下处理：</p>
<ul>
<li>对一个元素加分时，加当日周期榜<img src="//blog.com/2019/03/30/基于Redis实现滚动排行榜【最近N期榜】/5.png" alt="">、滚动榜<img src="//blog.com/2019/03/30/基于Redis实现滚动排行榜【最近N期榜】/4.png" alt="">；还需根据其在今日滚动榜中的分数<code>s</code>、及<code>n-1</code>天日榜中的分数<code>r</code>，计算出其在明日滚动榜中的初始分数<code>s-r</code>写入明日滚动榜中；即3个写操作；</li>
<li>如果一个元素在当日没有任何加分操作，那么不会触发写入初始分数操作，所以还需要一个离线工具补齐。<strong>与方案1、2不同的是，该离线工具可提前一天运行，即当日运行离线工具补齐次日的滚动榜数据即可</strong>。  </li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简而言之：第一步是运行离线工具生成次日的滚动榜；第二步是在写操作时同时更新次日的滚动榜。  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该方案也是每日一个滚动榜。相对方案3而言，是空间换时间。如果空间不足且无保留历史的需求，可在离线工具中清理历史数据。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">                                +--------------+</span><br><span class="line">                                |              |</span><br><span class="line">                                |   AddScore   |</span><br><span class="line">                                |              |</span><br><span class="line">                                +-+----+-----+-+</span><br><span class="line">                                  |    |     |</span><br><span class="line">                                  v    |     |</span><br><span class="line">+--------+   +--------+   +-------++   |     |</span><br><span class="line">|        |   |        |   |        |   |     |</span><br><span class="line">| R(i<span class="number">-2</span>) |   | R(i<span class="number">-1</span>) |   |  R(i)  |   |     |</span><br><span class="line">|        |   |        |   |        |   |     |</span><br><span class="line">+--------+   +--------+   +--------+   |     |</span><br><span class="line">                                       |     v</span><br><span class="line">                          +--------+   |    ++-------+</span><br><span class="line">                          |        |   |    |        |</span><br><span class="line">                          |  S(i)  +<span class="xml"><span class="tag">&lt;<span class="name">--+</span>    | <span class="attr">S</span>(<span class="attr">i</span>+<span class="attr">1</span>) |</span></span></span><br><span class="line"><span class="xml">                          |        |        |        |</span></span><br><span class="line"><span class="xml">                          +--------+        +----+---+</span></span><br><span class="line"><span class="xml">                                                 ^</span></span><br><span class="line"><span class="xml">                                                 |</span></span><br><span class="line"><span class="xml">                                                 |</span></span><br><span class="line"><span class="xml">                                          +------+-----+</span></span><br><span class="line"><span class="xml">                                          |            |</span></span><br><span class="line"><span class="xml">                                          |    Tool    |</span></span><br><span class="line"><span class="xml">                                          |            |</span></span><br><span class="line"><span class="xml">                                          +------------+</span></span><br></pre></td></tr></table></figure>
<h5 id="方案4的实现"><a href="#方案4的实现" class="headerlink" title="方案4的实现"></a>方案4的实现</h5><p>以下是实现参考。此处仅列出核心的<code>lua</code>脚本。<code>Redis</code>命令调用脚本的参数定义为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> script <span class="number">4</span> 当日日榜key 当日滚动榜key 即将淘汰的日榜key 明日滚动榜key 榜单元素名 加分数</span><br></pre></td></tr></table></figure>
<p><code>lua</code>脚本<code>script</code>如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--加今日日榜分数</span></span><br><span class="line">redis.call(<span class="string">'ZINCRBY'</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], ARGV[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">--加今日滚动榜分数</span></span><br><span class="line"><span class="comment">--这里是因为redis的特性【不存在的key会自动创建】，所以我们不用判断是否存在key</span></span><br><span class="line"><span class="keyword">local</span> rs = redis.call(<span class="string">'ZINCRBY'</span>, KEYS[<span class="number">2</span>], ARGV[<span class="number">2</span>], ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> curRoundScore = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> (rs) <span class="keyword">then</span></span><br><span class="line">    curRoundScore = <span class="built_in">tonumber</span>(rs)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--取即将淘汰的日榜分数</span></span><br><span class="line">rs = redis.call(<span class="string">'ZSCORE'</span>, KEYS[<span class="number">3</span>], ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> oldCycleScore = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> (rs) <span class="keyword">then</span></span><br><span class="line">    oldCycleScore = <span class="built_in">tonumber</span>(rs)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--计算次日滚动榜初始分数</span></span><br><span class="line"><span class="keyword">local</span> nextRoundScore = curRoundScore - oldCycleScore</span><br><span class="line"><span class="keyword">if</span> nextRoundScore &lt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    nextRoundScore = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 原文中存在一个bug（重复扣减将淘汰的日榜分数，每执行一次就减一次）</span></span><br><span class="line">redis.call(<span class="string">'ZINCRBY'</span>, KEYS[<span class="number">3</span>], <span class="number">-1</span>*oldCycleScore, ARGV[<span class="number">1</span>])  <span class="comment">-- 将值置为0</span></span><br><span class="line"><span class="comment">-- redis.call('ZREM', KEYS[3], ARGV[1]) 另外一种修改方案，直接删除，但需要每次判断一下是否存在，不推荐使用，复杂化了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--设置次日滚动榜分数</span></span><br><span class="line"><span class="comment">--如果对应的元素已经存在，ZADD会主动更新score，所以不需要在script中判断今天是否已经访问过</span></span><br><span class="line"><span class="comment">--因为zadd的这个特性，所以我们可以在前一天的零点就计算更新次日滚动榜初始分数 Si - Ri-(N-1) 【这里有一个问题不好解决的是，初始化时与访问冲突 因为Si中的值会发生变化 可以用lua script脚本来保证一致性  检测到冲突时 请求资源的一方延迟1秒左右再次进行更新】</span></span><br><span class="line">redis.call(<span class="string">'ZADD'</span>, KEYS[<span class="number">4</span>], nextRoundScore, ARGV[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">--返回今日分数</span></span><br><span class="line">rs = redis.call(<span class="string">'ZREVRANK'</span>, KEYS[<span class="number">2</span>], ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> &#123;curRoundScore, rs&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>关于榜单key计算准确度的探讨</strong> </p>
<p>​     我们的业务是在排行榜接入层逻辑中计算榜单后缀的，这种方案<strong>对逻辑层多台机器的时间一致性要求较高</strong>，如果逻辑层服务器时钟不一致，可能在时间切换点上出现不同机器读写不同榜单的问题。如果业务对时间精确度要求严格，可以考虑通过<code>lua</code>脚步在<code>redis</code>端计算后缀。  </p>
</blockquote>
<blockquote>
<p><strong>关于内存容量限制的探讨</strong> </p>
<p>​      基于<code>ZSet</code>实现的排行榜，每个元素约需要100字节内存。如果榜单长度为1000万，则每个榜单约需要1G内存。滚动榜的计算需要每日保留一个日榜，如果滚动周期较长，则可能单机内存容量不足以容纳所有需要的榜单。 考虑到<strong>历史日榜数据是不会变更的</strong>，因此不在<code>lua</code>脚本中读取历史日榜数据也无一致性问题。故<strong>可以将榜单打散到多个<code>Redis</code>实例，在接入层做逻辑读取历史日榜的分数，再以参数形式传入给<code>lua</code>脚本处理</strong>。</p>
</blockquote>
<h2 id="一个优化建议"><a href="#一个优化建议" class="headerlink" title="一个优化建议"></a>一个优化建议</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将<strong>当日滚动榜</strong>的<code>ttl</code>设置为<strong>N+1*统计周期</strong>，统计周期指的是天、小时、周、月……，防止因为没有设置有效期，内存溢出。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在榜单长度不大且并发量不高的场景下，使用<code>关系数据库+Cache</code>的方案实现排行榜有更高的灵活性。而在海量数据与高并发的场景下，<code>Redis</code>是一个更好的选择。本文基于<code>Redis</code>实现的滚动榜，不论滚动周期多长，都只需要常数（3）次数的写操作，有较好的性能和可扩展性。且通过离线+在线的双预生成机制，确保了榜单实时生效，可用性较强。</p>
<p><strong>对于方案的可实现难度  推荐方案2</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/03/30/深入理解RPC之服务注册与发现篇/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/30/深入理解RPC之服务注册与发现篇/" itemprop="url">深入理解RPC之服务注册与发现篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-30T12:12:57+08:00">
                2019-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/服务注册与发现/" itemprop="url" rel="index">
                    <span itemprop="name">服务注册与发现</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="深入理解RPC之服务注册与发现篇"><a href="#深入理解RPC之服务注册与发现篇" class="headerlink" title="深入理解RPC之服务注册与发现篇"></a>深入理解RPC之服务注册与发现篇</h1><blockquote>
<p>原文地址：<a href="https://www.cnkirito.moe/rpc-registry/" target="_blank" rel="noopener">https://www.cnkirito.moe/rpc-registry/</a></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>在我们之前 RPC 原理的分析中，主要将笔墨集中在 Client 和 Server 端。而成熟的服务治理框架中不止存在这两个角色，一般还会有一个 Registry（注册中心）的角色。一张图就可以解释注册中心的主要职责。</p>
<p><img src="//blog.com/2019/03/30/深入理解RPC之服务注册与发现篇/17071-20170522235215679-280378465.png" alt="注册中心的地位"></p>
<ul>
<li><p>注册中心，用于服务端注册远程服务以及客户端发现服务</p>
</li>
<li><p>服务端，对外提供后台服务，将自己的服务信息注册到注册中心</p>
</li>
<li><p>客户端，从注册中心获取远程服务的注册信息，然后进行远程过程调用</p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;目前主要的注册中心可以借由 zookeeper，eureka，consul，etcd 等开源框架实现。互联网公司也会因为自身业务的特性自研，如美团点评自研的 MNS，新浪微博自研的 vintage。</p>
<h2 id="注册中心的抽象"><a href="#注册中心的抽象" class="headerlink" title="注册中心的抽象"></a>注册中心的抽象</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;借用开源框架中的核心接口，可以帮助我们从一个较为抽象的高度去理解注册中心。例如 motan 中的相关接口：</p>
<p>服务注册接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RegistryService</span> </span>&#123;</span><br><span class="line">	<span class="comment">//1. 向注册中心注册服务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span></span>;</span><br><span class="line">    <span class="comment">//2. 从注册中心摘除服务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">(URL url)</span></span>;</span><br><span class="line">    <span class="comment">//3. 将服务设置为可用，供客户端调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">available</span><span class="params">(URL url)</span></span>;</span><br><span class="line">    <span class="comment">//4. 禁用服务，客户端无法发现该服务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unavailable</span><span class="params">(URL url)</span></span>;</span><br><span class="line">  	<span class="comment">//5. 获取已注册服务的集合</span></span><br><span class="line">    <span class="function">Collection&lt;URL&gt; <span class="title">getRegisteredServiceUrls</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务发现接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscoveryService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 订阅服务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url, NotifyListener listener)</span></span>;</span><br><span class="line">    <span class="comment">//2. 取消订阅</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(URL url, NotifyListener listener)</span></span>;</span><br><span class="line">    <span class="comment">//3. 发现服务列表</span></span><br><span class="line">    <span class="function">List&lt;URL&gt; <span class="title">discover</span><span class="params">(URL url)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;主要使用的方法是 RegistryService#register(URL) 和 DiscoveryService#discover(URL)。其中这个 URL 参数被传递，显然也是很重要的一个类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class URL &#123;</span><br><span class="line">    private String protocol;//协议名称</span><br><span class="line">    private String host;</span><br><span class="line">    private int port;</span><br><span class="line">    // interfaceName,也代表着路径</span><br><span class="line">    private String path;</span><br><span class="line">    private Map&lt;String, String&gt; parameters;</span><br><span class="line">    private volatile transient Map&lt;String, Number&gt; numbers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;注册中心也没那么玄乎，其实可以简单理解为：提供一个<strong>存储介质</strong>，供服务提供者和服务消费者共同连接，而存储的主要信息就是这里的 URL。但是具体 URL 都包含了什么实际信息，我们还没有一个直观的感受。</p>
<h2 id="注册信息概览"><a href="#注册信息概览" class="headerlink" title="注册信息概览"></a>注册信息概览</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;以元老级别的注册中心 zookeeper 为例，看看它实际都存储了什么信息以及它是如何持久化上一节的 URL。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;为了测试，我创建了一个 RPC 服务接口 <code>com.sinosoft.student.api.DemoApi</code> ,并且在 6666 端口暴露了这个服务的实现类，将其作为服务提供者。在 6667 端口远程调用这个服务，作为服务消费者。两者都连接本地的 zookeeper，本机 ip 为 192.168.150.1。</p>
<p>使用 zkClient.bash 或者 zkClient.sh 作为客户端连接到本地的 zookeeper，执行如下的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 1] ls /motan/demo_group/com.sinosoft.student.api.DemoApi</span><br><span class="line">&gt; [client, server, unavailableServer]</span><br></pre></td></tr></table></figure>
<p>zookeeper 有着和 linux 类似的命令和结构，其中 motan，demo_group，com.sinosoft.student.api.DemoApi，client, server, unavailableServer 都是一个个节点。可以从上述命令看出他们的父子关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/motan/demo_group/com.sinosoft.student.api.DemoApi` 的结构为 /框架标识/分组名/接口名</span><br><span class="line">其中的分组是 motan 为了隔离不同组的服务而设置的。这样，接口名称相同，分组不同的服务无法互相发现。</span><br><span class="line"></span><br><span class="line">如果此时有一个分组名为 demo_group2 的服务，接口名称为 DemoApi2，则 motan 会为其创建一个新的节点 /motan/demo_group2/com.sinosoft.student.api.DemoApi2</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;而 client，server，unavailableServer 则就是服务注册与发现的核心节点了。我们先看看这些节点都存储了什么信息。</p>
<p>server 节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 2] ls /motan/demo_group/com.sinosoft.student.api.DemoApi/server</span><br><span class="line">&gt; [192.168.150.1:6666]</span><br><span class="line"></span><br><span class="line">[zk: localhost:2181(CONNECTED) 3] get /motan/demo_group/com.sinosoft.student.api.DemoApi/server/192.168.150.1:6666</span><br><span class="line">&gt; motan://192.168.150.1:6666/com.sinosoft.student.api.DemoApi?serialization=hessian2&amp;protocol=motan&amp;isDefault=true&amp;maxContentLength=1548576&amp;shareChannel=true&amp;refreshTimestamp=1515122649835&amp;id=motanServerBasicConfig&amp;nodeType=service&amp;export=motan:6666&amp;requestTimeout=9000000&amp;accessLog=false&amp;group=demo_group&amp;</span><br></pre></td></tr></table></figure>
<p>client 节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /motan/demo_group/com.sinosoft.student.api.DemoApi/client</span><br><span class="line">&gt; [192.168.150.1]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 5] get /motan/demo_group/com.sinosoft.student.api.DemoApi/client/192.168.150.1</span><br><span class="line">&gt; motan://192.168.150.1:0/com.sinosoft.student.api.DemoApi?singleton=true&amp;maxContentLength=1548576&amp;check=false&amp;nodeType=service&amp;version=1.0&amp;throwException=true&amp;accessLog=false&amp;serialization=hessian2&amp;retries=0&amp;protocol=motan&amp;isDefault=true&amp;refreshTimestamp=1515122631758&amp;id=motanClientBasicConfig&amp;requestTimeout=9000&amp;group=demo_group&amp;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;unavailableServer 节点是一个过渡节点，所以在一切正常的情况下不会存在信息，它的具体作用在下面会介绍。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;从这些输出数据可以发现，注册中心承担的一个职责就是存储服务调用中相关的信息，server 向 zookeeper 注册信息，保存在 server 节点，而 client 实际和 server 共享同一个接口，接口名称就是路径名，所以也到达了同样的 server 节点去获取信息。并且同时注册到了 client 节点下。</p>
<h2 id="注册信息详解"><a href="#注册信息详解" class="headerlink" title="注册信息详解"></a>注册信息详解</h2><h3 id="Server-节点"><a href="#Server-节点" class="headerlink" title="Server 节点"></a>Server 节点</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>server 节点承担着最重要的职责，它由服务提供者创建，以供服务消费者获取节点中的信息，从而定位到服务提供者真正网络拓扑位置以及得知如何调用</strong>。demo 中我只在本机 [192.168.150.1:6666] 启动了一个实例，所以在server 节点之下，只存在这么一个节点，继续 get 这个节点，可以获取更详细的信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">motan://192.168.150.1:6666/com.sinosoft.student.api.DemoApi?serialization=hessian2&amp;protocol=motan&amp;isDefault=true&amp;maxContentLength=1548576&amp;shareChannel=true&amp;refreshTimestamp=1515122649835&amp;id=motanServerBasicConfig&amp;nodeType=service&amp;export=motan:6666&amp;requestTimeout=9000000&amp;accessLog=false&amp;group=demo_group&amp;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;作为一个 value 值，它和 http 协议的请求十分相似，不过是以 motan:// 开头，表达的意图也很明确，这是 motan 协议和相关的路径及参数，关于 RPC 中的协议，可以翻看我的上一篇文章《深入理解RPC之协议篇》。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;serialization 对应序列化方式，protocol 对应协议名称，maxContentLength 对应 RPC 传输中数据报文的最大长度，shareChannel 是传输层用到的参数，netty channel 中的一个属性，group 对应分组名称。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;上述的 value 包含了 RPC 调用中所需要的全部信息。</p>
<h3 id="Client-节点"><a href="#Client-节点" class="headerlink" title="Client 节点"></a>Client 节点</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在 motan 中使用 zookeeper 作为注册中心时，客户端订阅服务时会向 zookeeper 注册自身，主要是方便对调用方进行统计、管理。<strong>但订阅时是否注册 client 不是必要行为，和不同的注册中心实现有关</strong>，例如使用 consul 时便没有注册。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;由于我们使用 zookeeper，也可以分析下 zookeeper 中都注册了什么信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">motan://192.168.150.1:0/com.sinosoft.student.api.DemoApi?singleton=true&amp;maxContentLength=1548576&amp;check=false&amp;nodeType=service&amp;version=1.0&amp;throwException=true&amp;accessLog=false&amp;serialization=hessian2&amp;retries=0&amp;protocol=motan&amp;isDefault=true&amp;refreshTimestamp=1515122631758&amp;id=motanClientBasicConfig&amp;requestTimeout=9000&amp;group=demo_group</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;和 Server 节点的值类似，但也有客户独有的一些属性，如 singleton 代表服务是否单例，check 检查服务提供者是否存在，retries 代表重试次数，这也是 RPC 中特别需要注意的一点。</p>
<h3 id="UnavailableServer-节点"><a href="#UnavailableServer-节点" class="headerlink" title="UnavailableServer 节点"></a>UnavailableServer 节点</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;unavailableServer 节点也不是必须存在的一个节点，它主要用来做 server 端的延迟上线，优雅关机。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>延迟上线</strong>：一般推荐的服务端启动流程为：server 向注册中心的 unavailableServer 注册，状态为 unavailable，此时整个服务处于启动状态，但不对外提供服务，在服务验证通过，预热完毕，此时打开心跳开关，此时正式提供服务。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>优雅关机</strong>：当需要对 server 方进行维护升级时，如果直接关闭，则会影响到客户端的请求。所以理想的情况应当是首先切断流量，再进行 server 的下线。具体的做法便是：先关闭心跳开关，客户端感知停止调用后，再关闭服务进程。</p>
<h2 id="感知服务的下线"><a href="#感知服务的下线" class="headerlink" title="感知服务的下线"></a>感知服务的下线</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;服务上线时自然要注册到注册中心，但下线时也得从注册中心中摘除。注册是一个主动的行为，这没有特别要注意的地方，但服务下线却是一个值得思考的问题。服务下线包含了主动下线和系统宕机等异常方式的下线。</p>
<h3 id="临时节点-长连接"><a href="#临时节点-长连接" class="headerlink" title="临时节点+长连接"></a>临时节点+长连接</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在 zookeeper 中存在持久化节点和临时节点的概念。持久化节点一经创建，只要不主动删除，便会一直持久化存在；<strong>临时节点的生命周期则是和客户端的连接同生共死的，应用连接到 zookeeper 时创建一个临时节点，使用长连接维持会话，这样无论何种方式服务发生下线，zookeeper 都可以感知到，进而删除临时节点</strong>。zookeeper 的这一特性和服务下线的需求契合的比较好，所以临时节点被广泛应用。</p>
<h3 id="主动下线-心跳检测"><a href="#主动下线-心跳检测" class="headerlink" title="主动下线+心跳检测"></a>主动下线+心跳检测</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;并不是所有注册中心都有临时节点的概念，另外一种感知服务下线的方式是主动下线。例如在 eureka 中，会有 eureka-server 和 eureka-client 两个角色，其中 eureka-server 保存注册信息，地位等同于 zookeeper。当 eureka-client 需要关闭时，会发送一个通知给 eureka-server，从而让 eureka-server 摘除自己这个节点。但这么做最大的一个问题是，如果仅仅只有主动下线这么一个手段，一旦 eureka-client 非正常下线（如断电，断网），eureka-server 便会一直存在一个已经下线的服务节点，一旦被其他服务发现进而调用，便会带来问题。<strong>为了避免出现这样的情况，需要给 eureka-server 增加一个心跳检测功能，它会对服务提供者进行探测，比如每隔30s发送一个心跳，如果三次心跳结果都没有返回值，就认为该服务已下线</strong>。</p>
<h2 id="注册中心对比"><a href="#注册中心对比" class="headerlink" title="注册中心对比"></a>注册中心对比</h2><table>
<thead>
<tr>
<th style="text-align:left">Feature</th>
<th style="text-align:left">Consul</th>
<th style="text-align:left">zookeeper</th>
<th style="text-align:left">etcd</th>
<th style="text-align:left">euerka</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">服务健康检查</td>
<td style="text-align:left">服务状态，内存，硬盘等</td>
<td style="text-align:left">(弱)长连接，keepalive</td>
<td style="text-align:left">连接心跳</td>
<td style="text-align:left">可配支持</td>
</tr>
<tr>
<td style="text-align:left">多数据中心</td>
<td style="text-align:left">支持</td>
<td style="text-align:left">—</td>
<td style="text-align:left">—</td>
<td style="text-align:left">—</td>
</tr>
<tr>
<td style="text-align:left">kv存储服务</td>
<td style="text-align:left">支持</td>
<td style="text-align:left">支持</td>
<td style="text-align:left">支持</td>
<td style="text-align:left">—</td>
</tr>
<tr>
<td style="text-align:left">一致性</td>
<td style="text-align:left">raft</td>
<td style="text-align:left">paxos</td>
<td style="text-align:left">raft</td>
<td style="text-align:left">—</td>
</tr>
<tr>
<td style="text-align:left">cap</td>
<td style="text-align:left">ca</td>
<td style="text-align:left">cp</td>
<td style="text-align:left">cp</td>
<td style="text-align:left">ap</td>
</tr>
<tr>
<td style="text-align:left">使用接口(多语言能力)</td>
<td style="text-align:left">支持http和dns</td>
<td style="text-align:left">客户端</td>
<td style="text-align:left">http/grpc</td>
<td style="text-align:left">http（sidecar）</td>
</tr>
<tr>
<td style="text-align:left">watch支持</td>
<td style="text-align:left">全量/支持long polling</td>
<td style="text-align:left">支持</td>
<td style="text-align:left">支持 long polling</td>
<td style="text-align:left">支持 long polling/大部分增量</td>
</tr>
<tr>
<td style="text-align:left">自身监控</td>
<td style="text-align:left">metrics</td>
<td style="text-align:left">—</td>
<td style="text-align:left">metrics</td>
<td style="text-align:left">metrics</td>
</tr>
<tr>
<td style="text-align:left">安全</td>
<td style="text-align:left">acl /https</td>
<td style="text-align:left">acl</td>
<td style="text-align:left">https支持（弱）</td>
<td style="text-align:left">—</td>
</tr>
<tr>
<td style="text-align:left">spring cloud集成</td>
<td style="text-align:left">已支持</td>
<td style="text-align:left">已支持</td>
<td style="text-align:left">已支持</td>
<td style="text-align:left">已支持</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;一般而言注册中心的特性决定了其使用的场景，例如很多框架支持 zookeeper，在我自己看来是因为其老牌，易用，但业界也有很多人认为 zookeeper 不适合做注册中心，它本身是一个分布式协调组件，并不是为注册服务而生，server 端注册一个服务节点，client 端并不需要在同一时刻拿到完全一致的服务列表，只要最终一致性即可。在跨IDC，多数据中心等场景下 consul 发挥了很大的优势，这也是很多互联网公司选择使用 consul 的原因。 eureka 是 ap 注册中心，并且是 spring cloud 默认使用的组件，spring cloud eureka 较为贴近 spring cloud 生态。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;注册中心主要用于解耦服务调用中的定位问题，是分布式系统必须面对的一个问题。更多专业性的对比，可以期待 spring4all.com 的注册中心专题讨论，相信会有更为细致地对比。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/106/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/106/">106</a><span class="page-number current">107</span><a class="page-number" href="/page/108/">108</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/108/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
