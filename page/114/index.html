<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/page/114/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/page/114/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/03/22/为什么要分库分表/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/22/为什么要分库分表/" itemprop="url">为什么要分库分表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-22T12:12:57+08:00">
                2019-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/分库分表/" itemprop="url" rel="index">
                    <span itemprop="name">分库分表</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="为什么要分库分表"><a href="#为什么要分库分表" class="headerlink" title="为什么要分库分表"></a>为什么要分库分表</h1><blockquote>
<p>需要重新做一个会员系统,一个会员表有30多个字段,有一半是不常用到的, 另外会员表里面有很多僵尸会员,啰嗦了那么多,开始正式话题:</p>
<p>会员表是按照办卡日期或ID进行水平分表好,<br>还是按照常用字段和不常用字段进行垂直分割的好?  </p>
</blockquote>
<h2 id="分表基本思想"><a href="#分表基本思想" class="headerlink" title="分表基本思想"></a>分表基本思想</h2><p>​    分区的思想，垂直分区和水平分区，<strong>水平分区是指将表的数据行存储在不同的partition中，垂直分区是指将table拆分成多个表，并通过PK 链接在一起</strong></p>
<p>​    垂直分区的出发点是<strong>column 太宽</strong>，并且不常用，如果存在这样的column，垂直分区效果好；</p>
<p>​    水平分区的出发点是有些row 不常用，这样，<strong>将常用的rows 存储在一个partition中，使查询的范围缩小到一个partition中，减少query的时间消耗，提高性能</strong>    </p>
<p><strong>列太多 =》 垂直拆分</strong></p>
<p><strong>行太多 =》水平拆分</strong></p>
<h3 id="水平分表纬度"><a href="#水平分表纬度" class="headerlink" title="水平分表纬度"></a>水平分表纬度</h3><p>​    <strong>汇总表    =》 活跃度、时间、用户ID</strong></p>
<p>​    可以用<strong>表/缓存</strong>来保存<strong>分区键与常用查询条件的映射关系</strong></p>
<h3 id="垂直分表数据聚合"><a href="#垂直分表数据聚合" class="headerlink" title="垂直分表数据聚合"></a>垂直分表数据聚合</h3><p>​    <strong>视图</strong></p>
<h2 id="为什么要垂直分表？"><a href="#为什么要垂直分表？" class="headerlink" title="为什么要垂直分表？"></a>为什么要垂直分表？</h2><p>在这里我可能在个人的知识范畴内说几点，如果有不同的看法，或者发现错误，希望大家提出。</p>
<h3 id="行溢出"><a href="#行溢出" class="headerlink" title="行溢出"></a>行溢出</h3><p>​    这个主要是大字段的拆分，因为字段本身可能非常大，超出行的可变长度，这个是在使用varchar可变类型情况下，因为数据库的行格式会存储变长字段的长度，而这个存储的字段最多就2字节，这样的话可变长度最多就可以达到65535，达到这个长度的话，计算了一下，一行数据的可变长度的列总和不超过64k左右（没精准算），超过的话会溢出行到blob页，这里还衍生了个问题，因为<strong>页存储就16k，而一行数据就远远超出，这样就失去了b+树的意义了，所以一般mysql会拆分前缀存储额外数据到额外页，一页保持至少两行数据</strong></p>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>mysql的查询缓存具体是根据查询语句来的，这里具体可以去看《高性能MYSQL》一书，大概表达的意思是查询语句不能有变量或者函数，例如current_timestamp之类的，这样不会有缓存，有点跑偏了。这里的意思是，垂直拆分表后，有些字段是常修改的，例如用户的个性签名之类的，而更新操作会让查询缓存无效，所以垂直拆分会优化查询效率。</p>
<h3 id="数据页的影响"><a href="#数据页的影响" class="headerlink" title="数据页的影响"></a>数据页的影响</h3><p>​    页是什么呢？页应该算作数据库的存储最小单位，在mysql中例如，insert_buffer_pool，AIO，<strong>索引查找都是以页为单位，首先垂直拆分表的话，随着字段的减少，每页里面的数据行也会增多，理论上页里面的数据行越多性能越好</strong><br>例如图中所示假如未分表之前页分布是这样的，如果要查询id=1和id=9的话可能是需要两次索引查询，两次磁盘IO，这里为啥说页1和页3呢，因为异步IO的可能性，innodb不会去等待第一个扫描结果，而是先扫描，然后去取数据，例如如果是id=1和id=6，根据page判断数据是相邻页，因为页是顺序存储的，所以会合并也就一次磁盘IO取出两页数据。</p>
<p>像上面这样，<strong>页里的行数增多，就可以减少一部分磁盘的IO，这样也就增加了查询效率</strong></p>
<h3 id="对写入更新的影响"><a href="#对写入更新的影响" class="headerlink" title="对写入更新的影响"></a>对写入更新的影响</h3><p>​    写入和更新其实还是页的问题，同样的问题，页的减少，就会影响脏页的刷新，insert_buffer的mergy，这样都会影响iops，<strong>如果页的减少，数据也会存储更有顺序性，对于写入与读取的话，顺序读比离散读要快，性能也能得到提升</strong></p>
<h2 id="分库基本思想"><a href="#分库基本思想" class="headerlink" title="分库基本思想"></a>分库基本思想</h2><h3 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h3><p>​      Sharding的基本思想就要把一个数据库切分成多个部分放到不同的数据库(server)上，从而缓解单一数据库的性能问题。不太严格的讲，对于海量数据的数据库，如果是因为表多而数据多，这时候适合使用垂直切分，即把关系紧密（比如同一模块）的表切分出来放在一个server上。如果表并不多，但每张表的数据非常多，这时候适合水平切分，即<strong>把表的数据按某种规则（比如按ID散列）切分到多个数据库(server)上</strong>。当然，现实中更多是这两种情况混杂在一起，这时候需要根据实际情况做出选择，也可能会综合使用垂直与水平切分，从而将原有数据库切分成类似矩阵一样可以无限扩充的数据库(server)阵列。</p>
<h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>​      垂直切分的最大特点就是规则简单，实施也更为方便，尤其<strong>适合各业务之间的耦合度非常低，相互影响很小，业务逻辑非常清晰的系统</strong>。在这种系统中，可以很容易做到<strong>将不同业务模块所使用的表分拆到不同的数据库中。根据不同的表来进行拆分，对应用程序的影响也更小，拆分规则也会比较简单清晰</strong>。（这也就是所谓的”share nothing”）。</p>
<p><img src="//blog.com/2019/03/22/为什么要分库分表/0_12958577041KqK.gif" alt="img"></p>
<p>​      水平切分于垂直切分相比，相对来说稍微复杂一些。因为要将同一个表中的不同数据拆<br>分到不同的数据库中，对于应用程序来说，拆分规则本身就较根据表名来拆分更为复杂，后<br>期的数据维护也会更为复杂一些。</p>
<p><img src="//blog.com/2019/03/22/为什么要分库分表/0_1295857710BUth.gif" alt="img"></p>
<p>​      让我们从普遍的情况来考虑数据的切分：一方面，一个库的所有表通常不可能由某一张表全部串联起来，这句话暗含的意思是，水平切分几乎都是针对一小搓一小搓（实际上就是垂直切分出来的块）关系紧密的表进行的，而不可能是针对所有表进行的。另一方面，一些负载非常高的系统，即使仅仅只是单个表都无法通过单台数据库主机来承担其负载，这意味着单单是垂直切分也不能完全解决问明。因此多数系统会将垂直切分和水平切分联合使用，<strong>先对系统做垂直切分，再针对每一小搓表的情况选择性地做水平切分。从而将整个数据库切分成一个分布式矩阵</strong>。</p>
<p><img src="//blog.com/2019/03/22/为什么要分库分表/0_1295857852VJcX.gif" alt="img"></p>
<h3 id="切分策略"><a href="#切分策略" class="headerlink" title="切分策略"></a>切分策略</h3><p>​      <strong>切分是按先垂直切分再水平切分的步骤进行的。垂直切分的结果正好为水平切分做好了铺垫。垂直切分的思路就是分析表间的聚合关系，把关系紧密的表放在一起</strong>。多数情况下可能是同一个模块，或者是同一“聚集”。这里的“聚集”正是领域驱动设计里所说的聚集。在垂直切分出的表聚集内，找出“根元素”（这里的“根元素”就是领域驱动设计里的“聚合根”），按“根元素”进行水平切分，也就是从“根元素”开始，把所有和它直接与间接关联的数据放入一个shard里。这样出现跨shard关联的可能性就非常的小。应用程序就不必打断既有的表间关联。比如：对于社交网站，几乎所有数据最终都会关联到某个用户上，基于用户进行切分就是最好的选择。再比如论坛系统，用户和论坛两个模块应该在垂直切分时被分在了两个shard里，对于论坛模块来说，Forum显然是聚合根，因此按Forum进行水平切分，把Forum里所有的帖子和回帖都随Forum放在一个shard里是很自然的。</p>
<p>​      对于共享数据数据，如果是只读的字典表，每个shard里维护一份应该是一个不错的选择，这样不必打断关联关系。如果是一般数据间的跨节点的关联，就必须打断。</p>
<p>​      <strong>需要特别说明的是：当同时进行垂直和水平切分时，切分策略会发生一些微妙的变化。比如：在只考虑垂直切分的时候，被划分到一起的表之间可以保持任意的关联关系，因此你可以按“功能模块”划分表格，但是一旦引入水平切分之后，表间关联关系就会受到很大的制约，通常只能允许一个主表（以该表ID进行散列的表）和其多个次表之间保留关联关系，也就是说：当同时进行垂直和水平切分时，在垂直方向上的切分将不再以“功能模块”进行划分，而是需要更加细粒度的垂直切分，而这个粒度与领域驱动设计中的“聚合”概念不谋而合，甚至可以说是完全一致，每个shard的主表正是一个聚合中的聚合根！这样切分下来你会发现数据库分被切分地过于分散了（shard的数量会比较多，但是shard里的表却不多），为了避免管理过多的数据源，充分利用每一个数据库服务器的资源，可以考虑将业务上相近，并且具有相近数据增长速率（主表数据量在同一数量级上）的两个或多个shard放到同一个数据源里，每个shard依然是独立的，它们有各自的主表，并使用各自主表ID进行散列，不同的只是它们的散列取模（即节点数量）必需是一致的。</strong></p>
<h3 id="分库后存在的问题"><a href="#分库后存在的问题" class="headerlink" title="分库后存在的问题"></a>分库后存在的问题</h3><h4 id="1-分布式事务"><a href="#1-分布式事务" class="headerlink" title="1. 分布式事务"></a>1. 分布式事务</h4><blockquote>
<p>方案一：使用分布式事务</p>
</blockquote>
<p>​    优点：交由数据库管理，简单有效<br>​    缺点：性能代价高，特别是shard越来越多时</p>
<blockquote>
<p>方案二：由应用程序和数据库共同控制</p>
</blockquote>
<p>​     原理：将一个跨多个数据库的分布式事务分拆成多个仅处于单个数据库上面的小事务，并通过应用程序来总控<br>​           各个小事务。<br>​     优点：性能上有优势<br>​     缺点：需要应用程序在事务控制上做灵活设计。如果使用了spring的事务管理，改动起来会面临一定的困难。</p>
<blockquote>
<p>方案三：消息队列+补偿机制</p>
</blockquote>
<h4 id="2-跨节点Join的问题"><a href="#2-跨节点Join的问题" class="headerlink" title="2. 跨节点Join的问题"></a>2. 跨节点Join的问题</h4><p>​        只要是实行切分，跨节点Join的问明是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。</p>
<p>​    解决方案：<strong>分两次查询实现</strong>，在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。</p>
<h4 id="3-跨节点的count-order-by-group-by以及聚合函数问题"><a href="#3-跨节点的count-order-by-group-by以及聚合函数问题" class="headerlink" title="3. 跨节点的count,order by,group by以及聚合函数问题"></a>3. 跨节点的count,order by,group by以及聚合函数问题</h4><p>​      这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。</p>
<p>​    解决方案：与解决跨节点join问题的类似，<strong>分别在各个节点上得到结果后在应用程序端进行合并</strong>。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p>
<h2 id="水平分库分表策略"><a href="#水平分库分表策略" class="headerlink" title="水平分库分表策略"></a>水平分库分表策略</h2><p>介绍一种方案</p>
<p>预估行数：10亿<br>需要表数：10亿 / 500w = 200<br>分成10个库，每个库20张表<br>使用：<strong>客户端每个库对应一个主机，库 – scheme_(hash(id) % 10)（根据库名获取mysql主机配置），表名</strong></p>
<ul>
<li>.table_(hash(id) % 20)<br>扩展：以库为单位搭建主从，当主从无延迟时修改客户端配置；停止主从，观察一段时间后，删除原主库上的库即可</li>
<li>常用的hash算法<br>md5 + substr前多少位：缺点分库分表数只能是16的幂<br><strong>sprintf(%u, crc32(…)) % mod</strong></li>
</ul>
<h2 id="分库示例演示"><a href="#分库示例演示" class="headerlink" title="分库示例演示"></a>分库示例演示</h2><h4 id="第一部分：实施策略"><a href="#第一部分：实施策略" class="headerlink" title="第一部分：实施策略"></a>第一部分：实施策略</h4><p><img src="//blog.com/2019/03/22/为什么要分库分表/67a6a651gw1ducq4lmzyzj.jpg" alt="img"></p>
<h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><p>对数据库进行分库分表(Sharding化)前，需要开发人员充分了解系统业务逻辑和数据库schema.一个好的建议是绘制一张数据库ER图或领域模型图，以这类图为基础划分shard,直观易行，可以确保开发人员始终保持清醒思路。对于是选择数据库ER图还是领域模型图要根据项目自身情况进行选择。如果项目使用数据驱动的开发方式，团队以数据库ER图作为业务交流的基础，则自然会选择数据库ER图，如果项目使用的是领域驱动的开发方式，并通过OR-Mapping构建了一个良好的领域模型，那么领域模型图无疑是最好的选择。就我个人来说，更加倾向使用领域模型图，因为进行切分时更多的是以业务为依据进行分析判断，领域模型无疑更加清晰和直观。</p>
<h4 id="分析阶段"><a href="#分析阶段" class="headerlink" title="分析阶段"></a>分析阶段</h4><h5 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h5><p>垂直切分的依据原则是：将业务紧密，表间关联密切的表划分在一起，例如同一模块的表。结合已经准备好的数据库ER图或领域模型图，仿照活动图中的泳道概念，一个泳道代表一个shard，把所有表格划分到不同的泳道中。下面的分析示例会展示这种做法。当然，你也可以在打印出的ER图或模型图上直接用铅笔圈，一切取决于你自己的喜好。</p>
<h5 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h5><p>垂直切分后，需要对shard内表格的数据量和增速进一步分析，以确定是否需要进行水平切分。</p>
<p><strong>2.1</strong>若划分到一起的表格数据增长缓慢，在产品上线后可遇见的足够长的时期内均可以由单一数据库承载，则不需要进行水平切分，所有表格驻留同一shard,所有表间关联关系会得到最大限度的保留，同时保证了书写SQL的自由度，不易受join、group by、order by等子句限制。</p>
<p><strong>2.2</strong> 若划分到一起的表格数据量巨大，增速迅猛，需要进一步进行水平分割。进一步的水平分割就这样进行：</p>
<p><strong>2.2.1</strong>.结合业务逻辑和表间关系，将当前shard划分成多个更小的shard,通常情况下，这些更小的shard每一个都只包含一个主表（将以该表ID进行散列的表）和多个与其关联或间接关联的次表。这种一个shard一张主表多张次表的状况是水平切分的必然结果。这样切分下来，shard数量就会迅速增多。如果每一个shard代表一个独立的数据库，那么管理和维护数据库将会非常麻烦，而且这些小shard往往只有两三张表，为此而建立一个新库，利用率并不高，因此，<strong>在水平切分完成后可再进行一次“反向的Merge”,即：将业务上相近，并且具有相近数据增长速率（主表数据量在同一数量级上）的两个或多个shard放到同一个数据库上，在逻辑上它们依然是独立的shard，有各自的主表，并依据各自主表的ID进行散列，不同的只是它们的散列取模（即节点数量）必需是一致的。这样，每个数据库结点上的表格数量就相对平均了</strong></p>
<p><strong>2.2.2.</strong> <strong>所有表格均划分到合适的shard之后，所有跨越shard的表间关联都必须打断，在书写sql时，跨shard的join、group by、order by都将被禁止，需要在应用程序层面协调解决这些问题</strong></p>
<p>特别想提一点：经水平切分后，shard的粒度往往要比只做垂直切割的粒度要小，原单一垂直shard会被细分为一到多个以一个主表为中心关联或间接关联多个次表的shard，此时的shard粒度与领域驱动设计中的“聚合”概念不谋而合，甚至可以说是完全一致，每个shard的主表正是一个聚合中的聚合根！</p>
<h4 id="实施阶段"><a href="#实施阶段" class="headerlink" title="实施阶段"></a>实施阶段</h4><p>​    如果项目在开发伊始就决定进行分库分表，则严格按照分析设计方案推进即可。如果是在中期架构演进中实施，除搭建实现sharding逻辑的基础设施外(关于该话题会在下篇文章中进行阐述)，还需要对原有SQL逐一过滤分析，修改那些因为sharding而受到影响的sql.</p>
<h4 id="示例演示"><a href="#示例演示" class="headerlink" title="示例演示"></a>示例演示</h4><p>本文选择一个人尽皆知的应用：jpetstore来演示如何进行分库分表(sharding)在分析阶段的工作。由于一些个人原因，演示使用的jpetstore来自原ibatis官方的一个Demo版本，SVN地址为：<a href="http://mybatis.googlecode.com/svn/tags/java_release_2.3.4-726/jpetstore-5。关于jpetstore的业务逻辑这里不再介绍，这是一个非常简单的电商系统原型，其领域模型如下图：" target="_blank" rel="noopener">http://mybatis.googlecode.com/svn/tags/java_release_2.3.4-726/jpetstore-5。关于jpetstore的业务逻辑这里不再介绍，这是一个非常简单的电商系统原型，其领域模型如下图：</a></p>
<p><img src="//blog.com/2019/03/22/为什么要分库分表/67a6a651tw1dv5vr1tskuj.jpg" alt="img"></p>
<p><strong>图2. jpetstore领域模型</strong></p>
<p>由于系统较简单，我们很容易从模型上看出，其主要由三个模块组成：用户，产品和订单。那么垂直切分的方案也就出来了。接下来看水平切分，如果我们从一个实际的宠物店出发考虑，可能出现数据激增的单表应该是Account和Order,因此这两张表需要进行水平切分。对于Product模块来说，如果是一个实际的系统，Product和Item的数量都不会很大，因此只做垂直切分就足够了，也就是（Product，Category，Item，Iventory，Supplier）五张表在一个数据库结点上（没有水平切分，不会存在两个以上的数据库结点）。<strong>但是作为一个演示，我们假设产品模块也有大量的数据需要我们做水平切分</strong>，那么分析来看，这个模块要拆分出两个shard:一个是（Product（主），Category），另一个是（Item（主），Iventory，Supplier），<strong>同时，我们认为：这两个shard在数据增速上应该是相近的，且在业务上也很紧密</strong>，那么我们可以<strong>把这两个shard放在同一个数据库节点上，Item和Product数据在散列时取一样的模</strong>。根据前文介绍的图纸绘制方法，我们得到下面这张sharding示意图：</p>
<p><img src="//blog.com/2019/03/22/为什么要分库分表/67a6a651tw1dv5vpue9s3j.jpg" alt="img"></p>
<p><strong>图3. jpetstore sharding示意图</strong></p>
<p>对于这张图再说明几点：</p>
<p><strong>1.使用泳道表示物理shard（一个数据库结点）</strong></p>
<p><strong>2.若垂直切分出的shard进行了进一步的水平切分，但公用一个物理shard的话，则用虚线框住，表示其在逻辑上是一个独立的shard。</strong></p>
<p><strong>3.深色实体表示主表</strong></p>
<p><strong>4.X表示需要打断的表间关联</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/03/22/水平分库分表的关键步骤以及可能遇到的问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/22/水平分库分表的关键步骤以及可能遇到的问题/" itemprop="url">水平分库分表的关键步骤以及可能遇到的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-22T12:12:57+08:00">
                2019-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/分库分表/" itemprop="url" rel="index">
                    <span itemprop="name">分库分表</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="水平分库分表的关键步骤以及可能遇到的问题"><a href="#水平分库分表的关键步骤以及可能遇到的问题" class="headerlink" title="水平分库分表的关键步骤以及可能遇到的问题"></a>水平分库分表的关键步骤以及可能遇到的问题</h1><blockquote>
<p>原文地址：<a href="https://www.infoq.cn/article/key-steps-and-likely-problems-of-horizontal-split-table" target="_blank" rel="noopener">https://www.infoq.cn/article/key-steps-and-likely-problems-of-horizontal-split-table</a></p>
</blockquote>
<h2 id="分片技术的由来"><a href="#分片技术的由来" class="headerlink" title="分片技术的由来"></a>分片技术的由来</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关系型数据库本身比较容易成为系统性能瓶颈，单机存储容量、连接数、处理能力等都很有限，数据库本身的“有状态性”导致了它并不像 Web 和应用服务器那么容易扩展。在互联网行业海量数据和高并发访问的考验下，聪明的技术人员提出了分库分表技术（有些地方也称为 Sharding、分片）。同时，流行的分布式系统中间件（例如 MongoDB、ElasticSearch 等）均自身友好支持 Sharding，其原理和思想都是大同小异的。</p>
<h2 id="分布式全局唯一-ID"><a href="#分布式全局唯一-ID" class="headerlink" title="分布式全局唯一 ID"></a>分布式全局唯一 ID</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在很多中小项目中，我们往往直接使用数据库自增特性来生成主键 ID，这样确实比较简单。而在分库分表的环境中，数据分布在不同的分片上，不能再借助数据库自增长特性直接生成，否则会造成不同分片上的数据表主键会重复。简单介绍下使用和了解过的几种 ID 生成算法。</p>
<ol>
<li>Twitter 的 Snowflake（又名“雪花算法”）</li>
<li>UUID/GUID（一般应用程序和数据库均支持）</li>
<li>MongoDB ObjectID（类似 UUID 的方式）</li>
<li>Ticket Server（数据库生存方式，Flickr 采用的就是这种方式）</li>
</ol>
<p>其中，Twitter 的 Snowflake 算法是笔者近几年在分布式系统项目中使用最多的，未发现重复或并发的问题。该算法生成的是 64 位唯一 Id（由 41 位的 timestamp+ 10 位自定义的机器码 + 13 位累加计数器组成）。这里不做过多介绍，感兴趣的读者可自行查阅相关资料。</p>
<h2 id="常见分片规则和策略"><a href="#常见分片规则和策略" class="headerlink" title="常见分片规则和策略"></a>常见分片规则和策略</h2><h3 id="分片字段该如何选择"><a href="#分片字段该如何选择" class="headerlink" title="分片字段该如何选择"></a>分片字段该如何选择</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在开始分片之前，我们首先要确定分片字段（也可称为“片键”）。很多常见的例子和场景中是采用 ID 或者时间字段进行拆分。这也并不绝对的，我的建议是结合实际业务，通过对系统中执行的 sql 语句进行统计分析，选择出需要分片的那个表中最频繁被使用，或者最重要的字段来作为分片字段。</p>
<h3 id="常见分片规则"><a href="#常见分片规则" class="headerlink" title="常见分片规则"></a>常见分片规则</h3><p>常见的分片策略有随机分片和连续分片这两种，如下图所示：</p>
<p><img src="//blog.com/2019/03/22/水平分库分表的关键步骤以及可能遇到的问题/1.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当需要使用分片字段进行范围查找时，连续分片可以快速定位分片进行高效查询，大多数情况下可以有效避免跨分片查询的问题。后期如果想对整个分片集群扩容时，只需要添加节点即可，无需对其他分片的数据进行迁移。但是，<strong>连续分片也有可能存在数据热点的问题</strong>，就像图中按时间字段分片的例子，有些节点可能会被频繁查询压力较大，热数据节点就成为了整个集群的瓶颈。而有些节点可能存的是历史数据，很少需要被查询到。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随机分片其实并不是随机的，也遵循一定规则。通常，我们会采用 Hash 取模的方式进行分片拆分，所以有些时候也被称为离散分片。随机分片的数据相对比较均匀，不容易出现热点和并发访问的瓶颈。但是，后期分片集群扩容起来需要迁移旧的数据。使用<strong>一致性 Hash 算法</strong>能够很大程度的避免这个问题，所以很多中间件的分片集群都会采用一致性 Hash 算法。离散分片也很容易面临跨分片查询的复杂问题。</p>
<h3 id="数据迁移，容量规划，扩容等问题"><a href="#数据迁移，容量规划，扩容等问题" class="headerlink" title="数据迁移，容量规划，扩容等问题"></a>数据迁移，容量规划，扩容等问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很少有项目会在初期就开始考虑分片设计的，一般都是在业务高速发展面临性能和存储的瓶颈时才会提前准备。因此，不可避免的就需要考虑历史数据迁移的问题。一般做法就是通过程序先读出历史数据，然后按照指定的分片规则再将数据写入到各个分片节点中。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，我们需要根据当前的数据量和 QPS 等进行容量规划，综合成本因素，推算出大概需要多少分片（一般建议单个分片上的单表数据量不要超过 1000W）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果是采用随机分片，则需要考虑后期的扩容问题，相对会比较麻烦。<strong>如果是采用的范围分片，只需要添加节点就可以自动扩容</strong>。</p>
<h2 id="跨分片技术问题"><a href="#跨分片技术问题" class="headerlink" title="跨分片技术问题"></a>跨分片技术问题</h2><h3 id="跨分片的排序分页"><a href="#跨分片的排序分页" class="headerlink" title="跨分片的排序分页"></a>跨分片的排序分页</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p>
<p><img src="//blog.com/2019/03/22/水平分库分表的关键步骤以及可能遇到的问题/2.jpg" alt="img"></p>
<p>上面图中所描述的只是最简单的一种情况（取第一页数据），看起来对性能的影响并不大。但是，如果想取出第 10 页数据，情况又将变得复杂很多，如下图所示：</p>
<p><img src="//blog.com/2019/03/22/水平分库分表的关键步骤以及可能遇到的问题/4.jpg" alt="img"></p>
<p>有些读者可能并不太理解，为什么不能像获取第一页数据那样简单处理（排序取出前 10 条再合并、排序）。其实并不难理解，因为各分片节点中的数据可能是随机的，为了排序的准确性，必须把所有分片节点的前 N 页数据都排序好后做合并，最后再进行整体的排序。很显然，这样的操作是比较消耗资源的，用户越往后翻页，系统性能将会越差。</p>
<h3 id="跨分片的函数处理"><a href="#跨分片的函数处理" class="headerlink" title="跨分片的函数处理"></a>跨分片的函数处理</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用 Max、Min、Sum、Count 之类的函数进行统计和计算的时候，需要先在每个分片数据源上执行相应的函数处理，然后再将各个结果集进行二次处理，最终再将处理结果返回。如下图所示：</p>
<p><img src="//blog.com/2019/03/22/水平分库分表的关键步骤以及可能遇到的问题/5.jpg" alt="img"></p>
<h3 id="跨分片-join"><a href="#跨分片-join" class="headerlink" title="跨分片 join"></a>跨分片 join</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Join 是关系型数据库中最常用的特性，但是在分片集群中，join 也变得非常复杂。应该尽量避免跨分片的 join 查询（这种场景，比上面的跨分片分页更加复杂，而且对性能的影响很大）。通常有以下几种方式来避免：</p>
<h3 id="全局表"><a href="#全局表" class="headerlink" title="全局表"></a>全局表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;全局表的概念之前在“垂直分库”时提过。基本思想一致，就是把一些类似数据字典又可能会产生 join 查询的表信息放到各分片中，从而避免跨分片的 join。</p>
<h3 id="ER-分片"><a href="#ER-分片" class="headerlink" title="ER 分片"></a>ER 分片</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在关系型数据库中，表之间往往存在一些关联的关系。如果我们可以先确定好关联关系，并将那些存在关联关系的表记录存放在同一个分片上，那么就能很好的避免跨分片 join 问题。在一对多关系的情况下，我们通常会选择按照数据较多的那一方进行拆分。如下图所示：</p>
<p><img src="//blog.com/2019/03/22/水平分库分表的关键步骤以及可能遇到的问题/6.jpg" alt="img"></p>
<p>这样一来，Data Node1 上面的订单表与订单详细表就可以直接关联，进行局部的 join 查询了，Data Node2 上也一样。基于 ER 分片的这种方式，能够有效避免大多数业务场景中的跨分片 join 问题。</p>
<h3 id="内存计算"><a href="#内存计算" class="headerlink" title="内存计算"></a>内存计算</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随着 spark 内存计算的兴起，理论上来讲，很多跨数据源的操作问题看起来似乎都能够得到解决。可以将数据丢给 spark 集群进行内存计算，最后将计算结果返回。</p>
<h2 id="跨分片事务问题"><a href="#跨分片事务问题" class="headerlink" title="跨分片事务问题"></a>跨分片事务问题</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跨分片事务也分布式事务，想要了解分布式事务，就需要了解“XA 接口”和“两阶段提交”。值得提到的是，MySQL5.5x 和 5.6x 中的 xa 支持是存在问题的，会导致主从数据不一致。直到 5.7x 版本中才得到修复。Java 应用程序可以采用 Atomikos 框架来实现 XA 事务（J2EE 中 JTA）。感兴趣的读者可以自行参考《分布式事务一致性解决方案》，链接地址：</p>
<p><a href="http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency</a></p>
<h2 id="我们的系统真的需要分库分表吗"><a href="#我们的系统真的需要分库分表吗" class="headerlink" title="我们的系统真的需要分库分表吗"></a>我们的系统真的需要分库分表吗</h2><p>读完上面内容，不禁引起有些读者的思考，我们的系统是否需要分库分表吗？</p>
<p>其实这点没有明确的判断标准，比较依赖实际业务情况和经验判断。依照笔者个人的经验，一般 MySQL 单表 1000W 左右的数据是没有问题的（前提是应用系统和数据库等层面设计和优化的比较好）。当然，除了考虑当前的数据量和性能情况时，作为架构师，我们需要提前考虑系统半年到一年左右的业务增长情况，对数据库服务器的 QPS、连接数、容量等做合理评估和规划，并提前做好相应的准备工作。如果单机无法满足，且很难再从其他方面优化，那么说明是需要考虑分片的。这种情况可以先去掉数据库中自增 ID，为分片和后面的数据迁移工作提前做准备。</p>
<p>很多人觉得“分库分表”是宜早不宜迟，应该尽早进行，因为担心越往后公司业务发展越快、系统越来越复杂、系统重构和扩展越困难…这种话听起来是有那么一点道理，但我的观点恰好相反，对于关系型数据库来讲，我认为“能不分片就别分片”，除非是系统真正需要，因为数据库分片并非低成本或者免费的。</p>
<p>这里笔者推荐一个比较靠谱的过渡技术–“表分区”。主流的关系型数据库中基本都支持。不同的分区在逻辑上仍是一张表，但是物理上却是分开的，能在一定程度上提高查询性能，而且对应用程序透明，无需修改任何代码。笔者曾经负责优化过一个系统，主业务表有大约 8000W 左右的数据，考虑到成本问题，当时就是采用“表分区”来做的，效果比较明显，且系统运行的很稳定。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>最后，有很多读者都想了解当前社区中有没有开源免费的分库分表解决方案，毕竟站在巨人的肩膀上能省力很多。当前主要有两类解决方案：</p>
<ol>
<li><p>基于应用程序层面的 DDAL（分布式数据库访问层） </p>
<p>比较典型的就是淘宝半开源的 TDDL，当当网开源的 Sharding-JDBC 等。分布式数据访问层无需硬件投入，技术能力较强的大公司通常会选择自研或参照开源框架进行二次开发和定制。对应用程序的侵入性一般较大，会增加技术成本和复杂度。通常仅支持特定编程语言平台（Java 平台的居多），或者仅支持特定的数据库和特定数据访问框架技术（一般支持 MySQL 数据库，JDBC、MyBatis、Hibernate 等框架技术）。</p>
</li>
<li><p>数据库中间件，比较典型的像 mycat（在阿里开源的 cobar 基础上做了很多优化和改进，属于后起之秀，也支持很多新特性），基于 Go 语言实现 kingSharding，比较老牌的 Atlas（由 360 开源）等。这些中间件在互联网企业中大量被使用。另外，MySQL 5.x 企业版中官方提供的 Fabric 组件也号称支持分片技术，不过国内使用的企业较少。 </p>
<p>中间件也可以称为“透明网关”，大名鼎鼎的 mysql_proxy 大概是该领域的鼻祖（由 MySQL 官方提供，仅限于实现“读写分离”）。中间件一般实现了特定数据库的网络通信协议，模拟一个真实的数据库服务，屏蔽了后端真实的 Server，应用程序通常直接连接中间件即可。而在执行 SQL 操作时，中间件会按照预先定义分片规则，对 SQL 语句进行解析、路由，并对结果集做二次计算再最终返回。引入数据库中间件的技术成本更低，对应用程序来讲侵入性几乎没有，可以满足大部分的业务。增加了额外的硬件投入和运维成本，同时，中间件自身也存在性能瓶颈和单点故障问题，需要能够保证中间件自身的高可用、可扩展。</p>
</li>
</ol>
<p>总之，不管是使用分布式数据访问层还是数据库中间件，都会带来一定的成本和复杂度，也会有一定的性能影响。所以，还需读者根据实际情况和业务发展需要慎重考虑和选择。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/03/22/【转】分库分表的几种常见形式以及可能遇到的问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/22/【转】分库分表的几种常见形式以及可能遇到的问题/" itemprop="url">【转】分库分表的几种常见形式以及可能遇到的问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-22T12:12:57+08:00">
                2019-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/分库分表/" itemprop="url" rel="index">
                    <span itemprop="name">分库分表</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="【转】分库分表的几种常见形式以及可能遇到的问题"><a href="#【转】分库分表的几种常见形式以及可能遇到的问题" class="headerlink" title="【转】分库分表的几种常见形式以及可能遇到的问题"></a>【转】分库分表的几种常见形式以及可能遇到的问题</h1><blockquote>
<p>原文地址：<a href="https://www.infoq.cn/article/key-steps-and-likely-problems-of-split-table" target="_blank" rel="noopener">https://www.infoq.cn/article/key-steps-and-likely-problems-of-split-table</a></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在谈论数据库架构和数据库优化的时候，我们经常会听到“分库分表”、“分片”、“Sharding”…这样的关键词。让人感到高兴的是，这些朋友所服务的公司业务量正在（或者即将面临）高速增长，技术方面也面临着一些挑战。让人感到担忧的是，他们系统真的就需要“分库分表”了吗？“分库分表”有那么容易实践吗？为此，笔者整理了分库分表中可能遇到的一些问题，并结合以往经验介绍了对应的解决思路和建议。 </p>
<h2 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;垂直分表在日常开发和设计中比较常见，通俗的说法叫做<strong>“大表拆小表”，拆分是基于关系型数据库中的“列”（字段）进行的。通常情况，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中</strong>，如下图所示： </p>
<p><img src="//blog.com/2019/03/22/【转】分库分表的几种常见形式以及可能遇到的问题/1.jpg" alt="img"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在字段很多的情况下，拆分开确实更便于开发和维护（笔者曾见过某个遗留系统中，一个大表中包含 100 多列的）。某种意义上也能避免“跨页”的问题（MySQL、MSSQL 底层都是通过“数据页”来存储的，“跨页”问题可能会造成额外的性能开销，这里不展开，感兴趣的朋友可以自行查阅相关资料进行研究）。 </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>拆分字段的操作建议在数据库设计阶段就做好。如果是在发展过程中拆分，则需要改写以前的查询语句，会额外带来一定的成本和风险，建议谨慎</strong>。 </p>
<h2 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;垂直分库在“微服务”盛行的今天已经非常普及了。<strong>基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中</strong>。如下图： </p>
<p><img src="//blog.com/2019/03/22/【转】分库分表的几种常见形式以及可能遇到的问题/2.jpg" alt="img"></p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统层面的“服务化”拆分操作，能够解决业务系统层面的耦合和性能瓶颈，有利于系统的扩展维护。而数据库层面的拆分，道理也是相通的。与服务的“治理”和“降级”机制类似，我们也能对不同业务类型的数据进行“分级”管理、维护、监控、扩展等。 </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;众所周知，数据库往往最容易成为应用系统的瓶颈，而数据库本身属于“有状态”的，相对于 Web 和应用服务器来讲，是比较难实现“横向扩展”的。数据库的连接资源比较宝贵且单机处理能力也有限，在高并发场景下，垂直分库一定程度上能够突破 IO、连接数及单机硬件资源的瓶颈，是大型分布式系统中优化数据库架构的重要手段。 </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，很多人并没有从根本上搞清楚为什么要拆分，也没有掌握拆分的原则和技巧，只是一味的模仿大厂的做法。导致拆分后遇到很多问题（例如：<strong>跨库 join，分布式事务</strong>等）。 </p>
<h2 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;水平分表也称为横向分表，比较容易理解，就是<strong>将表中不同的数据行按照一定规律分布到不同的数据库表中</strong>（这些表保存在同一个数据库中），这样来降低单表数据量，优化查询性能。最常见的方式就是<strong>通过主键或者时间等字段进行 Hash 和取模后拆分</strong>。如下图所示： </p>
<p><img src="https://static001.infoq.cn/resource/image/fc/4b/fc53b60a24cea95d5197df6dbfbf684b.jpg" alt="img"></p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;水平分表，能够降低单表的数据量，一定程度上可以缓解查询性能瓶颈。但本质上这些表还保存在同一个库中，所以库级别还是会有 IO 瓶颈。所以，一般不建议采用这种做法。 </p>
<h2 id="水平分库分表"><a href="#水平分库分表" class="headerlink" title="水平分库分表"></a>水平分库分表</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;水平分库分表与上面讲到的水平分表的思想相同，唯一不同的就是将这些拆分出来的表保存在不同的数据中。这也是很多大型互联网公司所选择的做法。如下图： </p>
<p><img src="//blog.com/2019/03/22/【转】分库分表的几种常见形式以及可能遇到的问题/3.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;某种意义上来讲，有些系统中使用的“冷热数据分离”（将一些使用较少的历史数据迁移到其他的数据库中。而在业务功能上，通常默认只提供热点数据的查询），也是类似的实践。在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破 IO、连接数、硬件资源的瓶颈。当然，投入的硬件成本也会更高。同时，这也会带来一些复杂的技术问题和挑战（例如：跨分片的复杂查询，跨分片事务等） </p>
<h3 id="分库分表的难点"><a href="#分库分表的难点" class="headerlink" title="分库分表的难点"></a>分库分表的难点</h3><p>垂直分库带来的问题和解决思路： </p>
<h3 id="跨库-join-的问题"><a href="#跨库-join-的问题" class="headerlink" title="跨库 join 的问题"></a>跨库 join 的问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在拆分之前，系统中很多列表和详情页所需的数据是可以通过 sql join 来完成的。而拆分后，数据库可能是分布式在不同实例和不同的主机上，join 将变得非常麻烦。而且基于架构规范，性能，安全性等方面考虑，一般是禁止跨库 join 的。那该怎么办呢？首先要考虑下垂直分库的设计问题，如果可以调整，那就优先调整。如果无法调整的情况，下面笔者将结合以往的实际经验，总结几种常见的解决思路，并分析其适用场景。 </p>
<h3 id="跨库-Join-的几种解决思路"><a href="#跨库-Join-的几种解决思路" class="headerlink" title="跨库 Join 的几种解决思路"></a>跨库 Join 的几种解决思路</h3><h4 id="全局表"><a href="#全局表" class="headerlink" title="全局表"></a>全局表</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓<strong>全局表，就是有可能系统中所有模块都可能会依赖到的一些表</strong>。比较类似我们理解的“数据字典”。为了避免跨库 join 查询，我们可以将这类表在其他每个数据库中均保存一份。同时，这类数据通常也很少发生修改（甚至几乎不会），所以也不用太担心“一致性”问题。 </p>
<h4 id="字段冗余"><a href="#字段冗余" class="headerlink" title="字段冗余"></a>字段冗余</h4><p>这是一种典型的反范式设计，在互联网行业中比较常见，通常是为了性能来避免 join 查询。 </p>
<blockquote>
<p>举个电商业务中很简单的场景： </p>
<p>“订单表”中保存“卖家 Id”的同时，将卖家的“Name”字段也冗余，这样查询订单详情的时候就不需要再去查询“卖家用户表”。 </p>
</blockquote>
<p><strong>字段冗余能带来便利，是一种“空间换时间”的体现。但其适用场景也比较有限，比较适合依赖字段较少的情况</strong>。<strong>最复杂的还是数据一致性问题，这点很难保证，可以借助数据库中的触发器或者在业务代码层面去保证</strong>。当然，也需要结合实际业务场景来看一致性的要求。就像上面例子，如果卖家修改了 Name 之后，是否需要在订单信息中同步更新呢？ </p>
<h4 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定时 A 库中的 tab_a 表和 B 库中 tbl_b 有关联，可以定时将指定的表做同步。当然，同步本来会对数据库带来一定的影响，需要性能影响和数据时效性中取得一个平衡。这样来避免复杂的跨库查询。笔者曾经在项目中是通过 ETL 工具来实施的。 </p>
<h4 id="系统层组装"><a href="#系统层组装" class="headerlink" title="系统层组装"></a>系统层组装</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在系统层面，通过调用不同模块的组件或者服务，获取到数据并进行字段拼装。说起来很容易，但实践起来可真没有这么简单，尤其是数据库设计上存在问题但又无法轻易调整的时候。 </p>
<p>具体情况通常会比较复杂。下面笔者结合以往实际经验，并通过伪代码方式来描述。 </p>
<p><strong>简单的列表查询的情况</strong> </p>
<p><img src="//blog.com/2019/03/22/【转】分库分表的几种常见形式以及可能遇到的问题/5.jpg" alt="img"></p>
<p>伪代码很容易理解，先获取“我的提问列表”数据，然后再根据列表中的 UserId 去循环调用依赖的用户服务获取到用户的 RealName，拼装结果并返回。 </p>
<p>有经验的读者一眼就能看出上诉伪代码存在效率问题。循环调用服务，可能会有循环 RPC，循环查询数据库…不推荐使用。再看看改进后的： </p>
<p><img src="//blog.com/2019/03/22/【转】分库分表的几种常见形式以及可能遇到的问题/6.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种实现方式，看起来要优雅一点，其实就是把循环调用改成一次调用。当然，用户服务的数据库查询中很可能是 In 查询，效率方面比上一种方式更高。（坊间流传 In 查询会全表扫描，存在性能问题，传闻不可全信。其实查询优化器都是基本成本估算的，经过测试，在 In 语句中条件字段有索引的时候，条件较少的情况是会走索引的。这里不细展开说明，感兴趣的朋友请自行测试）。 </p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>简单字段组装的情况下，我们只需要先获取“主表”数据，然后再根据关联关系，调用其他模块的组件或服务来获取依赖的其他字段（如例中依赖的用户信息），最后将数据进行组装。 </p>
<p>通常，我们都会通过缓存来避免频繁 RPC 通信和数据库查询的开销。 </p>
<p>列表查询带条件过滤的情况  </p>
<p>在上述例子中，都是简单的字段组装，而不存在条件过滤。看拆分前的 SQL： </p>
<p><img src="//blog.com/2019/03/22/【转】分库分表的几种常见形式以及可能遇到的问题/7.jpg" alt="img"></p>
<p>这种连接查询并且还带条件过滤的情况，想在代码层面组装数据其实是非常复杂的（尤其是左表和右表都带条件过滤的情况会更复杂），不能像之前例子中那样简单的进行组装了。试想一下，如果像上面那样简单的进行组装，造成的结果就是返回的数据不完整，不准确。 </p>
<p>有如下几种解决思路： </p>
<ol>
<li><p>查出所有的问答数据，然后调用用户服务进行拼装数据，再根据过滤字段 state 字段进行过滤，最后进行排序和分页并返回。 </p>
<p>这种方式能够保证数据的准确性和完整性，但是性能影响非常大，不建议使用。</p>
</li>
<li><p>查询出 state 字段符合 / 不符合的 UserId，在查询问答数据的时候使用 in/not in 进行过滤，排序，分页等。过滤出有效的问答数据后，再调用用户服务获取数据进行组装。 </p>
<p>这种方式明显更优雅点。笔者之前在某个项目的特殊场景中就是采用过这种方式实现。</p>
</li>
</ol>
<p><strong>跨库事务（分布式事务）的问题</strong> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按业务拆分数据库之后，不可避免的就是“分布式事务”的问题。以往在代码中通过 spring 注解简单配置就能实现事务的，现在则需要花很大的成本去保证一致性。这里不展开介绍， </p>
<p>感兴趣的读者可以自行参考《分布式事务一致性解决方案》，链接地址： </p>
<p><a href="http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency</a> </p>
<h2 id="垂直分库总结和实践建议"><a href="#垂直分库总结和实践建议" class="headerlink" title="垂直分库总结和实践建议"></a>垂直分库总结和实践建议</h2><p>本篇中主要描述了几种常见的拆分方式，并着重介绍了垂直分库带来的一些问题和解决思路。读者朋友可能还有些问题和疑惑。 </p>
<p><strong>1. 我们目前的数据库是否需要进行垂直分库？</strong> </p>
<blockquote>
<p>根据系统架构和公司实际情况来，如果你们的系统还是个简单的单体应用，并且没有什么访问量和数据量，那就别着急折腾“垂直分库”了，否则没有任何收益，也很难有好结果。 </p>
<p>切记，“过度设计”和“过早优化”是很多架构师和技术人员常犯的毛病。</p>
</blockquote>
<p><strong>2. 垂直拆分有没有原则或者技巧？</strong> </p>
<blockquote>
<p>没有什么黄金法则和标准答案。一般是参考系统的业务模块拆分来进行数据库的拆分。比如“用户服务”，对应的可能就是“用户数据库”。但是也不一定严格一一对应。有些情况下，数据库拆分的粒度可能会比系统拆分的粒度更粗。笔者也确实见过有些系统中的某些表原本应该放 A 库中的，却放在了 B 库中。有些库和表原本是可以合并的，却单独保存着。还有些表，看起来放在 A 库中也 OK，放在 B 库中也合理。 </p>
<p>如何设计和权衡，这个就看实际情况和架构师 / 开发人员的水平了。</p>
</blockquote>
<p><strong>3. 上面举例的都太简单了，我们的后台报表系统中 join 的表都有 n 个了，</strong> <strong>分库后该怎么查？</strong></p>
<blockquote>
<p>有很多朋友跟我提过类似的问题。其实互联网的业务系统中，本来就应该尽量避免 join 的，如果有多个 join 的，要么是设计不合理，要么是技术选型有误。请自行科普下 OLAP 和 OLTP，报表类的系统在传统 BI 时代都是通过 OLAP 数据仓库去实现的（现在则更多是借助离线分析、流式计算等手段实现），而不该向上面描述的那样直接在业务库中执行大量 join 和统计。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/03/21/Go中的Channel/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/21/Go中的Channel/" itemprop="url">Go中的Channel</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-21T12:12:57+08:00">
                2019-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/Go并发/" itemprop="url" rel="index">
                    <span itemprop="name">Go并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Go中的Channel"><a href="#Go中的Channel" class="headerlink" title="Go中的Channel"></a>Go中的Channel</h1><blockquote>
<p>原文地址：<a href="https://www.jianshu.com/p/15c94893124c" target="_blank" rel="noopener">https://www.jianshu.com/p/15c94893124c</a></p>
<p>英文原文地址：<a href="http://golangtutorials.blogspot.com/2011/06/channels-in-go.html" target="_blank" rel="noopener">http://golangtutorials.blogspot.com/2011/06/channels-in-go.html</a></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;goroutine允许我们并行的运行一些代码。但是要想让这些代码对我们来说更有意义，我们会有一些额外的需求–我们应该能够传递数据到正在运行的进程中；当并行的进程成功产生数据时，我们应该能从该进程中获取到数据。channel配合goroutine提供了实现这些需求的途径。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;channel可以想象为一个指定了大小和容量的管道或传送带。我们可以在其一边放置内容，然后在另一边获取内容</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/118750-1b9fca6d18358cc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/509/format/webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;我们采用一个蛋糕制作装箱工厂的例子来进行下面的说明。我们有一台用于制作蛋糕的机器，还有一台用于装箱的机器。她们通过一条传送带互相连接–蛋糕机将蛋糕放上传送带，装箱机在发现传送带上么有蛋糕时将其取走并装入箱子。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在go中，<code>chan</code>关键字用于定义一个channel。<code>make</code>关键字用于创建cahnnel，创建时指定channel传递的数据类型</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ic := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">//a channel that can send and receive an int</span></span><br><span class="line">sc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>) <span class="comment">//a channel hat can send and receive a string</span></span><br><span class="line">myc := <span class="built_in">make</span> (<span class="keyword">chan</span> my_type) <span class="comment">//a channel for a custom defined struct type</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在channel的变量名前面或后面，你可以使用<code>&lt;-</code>操作符来指示channel用于发送还是接收数据(注意对应关系).假设，<code>my_channel</code>是一个接收<code>int</code>类型数据的channel，你可以像<code>my_channel &lt;- 5</code>这样向其发送数据，并且你可以像<code>my_recvd_value &lt;- my_channel</code>这样来从中接收收据</p>
<p>想象channel是一个有方向的传送带：<br> 从外部指向channel的箭头用于向channel放置数据<br> 从channel指向外部的箭头用于从channel获取数据</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">my_channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//within some goroutine - to put a value on the channel</span></span><br><span class="line">my_channel &lt;- <span class="number">5</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//within some other goroutine - to take a value off the channel</span></span><br><span class="line"><span class="keyword">var</span> my_recvd_value <span class="keyword">int</span></span><br><span class="line">my_recvd_value = &lt;- my_channel</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当然，你也可以指定channel中的数据移动方向，只需要在创建channel时在<code>chan</code>关键字旁使用<code>&lt;-</code>指明方向</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ic_send_only := <span class="built_in">make</span> (&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">//a channel that can only send data - arrow going out is sending</span></span><br><span class="line">ic_recv_only := <span class="built_in">make</span> (<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>) <span class="comment">//a channel that can only receive a data - arrow going in is receiving</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;channel能够保有的数据个数很重要。她能指示具体有多少条数据可以同时工作。即使发送者有能力产生很多条目，如果接受者没有能力接收她们，那么她们就不能工作。这将会有很多蛋糕从传送带上掉落并浪费掉ORZ。在并行计算中，这叫做<strong>生产者-消费者同步问题(producer-consumer synchronization problem)</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果channel的容量(capacity)是1——也就是说，一旦有数据被放入channel，那么该数据必须被取走才能让另一条数据放入，这就是<strong>同步channel(synchronous channel)</strong>。channel的每一边——发送者和接受者——在同一时间只交流一条数据，然后必须等待，直到另一边完成了相应的发送或接收动作。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;目前为止，我们定义的所有的channel默认都是同步channel，也就是说，一条数据被放入channel后必须被取走才能再放置另一条数据。现在，我们完成上面提到的蛋糕制作装箱工厂。由于channel在不同的goroutine之间交流数据，我们有两个名为<code>makeCakeAndSend</code>和<code>receiveCakeAndPack</code>的函数。每个函数都接收一个channel的引用作为参数，这样它们可以通过该channel进行交流。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeCakeAndSend</span><span class="params">(cs <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    cakeName := <span class="string">"Strawberry Cake "</span> + strconv.Itoa(i)</span><br><span class="line">    fmt.Println(<span class="string">"Making a cake and sending ..."</span>, cakeName)</span><br><span class="line">    cs &lt;- cakeName <span class="comment">//send a strawberry cake</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiveCakeAndPack</span><span class="params">(cs <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    s := &lt;-cs <span class="comment">//get whatever cake is on the channel</span></span><br><span class="line">    fmt.Println(<span class="string">"Packing received cake: "</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;<span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> makeCakeAndSend(cs)</span><br><span class="line">        <span class="keyword">go</span> receiveCakeAndPack(cs)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//sleep for a while so that the program doesn’t exit immediately and output is clear for illustration</span></span><br><span class="line">        time.Sleep(<span class="number">1</span> * <span class="number">1e9</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Making a cake and sending ... Strawberry Cake 1 </span></span><br><span class="line"><span class="comment">Packing received cake: Strawberry Cake 1 </span></span><br><span class="line"><span class="comment">Making a cake and sending ... Strawberry Cake 2 </span></span><br><span class="line"><span class="comment">Packing received cake: Strawberry Cake 2 </span></span><br><span class="line"><span class="comment">Making a cake and sending ... Strawberry Cake 3 </span></span><br><span class="line"><span class="comment">Packing received cake: Strawberry Cake 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在上述代码中，我们创建了三个制作蛋糕的函数调用，并在其之后立刻创建了三个装箱蛋糕的函数调用。我们知道，每当一个蛋糕被装箱，就会有另一个蛋糕同时被制作并准备好被装箱。当然如果你吹毛求疵，代码中确实有一个很轻微的含混之处——在打印<code>Making a cake and sending …</code>和实际发送蛋糕到channel之间有延时。代码中我们<strong>在每个循环中调用了<code>time.Sleep()</code>，用于让制作和装箱动作一个接一个的发生，这样做是正确的</strong>。<strong>由于我们的channel是同步的，而且同一时间仅支持一条数据，一个从channel中移除蛋糕的动作也就是一个装箱动作，必须在制作新蛋糕并将其放入channel之前发生</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;现在我们改动下上面的内容让其更像我们正常使用的代码。典型的goroutine一般是一个包含了不断循环的内容的代码块，其内部完成一些操作并且与其他的goroutine通过channel交换数据。在下面的例子中，我们将循环移至goroutine函数内部，然后我们仅调用该goroutine一次</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main                                                                                                                                                           </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeCakeAndSend</span><span class="params">(cs <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i&lt;=<span class="number">3</span>; i++ &#123;</span><br><span class="line">        cakeName := <span class="string">"Strawberry Cake "</span> + strconv.Itoa(i)</span><br><span class="line">        fmt.Println(<span class="string">"Making a cake and sending ..."</span>, cakeName)</span><br><span class="line">        cs &lt;- cakeName <span class="comment">//send a strawberry cake</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiveCakeAndPack</span><span class="params">(cs <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i&lt;=<span class="number">3</span>; i++ &#123;</span><br><span class="line">        s := &lt;-cs <span class="comment">//get whatever cake is on the channel</span></span><br><span class="line">        fmt.Println(<span class="string">"Packing received cake: "</span>, s)</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> makeCakeAndSend(cs)</span><br><span class="line">    <span class="keyword">go</span> receiveCakeAndPack(cs)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sleep for a while so that the program doesn’t exit immediately</span></span><br><span class="line">    time.Sleep(<span class="number">4</span> * <span class="number">1e9</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Making a cake and sending ... Strawberry Cake 1 </span></span><br><span class="line"><span class="comment">Making a cake and sending ... Strawberry Cake 2 </span></span><br><span class="line"><span class="comment">Packing received cake: Strawberry Cake 1 </span></span><br><span class="line"><span class="comment">Packing received cake: Strawberry Cake 2 </span></span><br><span class="line"><span class="comment">Making a cake and sending ... Strawberry Cake 3 </span></span><br><span class="line"><span class="comment">Packing received cake: Strawberry Cake 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;输出结果在我电脑上是这样的，在你电脑上可能会不同，输出结果依赖于你机器上goroutine的执行顺序。如前所述，我们仅调用了每个goroutine一次，并且传递了一个公有的channel给她们。在每个goroutine内部有三个循环，<code>makeCakeAndSend</code>将蛋糕放入channel，<code>receiveCakeAndPack</code>将蛋糕从channel中取出。<strong>由于程序会在我们创建了两个goroutine后立即结束，因此我们必须手动增加一个时间暂停操作来让三个蛋糕都被制作和装箱好</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;极其重要的一点是，<strong>我们必须理解，上面的输出并没有正确的反应channel中实际的发送和接收操作。发送和接收在这里是同步的——同一时间仅有一个蛋糕</strong>。<strong>然而由于在打印语句和实际发送与接收间的延时，输出看起来在顺序上是错误的。而实际上发生的是</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Making a cake and sending ... Strawberry Cake 1 </span><br><span class="line">Packing received cake: Strawberry Cake 1 </span><br><span class="line">Making a cake and sending ... Strawberry Cake 2 </span><br><span class="line">Packing received cake: Strawberry Cake 2 </span><br><span class="line">Making a cake and sending ... Strawberry Cake 3 Packing received cake: Strawberry Cake 3</span><br></pre></td></tr></table></figure>
<p>因此，<strong>一定要记住，在处理goroutine和channel时，通过打印日志分析执行顺序一定要万分小心</strong></p>
<h3 id="Channel-and-Range"><a href="#Channel-and-Range" class="headerlink" title="Channel and Range"></a>Channel and Range</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>数据接受者总是面临这样的问题：何时停止等待数据？还会有更多的数据么，还是所有内容都完成了？我应该继续等待还是该做别的了？</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;对于该问题，一个可选的方式是，持续的访问数据源并检查channel是否已经关闭，但是这并不是高效的解决方式。<strong>Go提供了<code>range</code>关键字，将其使用在channel上时，会自动等待channel的动作一直到channel被关闭</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main                                                                                             </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeCakeAndSend</span><span class="params">(cs <span class="keyword">chan</span> <span class="keyword">string</span>, count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= count; i++ &#123;</span><br><span class="line">        cakeName := <span class="string">"Strawberry Cake "</span> + strconv.Itoa(i)</span><br><span class="line">        cs &lt;- cakeName <span class="comment">//send a strawberry cake</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiveCakeAndPack</span><span class="params">(cs <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> s := <span class="keyword">range</span> cs &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Packing received cake: "</span>, s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> makeCakeAndSend(cs, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">go</span> receiveCakeAndPack(cs)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sleep for a while so that the program doesn’t exit immediately</span></span><br><span class="line">    time.Sleep(<span class="number">3</span> * <span class="number">1e9</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">输出结果：</span></span><br><span class="line"><span class="comment">Packing received cake: Strawberry Cake 1</span></span><br><span class="line"><span class="comment">Packing received cake: Strawberry Cake 2</span></span><br><span class="line"><span class="comment">Packing received cake: Strawberry Cake 3</span></span><br><span class="line"><span class="comment">Packing received cake: Strawberry Cake 4</span></span><br><span class="line"><span class="comment">Packing received cake: Strawberry Cake 5</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;我们告诉了蛋糕制作器我们需要5个蛋糕，但是蛋糕装箱器并不知道数目，而在之前版本的代码中，我们写死了具体的接收数目。上面的代码中，<strong>通过对channel使用<code>range</code>关键字，我们避免了给接收者写明要接收的数据个数这种不合理的需求——当channel被关闭时，接收者的<code>for</code>循环也被自动停止了</strong>。</p>
<h3 id="Channel-and-select"><a href="#Channel-and-select" class="headerlink" title="Channel and select"></a>Channel and select</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<code>select</code>关键字用于多个channel的结合，这些channel会通过类似于<strong>are-you-ready polling</strong>的机制来工作。<code>select</code>中会有<code>case</code>代码块，用于发送或接收数据——不论通过<code>&lt;-</code>操作符指定的发送还是接收操作准备好时，channel也就准备好了。在<code>select</code>中也可以有一个<code>default</code>代码块，其一直是准备好的。那么，在<code>select</code>中，哪一个代码块被执行的算法大致如下：</p>
<ul>
<li>检查每个<code>case</code>代码块</li>
<li><strong>如果任意一个<code>case</code>代码块准备好发送或接收，执行对应内容</strong></li>
<li>如果多余一个<code>case</code>代码块准备好发送或接收，随机选取一个并执行对应内容</li>
<li>如果任何一个<code>case</code>代码块都没有准备好，等待</li>
<li><strong>如果有<code>default</code>代码块，并且没有任何<code>case</code>代码块准备好，执行<code>default</code>代码块对应内容</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在下面的程序中，我们扩展蛋糕制作工厂来模拟多于一种口味的蛋糕生产的情况——现在有草莓和巧克力两种口味！但是装箱机制还是同以前一样的。由于蛋糕来自不同的channel，而装箱器不知道确切的何时会有何种蛋糕放置到某个或多个channel上，这就可以用<code>select</code>语句来处理所有这些情况——一旦某一个channel准备好接收蛋糕/数据，<code>select</code>就会完成该对应的代码块内容</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;注意，我们这里使用的<strong>多个返回值<code>case cakeName, strbry_ok := &lt;-strbry_cs</code>，第二个返回值是一个<code>bool</code>类型，当其为<code>false</code>时说明channel被关闭了</strong>。如果是<code>true</code>，说明有一个值被成功传递了。我们使用这个值来判断是否应该停止等待。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeCakeAndSend</span><span class="params">(cs <span class="keyword">chan</span> <span class="keyword">string</span>, flavor <span class="keyword">string</span>, count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= count; i++ &#123;</span><br><span class="line">        cakeName := flavor + <span class="string">" Cake "</span> + strconv.Itoa(i)</span><br><span class="line">        cs &lt;- cakeName <span class="comment">//send a strawberry cake</span></span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">close</span>(cs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiveCakeAndPack</span><span class="params">(strbry_cs <span class="keyword">chan</span> <span class="keyword">string</span>, choco_cs <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    strbry_closed, choco_closed := <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//if both channels are closed then we can stop</span></span><br><span class="line">        <span class="keyword">if</span> (strbry_closed &amp;&amp; choco_closed) &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        fmt.Println(<span class="string">"Waiting for a new cake ..."</span>)</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> cakeName, strbry_ok := &lt;-strbry_cs:</span><br><span class="line">            <span class="keyword">if</span> (!strbry_ok) &#123;</span><br><span class="line">                strbry_closed = <span class="literal">true</span></span><br><span class="line">                fmt.Println(<span class="string">" ... Strawberry channel closed!"</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"Received from Strawberry channel.  Now packing"</span>, cakeName)</span><br><span class="line">            &#125;   </span><br><span class="line">        <span class="keyword">case</span> cakeName, choco_ok := &lt;-choco_cs:</span><br><span class="line">            <span class="keyword">if</span> (!choco_ok) &#123;</span><br><span class="line">                choco_closed = <span class="literal">true</span></span><br><span class="line">                fmt.Println(<span class="string">" ... Chocolate channel closed!"</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"Received from Chocolate channel.  Now packing"</span>, cakeName)</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    strbry_cs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    choco_cs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//two cake makers</span></span><br><span class="line">    <span class="keyword">go</span> makeCakeAndSend(choco_cs, <span class="string">"Chocolate"</span>, <span class="number">3</span>)  <span class="comment">//make 3 chocolate cakes and send</span></span><br><span class="line">    <span class="keyword">go</span> makeCakeAndSend(strbry_cs, <span class="string">"Strawberry"</span>, <span class="number">3</span>)  <span class="comment">//make 3 strawberry cakes and send</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//one cake receiver and packer</span></span><br><span class="line">    <span class="keyword">go</span> receiveCakeAndPack(strbry_cs, choco_cs)  <span class="comment">//pack all cakes received on these cake channels</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//sleep for a while so that the program doesn’t exit immediately</span></span><br><span class="line">    time.Sleep(<span class="number">2</span> * <span class="number">1e9</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">输出结果</span></span><br><span class="line"><span class="comment">Waiting for a new cake ... </span></span><br><span class="line"><span class="comment">Received from Strawberry channel. Now packing Strawberry Cake 1 </span></span><br><span class="line"><span class="comment">Waiting for a new cake ... </span></span><br><span class="line"><span class="comment">Received from Chocolate channel. Now packing Chocolate Cake 1 </span></span><br><span class="line"><span class="comment">Waiting for a new cake ... </span></span><br><span class="line"><span class="comment">Received from Chocolate channel. Now packing Chocolate Cake 2 </span></span><br><span class="line"><span class="comment">Waiting for a new cake ... </span></span><br><span class="line"><span class="comment">Received from Strawberry channel. Now packing Strawberry Cake 2 </span></span><br><span class="line"><span class="comment">Waiting for a new cake ... </span></span><br><span class="line"><span class="comment">Received from Strawberry channel. Now packing Strawberry Cake 3 </span></span><br><span class="line"><span class="comment">Waiting for a new cake ... </span></span><br><span class="line"><span class="comment">Received from Chocolate channel. Now packing Chocolate Cake 3 </span></span><br><span class="line"><span class="comment">Waiting for a new cake ... </span></span><br><span class="line"><span class="comment">... Strawberry channel closed! </span></span><br><span class="line"><span class="comment">Waiting for a new cake ... </span></span><br><span class="line"><span class="comment">... Chocolate channel closed!</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;实际上，有经验的Gopher一眼就能发现，<code>示例代码</code>中的channel是没有正确关闭的，在<code>for range</code>语句的执行<strong>一直没有停止</strong>因为channel一直存在而没有被关闭，只不过随着<code>time.Sleep()</code>结束，main函数退出，所有的goroutine被关闭，该语句也被结束了而已。</p>
<p>正确的解决步骤：<br> a) <strong>发送器一旦停止发送数据后立即关闭channel</strong><br> b)  <strong>接收器一旦停止接收内容，终止程序 </strong><br> c)  <strong>移除<code>time.Sleep</code>语句 </strong></p>
<p>修改后代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeCakeAndSend</span><span class="params">(cs <span class="keyword">chan</span> <span class="keyword">string</span>, count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= count; i++ &#123;</span><br><span class="line">        cakeName := <span class="string">"Strawberry Cake "</span> + strconv.Itoa(i)</span><br><span class="line">        cs &lt;- cakeName <span class="comment">//send a strawberry cake</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(cs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiveCakeAndPack</span><span class="params">(cs <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> s := <span class="keyword">range</span> cs &#123;</span><br><span class="line">        fmt.Println(<span class="string">"Packing received cake: "</span>, s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    <span class="keyword">go</span> makeCakeAndSend(cs, <span class="number">5</span>)</span><br><span class="line">    receiveCakeAndPack(cs)</span><br><span class="line">     <span class="comment">// 这里不能够再加上go关键字的原因：因为主程序会立刻退出，得不到任何输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样才是对channel使用<code>range</code>进行处理的优雅方法</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;同样的，第二个例子中，<code>time.Sleep()</code>语句可以去除掉，我们只需要让<code>receiveCakeAndPack</code>函数执行完毕后退出程序即可</p>
<p>修改后代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeCakeAndSend</span><span class="params">(cs <span class="keyword">chan</span> <span class="keyword">string</span>, flavor <span class="keyword">string</span>, count <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= count; i++ &#123;</span><br><span class="line">        cakeName := flavor + <span class="string">" Cake "</span> + strconv.Itoa(i)</span><br><span class="line">        cs &lt;- cakeName <span class="comment">//send a strawberry cake</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(cs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiveCakeAndPack</span><span class="params">(strbry_cs <span class="keyword">chan</span> <span class="keyword">string</span>, choco_cs <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    strbry_closed, choco_closed := <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">//if both channels are closed then we can stop</span></span><br><span class="line">        <span class="keyword">if</span> strbry_closed &amp;&amp; choco_closed &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(<span class="string">"Waiting for a new cake ..."</span>)</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> cakeName, strbry_ok := &lt;-strbry_cs:</span><br><span class="line">            <span class="keyword">if</span> !strbry_ok &#123;</span><br><span class="line">                strbry_closed = <span class="literal">true</span></span><br><span class="line">                fmt.Println(<span class="string">" ... Strawberry channel closed!"</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"Received from Strawberry channel.  Now packing"</span>, cakeName)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> cakeName, choco_ok := &lt;-choco_cs:</span><br><span class="line">            <span class="keyword">if</span> !choco_ok &#123;</span><br><span class="line">                choco_closed = <span class="literal">true</span></span><br><span class="line">                fmt.Println(<span class="string">" ... Chocolate channel closed!"</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">"Received from Chocolate channel.  Now packing"</span>, cakeName)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    strbry_cs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    choco_cs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//two cake makers</span></span><br><span class="line">    <span class="keyword">go</span> makeCakeAndSend(choco_cs, <span class="string">"Chocolate"</span>, <span class="number">3</span>)   <span class="comment">//make 3 chocolate cakes and send</span></span><br><span class="line">    <span class="keyword">go</span> makeCakeAndSend(strbry_cs, <span class="string">"Strawberry"</span>, <span class="number">4</span>) <span class="comment">//make 3 strawberry cakes and send</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//one cake receiver and packer</span></span><br><span class="line">    receiveCakeAndPack(strbry_cs, choco_cs) <span class="comment">//pack all cakes received on these cake channels</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里不能够再加上go关键字的原因：因为主程序会立刻退出，得不到任何输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/03/21/Go并发原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/21/Go并发原理/" itemprop="url">Go并发原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-21T12:12:57+08:00">
                2019-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/Go并发/" itemprop="url" rel="index">
                    <span itemprop="name">Go并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Go并发原理"><a href="#Go并发原理" class="headerlink" title="Go并发原理"></a>Go并发原理</h1><blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s?__biz=MzIyMTg0OTExOQ%3D%3D&amp;mid=2247484436&amp;idx=2&amp;sn=2864adc11a787c1c3ee79e8dbd96c27a&amp;scene=45#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIyMTg0OTExOQ%3D%3D&amp;mid=2247484436&amp;idx=2&amp;sn=2864adc11a787c1c3ee79e8dbd96c27a&amp;scene=45#wechat_redirect</a></p>
</blockquote>
<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Go语言是为并发而生的语言，Go语言是为数不多的在语言层面实现并发的语言；也正是Go语言的并发特性，吸引了全球无数的开发者。</p>
<h4 id="2-并发和并行"><a href="#2-并发和并行" class="headerlink" title="2. 并发和并行"></a>2. 并发和并行</h4><p><strong>并发(concurrency)：</strong>两个或两个以上的任务在一段时间内被执行。我们不必care这些任务在某一个时间点是否是同时执行，可能同时执行，也可能不是，我们只关心在一段时间内，哪怕是很短的时间（一秒或者两秒）是否执行解决了两个或两个以上任务。</p>
<p><strong>并行(parallellism)：</strong>两个或两个以上的任务在同一时刻被同时执行。</p>
<p>并发说的是逻辑上的概念，而并行，强调的是物理运行状态。并发“包含”并行。</p>
<h3 id="3-Go的CSP并发模型"><a href="#3-Go的CSP并发模型" class="headerlink" title="3. Go的CSP并发模型"></a>3. Go的CSP并发模型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Go实现了两种并发形式。第一种是大家普遍认知的：多线程共享内存。其实就是Java或者C++等语言中的多线程开发。另外一种是Go语言特有的，也是Go语言推荐的：CSP（communicating sequential processes）并发模型。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;CSP并发模型是在1970年左右提出的概念，属于比较新的概念，<strong>不同于传统的多线程通过共享内存来通信，CSP讲究的是“以通信的方式来共享内存”</strong>。</p>
<blockquote>
<p>请记住下面这句话：<br><strong>Do not communicate by sharing memory; instead, share memory by communicating.</strong><br>“不要以共享内存的方式来通信，相反，要通过通信来共享内存。”</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;普通的线程并发模型，就是像Java、C++、或者Python，他们线程间通信都是通过共享内存的方式来进行的。非常典型的方式就是，在访问共享数据（例如数组、Map、或者某个结构体或对象）的时候，通过锁来访问，因此，在很多时候，衍生出一种方便操作的数据结构，叫做“线程安全的数据结构”。例如Java提供的包”java.util.concurrent”中的数据结构。Go中也实现了传统的线程并发模型。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>Go的CSP并发模型，是通过<code>goroutine</code>和<code>channel</code>来实现的</strong>。</p>
<ul>
<li><code>goroutine</code> 是Go语言中并发的执行单位。有点抽象，其实就是和传统概念上的”线程“类似，可以理解为”线程“。</li>
<li><code>channel</code>是Go语言中各个并发结构体(<code>goroutine</code>)之前的通信机制。 通俗的讲，就是各个<code>goroutine</code>之间通信的”管道“，有点类似于Linux中的管道。</li>
</ul>
<p>生成一个<code>goroutine</code>的方式非常的简单：Go一下，就生成了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> f();</span><br></pre></td></tr></table></figure>
<p>通信机制<code>channel</code>也很方便，传数据用<code>channel &lt;- data</code>，取数据用<code>&lt;-channel</code>。</p>
<p>在通信过程中，传数据<code>channel &lt;- data</code>和取数据<code>&lt;-channel</code>必然会成对出现，因为这边传，那边取，两个<code>goroutine</code>之间才会实现通信。</p>
<p>而且不管传还是取，必阻塞，直到另外的<code>goroutine</code>传或者取为止。</p>
<p>有两个<code>goroutine</code>，其中一个发起了向<code>channel</code>中发起了传值操作。（<code>goroutine</code>为矩形，<code>channel</code>为箭头）</p>
<p>左边的<code>goroutine</code>开始阻塞，等待有人接收。</p>
<p>这时候，右边的<code>goroutine</code>发起了接收操作。</p>
<p>右边的<code>goroutine</code>也开始阻塞，等待别人传送。</p>
<p>这时候，两边<code>goroutine</code>都发现了对方，于是两个<code>goroutine</code>开始一传，一收。</p>
<p><img src="//blog.com/2019/03/21/Go并发原理/1.webp" alt="img"></p>
<p>这便是Golang CSP并发模型最基本的形式。</p>
<h3 id="4-Go并发模型的实现原理"><a href="#4-Go并发模型的实现原理" class="headerlink" title="4. Go并发模型的实现原理"></a>4. Go并发模型的实现原理</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;我们先从线程讲起，<strong>无论语言层面何种并发模型，到了操作系统层面，一定是以线程的形态存在的</strong>。而操作系统根据资源访问权限的不同，体系架构可分为用户空间和内核空间；<strong>内核空间主要操作访问CPU资源、I/O资源、内存资源等硬件资源，为上层应用程序提供最基本的基础资源</strong>，用户空间呢就是上层应用程序的固定活动空间，<strong>用户空间不可以直接访问资源，必须通过“系统调用”、“库函数”或“Shell脚本”来调用内核空间提供的资源</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;我们现在的计算机语言，可以狭义的认为是一种“软件”，它们中所谓的“线程”，往往是用户态的线程，和操作系统本身内核态的线程（简称KSE），还是有区别的。</p>
<p>线程模型的实现，可以分为以下几种方式：</p>
<h4 id="1）用户级线程模型"><a href="#1）用户级线程模型" class="headerlink" title="1）用户级线程模型"></a>1）用户级线程模型</h4><p><img src="//blog.com/2019/03/21/Go并发原理/2.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如图所示，多个用户态的线程对应着一个内核线程，程序线程的创建、终止、切换或者同步等线程工作必须自身来完成。</p>
<h4 id="2）内核级线程模型"><a href="#2）内核级线程模型" class="headerlink" title="2）内核级线程模型"></a>2）内核级线程模型</h4><p><img src="//blog.com/2019/03/21/Go并发原理/3.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这种模型直接调用操作系统的内核线程，所有线程的创建、终止、切换、同步等操作，都由内核来完成。C++就是这种。</p>
<h4 id="3）两级线程模型"><a href="#3）两级线程模型" class="headerlink" title="3）两级线程模型"></a>3）两级线程模型</h4><p><img src="//blog.com/2019/03/21/Go并发原理/4.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这种模型是介于用户级线程模型和内核级线程模型之间的一种线程模型。这种模型的实现非常复杂，和内核级线程模型类似，<strong>一个进程中可以对应多个内核级线程，但是进程中的线程不和内核线程一一对应；这种线程模型会先创建多个内核级线程，然后用自身的用户级线程去对应创建的多个内核级线程，自身的用户级线程需要本身程序去调度，内核级的线程交给操作系统内核去调度</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Go语言的线程模型就是一种特殊的两级线程模型。暂且叫它“MPG”模型吧。</p>
<h3 id="5-Go线程实现模型MPG"><a href="#5-Go线程实现模型MPG" class="headerlink" title="5. Go线程实现模型MPG"></a>5. Go线程实现模型MPG</h3><p><strong><code>M</code>指的是<code>Machine</code>，一个<code>M</code>直接关联了一个内核线程</strong>。</p>
<p><strong><code>P</code>指的是”processor”，代表了<code>M</code>所需的上下文环境，也是处理用户级代码逻辑的处理器</strong>。<br><strong><code>G</code>指的是<code>Goroutine</code>，其实本质上也是一种轻量级的线程</strong>。</p>
<p>三者关系如下图所示：</p>
<p><img src="//blog.com/2019/03/21/Go并发原理/5.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;以上这个图讲的是两个线程(内核线程)的情况。一个M会对应一个内核线程，一个M也会连接一个上下文P，一个上下文P相当于一个“处理器”，一个上下文连接一个或者多个Goroutine。P(Processor)的数量是在启动时被设置为环境变量GOMAXPROCS的值，或者通过运行时调用函数<code>runtime.GOMAXPROCS()</code>进行设置。Processor数量固定意味着任意时刻只有固定数量的线程在运行go代码。Goroutine中就是我们要执行并发的代码。图中P正在执行的<code>Goroutine</code>为蓝色的；处于待执行状态的<code>Goroutine</code>为灰色的，灰色的<code>Goroutine</code>形成了一个队列<code>runqueues</code></p>
<p>三者关系的宏观的图为：</p>
<p><img src="//blog.com/2019/03/21/Go并发原理/6.webp" alt="img"></p>
<h3 id="6-抛弃P（Processor）"><a href="#6-抛弃P（Processor）" class="headerlink" title="6. 抛弃P（Processor）"></a>6. 抛弃P（Processor）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;你可能会想，为什么一定需要一个上下文，我们能不能直接除去上下文，让<code>Goroutine</code>的<code>runqueues</code>挂到M上呢？答案是不行，<strong>需要上下文的目的，是让我们可以直接放开其他线程，当遇到内核线程阻塞的时候</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;一个很简单的例子就是系统调用<code>sysall</code>，一个线程肯定不能同时执行代码和系统调用被阻塞，这个时候，此线程M需要放弃当前的上下文环境P，以便可以让其他的<code>Goroutine</code>被调度执行。</p>
<p><img src="//blog.com/2019/03/21/Go并发原理/7.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如上图左图所示，M0中的G0执行了syscall，然后就创建了一个M1(也有可能本身就存在，没创建)，（转向右图）然后M0丢弃了P，等待syscall的返回值，M1接受了P，将·继续执行<code>Goroutine</code>队列中的其他<code>Goroutine</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当系统调用syscall结束后，M0会“偷”一个上下文，如果不成功，M0就把它的Gouroutine G0放到一个全局的runqueue中，然后自己放到线程池或者转入休眠状态。全局runqueue是各个P在运行完自己的本地的Goroutine runqueue后用来拉取新goroutine的地方。P也会周期性的检查这个全局runqueue上的goroutine，否则，全局runqueue上的goroutines可能得不到执行而饿死。</p>
<h3 id="7-均衡的分配工作"><a href="#7-均衡的分配工作" class="headerlink" title="7. 均衡的分配工作"></a>7. 均衡的分配工作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;按照以上的说法，上下文P会定期的检查全局的goroutine 队列中的goroutine，以便自己在消费掉自身Goroutine&nbsp;&nbsp;&nbsp;&nbsp;队列的时候有事可做。假如全局goroutine队列中的goroutine也没了呢？就从其他运行的中的P的runqueue里偷。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;每个P中的<code>Goroutine</code>不同导致他们运行的效率和时间也不同，在一个有很多P和M的环境中，不能让一个P跑完自身的<code>Goroutine</code>就没事可做了，因为或许其他的P有很长的<code>goroutine</code>队列要跑，得需要均衡。<br>该如何解决呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Go的做法倒也直接，从其他P中偷一半！</p>
<p><img src="//blog.com/2019/03/21/Go并发原理/8.webp" alt="img"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/113/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/113/">113</a><span class="page-number current">114</span><a class="page-number" href="/page/115/">115</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/115/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
