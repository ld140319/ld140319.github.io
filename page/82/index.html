<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/page/82/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/page/82/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/09/RESTful API 设计规范/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/RESTful API 设计规范/" itemprop="url">RESTful API 设计规范</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-09T12:12:57+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/API设计/" itemprop="url" rel="index">
                    <span itemprop="name">API设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="RESTful-API-设计规范"><a href="#RESTful-API-设计规范" class="headerlink" title="RESTful API 设计规范"></a>RESTful API 设计规范</h1><h2 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h2><ul>
<li><a href="#restful-api-设计规范">RESTful API 设计规范</a></li>
<li><a href="#关于能愿动词的使用">关于「能愿动词」的使用</a></li>
<li><a href="#protocol">Protocol</a></li>
<li><a href="#api-root-url">API Root URL</a></li>
<li><a href="#versioning">Versioning</a><ul>
<li><a href="#在-url-中嵌入版本编号">在 URL 中嵌入版本编号</a></li>
<li><a href="#通过媒体类型来指定版本信息">通过媒体类型来指定版本信息</a></li>
</ul>
</li>
<li><a href="#endpoints">Endpoints</a></li>
<li><a href="#http-动词">HTTP 动词</a></li>
<li><a href="#filtering">Filtering</a></li>
<li><a href="#authentication">Authentication</a></li>
<li><a href="#response">Response</a><ul>
<li><a href="#200-ok">200 ok</a></li>
<li><a href="#201-created">201 Created</a></li>
<li><a href="#202-accepted">202 Accepted</a></li>
<li><a href="#204-no-content">204 No Content</a></li>
<li><a href="#3xx-重定向">3xx 重定向</a></li>
<li><a href="#400-bad-request">400 Bad Request</a></li>
<li><a href="#401-unauthorized">401 Unauthorized</a></li>
<li><a href="#403-forbidden">403 Forbidden</a></li>
<li><a href="#404-not-found">404 Not Found</a></li>
<li><a href="#405-method-not-allowd">405 Method Not Allowd</a></li>
<li><a href="#406-not-acceptable">406 Not Acceptable</a></li>
<li><a href="#408-request-timeout">408 Request Timeout</a></li>
<li><a href="#409-gonfilct">409 Gonfilct</a></li>
<li><a href="#410-gone">410 Gone</a></li>
<li><a href="#413-request-entity-too-large">413 Request Entity Too Large</a></li>
<li><a href="#414-request-uri-too-long">414 Request-URI Too Long</a></li>
<li><a href="#415-unsupported-media-type">415 Unsupported Media Type</a></li>
<li><a href="#429-too-many-request">429 Too Many Request</a></li>
<li><a href="#500-internal-server-error">500 Internal Server Error</a></li>
<li><a href="#503-service-unavailable">503 Service Unavailable</a></li>
</ul>
</li>
<li><a href="#版权声明">版权声明</a></li>
<li><a href="#建议参考">建议参考</a></li>
<li><a href="#license">LICENSE</a></li>
</ul>
<h2 id="关于「能愿动词」的使用"><a href="#关于「能愿动词」的使用" class="headerlink" title="关于「能愿动词」的使用"></a>关于「能愿动词」的使用</h2><p>为了避免歧义，文档大量使用了「能愿动词」，对应的解释如下：</p>
<ul>
<li><code>必须 (MUST)</code>：绝对，严格遵循，请照做，无条件遵守；</li>
<li><code>一定不可 (MUST NOT)</code>：禁令，严令禁止；</li>
<li><code>应该 (SHOULD)</code> ：强烈建议这样做，但是不强求；</li>
<li><code>不该 (SHOULD NOT)</code>：强烈不建议这样做，但是不强求；</li>
<li><code>可以 (MAY)</code> 和 <code>可选 (OPTIONAL)</code> ：选择性高一点，在这个文档内，此词语使用较少；</li>
</ul>
<blockquote>
<p>参见：<a href="http://www.ietf.org/rfc/rfc2119.txt" target="_blank" rel="noopener">RFC 2119</a></p>
</blockquote>
<h2 id="Protocol"><a href="#Protocol" class="headerlink" title="Protocol"></a>Protocol</h2><p>客户端在通过 <code>API</code> 与后端服务通信的过程中，<code>应该</code> 使用 <code>HTTPS</code> 协议。</p>
<h2 id="API-Root-URL"><a href="#API-Root-URL" class="headerlink" title="API Root URL"></a>API Root URL</h2><p><code>API</code> 的根入口点应尽可能保持足够简单，这里有两个常见的 <code>URL</code> 根例子：</p>
<ul>
<li>api.example.com/*</li>
<li>example.com/api/*</li>
</ul>
<blockquote>
<p>如果你的应用很庞大或者你预计它将会变的很庞大，那 <code>应该</code> 将 <code>API</code> 放到子域下（<code>api.example.com</code>）。这种做法可以保持某些规模化上的灵活性。</p>
</blockquote>
<h2 id="Versioning"><a href="#Versioning" class="headerlink" title="Versioning"></a>Versioning</h2><p>所有的 <code>API</code> 必须保持向后兼容，你 <code>必须</code> 在引入新版本 <code>API</code> 的同时确保旧版本 <code>API</code> 仍然可用。所以 <code>应该</code> 为其提供版本支持。</p>
<p>目前比较常见的两种版本号形式：</p>
<h3 id="在-URL-中嵌入版本编号"><a href="#在-URL-中嵌入版本编号" class="headerlink" title="在 URL 中嵌入版本编号"></a>在 URL 中嵌入版本编号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api.example.com/v1/*</span><br></pre></td></tr></table></figure>
<p>这种做法是版本号直观、易于调试；另一种做法是，将版本号放在 <code>HTTP Header</code> 头中：</p>
<h3 id="通过媒体类型来指定版本信息"><a href="#通过媒体类型来指定版本信息" class="headerlink" title="通过媒体类型来指定版本信息"></a>通过媒体类型来指定版本信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: application/vnd.example.com.v1+json</span><br></pre></td></tr></table></figure>
<p>其中 <code>vnd</code> 表示 <code>Standards Tree</code> 标准树类型，有三个不同的树: <code>x</code>，<code>prs</code> 和 <code>vnd</code>。你使用的标准树需要取决于你开发的项目</p>
<ul>
<li>未注册的树（<code>x</code>）主要表示本地和私有环境</li>
<li>私有树（<code>prs</code>）主要表示没有商业发布的项目</li>
<li>供应商树（<code>vnd</code>）主要表示公开发布的项目</li>
</ul>
<blockquote>
<p>后面几个参数依次为应用名称（一般为应用域名）、版本号、期望的返回格式。</p>
</blockquote>
<p>至于具体把版本号放在什么地方，这个问题一直存在很大的争议，但由于我们大多数时间都在使用 <code>Laravel</code> 开发，<code>应该</code> 使用 <a href="https://github.com/dingo/api" target="_blank" rel="noopener">dingo/api</a> 来快速构建应用，它采用第二种方式来管理 <code>API</code> 版本，并且已集成了标准的 <code>HTTP Response</code>。</p>
<h2 id="Endpoints"><a href="#Endpoints" class="headerlink" title="Endpoints"></a>Endpoints</h2><p>端点就是指向特定资源或资源集合的 <code>URL</code>。在端点的设计中，你 <code>必须</code> 遵守下列约定：</p>
<ul>
<li>URL 的命名 <code>必须</code> 全部小写</li>
<li>URL 中资源（<code>resource</code>）的命名 <code>必须</code> 是名词，并且 <code>必须</code> 是复数形式</li>
<li><code>必须</code> 优先使用 <code>Restful</code> 类型的 URL</li>
<li>URL <code>必须</code> 是易读的</li>
<li>URL <code>一定不可</code> 暴露服务器架构</li>
</ul>
<blockquote>
<p>至于 URL 是否必须使用连字符（<code>-</code>） 或下划线（<code>_</code>），不做硬性规定，但 <code>必须</code> 根据团队情况统一一种风格。</p>
</blockquote>
<p>来看一个反例</p>
<ul>
<li><a href="https://api.example.com/getUserInfo?userid=1" target="_blank" rel="noopener">https://api.example.com/getUserInfo?userid=1</a></li>
<li><a href="https://api.example.com/getusers" target="_blank" rel="noopener">https://api.example.com/getusers</a></li>
<li><a href="https://api.example.com/sv/u" target="_blank" rel="noopener">https://api.example.com/sv/u</a></li>
<li><a href="https://api.example.com/cgi-bin/users/get_user.php?userid=1" target="_blank" rel="noopener">https://api.example.com/cgi-bin/users/get_user.php?userid=1</a></li>
</ul>
<p>再来看一个正列</p>
<ul>
<li><a href="https://api.example.com/zoos" target="_blank" rel="noopener">https://api.example.com/zoos</a></li>
<li><a href="https://api.example.com/animals" target="_blank" rel="noopener">https://api.example.com/animals</a></li>
<li><a href="https://api.example.com/zoos/{zoo}/animals" target="_blank" rel="noopener">https://api.example.com/zoos/{zoo}/animals</a></li>
<li><a href="https://api.example.com/animal_types" target="_blank" rel="noopener">https://api.example.com/animal_types</a></li>
<li><a href="https://api.example.com/employees" target="_blank" rel="noopener">https://api.example.com/employees</a></li>
</ul>
<h2 id="HTTP-动词"><a href="#HTTP-动词" class="headerlink" title="HTTP 动词"></a>HTTP 动词</h2><p>对于资源的具体操作类型，由 <code>HTTP</code> 动词表示。常用的 <code>HTTP</code> 动词有下面五个（括号里是对应的 <code>SQL</code> 命令）。</p>
<ul>
<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>
<li>POST（CREATE）：在服务器新建一个资源。</li>
<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>
<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>
<li>DELETE（DELETE）：从服务器删除资源。</li>
</ul>
<p>其中</p>
<p>1 删除资源 <code>必须</code> 用 <code>DELETE</code> 方法<br>2 创建新的资源 <code>必须</code> 使用 <code>POST</code> 方法<br>3 更新资源 <code>应该</code> 使用 <code>PUT</code> 方法<br>4 获取资源信息 <code>必须</code> 使用 <code>GET</code> 方法</p>
<p>针对每一个端点来说，下面列出所有可行的 <code>HTTP</code> 动词和端点的组合</p>
<table>
<thead>
<tr>
<th>请求方法</th>
<th>URL</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>/zoos</td>
<td>列出所有的动物园(ID和名称，不要太详细)</td>
</tr>
<tr>
<td>POST</td>
<td>/zoos</td>
<td>新增一个新的动物园</td>
</tr>
<tr>
<td>GET</td>
<td>/zoos/{zoo}</td>
<td>获取指定动物园详情</td>
</tr>
<tr>
<td>PUT</td>
<td>/zoos/{zoo}</td>
<td>更新指定动物园(整个对象)</td>
</tr>
<tr>
<td>PATCH</td>
<td>/zoos/{zoo}</td>
<td>更新动物园(部分对象)</td>
</tr>
<tr>
<td>DELETE</td>
<td>/zoos/{zoo}</td>
<td>删除指定动物园</td>
</tr>
<tr>
<td>GET</td>
<td>/zoos/{zoo}/animals</td>
<td>检索指定动物园下的动物列表(ID和名称，不要太详细)</td>
</tr>
<tr>
<td>GET</td>
<td>/animals</td>
<td>列出所有动物(ID和名称)。</td>
</tr>
<tr>
<td>POST</td>
<td>/animals</td>
<td>新增新的动物</td>
</tr>
<tr>
<td>GET</td>
<td>/animals/{animal}</td>
<td>获取指定的动物详情</td>
</tr>
<tr>
<td>PUT</td>
<td>/animals/{animal}</td>
<td>更新指定的动物(整个对象)</td>
</tr>
<tr>
<td>PATCH</td>
<td>/animals/{animal}</td>
<td>更新指定的动物(部分对象)</td>
</tr>
<tr>
<td>GET</td>
<td>/animal_types</td>
<td>获取所有动物类型(ID和名称，不要太详细)</td>
</tr>
<tr>
<td>GET</td>
<td>/animal_types/{type}</td>
<td>获取指定的动物类型详情</td>
</tr>
<tr>
<td>GET</td>
<td>/employees</td>
<td>检索整个雇员列表</td>
</tr>
<tr>
<td>GET</td>
<td>/employees/{employee}</td>
<td>检索指定特定的员工</td>
</tr>
<tr>
<td>GET</td>
<td>/zoos/{zoo}/employees</td>
<td>检索在这个动物园工作的雇员的名单(身份证和姓名)</td>
</tr>
<tr>
<td>POST</td>
<td>/employees</td>
<td>新增指定新员工</td>
</tr>
<tr>
<td>POST</td>
<td>/zoos/{zoo}/employees</td>
<td>在特定的动物园雇佣一名员工</td>
</tr>
<tr>
<td>DELETE</td>
<td>/zoos/{zoo}/employees/{employee}</td>
<td>从某个动物园解雇一名员工</td>
</tr>
</tbody>
</table>
<blockquote>
<p>超出 <code>Restful</code> 端点的，<code>应该</code> 模仿上表的方式来定义端点。</p>
</blockquote>
<h2 id="Filtering"><a href="#Filtering" class="headerlink" title="Filtering"></a>Filtering</h2><blockquote>
<p>如果记录数量很多，服务器不可能都将它们返回给用户。API <code>应该</code> 提供参数，过滤返回结果。下面是一些常见的参数。</p>
</blockquote>
<ul>
<li>?limit=10：指定返回记录的数量</li>
<li>?offset=10：指定返回记录的开始位置。</li>
<li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li>
<li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li>
<li>?animal_type_id=1：指定筛选条件</li>
</ul>
<p>所有 <code>URL</code> 参数 <code>必须</code> 是全小写，<code>必须</code> 使用下划线类型的参数形式。</p>
<blockquote>
<p>分页参数 <code>必须</code> 固定为 <code>page</code>、<code>per_page</code></p>
</blockquote>
<p>经常使用的、复杂的查询 <code>应该</code> 标签化，降低维护成本。如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /trades?status=closed&amp;sort=sortby=name&amp;order=asc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可为其定制快捷方式</span></span><br><span class="line">GET /trades/recently_closed</span><br></pre></td></tr></table></figure>
<h2 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h2><p><code>应该</code> 使用 <code>OAuth2.0</code> 的方式为 API 调用者提供登录认证。<code>必须</code> 先通过登录接口获取 <code>Access Token</code> 后再通过该 <code>token</code> 调用需要身份认证的 <code>API</code>。</p>
<p>Oauth 的端点设计示列</p>
<ul>
<li>RFC 6749   /token</li>
<li>Twitter    /oauth2/token</li>
<li>Fackbook   /oauth/access_token</li>
<li>Google     /o/oauth2/token</li>
<li>Github     /login/oauth/access_token</li>
<li>Instagram  /oauth/authorize</li>
</ul>
<p>客户端在获得 <code>access token</code> 的同时 <code>必须</code> 在响应中包含一个名为 <code>expires_in</code> 的数据，它表示当前获得的 <code>token</code> 会在多少 <code>秒</code> 后失效。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"access_token"</span>: <span class="string">"token...."</span>,</span><br><span class="line">    <span class="attr">"token_type"</span>: <span class="string">"Bearer"</span>,</span><br><span class="line">    <span class="attr">"expires_in"</span>: <span class="number">3600</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端在请求需要认证的 <code>API</code> 时，<code>必须</code> 在请求头 <code>Authorization</code> 中带上 <code>access_token</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer token...</span><br></pre></td></tr></table></figure>
<p>当超过指定的秒数后，<code>access token</code> 就会过期，再次用过期/或无效的 <code>token</code> 访问时，服务端 <code>应该</code> 返回 <code>invalid_token</code> 的错误或 <code>401</code> 错误码。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">401</span> Unauthorized</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    "error": "invalid_token"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Laravel 开发中，<code>应该</code> 使用 <a href="https://github.com/tymondesigns/jwt-auth" target="_blank" rel="noopener">JWT</a> 来为管理你的 Token，并且 <code>一定不可</code> 在 <code>api</code> 中间件中开启请求 <code>session</code>。</p>
</blockquote>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p>所有的 <code>API</code> 响应，<code>必须</code> 遵守 <code>HTTP</code> 设计规范，<code>必须</code> 选择合适的 <code>HTTP</code> 状态码。<code>一定不可</code> 所有接口都返回状态码为 <code>200</code> 的 <code>HTTP</code> 响应，如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> ok</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Server</span>: example.com</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    "code": 0,</span><br><span class="line">    "msg": "success",</span><br><span class="line">    "data": &#123;</span><br><span class="line">        "username": "username"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> ok</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Server</span>: example.com</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    "code": -1,</span><br><span class="line">    "msg": "该活动不存在",</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下表列举了常见的 <code>HTTP</code> 状态码</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1xx</td>
<td>代表请求已被接受，需要继续处理</td>
</tr>
<tr>
<td>2xx</td>
<td>请求已成功，请求所希望的响应头或数据体将随此响应返回</td>
</tr>
<tr>
<td>3xx</td>
<td>重定向</td>
</tr>
<tr>
<td>4xx</td>
<td>客户端原因引起的错误</td>
</tr>
<tr>
<td>5xx</td>
<td>服务端原因引起的错误</td>
</tr>
</tbody>
</table>
<blockquote>
<p>只有来自客户端的请求被正确的处理后才能返回 <code>2xx</code> 的响应，所以当 API 返回 <code>2xx</code> 类型的状态码时，前端 <code>必须</code> 认定该请求已处理成功。</p>
</blockquote>
<p>必须强调的是，所有 <code>API</code> <code>一定不可</code> 返回 <code>1xx</code> 类型的状态码。当 <code>API</code> 发生错误时，<code>必须</code> 返回出错时的详细信息。目前常见返回错误信息的方法有两种：</p>
<p>1、将错误详细放入 <code>HTTP</code> 响应首部；</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">X-MYNAME-ERROR-CODE</span>: 4001</span><br><span class="line"><span class="attribute">X-MYNAME-ERROR-MESSAGE</span>: Bad authentication token</span><br><span class="line"><span class="attribute">X-MYNAME-ERROR-INFO</span>: http://docs.example.com/api/v1/authentication</span><br></pre></td></tr></table></figure>
<p>2、直接放入响应实体中；</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">401</span> Unauthorized</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, private</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 10:02:59 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;"error_code":40100,"message":"Unauthorized"&#125;</span><br></pre></td></tr></table></figure>
<p>考虑到易读性和客户端的易处理性，我们 <code>必须</code> 把错误信息直接放到响应实体中，并且错误格式 <code>应该</code> 满足如下格式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"您查找的资源不存在"</span>,</span><br><span class="line">    <span class="attr">"error_code"</span>: <span class="number">404001</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中错误码（<code>error_code</code>）<code>必须</code> 和 <code>HTTP</code> 状态码对应，也方便错误码归类，如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">429</span> Too Many Requests</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, private</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 10:15:52 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;"error_code":429001,"message":"你操作太频繁了"&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">403</span> Forbidden</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, private</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 10:19:27 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;"error_code":403002,"message":"用户已禁用"&#125;</span><br></pre></td></tr></table></figure>
<p><code>应该</code> 在返回的错误信息中，同时包含面向开发者和面向用户的提示信息，前者可方便开发人员调试，后者可直接展示给终端用户查看如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"直接展示给终端用户的错误信息"</span>,</span><br><span class="line">    <span class="attr">"error_code"</span>: <span class="string">"业务错误码"</span>,</span><br><span class="line">    <span class="attr">"error"</span>: <span class="string">"供开发者查看的错误信息"</span>,</span><br><span class="line">    <span class="attr">"debug"</span>: [</span><br><span class="line">        <span class="string">"错误堆栈，必须开启 debug 才存在"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面详细列举了各种情况 API 的返回说明。</p>
<h3 id="200-ok"><a href="#200-ok" class="headerlink" title="200 ok"></a>200 ok</h3><p><code>200</code> 状态码是最常见的 <code>HTTP</code> 状态码，在所有 <strong>成功</strong> 的 <code>GET</code> 请求中，<code>必须</code> 返回此状态码。<code>HTTP</code> 响应实体部分 <code>必须</code> 直接就是数据，不要做多余的包装。</p>
<p>错误示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> ok</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Server</span>: example.com</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    "user": &#123;</span><br><span class="line">        "id":1,</span><br><span class="line">        "nickname":"fwest",</span><br><span class="line">        "username": "example"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确示例：</p>
<p>1、获取单个资源详情</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"username"</span>: <span class="string">"godruoyi"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">88</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、获取资源集合</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"username"</span>: <span class="string">"godruoyi"</span>,</span><br><span class="line">        <span class="attr">"age"</span>: <span class="number">88</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"username"</span>: <span class="string">"foo"</span>,</span><br><span class="line">        <span class="attr">"age"</span>: <span class="number">88</span>,</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>3、额外的媒体信息</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"avatar"</span>: <span class="string">"https://lorempixel.com/640/480/?32556"</span>,</span><br><span class="line">            <span class="attr">"nickname"</span>: <span class="string">"fwest"</span>,</span><br><span class="line">            <span class="attr">"last_logined_time"</span>: <span class="string">"2018-05-29 04:56:43"</span>,</span><br><span class="line">            <span class="attr">"has_registed"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"id"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"avatar"</span>: <span class="string">"https://lorempixel.com/640/480/?86144"</span>,</span><br><span class="line">            <span class="attr">"nickname"</span>: <span class="string">"zschowalter"</span>,</span><br><span class="line">            <span class="attr">"last_logined_time"</span>: <span class="string">"2018-06-16 15:18:34"</span>,</span><br><span class="line">            <span class="attr">"has_registed"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"meta"</span>: &#123;</span><br><span class="line">        <span class="attr">"pagination"</span>: &#123;</span><br><span class="line">            <span class="attr">"total"</span>: <span class="number">101</span>,</span><br><span class="line">            <span class="attr">"count"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"per_page"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="attr">"current_page"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="attr">"total_pages"</span>: <span class="number">51</span>,</span><br><span class="line">            <span class="attr">"links"</span>: &#123;</span><br><span class="line">                <span class="attr">"next"</span>: <span class="string">"http://api.example.com?page=2"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中，分页和其他额外的媒体信息，必须放到 <code>meta</code> 字段中。</p>
</blockquote>
<h3 id="201-Created"><a href="#201-Created" class="headerlink" title="201 Created"></a>201 Created</h3><p>当服务器创建数据成功时，<code>应该</code> 返回此状态码。常见的应用场景是使用 <code>POST</code> 提交用户信息，如：</p>
<ul>
<li>添加了新用户</li>
<li>上传了图片</li>
<li>创建了新活动</li>
</ul>
<p>等，都可以返回 <code>201</code> 状态码。需要注意的是，你可以选择在用户创建成功后返回新用户的数据</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">201</span> Created</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 09:13:40 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    "id": 1,</span><br><span class="line">    "avatar": "https:\/\/lorempixel.com\/640\/480\/?32556",</span><br><span class="line">    "nickname": "fwest",</span><br><span class="line">    "last_logined_time": "2018-05-29 04:56:43",</span><br><span class="line">    "created_at": "2018-06-16 17:55:55",</span><br><span class="line">    "updated_at": "2018-06-16 17:55:55"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以返回一个响应实体为空的 <code>HTTP Response</code> 如：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">201</span> Created</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=UTF-8</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 09:12:20 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里我们 <code>应该</code> 采用第二种方式，因为大多数情况下，客户端只需要知道该请求操作成功与否，并不需要返回新资源的信息。</p>
</blockquote>
<h3 id="202-Accepted"><a href="#202-Accepted" class="headerlink" title="202 Accepted"></a>202 Accepted</h3><p>该状态码表示服务器已经接受到了来自客户端的请求，但还未开始处理。常用短信发送、邮件通知、模板消息推送等这类很耗时需要队列支持的场景中；</p>
<blockquote>
<p>返回该状态码时，响应实体 <code>必须</code> 为空。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 202 Accepted</span><br><span class="line">Server: nginx/1.11.9</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Date: Sun, 24 Jun 2018 09:25:15 GMT</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>
<h3 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h3><p>该状态码表示响应实体不包含任何数据，其中：</p>
<ul>
<li>在使用 <code>DELETE</code> 方法删除资源 <strong>成功</strong> 时，<code>必须</code> 返回该状态码</li>
<li>使用 <code>PUT</code>、<code>PATCH</code> 方法更新数据 <strong>成功</strong> 时，也 <code>应该</code> 返回此状态码</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">204</span> No Content</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 09:29:12 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br></pre></td></tr></table></figure>
<h3 id="3xx-重定向"><a href="#3xx-重定向" class="headerlink" title="3xx 重定向"></a>3xx 重定向</h3><p>所有 <code>API</code> <code>不该</code> 返回 <code>3xx</code> 类型的状态码。因为 <code>3xx</code> 类型的响应格式一般为下列格式：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Server: nginx/1.11.9</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Cache-Control: no-cache, private</span><br><span class="line">Date: Sun, 24 Jun 2018 09:41:50 GMT</span><br><span class="line">Location: https://example.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"0;url=https://example.com"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Redirecting to https://example.com<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        Redirecting to <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://example.com"</span>&gt;</span>https://example.com<span class="tag">&lt;/<span class="name">a</span>&gt;</span>.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>所有 <code>API</code> <code>一定不可</code> 返回纯 <code>HTML</code> 结构的响应；若一定要使用重定向功能，<code>可以</code> 返回一个响应实体为空的 <code>3xx</code> 响应，并在响应头中加上 <code>Location</code> 字段:</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">302</span> Found</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=UTF-8</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 09:52:50 GMT</span><br><span class="line"><span class="attribute">Location</span>: https://godruoyi.com</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br></pre></td></tr></table></figure>
<h3 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h3><p>由于明显的客户端错误（例如，请求语法格式错误、无效的请求、无效的签名等），服务器 <code>应该</code> 放弃该请求。</p>
<blockquote>
<p>当服务器无法从其他 4xx 类型的状态码中找出合适的来表示错误类型时，都 <code>必须</code> 返回该状态码。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">400</span> Bad Request</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, private</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 13:22:36 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;"error_code":40000,"message":"无效的签名"&#125;</span><br></pre></td></tr></table></figure>
<h3 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h3><p>该状态码表示当前请求需要身份认证，以下情况都 <code>必须</code> 返回该状态码。</p>
<ul>
<li>未认证用户访问需要认证的 API</li>
<li>access_token 无效/过期</li>
</ul>
<blockquote>
<p>客户端在收到 <code>401</code> 响应后，都 <code>应该</code> 提示用户进行下一步的登录操作。</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">401</span> Unauthorized</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">WWW-Authenticate</span>: JWTAuth</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, private</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 13:17:02 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;"message":"Token Signature could not be verified.","error_code": "40100"&#125;</span><br></pre></td></tr></table></figure>
<h3 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h3><p>该状态码可以简单的理解为没有权限访问该请求，服务器收到请求但拒绝提供服务。</p>
<p>如当普通用户请求操作管理员用户时，<code>必须</code> 返回该状态码。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">403</span> Forbidden</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, private</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 13:05:34 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;"error_code":40301,"message":"权限不足"&#125;</span><br></pre></td></tr></table></figure>
<h3 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h3><p>该状态码表示用户请求的资源不存在，如</p>
<ul>
<li>获取不存在的用户信息 （get /users/9999999）</li>
<li>访问不存在的端点</li>
</ul>
<p>都 <code>必须</code> 返回该状态码，若该资源已永久不存在，则 <code>应该</code> 返回 <code>410</code> 响应。</p>
<h3 id="405-Method-Not-Allowed"><a href="#405-Method-Not-Allowed" class="headerlink" title="405 Method Not Allowed"></a>405 Method Not Allowed</h3><p>当客户端使用的 <code>HTTP</code> 请求方法不被服务器允许时，<code>必须</code> 返回该状态码。</p>
<blockquote>
<p>如客户端调用了 <code>POST</code> 方法来访问只支持 GET 方法的 API</p>
</blockquote>
<p>该响应 <code>必须</code> 返回一个 <code>Allow</code> 头信息用以表示出当前资源能够接受的请求方法的列表。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">405</span> Method Not Allowed</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Allow</span>: GET, HEAD</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, private</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 12:30:57 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;"message":"405 Method Not Allowed","error_code": 40500&#125;</span><br></pre></td></tr></table></figure>
<h3 id="406-Not-Acceptable"><a href="#406-Not-Acceptable" class="headerlink" title="406 Not Acceptable"></a>406 Not Acceptable</h3><p><code>API</code> 在不支持客户端指定的数据格式时，应该返回此状态码。如支持 <code>JSON</code> 和 <code>XML</code> 输出的 <code>API</code> 被指定返回 <code>YAML</code> 格式的数据时。</p>
<blockquote>
<p>Http 协议一般通过请求首部的 Accept 来指定数据格式</p>
</blockquote>
<h3 id="408-Request-Timeout"><a href="#408-Request-Timeout" class="headerlink" title="408 Request Timeout"></a>408 Request Timeout</h3><p>客户端请求超时时 <code>必须</code> 返回该状态码，需要注意的时，该状态码表示 <strong>客户端请求超时</strong>，在涉及第三方 <code>API</code> 调用超时时，<code>一定不可</code> 返回该状态码。</p>
<h3 id="409-Confilct"><a href="#409-Confilct" class="headerlink" title="409 Confilct"></a>409 Confilct</h3><p>该状态码表示因为请求存在冲突无法处理。如通过手机号码提供注册功能的 <code>API</code>，当用户提交的手机号已存在时，<code>必须</code> 返回此状态码。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">409</span> Conflict</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, private</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 12:19:04 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;"error_code":40900,"message":"手机号已存在"&#125;</span><br></pre></td></tr></table></figure>
<h3 id="410-Gone"><a href="#410-Gone" class="headerlink" title="410 Gone"></a>410 Gone</h3><p>和 <code>404</code> 类似，该状态码也表示请求的资源不存在，只是 <code>410</code> 状态码进一步表示所请求的资源已不存在，并且未来也不会存在。在收到 <code>410</code> 状态码后，客户端 <code>应该</code> 停止再次请求该资源。</p>
<h3 id="413-Request-Entity-Too-Large"><a href="#413-Request-Entity-Too-Large" class="headerlink" title="413 Request Entity Too Large"></a>413 Request Entity Too Large</h3><p>该状态码表示服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。</p>
<blockquote>
<p>此种情况下，服务器可以关闭连接以免客户端继续发送此请求。</p>
</blockquote>
<p>如果这个状况是临时的，服务器 <code>应该</code> 返回一个 <code>Retry-After</code> 的响应头，以告知客户端可以在多少时间以后重新尝试。</p>
<h3 id="414-Request-URI-Too-Long"><a href="#414-Request-URI-Too-Long" class="headerlink" title="414 Request-URI Too Long"></a>414 Request-URI Too Long</h3><p>该状态码表示请求的 <code>URI</code> 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。</p>
<h3 id="415-Unsupported-Media-Type"><a href="#415-Unsupported-Media-Type" class="headerlink" title="415 Unsupported Media Type"></a>415 Unsupported Media Type</h3><p>通常表示服务器不支持客户端请求首部 <code>Content-Type</code> 指定的数据格式。如在只接受 <code>JSON</code> 格式的 <code>API</code> 中放入 <code>XML</code> 类型的数据并向服务器发送，都 <code>应该</code> 返回该状态码。</p>
<p>该状态码也可用于如：只允许上传图片格式的文件，但是客户端提交媒体文件非法或不是图片类型，这时 <code>应该</code> 返回该状态码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">415</span> Unsupported Media Type</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, private</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 12:09:40 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;"error_code":41500,"message":"不允许上传的图片格式"&#125;</span><br></pre></td></tr></table></figure>
<h3 id="429-Too-Many-Requests"><a href="#429-Too-Many-Requests" class="headerlink" title="429 Too Many Requests"></a>429 Too Many Requests</h3><p>该状态码表示用户请求次数超过允许范围。如 <code>API</code> 设定为 <code>60次/分钟</code>，当用户在一分钟内请求次数超过 60 次后，都 <code>应该</code> 返回该状态码。并且也 <code>应该</code> 在响应首部中加上下列头部：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X-RateLimit-Limit: 10 请求速率（由应用设定，其单位一般为小时/分钟等，这里是 10次/5分钟）</span><br><span class="line">X-RateLimit-Remaining: 0 当前剩余的请求数量</span><br><span class="line">X-RateLimit-Reset: 1529839462 重置时间</span><br><span class="line">Retry-After: 120 下一次访问应该等待的时间（秒）</span><br></pre></td></tr></table></figure>
<p>列子</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">429</span> Too Many Requests</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">X-RateLimit-Limit</span>: 10</span><br><span class="line"><span class="attribute">X-RateLimit-Remaining</span>: 0</span><br><span class="line"><span class="attribute">X-RateLimit-Reset</span>: 1529839462</span><br><span class="line"><span class="attribute">Retry-After</span>: 290</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, private</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 11:19:32 GMT</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;"message":"You have exceeded your rate limit.","error_code":42900&#125;</span><br></pre></td></tr></table></figure>
<p><code>必须</code> 为所有的 API 设置 Rate Limit 支持。</p>
<h3 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h3><p>该状态码 <code>必须</code> 在服务器出错时抛出，对于所有的 <code>500</code> 错误，都 <code>应该</code> 提供完整的错误信息支持，也方便跟踪调试。</p>
<h3 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h3><p>该状态码表示服务器暂时处理不可用状态，当服务器需要维护或第三方 <code>API</code> 请求超时/不可达时，都 <code>应该</code> 返回该状态码，其中若是主动关闭 API 服务，<code>应该</code>在返回的响应首部加上 <code>Retry-After</code> 头部，表示多少秒后可以再次访问。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">503</span> Service Unavailable</span><br><span class="line"><span class="attribute">Server</span>: nginx/1.11.9</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"><span class="attribute">Transfer-Encoding</span>: chunked</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, private</span><br><span class="line"><span class="attribute">Date</span>: Sun, 24 Jun 2018 10:56:20 GMT</span><br><span class="line"><span class="attribute">Retry-After</span>: 60</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"></span><br><span class="line">&#123;"error_code":50300,"message":"服务维护中"&#125;</span><br></pre></td></tr></table></figure>
<p>其他 <code>HTTP</code> 状态码请参考 <a href="https://zh.wikipedia.org/zh-hans/HTTP%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" rel="noopener">HTTP 状态码- 维基百科</a>。</p>
<h2 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h2><blockquote>
<p>版权声明：自由转载-非商用-非衍生-保持署名（<a href="https://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank" rel="noopener">创意共享3.0许可证</a>）</p>
</blockquote>
<h2 id="建议参考"><a href="#建议参考" class="headerlink" title="建议参考"></a>建议参考</h2><p><a href="https://github.com/aisuhua/restful-api-design-references" target="_blank" rel="noopener">restful-api-design-references</a></p>
<p><a href="http://www.cnblogs.com/moonz-wu/p/4211626.html" target="_blank" rel="noopener">Principles of good RESTful API Design（译）</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">理解 RESTful 架构</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">RESTful API 设计指南</a></p>
<p><a href="https://zh.wikipedia.org/zh-hans/HTTP%E7%8A%B6%E6%80%81%E7%A0%81" target="_blank" rel="noopener">HTTP 状态码- 维基百科</a></p>
<h2 id="LICENSE"><a href="#LICENSE" class="headerlink" title="LICENSE"></a>LICENSE</h2><p>MIT License</p>
<p>Copyright (c) 2018 godruoyi</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy<br>of this software and associated documentation files (the “Software”), to deal<br>in the Software without restriction, including without limitation the rights<br>to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<br>copies of the Software, and to permit persons to whom the Software is<br>furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all<br>copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br>IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br>FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE<br>AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<br>LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<br>OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE<br>SOFTWARE.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/09/一条SQL语句执行得很慢的原因有哪些？/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/一条SQL语句执行得很慢的原因有哪些？/" itemprop="url">一条SQL语句执行得很慢的原因有哪些？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-09T12:12:57+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/MySql/" itemprop="url" rel="index">
                    <span itemprop="name">MySql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一条SQL语句执行得很慢的原因有哪些？"><a href="#一条SQL语句执行得很慢的原因有哪些？" class="headerlink" title="一条SQL语句执行得很慢的原因有哪些？"></a>一条SQL语句执行得很慢的原因有哪些？</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s/1paGaxINJcd5Wic0CMyLTQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1paGaxINJcd5Wic0CMyLTQ</a></p>
</blockquote>
<h2 id="一、开始装逼：分类讨论"><a href="#一、开始装逼：分类讨论" class="headerlink" title="一、开始装逼：分类讨论"></a>一、开始装逼：分类讨论</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一条 SQL 语句执行的很慢，那是每次执行都很慢呢？还是大多数情况下是正常的，偶尔出现很慢呢？所以我觉得，我们还得分以下两种情况来讨论。</p>
<p>1、大多数情况是正常的，只是偶尔会出现很慢的情况。</p>
<p>2、在数据量不变的情况下，这条<code>SQL</code>语句一直以来都执行的很慢。</p>
<p>针对这两种情况，我们来分析下可能是哪些原因导致的。</p>
<h2 id="二、针对偶尔很慢的情况"><a href="#二、针对偶尔很慢的情况" class="headerlink" title="二、针对偶尔很慢的情况"></a>二、针对偶尔很慢的情况</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一条 <code>SQL</code> 大多数情况正常，偶尔才能出现很慢的情况，针对这种情况，我觉得这条<code>SQL</code>语句的书写本身是没什么问题的，而是其他原因导致的，那会是什么原因呢？</p>
<h3 id="1、数据库在刷新脏页我也无奈啊"><a href="#1、数据库在刷新脏页我也无奈啊" class="headerlink" title="1、数据库在刷新脏页我也无奈啊"></a>1、数据库在刷新脏页我也无奈啊</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们要往数据库插入一条数据、或者要更新一条数据的时候，我们知道数据库会在<strong>内存</strong>中把对应字段的数据更新了，但是更新之后，这些更新的字段并不会马上同步持久化到<strong>磁盘</strong>中去，而是把这些更新的记录写入到 <code>redo log</code>日记中去，等到空闲的时候，在通过<code>redo log 里的</code>日记把最新的数据同步到<strong>磁盘</strong>中去。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，<code>redo log</code> 里的容量是有限的，如果数据库一直很忙，更新又很频繁，这个时候 redo log 很快就会被写满了，这个时候就没办法等到空闲的时候再把数据同步到磁盘的，只能暂停其他操作，全身心来把数据同步到磁盘中去的，而这个时候，<strong>就会导致我们平时正常的SQL语句突然执行的很慢</strong>，所以说，数据库在在同步数据到磁盘的时候，就有可能导致我们的<code>SQL</code>语句执行的很慢了。</p>
<h3 id="2、拿不到锁我能怎么办"><a href="#2、拿不到锁我能怎么办" class="headerlink" title="2、拿不到锁我能怎么办"></a>2、拿不到锁我能怎么办</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个就比较容易想到了，我们要执行的这条语句，刚好这条语句涉及到的<strong>表</strong>，别人在用，并且加锁了，我们拿不到锁，只能慢慢等待别人释放锁了。或者，表没有加锁，但要使用到的某个一行被加锁了，这个时候，我也没办法啊。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要判断是否真的在等待锁，我们可以用 <strong>show processlist</strong>这个命令来查看当前的状态哦</p>
<h2 id="三、针对一直都这么慢的情况"><a href="#三、针对一直都这么慢的情况" class="headerlink" title="三、针对一直都这么慢的情况"></a>三、针对一直都这么慢的情况</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果在数据量一样大的情况下，这条<code>SQL</code> 语句每次都执行的这么慢，那就就要好好考虑下你的 <code>SQL</code>书写了，下面我们来分析下哪些原因会导致我们的 <code>SQL</code> 语句执行的很不理想。</p>
<p>我们先来假设我们有一个表，表里有下面两个字段,分别是主键 id，和两个普通字段 c 和 d。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE `t` (</span><br><span class="line">  `id` int(11) NOT NULL,</span><br><span class="line">  `c` int(11) DEFAULT NULL,</span><br><span class="line">  `d` int(11) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB;</span><br></pre></td></tr></table></figure>
<h3 id="1、扎心了，没用到索引"><a href="#1、扎心了，没用到索引" class="headerlink" title="1、扎心了，没用到索引"></a>1、扎心了，没用到索引</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没有用上索引，我觉得这个原因是很多人都能想到的，例如你要查询这条语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c &lt; 100000;</span><br></pre></td></tr></table></figure>
<h4 id="（1）字段没有索引"><a href="#（1）字段没有索引" class="headerlink" title="（1）字段没有索引"></a><strong>（1）字段没有索引</strong></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;刚好你的 c 字段上没有索引，那么抱歉，只能走全表扫描了，你就体验不会索引带来的乐趣了，所以，这回导致这条查询语句很慢。</p>
<h4 id="（2）字段有索引，但却没有用索引"><a href="#（2）字段有索引，但却没有用索引" class="headerlink" title="（2）字段有索引，但却没有用索引"></a><strong>（2）字段有索引，但却没有用索引</strong></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好吧，这个时候你给 c 这个字段加上了索引，然后又查询了一条语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c - 1 = 1000;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我想问大家一个问题，这样子在查询的时候会用索引查询吗？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答是不会，如果我们在字段的左边做了运算，那么很抱歉，在查询的时候，就不会用上索引了，所以呢，大家要注意这种<strong>字段上有索引，但由于自己的疏忽，导致系统没有使用索引</strong>的情况了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正确的查询应该如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c = 1000 + 1;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有人可能会说，右边有运算就能用上索引？难道数据库就不会自动帮我们优化一下，自动把 c - 1=1000 自动转换为 c = 1000+1。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不好意思，确实不会帮你，所以，你要注意了。</p>
<h4 id="（3）函数操作导致没有用上索引"><a href="#（3）函数操作导致没有用上索引" class="headerlink" title="（3）函数操作导致没有用上索引"></a><strong>（3）函数操作导致没有用上索引</strong></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们在查询的时候，对字段进行了函数操作，也是会导致没有用上索引的，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where pow(c,2) = 1000;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我只是做一个例子，假设函数 pow 是求 c 的 n 次方，实际上可能并没有 pow(c,2)这个函数。其实这个和上面在左边做运算也是很类似的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以呢，一条语句执行都很慢的时候，可能是该语句没有用上索引了，不过具体是啥原因导致没有用上索引的呢，你就要会分析了，我上面列举的三个原因，应该是出现的比较多的吧。</p>
<h3 id="2、呵呵，数据库自己选错索引了"><a href="#2、呵呵，数据库自己选错索引了" class="headerlink" title="2、呵呵，数据库自己选错索引了"></a>2、呵呵，数据库自己选错索引了</h3><p>我们在进行查询操作的时候，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c &lt; 100000;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道，主键索引和非主键索引是有区别的，主键索引存放的值是<strong>整行字段的数据</strong>，而非主键索引上存放的值不是整行字段的数据，而且存放<strong>主键字段的值</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是说，我们如果走 c 这个字段的索引的话，最后会查询到对应主键的值，然后，再根据主键的值走主键索引，查询到整行数据返回。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好吧扯了这么多，其实我就是想告诉你，就算你在 c 字段上有索引，系统也并不一定会走 c 这个字段上的索引，而是有可能会直接扫描扫描全表，找出所有符合 <code>c &lt; 100000</code> 的数据。</p>
<p><strong>为什么会这样呢？</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实是这样的，系统在执行这条语句的时候，会进行预测：究竟是走 c 索引扫描的行数少，还是直接扫描全表扫描的行数少呢？显然，扫描行数越少当然越好了，因为扫描行数越少，意味着I/O操作的次数越少。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果是扫描全表的话，那么扫描的次数就是这个表的总行数了，假设为 n；而如果走索引 c 的话，我们通过索引 c 找到主键之后，还得再通过主键索引来找我们整行的数据，也就是说，需要走两次索引。而且，我们也不知道符合 <code>c &lt; 10000</code> 这个条件的数据有多少行，万一这个表是全部数据都符合呢？这个时候意味着，走 c 索引不仅扫描的行数是 n，同时还得每行数据走两次索引。</p>
<p><strong>所以呢，系统是有可能走全表扫描而不走索引的。那系统是怎么判断呢？</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;判断来源于系统的预测，也就是说，如果要走 c 字段索引的话，系统会预测走 c 字段索引大概需要扫描多少行。如果预测到要扫描的行数很多，它可能就不走索引而直接扫描全表了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么问题来了，<strong>系统是怎么预测判断的呢？</strong>这里我给你讲下系统是怎么判断的吧，虽然这个时候我已经写到脖子有点酸了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统是通过<strong>索引的区分度</strong>来判断的，一个索引上不同的值越多，意味着出现相同数值的索引越少，意味着索引的区分度越高。我们也把区分度称之为<strong>基数</strong>，即区分度越高，基数越大。所以呢，基数越大，意味着符合 <code>c &lt; 10000</code>这个条件的行数越少。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以呢，一个索引的基数越大，意味着走索引查询越有优势。</p>
<p><strong>那么问题来了，怎么知道这个索引的基数呢？</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统当然是不会遍历全部来获得一个索引的基数的，代价太大了，索引系统是通过遍历部分数据，也就是通过<strong>采样</strong>的方式，来预测索引的基数的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>扯了这么多，重点的来了</strong>，居然是采样，那就有可能出现<strong>失误</strong>的情况，也就是说，c 这个索引的基数实际上是很大的，但是采样的时候，却很不幸，把这个索引的基数预测成很小。例如你采样的那一部分数据刚好基数很小，然后就误以为索引的基数很小。<strong>然后就呵呵，系统就不走 c 索引了，直接走全部扫描了</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以呢，说了这么多，得出结论：<strong>由于统计的失误，导致系统没有走索引，而是走了全表扫描</strong>，而这，也是导致我们 SQL 语句执行的很慢的原因。</p>
<blockquote>
<p>这里我声明一下，系统判断是否走索引，扫描行数的预测其实只是原因之一，这条查询语句是否需要使用使用临时表、是否需要排序等也是会影响系统的选择的。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过呢，我们有时候也可以通过强制走索引的方式来查询，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t force index(a) where c &lt; 100000;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们也可以通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show index from t;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;来查询索引的基数和实际是否符合，如果和实际很不符合的话，我们可以重新来统计索引的基数，可以用这条命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">analyze table t;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;来重新统计分析。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>既然会预测错索引的基数，这也意味着，当我们的查询语句有多个索引的时候，系统有可能也会选错索引哦</strong>，这也可能是 SQL 执行的很慢的一个原因。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a><strong>四、总结</strong></h2><p>一个 <code>SQL</code>执行的很慢，我们要分两种情况讨论：</p>
<p>1、大多数情况下很正常，偶尔很慢，则有如下原因</p>
<p>(1)、数据库在刷新脏页，例如 <code>redo log</code> 写满了需要同步到磁盘。</p>
<p>(2)、执行的时候，遇到锁，如表锁、行锁。</p>
<p>2、这条 <code>SQL</code>语句一直执行的很慢，则有如下原因。</p>
<p>(1)、没有用上索引：例如该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。</p>
<p>(2)、数据库选错了索引。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/09/RESTful API 设计总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/RESTful API 设计总结/" itemprop="url">RESTful API 设计总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-09T12:12:57+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/API设计/" itemprop="url" rel="index">
                    <span itemprop="name">API设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="RESTful-API-设计总结"><a href="#RESTful-API-设计总结" class="headerlink" title="RESTful API 设计总结"></a>RESTful API 设计总结</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://segmentfault.com/a/1190000011338151" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011338151</a></p>
</blockquote>
<p><br></p>
<h5 id="1、协议-amp-域名-amp-版本"><a href="#1、协议-amp-域名-amp-版本" class="headerlink" title="1、协议&amp;域名&amp;版本"></a>1、协议&amp;域名&amp;版本</h5><p><strong>协议：</strong>API与用户的通信协议，总是使用HTTPS协议。<br><strong>域名：</strong>可以部署专有域名或者是主域名下加入URL里面。</p>
<blockquote>
<p><a href="https://api.github.com/" target="_blank" rel="noopener">https://api.github.com</a><br><a href="https://github.com/api" target="_blank" rel="noopener">https://github.com/api</a></p>
</blockquote>
<p><strong>版本：</strong>应该将API的版本号放入URL。</p>
<blockquote>
<p><a href="https://github.com/v1" target="_blank" rel="noopener">https://github.com/v1</a></p>
</blockquote>
<h5 id="2、CURD的请求设计"><a href="#2、CURD的请求设计" class="headerlink" title="2、CURD的请求设计"></a>2、CURD的请求设计</h5><p><strong>REST</strong>的关键原则把<strong>API</strong>分解成一种逻辑上的资源。这些资源可以通过有具体含义的HTTP方法（GET, POST, PUT, PATCH, DELETE）来进行修改。</p>
<blockquote>
<p><strong>GET</strong> /users - 获取user列表<br><strong>GET</strong> /users/12 - 获取指定ID为12的user对象<br><strong>POST</strong> /users - 创建一个新的user<br><strong>PUT</strong> /users/12 - 更新id为12的user<br><strong>PATCH</strong> /users/12 - 对id为12的user进行部分更新<br><strong>DELETE</strong> /users/12 - 删除id为12的user</p>
</blockquote>
<p><strong>① 新增：</strong>新增对象一般用到的是POST方法。</p>
<blockquote>
<p><strong>POST</strong> /users - 创建一个新的user<br><strong>POST</strong> /users?count=4 - 批量创建user对象</p>
</blockquote>
<p><strong>② 删除：</strong>DELETE作为删除的方法</p>
<blockquote>
<p><strong>DELETE</strong> /users/12 - 删除id为12的user<br><strong>DELETE</strong> /users [134 , 232 , 223 , 442] - 批量删除id为134 , 232 , 223 , 442的user</p>
</blockquote>
<p><strong>③ 更新：</strong>PUT、PATCH都是作为更新的HTTP方法，PUT表示更新USER对象，PATCH是对对象部分更新</p>
<blockquote>
<p><strong>PUT</strong> /users/12 - 更新id为12的user<br><strong>PUT</strong> /users - 批量更新user<br><strong>PATCH</strong> /users/12 - 对id为12的user进行部分更新<br><strong>PATCH</strong> /users - 批量对user进行部分更新</p>
</blockquote>
<p><strong>④ 查询：</strong>GET一般作为查询的HTTP方法，如何优雅的满足复杂的接口，不是一件很值得探讨的事情。<br><code>查询单个对象</code></p>
<blockquote>
<p><strong>GET</strong> /users/12 - 获取指定ID为12的user对象</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查询多个对象</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>GET</strong> /users - 获取user列表</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">条件过滤与分页查询</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>GET</strong> /users?page=3&amp;page_count=30：指定第几页，以及每页的记录数。<br><strong>GET</strong> /users?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。<br><strong>GET</strong> /users?role_id=1：指定筛选条件</p>
</blockquote>
<p>查询多个对象时，一般返回对象的列表，当分页查询需要返回查询的总的数据，应当在响应头部里面加入X-Total-Count的参数，同时在头部加入X-Page和X-Page-Size参数。</p>
<blockquote>
<p>X-Total-Count：1023<br>X-Page：3<br>X-Page-Size：30</p>
</blockquote>
<p><code>复杂的查询条件</code>当我们使用高级搜索的时候，GET方法的参数长度是没法满足查询的需求，这时候我们可以用POST方法提交参数实体来实现需求。</p>
<blockquote>
<p><strong>POST</strong> /users/search?page=3&amp;page_count=30<br>{</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; name : admin ,</span><br><span class="line">&gt; phone : 124 ,</span><br><span class="line">&gt; sex : 1</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>}</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">过滤返回对象属性</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>GET</strong> /users/12?fields=id,name,phone - 设置返回对象的属性</p>
</blockquote>
<h5 id="3、返回结果设计"><a href="#3、返回结果设计" class="headerlink" title="3、返回结果设计"></a>3、返回结果设计</h5><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>
<blockquote>
<p><strong>GET</strong> /collection：返回资源对象的列表（数组）<br><strong>GET</strong> /collection/resource：返回单个资源对象<br><strong>POST</strong> /collection：返回新生成的资源对象<br><strong>POST</strong> /collection：（批量新增）返回新生成的资源对象数量<br><strong>PUT</strong> /collection/resource：返回完整的资源对象<br><strong>PUT</strong> /collection：（批量更新）返回完整的资源对象数量<br><strong>PATCH</strong> /collection/resource：返回完整的资源对象<br><strong>PATCH</strong> /collection：（批量更新）返回完整的资源对象数量<br><strong>DELETE</strong> /collection/resource：返回一个空文档<br><strong>DELETE</strong> /collection：（批量删除）返回完整的资源对象数量</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">状态码</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>200</strong> OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。<br><strong>201</strong> CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。<br><strong>202</strong> Accepted - [<em>]：表示一个请求已经进入后台排队（异步任务）<br><strong>204</strong> NO CONTENT - [DELETE]：用户删除数据成功。<br><strong>400</strong> INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。<br><strong>401</strong> Unauthorized - [</em>]：表示用户没有权限（令牌、用户名、密码错误）。<br><strong>403</strong> Forbidden - [<em>] 表示用户得到授权（与401错误相对），但是访问是被禁止的。<br><strong>404</strong> NOT FOUND - [</em>]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。<br><strong>406</strong> Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。&gt;<br><strong>410</strong> Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。<br><strong>422</strong> Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。<br><strong>500</strong> INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</p>
</blockquote>
<p><code>错误处理</code>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可</p>
<blockquote>
<p>{<br>error: “Invalid API key”<br>}</p>
</blockquote>
<h5 id="4、Hypermedia-API"><a href="#4、Hypermedia-API" class="headerlink" title="4、Hypermedia API"></a>4、Hypermedia API</h5><p><strong>RESTful API</strong>最好做到<strong>Hypermedia</strong>，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。<br>比如，当用户向api.github.com的根目录发出请求，会得到这样一个文档。</p>
<blockquote>
<p>{“link”: {<br>“rel”: “collection <a href="https://www.example.com/zoo" target="_blank" rel="noopener">https://www.example.com/zoo</a>s”,<br>“href”: “<a href="https://api.example.com/zoos&quot;" target="_blank" rel="noopener">https://api.example.com/zoos&quot;</a>,<br>“title”: “List of zoos”,<br>“type”: “application/vnd.yourformat+json”<br>}}</p>
</blockquote>
<p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。<br><strong>Hypermedia API</strong>的设计被称为<strong>HATEOAS</strong>。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。</p>
<blockquote>
<p>{<br>“current_user_url”: “<a href="https://api.github.com/user&quot;" target="_blank" rel="noopener">https://api.github.com/user&quot;</a>,<br>“authorizations_url”: “<a href="https://api.github.com/authorizations&quot;" target="_blank" rel="noopener">https://api.github.com/authorizations&quot;</a>,<br>// …<br>}</p>
</blockquote>
<p>从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。</p>
<blockquote>
<p>{<br>“message”: “Requires authentication”,<br>“documentation_url”: “<a href="https://developer.github.com/v3&quot;" target="_blank" rel="noopener">https://developer.github.com/v3&quot;</a><br>}</p>
</blockquote>
<p>上面代码表示，服务器给出了提示信息，以及文档的网址。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/09/API接口安全/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/API接口安全/" itemprop="url">API接口安全</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-09T12:12:57+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/API设计/" itemprop="url" rel="index">
                    <span itemprop="name">API设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="API接口安全"><a href="#API接口安全" class="headerlink" title="API接口安全"></a>API接口安全</h1><h2 id="安全隐患"><a href="#安全隐患" class="headerlink" title="安全隐患"></a>安全隐患</h2><ul>
<li>SQL 注入</li>
<li>XSS 与 CSRF</li>
<li>输入过滤</li>
<li>Cookie 安全</li>
<li>禁用 mysql_ 系函数</li>
<li>数据库存储用户密码时，应该是怎么做才安全</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 加密存储  盐和加密后的密码一起存储 即加密后的密码一起存储:盐</span><br><span class="line">2. password_hash</span><br><span class="line"></span><br><span class="line">使用的算法、cost 和盐值作为散列的一部分返回。所以验证散列值的所有信息都已经包含在内。 这使 password_verify(密码, 密码hash) 函数验证的时候，不需要额外储存盐值或者算法的信息。</span><br></pre></td></tr></table></figure>
<ul>
<li>验证码 Session 问题</li>
<li>安全的 Session ID （让即使拦截后，也无法模拟使用）</li>
<li>目录权限安全</li>
<li>包含本地与远程文件</li>
<li>文件上传 (文件类型、文件大小、移动文件前，判断文件是否为上传文件……)</li>
<li>PHP 脚本</li>
<li>eval 函数执行脚本</li>
<li>disable_functions 关闭高危函数</li>
<li>FPM 独立用户与组，给每个目录特定权限，一般为nginx或者www用户</li>
<li>了解 Hash 与 Encrypt 区别</li>
</ul>
<h2 id="API安全之防止数据篡改"><a href="#API安全之防止数据篡改" class="headerlink" title="API安全之防止数据篡改"></a>API安全之防止数据篡改</h2><p>(1) 外部API: https</p>
<p>(2) 内部API数据签名</p>
<ol>
<li>为每个子系统分配一个acess_token</li>
<li>acess_token通过消息头Authentication传递。</li>
<li>服务调用方将请求参数，当前时间戳以及access_token一起进行计算签名：sign=MD5(请求参数 + timestamp + access_token)，服务提供方接收到参数时，先进行签名验证，如果签名不正确，则说明数据被修改，返回400。</li>
</ol>
<p>但是，简单的MD5签名规则也可能被破解，攻击者只需要使用相同的规则即可轻松修改数据。<br>所以，建议在对参数进行签名时添加盐值。为了避免盐值保存在服务调用方被泄露，可以动态从服务提供方动态获取盐值，即：sign=MD5(请求参数 + timestamp + access_token + 动态盐值)。动态盐值可以存放到缓存中，每个一定时间更新。</p>
<h2 id="请求参数防篡改原理"><a href="#请求参数防篡改原理" class="headerlink" title="请求参数防篡改原理"></a>请求参数防篡改原理</h2><p>采用https协议可以将传输的明文进行加密，但是黑客仍然可以截获传输的数据包，进一步伪造请求进行重放攻击。如果黑客使用特殊手段让请求方设备使用了伪造的证书进行通信，那么https加密的内容也将会被解密。<br>在API接口中我们除了使用https协议进行通信外，还需要有自己的一套加解密机制，对请求参数进行保护，防止被篡改。<br>过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 客户端使用约定好的秘钥对传输参数进行加密，得到签名值signature，并且将签名值也放入请求参数中，发送请求给服务端。</span><br><span class="line"></span><br><span class="line">2. 服务端接收客户端的请求，然后使用约定好的秘钥对请求的参数（除了signature以外）再次进行签名，得到签名值autograph。</span><br><span class="line"></span><br><span class="line">3. 服务端对比signature和autograph的值，如果对比一致，认定为合法请求。如果对比不一致，说明参数被篡改，认定为非法请求。</span><br><span class="line"></span><br><span class="line">一般采用不可逆的加密算法, 密钥保存在客户端本地</span><br></pre></td></tr></table></figure>
<p>因为<strong>黑客不知道签名的秘钥，所以即使截取到请求数据，对请求参数进行篡改，但是却无法对参数进行签名，无法得到修改后参数的签名值signature.</strong><br>签名的秘钥我们可以使用很多方案，可以采用对称加密或者非对称加密。</p>
<h2 id="防止重放攻击"><a href="#防止重放攻击" class="headerlink" title="防止重放攻击"></a>防止重放攻击</h2><h3 id="基于timestamp的方案"><a href="#基于timestamp的方案" class="headerlink" title="基于timestamp的方案"></a>基于timestamp的方案</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次HTTP请求，都需要加上timestamp参数，然后把timestamp和其他参数一起进行数字签名。因为一次正常的HTTP请求，从发出到达服务器一般都不会超过60s，所以服务器收到HTTP请求之后，首先判断时间戳参数与当前时间相比较，是否超过了60s，如果超过了则认为是非法的请求。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般情况下，黑客从抓包重放请求耗时远远超过了60s，所以此时请求中的timestamp参数已经失效了。<br>如果黑客修改timestamp参数为当前的时间戳，则signature参数对应的数字签名就会失效，因为黑客不知道签名秘钥，没有办法生成新的数字签名。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这种策略也存在问题，即如果一个黑客『眼疾手快』<strong>在有效期以内将你的包进行了重放， 那就来攻击成功.</strong></p>
<h3 id="基于nonce的方案"><a href="#基于nonce的方案" class="headerlink" title="基于nonce的方案"></a>基于nonce的方案</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nonce的意思是仅一次有效的随机字符串，要求每次请求时，该参数要保证不同，所以该参数一般与时间戳有关，我们这里为了方便起见，直接使用时间戳的16进制，实际使用时可以加上客户端的ip地址，mac地址等信息做个哈希之后，作为nonce参数。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们将每次请求的nonce参数存储到一个“集合”中，可以json格式存储到数据库或缓存中。 <strong>服务调用方写入  nonce必须唯一</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次处理HTTP请求时，首先判断该请求的nonce参数是否在该“集合”中，如果存在则认为是非法请求。 <strong>服务提供方查询(不存在 验证通过)</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nonce参数在首次请求时，已经被存储到了服务器上的“集合”中，再次发送请求会被识别并拒绝。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nonce参数作为数字签名的一部分，是无法篡改的，因为黑客不清楚token，所以不能生成新的sign。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方式也有很大的问题，那就是<strong>存储nonce参数的“集合”会越来越大，验证nonce是否存在“集合”中的耗时会越来越长.</strong>我们不能让nonce“集合”无限大，所以需要定期清理该“集合”，但是一旦该“集合”被清理，我们就无法验证被清理了的nonce参数了。也就是说，假设该“集合”平均1天清理一次的话，我们抓取到的该url，虽然当时无法进行重放攻击，但是我们还是可以每隔一天进行一次重放攻击的。而且存储24小时内，所有请求的“nonce”参数，也是一笔不小的开销。</p>
<h3 id="基于timestamp和nonce的方案"><a href="#基于timestamp和nonce的方案" class="headerlink" title="基于timestamp和nonce的方案"></a>基于timestamp和nonce的方案</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>nonce的一次性可以解决timestamp参数60s的问题，timestamp可以解决nonce参数“集合”越来越大的问题.</strong><br>防止重放攻击一般和防止请求参数被串改一起做。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在timestamp方案的基础上，加上nonce参数，因为timstamp参数对于超过60s的请求，都认为非法请求，所以我们只需要存储60s的nonce参数的“集合”即可。</p>
<h3 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过在请求中嵌入一个序列号，<strong>每次请求依次加一</strong>，如果一个请求的序列号早已用过，则认为无效。但是这个要用逻辑额外一个<strong>全局序列号</strong>，并不是特别方便。</p>
<p>实现方案: <strong>Redis incr 计数器</strong></p>
<p>缺陷： 验证规则一旦被发现，容易被伪造请求，直接<strong>改为最大的数即可，依次递减</strong></p>
<h2 id="数据加密与数据验签"><a href="#数据加密与数据验签" class="headerlink" title="数据加密与数据验签"></a>数据加密与数据验签</h2><p><strong>数据加密是为了防止数据窃取篡改</strong></p>
<p><strong>数据验签是验证数据是否被篡改</strong></p>
<h2 id="签名验证实现"><a href="#签名验证实现" class="headerlink" title="签名验证实现"></a>签名验证实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APIAuth</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"pre"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request = ctx.getRequest();</span><br><span class="line"></span><br><span class="line">        String token = request.getHeader(<span class="string">"token"</span>);</span><br><span class="line">        String timestamp = request.getHeader(<span class="string">"timestamp"</span>);</span><br><span class="line">        String nonce = request.getHeader(<span class="string">"nonce"</span>);</span><br><span class="line">        String sign = request.getHeader(<span class="string">"sign"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//时间限制配置</span></span><br><span class="line">        <span class="keyword">int</span> timeLimit = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">        ctx.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//请求头参数非空验证</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(token) || StringUtils.isEmpty(timestamp) || StringUtils.isEmpty(nonce) || StringUtils.isEmpty(sign)) &#123;</span><br><span class="line">            ctx.setResponseBody(JSON.toJSONString(<span class="keyword">new</span> Result(<span class="string">"-1"</span>, <span class="string">"请求头参数不正确"</span>)));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//请求时间和现在时间对比验证，发起请求时间和服务器时间不能超过timeLimit秒</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.timeDiffSeconds(<span class="keyword">new</span> Date(), timestamp) &gt; timeLimit) &#123;</span><br><span class="line">            ctx.setResponseBody(JSON.toJSONString(<span class="keyword">new</span> Result(<span class="string">"-1"</span>, <span class="string">"请求发起时间超过服务器限制"</span>)));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//验证用户信息</span></span><br><span class="line">        UserInfo userInfo = UserInfoUtil.getInfoByToken(token);</span><br><span class="line">        <span class="keyword">if</span> (userInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ctx.setResponseBody(JSON.toJSONString(<span class="keyword">new</span> Result(<span class="string">"-1"</span>, <span class="string">"错误的token信息"</span>)));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//验证相同noce的请求是否已经存在，存在表示为重复请求</span></span><br><span class="line">        <span class="keyword">if</span> (NoceUtil.exsit(userInfo, nonce)) &#123;</span><br><span class="line">            ctx.setResponseBody(JSON.toJSONString(<span class="keyword">new</span> Result(<span class="string">"-1"</span>, <span class="string">"重复的请求"</span>)));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果noce没有在缓存中，则需要加入，并设置过期时间为timeLimit秒</span></span><br><span class="line">            NoceUtil.addNoce(userInfo, nonce, timeLimit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//服务器生成签名与header中签名对比</span></span><br><span class="line">        String serverSign = SignUtil.getSign(userinfo, token, timestamp, nonce, request);</span><br><span class="line">        <span class="keyword">if</span> (!serverSign.equals(sign)) &#123;</span><br><span class="line">            ctx.setResponseBody(JSON.toJSONString(<span class="keyword">new</span> Result(<span class="string">"-1"</span>, <span class="string">"错误的签名信息"</span>)));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx.setSendZuulResponse(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/09/常见的违背Rest原则的接口设计做法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/常见的违背Rest原则的接口设计做法/" itemprop="url">常见的违背Rest原则的接口设计做法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-09T12:12:57+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/API设计/" itemprop="url" rel="index">
                    <span itemprop="name">API设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常见的违背Rest原则的接口设计做法"><a href="#常见的违背Rest原则的接口设计做法" class="headerlink" title="常见的违背Rest原则的接口设计做法"></a>常见的违背Rest原则的接口设计做法</h1><p>REST这词我们常常挂在嘴边，比如“开发一个rest接口”，又比如Spring项目的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Welcome to Yanxuan DMS!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>CommonController使用了@RestController注解，顾名思义，告诉读者这是一个Rest接口的实现。然而以@RestController注解的接口却不一定符合Rest原则。结合最近的项目，总结下常见的违背Rest设计的一些做法。</p>
<h3 id="一、一律使用POST或者GET方法"><a href="#一、一律使用POST或者GET方法" class="headerlink" title="一、一律使用POST或者GET方法"></a>一、一律使用POST或者GET方法</h3><p>典型的错误做法：无论什么请求，一律用POST，或者‘增删改’用POST，‘查’用GET。</p>
<p>其实REST有个原则叫统一接口（uniform interface），统一接口原则建议了各http方法的使用场合，</p>
<ol>
<li>GET：获取资源，返回消息头和消息表示，即header和body。</li>
<li>HEAD：获取资源元数据，返回消息头</li>
<li>DELETE：删除资源</li>
<li>POST：REST设计中，POST通常用来为一个已有资源创建一个从属资源（subordinate resource），如AWS S3的POST Object(或者称web post)接口。</li>
<li>PUT：创建或修改一个资源</li>
</ol>
<p>PUT和POST的区别比较微妙，这里拿AWS S3（或者参考网易对象存储NOS）的接口设计来举例。其中AWS S3的详细API文档参见：<a href="http://docs.aws.amazon.com/AmazonS3/latest/API/Welcome.html%E3%80%82" target="_blank" rel="noopener">http://docs.aws.amazon.com/AmazonS3/latest/API/Welcome.html。</a> S3有两种资源，桶（bucket）和对象（object），对象从属于某个桶。</p>
<p>创建一个桶的接口为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT /BucketName  HTTP/1.1</span><br><span class="line">Host: s3.amazonaws.com</span><br></pre></td></tr></table></figure>
<p>创建/修改一个对象的PUT Object接口为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT /BucketName/ObjectName  HTTP/1.1</span><br><span class="line">Host: s3.amazonaws.com[对象数据]</span><br></pre></td></tr></table></figure>
<p>AWS S3同时提供了POST Object接口，同样可以创建/修改一个对象，如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /BucketName HTTP/1.1Host: s3.amazonaws.comContent-Type: multipart/form-data; boundary=9431149156168[包含对象数据的body]</span><br></pre></td></tr></table></figure>
<p>获取对象的GET Object接口为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /BucketName/ObjectName  HTTP/1.1</span><br><span class="line">Host: s3.amazonaws.com</span><br></pre></td></tr></table></figure>
<p>同样的创建/修改一个对象，一个用PUT方法，另一个用POST方法，为什么？关键在于URL，PUT请求的目标URL（这里为/BucketName/ObjectName），就是将来用于获取该对象的URL，即PUT Object和GET Object的URL是一致的。但是POST Object的URL与GET ObjectURL不一样，POST 请求只知道父资源的URL（即/BucketName），表示在该父资源下创建新资源，至于新资源的确切URL，是由服务器决定的，一般来说是POST请求的响应应该包含一个Location消息头，其包含新建从属资源的URL。</p>
<p><strong>安全性safe和幂等性idempotent</strong></p>
<p>REST设计还应该遵循安全性和幂等性约束，如下：</p>
<ol>
<li>GET和HEAD应当是安全的：GET和HEAD请求不应该导致服务器状态发生改变</li>
<li>GET、HEAD、PUT和DELETE应当是幂等的：向一个URL发送多次PUT和DELETE请求，跟只做过一次请求一样。比如PUT不能是append语义，否则不幂等。GET和HEAD也是幂等。</li>
</ol>
<p><strong>统一接口原则的好处：</strong></p>
<ol>
<li>给一个资源URI，不用看文档就知道可以有GET、DELETE等操作及其意义，世界通用。</li>
<li>安全性和幂等性增加了http的可靠性：如果请求没成功（但也许已成功了），只需重新发一次即可，不用担心副作用。</li>
</ol>
<h3 id="二、HTTP-Code一律返回200"><a href="#二、HTTP-Code一律返回200" class="headerlink" title="二、HTTP Code一律返回200"></a>二、HTTP Code一律返回200</h3><p>典型的错误做法：无论成功失败，HTTP Code一律返回200，具体错误信息交由json body里的内容来判断，举例如下，</p>
<p>某甲服务xxx接口的响应如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK&#123;    &quot;status&quot;:1,  //1: 成功  0: 参数异常 -1: 失败</span><br><span class="line">    &quot;message&quot;:&quot;&quot; //返回的消息</span><br><span class="line">    成功时返回的数据</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>某乙服务xxx接口的响应如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK&#123;    &quot;code&quot;:200,  //1: 成功  0: 参数异常 -1: 失败</span><br><span class="line">    &quot;msg&quot;:&quot;&quot; //code非200时返回的错误信息</span><br><span class="line">    &quot;data&quot;:&#123;成功时返回的数据内容&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实RESTful的设计的一个标志特征是充分并正确利用HTTP响应码，典型的如：</p>
<ul>
<li>200 – OK，成功</li>
<li>301 – Moved Permanently，重定向</li>
<li>400 – Bad Request，错误的请求，比如缺少参数或者参数值不对</li>
<li>403 – Forbidden，无权限访问</li>
<li>404 – Not Found，url不存在</li>
<li>500 – Internal Server Error，系统错误，如数据库访问失败或者bug导致的错误</li>
</ul>
<p>设计REST接口应该遵循上面的响应码，语义明确并通用。如果像上面例子那样，任何情况都一律返回200，而具体成功与否需要到http响应消息体里去解析，而且不同的服务或开发者自定义消息体的格式，那么服务调用方就需要针对不同的服务写不同的判断逻辑，增加系统交互复杂性。</p>
<p>有些通用的客户端，会针对301自动处理重定向，针对500以上的响应自动重试，而一律返回200的设计是没法使用这些特性的，只能调用方一一自个处理。</p>
<h3 id="三、-面向操作而不是面向资源的url设计"><a href="#三、-面向操作而不是面向资源的url设计" class="headerlink" title="三、 面向操作而不是面向资源的url设计"></a>三、 面向操作而不是面向资源的url设计</h3><p>典型的错误做法：设计的URI是面向操作而不是面向资源的，举例如下，</p>
<p>某系统 设计的渠道相关的URI是这样的：</p>
<ol>
<li><p>新增渠道</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /xhr/thirdparty/admin/channel/add.json?&#123;渠道信息参数&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑渠道</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /xhr/thirdparty/admin/channel/update.json?&#123;渠道信息参数&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>删除渠道</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST /xhr/thirdparty/admin/channel/delete.json?channelId=id</span><br></pre></td></tr></table></figure>
<p>这里的接口设计有三个特点：</p>
<ol>
<li>http方法都是POST；</li>
<li>URI里携带操作信息，如URI里出现“add”，“update”，“delete”等字眼；</li>
<li>同一个资源由于操作不一样而URI不一样。</li>
</ol>
<p>其实REST式的设计中，URI即是资源的名称，也是资源的地址，因为不同的操作而资源地址不一样是不合适的。资源的操作（方法信息）应该由统一接口来表示，即http 方法PUT、POST、GET、DELETE等，而不应该放到URI中。</p>
<p>对照统一接口和面向资源这两个特征来设计，上面的接口RESTful化可以是这样的：</p>
<ol>
<li>新增渠道</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /xhr/thirdparty/admin/channel</span><br><span class="line"></span><br><span class="line">[渠道具体信息]</span><br></pre></td></tr></table></figure>
<ol>
<li>修改渠道</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUT /xhr/thirdparty/admin/channel?channelId=id 或者PUT /xhr/thirdparty/admin/channel/$&#123;id&#125;</span><br><span class="line"></span><br><span class="line">[渠道具体信息]</span><br></pre></td></tr></table></figure>
<ol>
<li>删除渠道</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /xhr/thirdparty/admin/channel?channelId=id或者DELETE /xhr/thirdparty/admin/channel/$&#123;id&#125;</span><br></pre></td></tr></table></figure>
<p>渠道的地址为/xhr/thirdparty/admin/channel?channelId=id或者/xhr/thirdparty/admin/channel/${id}，重在url唯一。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/81/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/81/">81</a><span class="page-number current">82</span><a class="page-number" href="/page/83/">83</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/83/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
