<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/page/85/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/page/85/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/06/Raft协议详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/06/Raft协议详解/" itemprop="url">Raft协议详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-06T12:12:57+08:00">
                2019-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/一致性协议/" itemprop="url" rel="index">
                    <span itemprop="name">一致性协议</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/一致性协议/Raft/" itemprop="url" rel="index">
                    <span itemprop="name">Raft</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Raft协议详解"><a href="#Raft协议详解" class="headerlink" title="Raft协议详解"></a>Raft协议详解</h1><blockquote>
<p>原文地址：<a href="https://zhuanlan.zhihu.com/p/27207160" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27207160</a></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分布式存储系统通常通过维护多个副本来进行容错，提高系统的可用性。要实现此目标，就必须要<strong>解决分布式存储系统的最核心问题：维护多个副本的一致性</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要解释一下什么是一致性（consensus）,它是构建具有容错性（fault-tolerant）的分布式系统的基础。 <strong>在一个具有一致性的性质的集群里面，同一时刻所有的结点对存储在其中的某个值都有相同的结果，即对其共享的存储保持一致</strong>。<strong>集群具有自动恢复的性质，当少数结点失效的时候不影响集群的正常工作，当大多数集群中的结点失效的时候，集群则会停止服务（不会返回一个错误的结果）</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一致性协议就是用来干这事的，<strong>用来保证即使在部分(确切地说是小部分)副本宕机的情况下，系统仍然能正常对外提供服务</strong>。<strong>一致性协议通常基于replicated state machines，即所有结点都从同一个state出发，都经过同样的一些操作序列（log），最后到达同样的state</strong>。</p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="三个组件"><a href="#三个组件" class="headerlink" title="三个组件"></a>三个组件</h3><p><img src="//blog.com/2019/05/06/Raft协议详解/v2-e747e997d58aee9252b187c8434a1cc1_hd.jpg" alt="img"></p>
<p>系统中每个结点有三个组件：</p>
<blockquote>
<p>状态机: 当我们说一致性的时候，实际就是在说要保证这个状态机的一致性。状态机会从log里面取出所有的命令，然后执行一遍，得到的结果就是我们对外提供的保证了一致性的数据<br>Log: 保存了所有修改记录<br>一致性模块: 一致性模块算法就是用来保证写入的log的命令的一致性，这也是raft算法核心内容</p>
</blockquote>
<h3 id="协议内容"><a href="#协议内容" class="headerlink" title="协议内容"></a>协议内容</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Raft</code>协议将一致性协议的核心内容分拆成为几个关键阶段，以简化流程，提高协议的可理解性。</p>
<h4 id="Leader-election"><a href="#Leader-election" class="headerlink" title="Leader election"></a><strong>Leader election</strong></h4><h5 id="Node的三种角色"><a href="#Node的三种角色" class="headerlink" title="Node的三种角色"></a>Node的三种角色</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Raft</code>协议的每个副本都会处于三种状态之一：<code>Leader</code>、<code>Follower</code>、<code>Candidate</code>。</p>
<h6 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有请求的处理者，<code>Leader</code>副本接受<code>client</code>的更新请求，本地处理后再同步至多个其他副本；</p>
<h6 id="Follower"><a href="#Follower" class="headerlink" title="Follower"></a>Follower</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请求的被动更新者，从<code>Leader</code>接受更新请求，然后写入本地日志文件；</p>
<h6 id="Candidate"><a href="#Candidate" class="headerlink" title="Candidate"></a>Candidate</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果<code>Follower</code>副本在一段时间内没有收到<code>Leader</code>副本的心跳，则判断<code>Leader</code>可能已经故障，此时启动选主过程，此时副本会变成<code>Candidate</code>状态，直到选主结束。</p>
<h5 id="选主结果"><a href="#选主结果" class="headerlink" title="选主结果"></a>选主结果</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时间被分为很多连续的随机长度的<code>term</code>，<code>term</code>有唯一的<code>id</code>。每个<code>term</code>一开始就进行选主：</p>
<ol>
<li><code>Follower</code>将自己维护的<code>current_term_id</code>加1。</li>
<li>然后将自己的状态转成<code>Candidate</code></li>
<li>发送<code>RequestVoteRPC</code>消息(带上<code>current_term_id</code>) 给 其它所有<code>server</code></li>
</ol>
<p>这个过程会有三种结果：</p>
<ul>
<li>自己被选成了主。当收到了<code>majority</code>的投票后，状态切成<code>Leader</code>，并且定期给其它的所有<code>server</code>发心跳消息（不带<code>log</code>的<code>AppendEntriesRPC</code>）以告诉对方自己是<code>current_term_id</code>所标识的<code>term</code>的<code>leader</code>。每个<code>term</code>最多只有一个<code>leader</code>，<code>term id</code>作为<code>logical clock</code>，在每个<code>RPC</code>消息中都会带上，用于检测过期的消息。当一个<code>server</code>收到的<code>RPC</code>消息中的<code>rpc_term_id</code>比本地的<code>current_term_id</code>更大时，就更新<code>current_term_id</code>为<code>rpc_term_id</code>，并且如果当前<code>state</code>为<code>leader</code>或者<code>candidate</code>时，将自己的状态切成<code>follower</code>。如果<code>rpc_term_id</code>比本地的<code>current_term_id</code>更小，则拒绝这个<code>RPC</code>消息。</li>
<li>别人成为了主。如1所述，当<code>Candidator</code>在等待投票的过程中，收到了大于或者等于本地的<code>current_term_id</code>的声明对方是<code>leader</code>的<code>AppendEntriesRPC</code>时，则将自己的<code>state</code>切成<code>follower</code>，并且更新本地的<code>current_term_id</code>。</li>
<li>没有选出主。当投票被瓜分，没有任何一个<code>candidate</code>收到了<code>majority</code>的<code>vote</code>时，没有<code>leader</code>被选出。这种情况下，每个<code>candidate</code>等待的投票的过程就超时了，接着<code>candidates</code>都会将本地的<code>current_term_id</code>再加1，发起<code>RequestVoteRPC</code>进行新一轮的<code>leader election</code>。</li>
</ul>
<h5 id="投票策略"><a href="#投票策略" class="headerlink" title="投票策略"></a>投票策略</h5><ul>
<li>每个节点只会给每个<code>term</code>投一票，具体的是否同意和后续的<code>Safety</code>有关。</li>
<li>当投票被瓜分后，所有的<code>candidate</code>同时超时，然后有可能进入新一轮的票数被瓜分，为了避免这个问题，<code>Raft</code>采用一种很简单的方法：每个<code>Candidate</code>的<code>election timeout</code>从<code>150ms-300ms</code>之间随机取，那么第一个超时的<code>Candidate</code>就可以发起新一轮的<code>leader election</code>，带着最大的<code>term_id</code>给其它所有<code>server</code>发送<code>RequestVoteRPC</code>消息，从而自己成为<code>leader</code>，然后给他们发送心跳消息以告诉他们自己是主。</li>
</ul>
<h4 id="Log-Replication"><a href="#Log-Replication" class="headerlink" title="Log Replication"></a>Log Replication</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当<code>Leader</code>被选出来后，就可以接受客户端发来的请求了，每个请求包含一条需要被<code>replicated state machines</code>执行的命令。<code>leader</code>会把它作为一个<code>log entry</code> <code>append到日志中</code>，然后给其它的<code>server</code>发<code>AppendEntriesRPC</code>请求。当<code>Leader</code>确定一个<code>log entry</code>被<code>safely replicated</code>了（<strong>大多数副本已经将该命令写入日志当中</strong>），就<strong><code>apply</code>这条<code>log entry</code>到状态机中然后返回结果给客户端</strong>。如果某个<code>Follower</code>宕机了或者运行的很慢，或者网络丢包了，则会一直给这个<code>Follower</code>发<code>AppendEntriesRPC</code>直到日志一致。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>当一条日志是<code>commited</code>时，<code>Leader</code>才可以将它应用到状态机中。<code>Raft</code>保证一条<code>commited</code>的<code>log entry</code>已经持久化了并且会被所有的节点执行</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一个新的<code>Leader</code>被选出来时，它的日志和其它的<code>Follower</code>的日志可能不一样，这个时候，就需要一个机制来保证日志的一致性。一个新<code>leader</code>产生时，集群状态可能如下：</p>
<p><img src="//blog.com/2019/05/06/Raft协议详解/v2-8884bbb61f0eed0aba4e8320c2692783_hd.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最上面这个是<code>新Leader</code>，a~f是<code>Follower</code>，每个格子代表一条<code>log entry</code>，格子内的数字代表这个<code>log entry</code>是在哪个<code>term</code>上产生的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新<code>Leader</code>产生后，就以<code>Leader</code>上的<code>log</code>为准。其它的<code>follower</code>要么少了数据比如b，要么多了数据，比如d，要么既少了又多了数据，比如f。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，需要有一种机制来让<code>leader</code>和<code>follower</code>对<code>log</code>达成一致，<strong><code>leader</code>会为每个<code>follower</code>维护一个<code>nextIndex</code>，表示<code>leader</code>给各个<code>follower</code>发送的下一条<code>log entry</code>在<code>log</code>中的<code>index</code>，初始化为<code>leade</code>的最后一条<code>log entry</code>的下一个位置</strong>。<code>leader</code>给<code>follower</code>发送<code>AppendEntriesRPC</code>消息，带着<code>(term_id, (nextIndex-1))</code>，<code>term_id</code>即<code>(nextIndex-1)</code>这个槽位的<code>log entry</code>的<code>term_id</code>，<strong><code>follower</code>接收到<code>AppendEntriesRPC</code>后，会从自己的<code>log</code>中找是不是存在这样的<code>log entry</code>，如果不存在，就给<code>leader</code>回复拒绝消息，然后<code>leader</code>则将<code>nextIndex</code>减1，再重复，直到<code>AppendEntriesRPC</code>消息被接收</strong>。</p>
<p>以<code>leader</code>和<code>b</code>为例：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始化，<code>nextIndex</code>为11，<code>leader</code>给b发送<code>AppendEntriesRPC(6,10)</code>，b在自己<code>log</code>的10号槽位中没有找到<code>term_id</code>为6的<code>log entry</code>。则给<code>leader</code>回应一个拒绝消息。接着，<code>leader</code>将<code>nextIndex</code>减一，变成10，然后给b发送<code>AppendEntriesRPC(6, 9)</code>，b在自己<code>log</code>的9号槽位中同样没有找到<code>term_id</code>为6的<code>log entry</code>。<strong>循环下去，直到<code>leader</code>发送了<code>AppendEntriesRPC(4,4)</code>，b在自己<code>log</code>的槽位4中找到了<code>term_id</code>为4的<code>log entry</code></strong>。接收了消息。<strong>随后，<code>leader</code>就可以从槽位5开始给b推送日志了</strong>。</p>
<h4 id="Safety"><a href="#Safety" class="headerlink" title="Safety"></a><strong>Safety</strong></h4><h5 id="哪些follower有资格成为leader"><a href="#哪些follower有资格成为leader" class="headerlink" title="哪些follower有资格成为leader?"></a>哪些follower有资格成为leader?</h5><blockquote>
<p>Raft保证被选为新leader的节点拥有所有已提交的log entry，这与ViewStamped Replication不同，后者不需要这个保证，而是通过其他机制从follower拉取自己没有的提交的日志记录</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个保证是在<code>RequestVoteRPC</code>阶段做的，<code>candidate</code>在发送<code>RequestVoteRPC</code>时，会带上自己的最后一条日志记录的<code>term_id</code>和<code>index</code>，其他节点收到消息时，如果发现自己的日志比<code>RPC</code>请求中携带的更新，拒绝投票。<strong>日志比较的原则是，如果比本地的最后一条<code>log entry</code>的<code>term id</code>更大，则更新，如果<code>term id</code>一样大，则日志更多的更大(<code>index</code>更大)</strong>。</p>
<h5 id="哪些日志记录被认为是commited"><a href="#哪些日志记录被认为是commited" class="headerlink" title="哪些日志记录被认为是commited?"></a>哪些日志记录被认为是commited?</h5><ol>
<li><p><code>leader</code>正在<code>replicate</code>当前<code>term</code>（即term 2）的日志记录给其它<code>Follower</code>，一旦<code>leader</code>确认了这条<code>log entry</code>被<code>majority</code>写盘了，这条<code>log entry</code>就被认为是<code>committed</code>。如图a，S1作为当前term即term2的leader，log index为2的日志被majority写盘了，这条log entry被认为是commited</p>
</li>
<li><p><code>leader</code>正在<code>replicate</code>更早的<code>term</code>的<code>log entry</code>给其它<code>follower</code>。图b的状态是这么出来的。</p>
</li>
</ol>
<h4 id="对协议的一点修正"><a href="#对协议的一点修正" class="headerlink" title="对协议的一点修正"></a><strong>对协议的一点修正</strong></h4><p>在实际的协议中，需要进行一些微调，这是因为可能会出现下面这种情况：</p>
<p><img src="//blog.com/2019/05/06/Raft协议详解/v2-77762ec1707940412736c332376dd0c6_hd.jpg" alt="img"></p>
<ol>
<li><p>在阶段a，<code>term</code>为2，S1是<code>Leader</code>，且S1写入日志<code>（term, index）</code>为(2, 2)，并且日志被同步写入了S2；</p>
</li>
<li><p>在阶段b，S1离线，触发一次新的选主，此时S5被选为新的<code>Leader</code>，此时系统<code>term</code>为3，且写入了日志<code>（term, index）</code>为（3， 2）;</p>
</li>
<li><p>S5尚未将日志推送到<code>Followers</code>变离线了，进而触发了一次新的选主，而之前离线的S1经过重新上线后被选中变成<code>Leader</code>，此时系统<code>term</code>为4，此时S1会将自己的日志同步到<code>Followers</code>，按照上图就是将日志（2， 2）同步到了S3，而此时由于该日志已经被同步到了多数节点<code>（S1, S2, S3）</code>，因此，此时日志（2，2）可以被<code>commit</code>了（即更新到状态机）；</p>
</li>
<li><p>在阶段d，S1又很不幸地下线了，系统触发一次选主，而S5有可能被选为新的<code>Leader</code>（这是因为S5可以满足作为主的一切条件：</p>
<ol>
<li><p>term = 3 &gt; 2</p>
</li>
<li><p>最新的日志index为2，比大多数节点（如S2/S3/S4的日志都新）</p>
</li>
</ol>
</li>
</ol>
<pre><code>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;然后S5会将自己的日志更新到`Followers`，于是S2、S3中已经被提交的日志（2，2）被截断了，这是致命性的错误，因为**一致性协议中不允许出现已经应用到状态机中的日志被截断**。
</code></pre><p>为了避免这种致命错误，需要对协议进行一个微调：</p>
<blockquote>
<p>只允许主节点提交包含当前term的日志</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对上述情况就是：即使日志（2，2）已经被大多数节点（S1、S2、S3）确认了，但是它不能被<code>Commit</code>，因为它是来自之前<code>term(2)</code>的日志，直到S1在当前<code>term</code>（4）产生的日志（4， 3）被大多数<code>Follower</code>确认，S1方可<code>Commit（4，3）</code>这条日志，当然，根据Raft定义，（4，3）之前的所有日志也会被<code>Commit</code>。此时即使S1再下线，重新选主时S5不可能成为<code>Leader</code>，因为它没有包含大多数节点已经拥有的日志（4，3）。</p>
<h5 id="Log-Compaction"><a href="#Log-Compaction" class="headerlink" title="Log Compaction"></a><strong>Log Compaction</strong></h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实际的系统中，<strong>不能让日志无限增长，否则系统重启时需要花很长的时间进行回放，从而影响<code>availability</code></strong>。<strong><code>Raft</code>采用对整个系统进行<code>snapshot</code>来处理，<code>snapshot</code>之前的日志都可以丢弃</strong>。<code>Snapshot</code>技术在<code>Chubby</code>和<code>ZooKeeper</code>系统中都有采用。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Raft</code>使用的方案是：<strong>每个副本独立的对自己的系统状态进行Snapshot，并且只能对已经提交的日志记录（已经应用到状态机）进行snapshot。</strong></p>
<p><code>Snapshot</code>中包含以下内容：</p>
<ul>
<li><strong>日志元数据，最后一条<code>commited log entry</code>的<code>(log index, last_included_term)</code></strong>。这两个值在<code>Snapshot</code>之后的第一条<code>log entry</code>的<code>AppendEntriesRPC</code>的<code>consistency check</code>的时候会被用上，之前讲过。<strong>一旦这个<code>server</code>做完了<code>snapshot</code>，就可以把这条记录的最后一条<code>log index</code>及其之前的所有的<code>log entry</code>都删掉</strong>。</li>
<li>系统状态机：存储系统当前状态（这是怎么生成的呢？）</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>snapshot</code>的缺点就是不是增量的，即使内存中某个值没有变，下次做<code>snapshot</code>的时候同样会被<code>dump</code>到磁盘。当<code>leader</code>需要发给某个<code>follower</code>的<code>log entry</code>被丢弃了(因为<code>leader</code>做了<code>snapshot</code>)，<code>leader</code>会将<code>snapshot</code>发给落后太多的<code>follower</code>。或者当新加进一台机器时，也会发送<code>snapshot</code>给它。发送<code>snapshot</code>使用新的<code>RPC，InstalledSnapshot</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;做<code>snapshot</code>有一些需要注意的性能点</p>
<ol>
<li>不要做太频繁，否则消耗磁盘带宽。</li>
<li>不要做的太不频繁，否则一旦节点重启需要回放大量日志，影响可用性。系统推荐当日志达到某个固定的大小做一次<code>snapshot</code>。</li>
<li>做一次<code>snapshot</code>可能耗时过长，会影响正常<code>log entry</code>的<code>replicate</code>。这个可以通过使用<code>copy-on-write</code>的技术来避免<code>snapshot</code>过程影响正常<code>log entry</code>的<code>replicate</code>。</li>
</ol>
<h5 id="集群拓扑变化"><a href="#集群拓扑变化" class="headerlink" title="集群拓扑变化"></a><strong>集群拓扑变化</strong></h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>集群拓扑变化的意思是在运行过程中多副本集群的结构性变化，如增加/减少副本数、节点替换等</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Raft</code>协议定义时也考虑了这种情况，从而避免由于下线老集群上线新集群而引起的系统不可用。<code>Raft</code>也是利用上面的<code>Log Entry</code>和一致性协议来实现该功能。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设在<code>Raft</code>中，老集群配置用<code>Cold</code>表示，新集群配置用<code>Cnew</code>表示，整个集群拓扑变化的流程如下：</p>
<ol>
<li>当集群成员配置改变时，<code>leader</code>收到人工发出的重配置命令从<code>Cold</code>切成<code>Cnew</code>；</li>
<li><code>Leader</code>副本在本地生成一个新的<code>log entry</code>，其内容是<code>Cold∪Cnew</code>，代表当前时刻新旧拓扑配置共存，写入本地日志，同时将该<code>log entry</code>推送至其他<code>Follower</code>节点</li>
<li><code>Follower</code>副本收到<code>log entry</code>后更新本地日志，并且此时就以该配置作为自己了解的全局拓扑结构，</li>
<li>如果多数<code>Follower</code>确认了<code>Cold U Cnew</code>这条日志的时候，<code>Leader</code>就<code>Commit</code>这条<code>log entry</code>；</li>
<li>接下来<code>Leader</code>生成一条新的<code>log entry</code>，其内容是全新的配置<code>Cnew</code>，同样将该<code>log entry</code>写入本地日志，同时推送到<code>Follower</code>上；</li>
<li><code>Follower</code>收到新的配置日志<code>Cnew</code>后，将其写入日志，并且从此刻起，就以该新的配置作为系统拓扑，并且如果发现自己不在<code>Cnew</code>这个配置中会自动退出</li>
<li><code>Leader</code>收到多数<code>Follower</code>的确认消息以后，给客户端发起命令执行成功的消息</li>
</ol>
<p><strong>异常分析</strong></p>
<ul>
<li>如果<code>Leader</code>的<code>Cold U Cnew</code>尚未推送到<code>Follower</code>，<code>Leader</code>就挂了，此时选出的新的<code>Leader</code>并不包含这条日志，此时新的<code>Leader</code>依然使用<code>Cold</code>作为全局拓扑配置</li>
<li>如果<code>Leade</code>r的<code>Cold U Cnew</code>推送到大部分的<code>Follower</code>后就挂了，此时选出的新的<code>Leader</code>可能是<code>Cold</code>也可能是<code>Cnew</code>中的某个<code>Follower</code>；</li>
<li>如果<code>Leader</code>在推送<code>Cnew</code>配置的过程中挂了，那么和2一样，新选出来的<code>Leader</code>可能是<code>Cold</code>也可能是<code>Cnew</code>中的某一个，那么此时客户端继续执行一次改变配置的命令即可</li>
<li>如果大多数的<code>Follower</code>确认了<code>Cnew</code>这个消息后，那么接下来即使<code>Leader</code>挂了，新选出来的<code>Leader</code>也肯定是位于<code>Cnew</code>这个配置中的，因为有<code>Raft</code>的协议保证。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>为什么需要弄这样一个两阶段协议，而不能直接从<code>Cold</code>切换至<code>Cnew</code>？</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是因为，<strong>如果直接这么简单粗暴的来做的话，可能会产生多主</strong>。简单说明下：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设<code>Cold</code>为拓扑为<code>(S1, S2, S3)</code>，且S1为当前的<code>Leader</code>，如下图：</p>
<p><img src="//blog.com/2019/05/06/Raft协议详解/v2-dc605b595be1836ef034864244c36f37_hd.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如此时变更了系统配置，将集群范围扩大为5个，新增了S4和S5两个服务节点，这个消息被分别推送至S2和S3，但是假如只有S3收到了消息并处理，S2尚未得到该消息</p>
<p><img src="//blog.com/2019/05/06/Raft协议详解/v2-9e275b79809c0793b3a74a6836222e9b_hd.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时在S2的眼里，拓扑依然是<code>&lt;S1, S2, S3&gt;</code>，而在S3的眼里拓扑则变成了<code>&lt;S1, S2, S3, S4, S5&gt;</code>。假如此时由于某种原因触发了一次新的选主，S2和S3分别发起选主的请求：</p>
<p><img src="//blog.com/2019/05/06/Raft协议详解/v2-63fee36e8721b0ace81ca47aa3f90a7a_hd.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最终，候选者S2获得了S1和S2自己的赞成票，那么在它眼里，它就变成了<code>Leader</code>，而S3获得了S4、S5和S3自己的赞成票，在它眼里S3也变成了<code>Leader</code>，那么多<code>Leader</code>的问题就产生了。而<strong>产生该问题的最根本原因是S2和S3的系统视图不一致</strong>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://link.zhihu.com/?target=https%3A//raft.github.io/raft.pdf" target="_blank" rel="noopener">https://raft.github.io/raft.pdf</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/06/raft 一致性算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/06/raft 一致性算法/" itemprop="url">raft 一致性算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-06T12:12:57+08:00">
                2019-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/一致性协议/" itemprop="url" rel="index">
                    <span itemprop="name">一致性协议</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/一致性协议/Raft/" itemprop="url" rel="index">
                    <span itemprop="name">Raft</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="raft-一致性算法"><a href="#raft-一致性算法" class="headerlink" title="raft 一致性算法"></a>raft 一致性算法</h1><h2 id="分布式系统和一致性"><a href="#分布式系统和一致性" class="headerlink" title="分布式系统和一致性"></a>分布式系统和一致性</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分布式系统有一个很重要的问题要解决，当一台机器出现问题时，我们希望整个集群还是能够正常运行的，以达到高可用的要求。因为系统的数据是不断变化的，所以要保证集群的数据是同步的，不然会出现数据混论或者丢失的情况。这就是<strong>一致性问题。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;换个说法，一致性就是让多台机器对一组给定的操作最终得到的状态一样，也就是所有机器执行命令的顺序是一样的，对客户端来说，它们表现得就要像一个机器一样。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分布式一致性问题可以抽象成下面这张图(分布式状态机 <code>Replicated State Machine</code>)：</p>
<p><img src="//blog.com/2019/05/06/raft 一致性算法/006tNc79gy1fm3p3e0lnnj30sh09zwhg.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>最终的目的是所有节点上保存的状态机器（文件内容）是一样的，这是通过各个节点上一致性模块之间的通信完成的，它们保证按顺序添加日志，然后把日志执行修改状态机的内容</strong>。<strong>如果机器初始状态相同，而且日志中记录顺序是一样的，那么最终的状态一定也是相同的</strong>。</p>
<p>一致性算法需要满足以下条件才能在实际系统中工作：</p>
<ul>
<li><p>安全（<code>safety</code>）：<strong>不会返回错误的结果，即使网络出现延迟、分割（partitions）、丢包、重复和乱序</strong></p>
</li>
<li><p>可用（<code>available</code>）：<strong>只要有一半以上的机器正常工作（能够互相通信并且可以和客户端通信），整个集群就要能正常工作</strong></p>
</li>
<li><p><strong>不能通过时间来保证一致性，错误的时钟以及严重的消息延迟最多只能造成集群不可用</strong></p>
</li>
<li><p><strong>只要大部分机器完成命令的执行，这个命令就算完成，结果可以返回给客户端</strong>。而不用等到那些执行更慢的少数节点完成，它们的操作可以异步在后台运行</p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分布式系统关于一致性最著名的算法是 <code>paxos</code>，它的发布者 Lamport 是图灵奖的获得者。但是 <code>paxos</code>算法非常复杂，很多实现都是它的特殊版。尽管 Lamport 后来还发布过 <code>Paxos Made Simple</code> 的文章，试图用更简单的语言解释 <code>paxos</code>算法，但是这个版本的解释还是过于复杂，这对于理解和实现都带来困难。</p>
<p><code>paxos</code> 算法在分布式系统中地位很高，<code>Chubby</code>作者有过这样一段话：</p>
<blockquote>
<p>There is only one consensus protocol, and that’s Paxos. All other approaches are just broken versions of Paxos.</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有一种一致性算法，那就是<code>Paxos</code>；而其他所有的一致性算法都是 <code>Paxos</code>的特殊版本。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>raft</code> 算法是基于<code>paxos</code> 算法提出来的，主要是为了更加易懂，提出 raft 算法的论文是 <code>《In search of an Understandable Consensus Algorithm</code>》，可以在网上很容易搜到原文。</p>
<h2 id="raft-算法"><a href="#raft-算法" class="headerlink" title="raft 算法"></a>raft 算法</h2><p>为了容易理解，<code>raft</code> 算法主要分成几个可以单独解释的问题：</p>
<ul>
<li><code>Leader election</code>：<strong>主节点选举</strong>，从集群中所有节点中选择一个作为主节点</li>
<li><code>Log replication</code>：<strong>日志复制</strong>，主节点全权负责和客户端的交互，以及日志复制到其他节点，保证日志的一致性</li>
<li><code>Safety</code>：<strong>安全</strong>，如果一个节点往保存的状态添加一个日志记录，其他节点不会再同一个日志 index 时期添加一个不同的记录</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它的工作流程是这样的：<strong>集群选择出一个节点作为 leader，leader 节点负责接收客户端的请求（日志），并负责把请求复制给所有的从节点，保证节点之间数据的同步</strong>。<strong>如果 leader 节点出现问题挂掉，那么其他正常节点会重新选择 leader</strong>。</p>
<h3 id="选主-leader-election"><a href="#选主-leader-election" class="headerlink" title="选主 leader election"></a>选主 leader election</h3><p>每个节点在任意情况下，只能有三种状态可选：</p>
<ul>
<li><code>leader</code>：领导节点，或者主节点，<strong>用来处理客户端发来的请求，并保证请求数据在整个集群的同步，需要用心跳和 follower 节点通信，通知它们自己的可用性</strong></li>
<li><code>follower</code>：负责处理 leader 和 candidate 请求的节点。<strong>如果客户端把请求发送给 follower 节点，它需要把请求转发给 leader，由 leader 统一负责管理</strong></li>
<li><code>candidate</code>：<strong>leader 的候选人，只是在选举过程中短暂出现的状态</strong>。如果通过选举，则会变成 leader；如果选举失败，还是会回到 follower 状态</li>
</ul>
<p><img src="//blog.com/2019/05/06/raft 一致性算法/006tNc79gy1fm40vgcvazj30y20j6tap.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>raft</code>算法还有一个<strong>任期（<code>Term</code>）</strong>的概念，<strong>任期是依次递增的编号，每次选举都是一个新的任期</strong>。<strong>在一个任期内最多只能有一个 leader</strong>，也就是说一个任期可以有一个 leader，表示正常工作；也可以没有 leader，表明选举失败。某个节点选举成功后，就成为当前任期的 leader，负责日志复制工作。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>任期的主要目的是保证所有节点逻辑时间上的一致，而不会出现过期的请求导致逻辑混乱的情况</strong>。</p>
<p><img src="//blog.com/2019/05/06/raft 一致性算法/006tNc79gy1fm40vu4bbij30ya0e9q3f.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>每个节点都会保存一个当前任期的值</strong>，当节点通信时会交互当前任期的值：</p>
<p><strong>1. 如果节点发现其他节点的当前任期比自己的大，就更新自己当前任期的值</strong>；</p>
<p><strong>2. 如果 leader 节点发现有比自己大的任期值，则知道自己的任期过期了，集群中有更新的 leader 节点，它立即变成 follower 状态</strong>；</p>
<p><strong>3. 如果节点接收到历史任期的请求，则直接无视</strong>（这很可能是因为网络延迟或者报文重复导致的）；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>当节点刚启动的时候，默认是在 follower 状态</strong>。</p>
<p><strong>如果它能定时收到 leader 的心跳或者日志复制的请求，则会一直处于该状态</strong>；</p>
<p><strong>如果在设定的超时时间（<code>election timeout</code>）内没有收到 leader 的消息，则认为当前集群没有 leader，或者 leader 以及失效，立即会发起重新投票</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>投票开始，节点会增加自己的当前任期值，转换成 <code>candidate</code>状态，并向其他节点发送请求投票的消息（表示自己想成为下一个任期的 leader）</strong>。下面的状态分为三种情况：</p>
<ol>
<li><p>节点收到大多数节点的投票，成为新任期的 leader。每个节点在每个任期只能投票一次，<strong>采取先到先得的原则，投票给最先收到的选主节点</strong>。大多数原则保证一个任期最多只能有一个节点</p>
</li>
<li><p>节点发现已经有另一个节点成为 leader。<strong>在等待选举结果的时候，节点收到了心跳或者日志复制的消息（也就是有 leader 了），如果这个 leader 合法（任期比自己的当前任期高），则当前节点会自动变成 follower 状态；否则会继续等待</strong></p>
</li>
<li><p>一段时间过去，并没有任何节点成为 leader。比如有多个节点要选举 leader，而且都投票结果比较分散，没有节点获得过半的票数。<strong>延迟等待发起下一轮选举</strong>。</p>
</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不采取任何措施，那么第三种情况一直出现，会导致整个集群一直处于选举的状态，这当然是不可接受的。为此，<strong>raft 采取了随机时间的办法</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，<strong>选举超时时间（<code>election timeout</code>）是随机的，保证会有一个节点首先超时</strong>，率先选举，其他节点来不及和它竞选，它就会成为新的 leader，发送心跳和日志复制请求。其次，<strong>在开始选举时，每个 candidate 节点重置它的超时计时器，等待计时器结束之后才会开始下一次选举</strong>，从而打乱下次选举的前后顺序，保证有一个节点先开始选举，并成为 leader。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事实证明，这两种方式能够保证选举在很短的时间里完成，而不会一直循环。</p>
<p><strong>NOTE:</strong></p>
<ol>
<li><strong>选举过期时间（<code>election timeout</code>）一般设置为 150-300ms</strong>，这是大量实验得到的经验值</li>
</ol>
<h3 id="日志复制-Log-replication"><a href="#日志复制-Log-replication" class="headerlink" title="日志复制 Log replication"></a>日志复制 Log replication</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一个节点成为 leader 之后，它就会负责接收客户端的请求。客户端的每个请求都是一个指令，<code>replicate state machine</code>（复制状态机） 会执行这个指令，修改自己的状态。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>主节点收到请求之后，把它作为新纪录写入到自己的日志中，然后发送请求给所有的follower节点，让它们进行日志复制，等到大部分follower节点日志复制完成，leader 节点进行commit并返回结果给客户端</strong>。如果有从节点失败或者比较慢，主节点会<strong>一直重试</strong>，直到所有的节点保存了所有的日志记录（达到统一的状态）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个日志记录都要保存一个状态机的指令，同时还保存主节点接受请求时候的任期值，此外还有一个 index 表示它在日志文件中的位置。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当日志记录被状态机执行后，就称它为已提交（commited）。<strong>当主节点知道日志记录已经复制到大多数节点时，会把当前记录提交到本地的状态机</strong>（因为日志已经更新到大多数节点，所有数据是安全的），也就是更改数据的值。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>leader 节点会记录已经提交（commited）的最大日志 index，然后后续的心跳和日志复制请求会带上这个值，这样从节点就能知道哪些记录已经提交了，自己也会让状态机开始执行日志中的记录</strong>。从而达到所有状态机数据的一致性！</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样的日志机制<strong>保证了如果不同节点的日志文件某个记录的 index 和任期都相同，那么它们的内容也一定相同，而且之前的日志记录也一定是一样的</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>当主节点发送日志复制的请求时，它会带上前一个日志记录的 index 和 term，如果从节点发现自己的日志中不存在这个记录，则会拒绝这个请求</strong>。</p>
<p><img src="//blog.com/2019/05/06/raft 一致性算法/006tNc79gy1fm40wfjblhj30ym0i5dif.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正常情况下，每次日志复制都能正常完成，而且节点都能保证日志记录都是完全一致的。但如果 leader 节点崩溃掉，可能会出现日志不一致的情况（奔溃的主节点还没有完全把自己日志文件中的记录复制到其他节点，因此有些节点的日志比另外一些节点内容更多）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>对于日志内容不一致的请求，raft 采取用主节点日志内容覆盖 follower 节点日志的做法，先找到从节点日志和自己日志记录第一个不一致的地方，然后一直覆盖到最后</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整个过程是这样的：当某个节点当选 leader 之后，会发送日志复制请求到从节点，并带着<strong>nextIndex（主节点要发送的下一个日志记录的 index）</strong>，如果从节点出现日志记录不一致的情况，会拒绝该请求，那么主节点知道发生了不一致，<strong>递减 nextIndex</strong>，然后<strong>重新发送请求，直到日志一致的地方，一切回复正常，然后继续发送日志复制请求，就会把从节点的日志覆盖为主节点的日志内容</strong>。</p>
<h3 id="安全-safety"><a href="#安全-safety" class="headerlink" title="安全 safety"></a>安全 safety</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面提到的选主和日志复制是 raft 算法的核心，能够保证日志里面记录最终是一致的，但是还不能够保证所有节点的状态机能够按顺序执行命令。raft 对选主做出了限制，从而实现算法的正确性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总的来说，这个限制只有一句话：<strong>只有保存了最新日志的节点才能选举成为 leader</strong>，选举的时候如果节点发现候选节点日志没有自己的新，则拒绝投票给它。因为保存了最新日志，因此新 leader 产生之后，follower 节点和它保持同步就不会出现数据冲突的问题。这样也能保证 leader 节点不会覆盖日志中的记录。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面<strong>最新日志指的是保存了所有的已提交日志记录，因为已提交已经包含了集群中大多数节点都会有对应的日志记录</strong>，因此能保证没有最新记录的候选人选不上（因为大多数节点会拒绝投票给它），而且至少有一个节点符合条件（只要集群节点数超过 3）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了上述最核心的内容之外，raft 算法还有节点增删时候保证数据一致性的解决方案，以及<strong>利用快照（<code>snapshot</code>）进行日志压缩（<code>log compaction</code>）的内容，而且还要求客户端发送请求时带有一个 id，raft 集群保证请求处理的幂等性</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总的来说，易懂性是 <code>raft</code> 强调的核心，在不损失功能和性能的情况下，保证算法和系统的容易理解非常重要，这也是为什么相比很早就就出现的 <code>paxos</code> 算法，2013 年刚出现的 <code>raft</code> 就成为了很多新的分布式系统核心算法（比如分布式键值数据库 <code>etcd</code>）。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://ramcloud.stanford.edu/raft.pdf" target="_blank" rel="noopener">raft 算法论文</a></li>
<li><a href="https://raft.github.io/" target="_blank" rel="noopener">raft 算法图解</a></li>
<li><a href="https://www.cnblogs.com/mindwind/p/5231986.html" target="_blank" rel="noopener">Raft 为什么是更易理解的分布式一致性算法</a></li>
<li><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">raft 算法动画解析</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/06/一致性算法Raft详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/06/一致性算法Raft详解/" itemprop="url">一致性算法Raft详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-06T12:12:57+08:00">
                2019-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/一致性协议/" itemprop="url" rel="index">
                    <span itemprop="name">一致性协议</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/一致性协议/Raft/" itemprop="url" rel="index">
                    <span itemprop="name">Raft</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一致性算法Raft详解"><a href="#一致性算法Raft详解" class="headerlink" title="一致性算法Raft详解"></a>一致性算法Raft详解</h1><blockquote>
<p>原文地址：<a href="http://www.solinx.co/archives/415?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">http://www.solinx.co/archives/415?utm_source=tuicool&amp;utm_medium=referral</a></p>
</blockquote>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;熟悉或了解分布性系统的开发者都字段一致性算法的重要性，Paxos一致性算法从90年提出到现在已经有二十几年了，而Paxos流程太过于繁杂实现起来也比较复杂，可能也是以为过于复杂 现在我听说过比较出名使用到Paxos的也就只是Chubby、libpaxos，搜了下发现Keyspace、BerkeleyDB数据库中也使用了该算法作为数据的一致性同步，虽然现在很广泛使用的Zookeeper也是基于Paxos算法来实现，但是Zookeeper使用的ZAB（Zookeeper Atomic Broadcast）协议对Paxos进行了很多的改进与优化，算法复杂我想会是制约他发展的一个重要原因；说了这么多只是为了要引出本篇文章的主角Raft一致性算法，没错Raft就是在这个背景下诞生的，文章开头也说到了Paxos最大的问题就是复杂，Raft一致性算法就是比Paxos简单又能实现Paxos所解决的问题的一致性算法。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Raft是斯坦福的Diego Ongaro、John Ousterhout两个人以易懂（Understandability）为目标设计的一致性算法，在2013年发布了论文：《In Search of an Understandable Consensus Algorithm》从2013年发布到现在不过只有两年，到现在已经有了十多种语言的Raft算法实现框架，较为出名的有etcd，Google的Kubernetes也是用了etcd作为他的服务发现框架；由此可见易懂性是多么的重要。</p>
<h2 id="Raft概述"><a href="#Raft概述" class="headerlink" title="Raft概述"></a>Raft概述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与Paxos不同Raft强调的是易懂（Understandability），<strong>Raft和Paxos一样只要保证n/2+1节点正常就能够提供服务</strong>；众所周知但问题较为复杂时可以把问题分解为几个小问题来处理，Raft也使用了分而治之的思想把算法流程分为三个子问题：<strong>选举（Leader election）</strong>、<strong>日志复制（Log replication）</strong>、<strong>安全性（Safety）</strong>三个子问题；这里先简单介绍下Raft的流程;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Raft开始时在集群中选举出Leader负责日志复制的管理，Leader接受来自客户端的事务请求（日志），并将它们复制给集群的其他节点，然后负责通知集群中其他节点提交日志，Leader负责保证其他节点与他的日志同步，当Leader宕掉后集群其他节点会发起选举选出新的Leader</strong>；</p>
<h2 id="Raft详解"><a href="#Raft详解" class="headerlink" title="Raft详解"></a>Raft详解</h2><h3 id="1、角色"><a href="#1、角色" class="headerlink" title="1、角色"></a><strong>1、角色</strong></h3><p>　　Raft把集群中的节点分为三种状态：<strong>Leader</strong>、 <strong>Follower</strong> 、<strong>Candidate</strong>，理所当然每种状态负责的任务也是不一样的，Raft运行时提供服务的时候只存在Leader与Follower两种状态；<br>　　<strong>Leader（领导者）</strong>：负责日志的同步管理，处理来自客户端的请求，与Follower保持这heartBeat的联系；<br>　　<strong>Follower（追随者）</strong>：刚启动时所有节点为Follower状态，响应Leader的日志同步请求，响应Candidate的请求，把请求到Follower的事务转发给Leader；<br>　　<strong>Candidate（候选者）</strong>：负责选举投票，Raft刚启动时由一个节点从Follower转为Candidate发起选举，选举出Leader后从Candidate转为Leader状态；</p>
<p><img src="//blog.com/2019/05/06/一致性算法Raft详解/Raft%E8%BD%AC%E6%8D%A2%E5%9B%BE%E7%8A%B6%E6%80%81.png" alt="状态转换图"></p>
<h3 id="2、Term"><a href="#2、Term" class="headerlink" title="2、Term"></a><strong>2、Term</strong></h3><p>　　在Raft中使用了一个可以理解为周期（第几届、任期）的概念，<strong>用Term作为一个周期，每个Term都是一个连续递增的编号</strong>，<strong>每一轮选举都是一个Term周期</strong>，<strong>在一个Term中只能产生一个Leader</strong>；</p>
<p>先简单描述下Term的变化流程： </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Raft开始时所有Follower的Term为1，其中一个Follower逻辑时钟到期后转换为Candidate，Term加1这是Term为2（任期），然后开始选举，这时候有几种情况会使Term发生改变：<br>　　1：<strong>如果当前Term为2的任期内没有选举出Leader或出现异常，则Term递增，开始新一任期选举</strong><br>　　2：<strong>当这轮Term为2的周期选举出Leader后，过后Leader宕掉了，然后其他Follower转为Candidate，Term递增，开始新一任期选举</strong><br>　　3：<strong>当Leader或Candidate发现自己的Term比别的Follower小时Leader或Candidate将转为Follower，Term递增</strong><br>　　4：当Follower的Term比别的Term小时，Follower也将更新Term保持与其他Follower一致；
　　</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以说每次Term的递增都将发生新一轮的选举，Raft保证一个Term只有一个Leader，在Raft正常运转中所有的节点的Term都是一致的，<strong>如果节点不发生故障一个Term（任期）会一直保持下去，当某节点收到的请求中Term比当前Term小时则拒绝该请求</strong>；</p>
<h3 id="3、选举（Election）"><a href="#3、选举（Election）" class="headerlink" title="3、选举（Election）"></a><strong>3、选举（Election）</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Raft的选举由定时器来触发，每个节点的选举定时器时间都是不一样的，开始时状态都为Follower某个节点定时器触发选举后Term递增，状态由Follower转为Candidate，向其他节点发起RequestVote RPC请求</strong>，这时候有三种可能的情况发生：<br>　　1：<strong>该RequestVote请求接收到n/2+1（过半数）个节点的投票，从Candidate转为Leader</strong>，向其他节点发送heartBeat以保持Leader的正常运转</p>
<p>　　2：<strong>在此期间如果收到其他节点发送过来的AppendEntries RPC请求，如该节点的Term大则当前节点转为Follower，否则保持Candidate拒绝该请求</strong></p>
<p>　　3：<strong>Election timeout发生则Term递增，重新发起选举</strong></p>
<p>　　在一个Term期间每个节点只能投票一次，所以<strong>当有多个Candidate存在时就会出现每个Candidate发起的选举都存在接收到的投票数都不过半的问题，这时每个Candidate都将Term递增、重启定时器并重新发起选举，由于每个节点中定时器的时间都是随机的，所以就不会多次存在有多个Candidate同时发起投票的问题</strong>。</p>
<p>　　有这么几种情况会发起选举，</p>
<p>1：Raft初次启动，不存在Leader，发起选举；</p>
<p>2：Leader宕机或Follower没有接收到Leader的heartBeat，发生election timeout从而发起选举;</p>
<p><img src="//blog.com/2019/05/06/一致性算法Raft详解/election1.png" alt="enter image description here"><br><img src="//blog.com/2019/05/06/一致性算法Raft详解/election2.png" alt="enter image description here"><br><img src="//blog.com/2019/05/06/一致性算法Raft详解/election3.png" alt="enter image description here"></p>
<h3 id="4、日志复制（Log-Replication）"><a href="#4、日志复制（Log-Replication）" class="headerlink" title="4、日志复制（Log Replication）"></a><strong>4、日志复制（Log Replication）</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>日志复制（Log Replication）</strong>主要作用是用于<strong>保证节点的一致性</strong>，这阶段所做的操作也是为了保证一致性与高可用性；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当Leader选举出来后便开始负责客户端的请求，<strong>所有事务（更新操作）请求都必须先经过Leader处理</strong>，这些事务请求或说成命令也就是这里说的日志，我们都知道要<strong>保证节点的一致性就要保证每个节点都按顺序执行相同的操作序列</strong>，日志复制（Log Replication）就是为了保证执行相同的操作序列所做的工作；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Raft中当接收到客户端的日志（事务请求）后<strong>先把该日志追加到本地的Log中，然后通过heartbeat把该Entry同步给其他Follower，Follower接收到日志后记录日志然后向Leader发送ACK，当Leader收到大多数（n/2+1）Follower的ACK信息后将该日志设置为已提交并追加到本地磁盘中，通知客户端并在下个heartbeat中Leader将通知所有的Follower将该日志存储在自己的本地磁盘中</strong>。</p>
<h3 id="5、安全性（Safety）"><a href="#5、安全性（Safety）" class="headerlink" title="5、安全性（Safety）"></a><strong>5、安全性（Safety）</strong></h3><p>　　安全性是用于保证每个节点都执行相同序列的安全机制，如当某个Follower在当前Leader commit Log时变得不可用了，稍后可能该Follower又会倍选举为Leader，这时新Leader可能会用新的Log覆盖先前已committed的Log，这就是导致节点执行不同序列；<strong>Safety就是用于保证选举出来的Leader一定包含先前 commited Log的机制</strong>；
　　</p>
<p><strong>选举安全性（Election Safety）</strong>
　　        </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>每个Term只能选举出一个Leader</strong></p>
<p><strong>Leader完整性（Leader Completeness）</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里所说的完整性是指Leader日志的完整性，<strong>当Log在Term1被Commit后，那么以后Term2、Term3…等的Leader必须包含该Log</strong>；Raft在选举阶段就使用Term的判断用于保证完整性：当请求投票的该Candidate的Term较大或Term相同Index更大则投票，否则拒绝该请求；</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a><strong>参考资料：</strong></h2><p><a href="http://ramcloud.stanford.edu/raft.pdf" target="_blank" rel="noopener">http://ramcloud.stanford.edu/raft.pdf</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/06/ETCD背后的Raft一致性算法原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/06/ETCD背后的Raft一致性算法原理/" itemprop="url">ETCD背后的Raft一致性算法原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-06T12:12:57+08:00">
                2019-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/一致性协议/" itemprop="url" rel="index">
                    <span itemprop="name">一致性协议</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/一致性协议/Raft/" itemprop="url" rel="index">
                    <span itemprop="name">Raft</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ETCD背后的Raft一致性算法原理"><a href="#ETCD背后的Raft一致性算法原理" class="headerlink" title="ETCD背后的Raft一致性算法原理"></a>ETCD背后的Raft一致性算法原理</h1><blockquote>
<p>原文地址：<a href="https://www.jianshu.com/p/5aed73b288f7" target="_blank" rel="noopener">https://www.jianshu.com/p/5aed73b288f7</a></p>
</blockquote>
<h2 id="ETCD是什么"><a href="#ETCD是什么" class="headerlink" title="ETCD是什么"></a>ETCD是什么</h2><ul>
<li><code>ETCD</code>是一个<code>go</code>语言实现的高可靠的KV存储系统，支持<code>HTTP</code>协议的<code>PUT/GET/DELETE</code>操作；</li>
<li>为了支持服务注册与发现，支持<code>WATCH</code>接口（通过<code>http long poll</code>实现）；</li>
<li>支持<code>KEY</code>持有<code>TTL</code>属性；</li>
<li><code>CAS（compare and swap）</code>操作;</li>
<li>支持多<code>key</code>的事务操作；</li>
<li>支持目录操作</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单的来说，<code>ETCD</code>可以看做是一个<code>no sql</code>的存储，存的是<code>key-value</code>的<code>node</code>，每个<code>node</code>又可以像树形结构一样产生子<code>node</code>。它是集群化的运行状态来保证高可用，并且对外提供了一套简单友好的交互接口。</p>
<h2 id="一致性的基础：Raft算法"><a href="#一致性的基础：Raft算法" class="headerlink" title="一致性的基础：Raft算法"></a>一致性的基础：Raft算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ETCD</code>实现高可靠的基础在于<code>Raft</code>算法，也是理解<code>ETCD</code>工作原理最重要的一部分。类似于<code>zookeeper</code>的<code>zab</code>协议（<code>Paxos</code>算法），<code>Raft</code>也是用于保证分布式环境下多节点数据的一致性，但更易于理解。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看了很多相关Raft算法的技术文章，要么是介绍的过于简单，要么是过于晦涩难懂。最后看了原始的论文<a href="https://link.jianshu.com?t=https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf" target="_blank" rel="noopener">In search of an Understandable Consensus Algorithm</a>和infoQ上对应的中文翻译<a href="https://link.jianshu.com?t=http://www.infoq.com/cn/articles/raft-paper" target="_blank" rel="noopener">Raft 一致性算法论文译文</a>才对整个逻辑有细致的理解。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先来看看<code>Raft</code>大致的原理，这是一个选主（<code>leader selection</code>）思想的算法，集群总每个节点都有三种可能的角色：</p>
<ul>
<li><code>leader</code><br> 对客户端通信的入口，对内数据同步的发起者，一个集群通常只有一个<code>leader</code>节点</li>
</ul>
<ul>
<li><code>follower</code><br> 非<code>leader</code>的节点，被动的接受来自<code>leader</code>的数据请求</li>
</ul>
<ul>
<li><code>candidate</code><br> 一种临时的角色，只存在于leader的选举阶段，某个节点想要变成<code>leader</code>，那么就发起投票请求，同时自己变成<code>candidate</code>。如果选举成功，则变为<code>candidate</code>，否则退回为<code>follower</code></li>
</ul>
<h3 id="数据提交的过程"><a href="#数据提交的过程" class="headerlink" title="数据提交的过程"></a>数据提交的过程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先看前两种角色，<strong><code>leader</code>扮演的是分布式事务中的协调者，每次有数据更新的时候产生二阶段提交（<code>two-phase commit</code>）</strong>。<strong>在<code>leader</code>收到数据操作的请求，先不着急更新本地数据（数据是持久化在磁盘上的），而是生成对应的<code>log</code>，然后把生成<code>log</code>的请求广播给所有的<code>follower</code></strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个<code>follower</code>在收到请求之后有两种选择：一种是听从<code>leader</code>的命令，也写入<code>log</code>，然后返回<code>success</code>回去；另一种情况，在某些条件不满足的情况下，<code>followe</code>认为不应该听从<code>leader</code>的命令，返回<code>false</code>。例如下图，<code>leader</code>收到客户端的写请求，我们暂时不考虑请求的具体值，虚线表示<code>leader</code>先写<code>log</code></p>
<p><img src="//blog.com/2019/05/06/ETCD背后的Raft一致性算法原理/4155740-cb622903b24eca64.webp" alt="img"></p>
<p>​                                                                <strong>leader写log</strong></p>
<p>然后告诉所有的<code>follower</code>准备提交数据，先和我一样写<code>log</code>，</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4155740-03cdfdddc5c18365.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p>
<p>​                                                                    <strong>同步log</strong></p>
<p>然后回到<code>leader</code>，此时如果超过半数的<code>follower</code>都成功写了log，那么<code>leader</code>开始<strong>第二阶段</strong>的提交：正式写入数据，然后同样广播给<code>follower</code>，<code>follower</code>也根据自身情况选择写入或者不写入并返回结果给<code>leader</code>。继续上面的例子，<strong><code>leader</code>先写自己的数据，然后告诉<code>follower</code>也开始持久化数据</strong>，</p>
<p><img src="//blog.com/2019/05/06/ETCD背后的Raft一致性算法原理/4155740-f52aba9a5adf2911.webp" alt="img"></p>
<p>​                                                        <strong>leader持久化并同步数据</strong></p>
<p>最终所有节点的数据达成一致，图中用实线表示已提交的数据。</p>
<p><img src="//blog.com/2019/05/06/ETCD背后的Raft一致性算法原理/4155740-085dfb6884f94668.webp" alt="img"></p>
<p>​                                                <strong>数据一致</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这两阶段中如果任意一个都有超过半数的<code>follower</code>返回<code>false</code>或者根本没有返回，那么这个分布式事务是不成功的。<strong>此时虽然不会有回滚的过程，但是由于数据不会真正在多数节点上提交，所以会在之后的过程中被覆盖掉</strong>。</p>
<h3 id="选举的过程"><a href="#选举的过程" class="headerlink" title="选举的过程"></a>选举的过程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面只说了常规时候两种角色是如何协调工作的，还剩下<code>candidate</code>没说，对，就是一个<code>follower</code>是如何逆袭成为<code>leader</code>的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始状态下，大家都是平等的<code>follower</code>，那么<code>follow</code>谁呢，总要选个老大吧。大家都蠢蠢欲动，<strong>每个<code>follower</code>内部都维护了一个随机的<code>timer</code></strong>。如下图，</p>
<p><img src="//blog.com/2019/05/06/ETCD背后的Raft一致性算法原理/4155740-a1489344bf45989a.webp" alt="img"></p>
<p>​                                                                <strong>每个follower都有timer</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在timer时间到了的时候还没有人主动联系它的话，那它就要变成<code>candidate</code>，同时发出投票请求（<code>RequestVote</code>）给其他人</strong>。特殊情况如下图，S1和S3都变成了<code>candidate</code>，</p>
<p><img src="//blog.com/2019/05/06/ETCD背后的Raft一致性算法原理/4155740-85c29a294e85597d.webp" alt="img"></p>
<p>​                                                        <strong>转变为candidate</strong></p>
<p>当然选不选就是人家的事了，原则是</p>
<blockquote>
<p><strong>每个follower一轮只能投一次票给一个candidate</strong></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>对于相同条件的<code>candidate</code>，<code>follower</code>们采取先来先投票的策略。如果超过半数的<code>follower</code>都认为他是合适做领导的，那么恭喜，新的<code>leader</code>产生了</strong>，如下图，S3变成了新一届的大哥，又可以很开心的像上一节一样的正常工作了。</p>
<p><img src="//blog.com/2019/05/06/ETCD背后的Raft一致性算法原理/4155740-25ab79cd881475a4.webp" alt="img"></p>
<p>​                                            <strong>所有follower接受candidate的大哥身份</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是如果很不幸，没有人愿意选这个悲剧的<code>candidate</code>，那它只有老老实实的变回小弟的状态。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>选举完成之后，<code>leader</code>靠什么来确保小弟是跟着我的呢？答案是定时发送心跳检测(heart beat)</strong>。<strong>小弟们也是通过心跳来感知大哥的存在的</strong>。如下图</p>
<p><img src="//blog.com/2019/05/06/ETCD背后的Raft一致性算法原理/4155740-0394aa275e193d63.webp" alt="img"></p>
<p>​                                                                    <strong>leader定期发心跳检测</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样的，如果在<code>timer</code>期间内没有收到大哥的联络，这时很可能大哥已经跪了，如下图，所有小弟又开始蠢蠢欲动，新的一轮(<code>term)</code>选举开始了。</p>
<p><img src="//blog.com/2019/05/06/ETCD背后的Raft一致性算法原理/4155740-4f0f3367dcd8a5e2.webp" alt="img"></p>
<p>​                                                                    <strong>新的一轮选举</strong></p>
<h3 id="选举时会产生的问题"><a href="#选举时会产生的问题" class="headerlink" title="选举时会产生的问题"></a>选举时会产生的问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之前说过，在选举阶段，每个<code>follower</code>如果在自身的<code>timer</code>到期之后都会变成<code>candidate</code>去参与选举。所以就这个<code>candidate</code>身份而言，是没有特别条件的，每个<code>follower</code>都有机会参选。但是，<strong>在分布式的环境里，每个follower节点存储的数据是不一样的</strong>，考虑一下下图的情况，在这些节点经历了一些损坏和恢复。此时S4想当leader，</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4155740-e9d15d881bb21b53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p>
<p>​                                                            <strong>不适合的candidate</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是如果S4成功当选的话，根据<code>leader</code>为上的原则，S4的<code>log</code>在<code>index</code>为4-7的数据，会覆盖掉S2和S3的8。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何解决这样的冲突的问题呢？有两种方法：</p>
<ol>
<li><p>S4在变为大哥之前，先向所有的小弟拿数据来保证自己数据是最全的；</p>
</li>
<li><p><strong>其他小弟遇到这样资历不足的大哥想上位的时候，完全不予以理睬</strong>；</p>
</li>
</ol>
<p>   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Raft算法认为第一种策略过于复杂，所以选择了第二种，保证数据只从leader流向follower</strong>。S4在<code>vote</code>请求中会带上<strong>自身数据的描述信息</strong>，包括：</p>
<ol>
<li><strong><code>term</code>，自身处于的选举周期</strong></li>
<li><strong><code>lastLogIndex</code>，<code>log</code>中最新的<code>index</code>值</strong></li>
<li><strong><code>lastLogTerm</code>，<code>log</code>中最近的<code>index</code>是在哪个<code>term</code>中产生的</strong></li>
</ol>
<p>S2和S3在收到<code>vote请求</code>时候会和自身的情况进行对比，<strong>每个节点保存的数据信息</strong>包括：</p>
<ol>
<li><p><strong><code>currentTerm</code>，节点处于的term号</strong></p>
</li>
<li><p><strong><code>log[ ]</code>，自身的log集合</strong></p>
</li>
<li><p><strong><code>commitIndex</code>，log中最后一个被提交的index值</strong></p>
</li>
</ol>
<p>对比的原则有：</p>
<ol>
<li>如果<code>term &lt; currentTerm</code>，也就是说<code>candidate</code>的版本还没我新，返回<code>false</code></li>
<li>如果已经投票给别的<code>candidate了（votedFor）</code>，则返回false</li>
<li><code>log</code>匹配，如果和自身的<code>log</code>匹配上了，则返回<code>true</code></li>
</ol>
<p>这个<code>log</code>匹配原则（<code>Log Matching Property</code>）具体是：</p>
<blockquote>
<p><strong>如果在不同日志中的两个条目有着相同的索引和任期号，则它们所存储的命令是相同的</strong>。</p>
</blockquote>
<blockquote>
<p><strong>如果在不同日志中的两个条目有着相同的索引和任期号，则它们之间的所有条目都是完全一样的</strong>。</p>
</blockquote>
<p>这样就可以一直等到含有最新数据的<code>candidate</code>被选上，从而保证领导人完全原则（<code>Leader Completeness</code>）：</p>
<blockquote>
<p><strong>如果一个日志的index在一个给定term内被提交，那么这个index一定会出现在所有term号更大的领导人中</strong>。</p>
</blockquote>
<p>好了，继续看图说话。S4的<code>vote请求</code>，</p>
<table>
<thead>
<tr>
<th style="text-align:center">term</th>
<th style="text-align:center">lastLogIndex</th>
<th style="text-align:center">lastLogTerm</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">6</td>
<td style="text-align:center">7</td>
</tr>
</tbody>
</table>
<p>被无情的拒绝。接下来S3也变成了<code>candidate</code>，</p>
<p><img src="//blog.com/2019/05/06/ETCD背后的Raft一致性算法原理/4155740-7acf2c68afd498c2.webp" alt="img"></p>
<p>​                                                                                <strong>S3变成candidate</strong></p>
<p>一直等到S3变成了<code>candidate</code>，发出<code>vote请求</code>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">term</th>
<th style="text-align:center">lastLogIndex</th>
<th style="text-align:center">lastLogTerm</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">6</td>
<td style="text-align:center">8</td>
</tr>
</tbody>
</table>
<p>被S4和S10接受，变成新的<code>leader</code>，并初始化两个数组：</p>
<ol>
<li><strong><code>nextIndex[ ]</code>，表示需要发给每个<code>follower</code>的下一个日志条目的索引（初始化为<code>leader</code>最新log的<code>index+1</code></strong>，因为leader总是先假定所有的<code>follower</code>和自己是一致的，后面说明当有不一致的时候是如何协商的）</li>
<li><strong><code>matchIndex[ ]</code>，表示已经复制到每个<code>follower</code>的log的<code>最高index值</code>（从0开始递增）</strong></li>
</ol>
<p>在这个例子中，S3中的这两个数组会初始化为，</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">S1</th>
<th style="text-align:center">S2</th>
<th style="text-align:center">S4</th>
<th style="text-align:center">S5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">nextIndex</td>
<td style="text-align:center">7</td>
<td style="text-align:center">7</td>
<td style="text-align:center">7</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">matchIndex</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<h3 id="数据更新的问题"><a href="#数据更新的问题" class="headerlink" title="数据更新的问题"></a>数据更新的问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在新的一届<code>leader</code>选举出来了，虽然选举的过程保证了<code>leader</code>的数据是最新的，但是<code>follower</code>中的数据还是可能存在不一致的情况。比如下图的S4，这就需要一个补偿机制来纠正这个问题。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在正常情况下，S3会给S4发心跳请求(一种名叫AppendEntries请求的特殊格式，entries为空)，其中携带一些数据信息</strong>，包括，</p>
<table>
<thead>
<tr>
<th style="text-align:center">term</th>
<th style="text-align:center">prevIndex</th>
<th style="text-align:center">prevTerm</th>
<th style="text-align:center">entries</th>
<th style="text-align:center">commitIndex</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">6</td>
<td style="text-align:center">8</td>
<td style="text-align:center">[ ]</td>
<td style="text-align:center">6</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>commitIndex</code>之前已经解释过了，是log中最后一个被提交的index值</strong>。<strong><code>prevIndex</code>与<code>lastLogIndex</code>类似，都是最新的日志的index值，只是属于不同的请求类型</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>prevTerm</code>也与<code>lastLogTerm</code>类似，是<code>prevLogIndex</code>对应的<code>term</code>号</strong>。</p>
<p>S4在接收到该请求之后会做一致性的判断，规则包括：</p>
<ol>
<li>如果<code>term &lt; currentTerm</code>返回<code>false</code></li>
<li>如果<code>在prevLogIndex</code>处的log的<code>term</code>号与<code>prevLogTerm</code>不匹配时，返回 <code>false</code></li>
<li><strong>如果一条已经存在的log与新的冲突（index相同但是term号不同），则删除已经存在的日志和它之后所有的日志，返回<code>true</code></strong></li>
<li>添加任何在已有的log中不存在的index，返回true</li>
<li><strong>如果请求中<code>leader的commitIndex &gt; 自身的commitIndex</code>，则比较leader的commitIndex和最新log index，将其中较小的赋给<code>自身的commitIndex</code></strong></li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结果与规则2不符合，返回false给S3。这时S3需要做一次退让，修改保存的<code>nextIndex数组</code>，将S4的<code>nextIndex退化为6</code></p>
<p><img src="//blog.com/2019/05/06/ETCD背后的Raft一致性算法原理/4155740-a03298dc7bc58cd0.webp" alt="img"></p>
<p>​                                                                <strong>S4的nextIndex退化为6</strong></p>
<p>再次发送<code>AppendEntries</code>询问S4</p>
<table>
<thead>
<tr>
<th style="text-align:center">term</th>
<th style="text-align:center">prevIndex</th>
<th style="text-align:center">prevTerm</th>
<th style="text-align:center">entries</th>
<th style="text-align:center">commitIndex</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">5</td>
<td style="text-align:center">8</td>
<td style="text-align:center">[ ]</td>
<td style="text-align:center">5</td>
</tr>
</tbody>
</table>
<p><strong>如此循环的退让，一直到<code>nextIndex</code>减小到4</strong></p>
<p><img src="//blog.com/2019/05/06/ETCD背后的Raft一致性算法原理/4155740-fc136a16d7e7a629.webp" alt="img"></p>
<p>​                                                                        <strong>nextIndex减小到4</strong></p>
<p>S3此时发送的请求为，</p>
<table>
<thead>
<tr>
<th style="text-align:center">term</th>
<th style="text-align:center">prevIndex</th>
<th style="text-align:center">prevTerm</th>
<th style="text-align:center">entries</th>
<th style="text-align:center">commitIndex</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">[ ]</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>S4和自己的log匹配成功，返回true，并告诉leader，当前的<code>matchIndex等于3</code></strong>。<strong>S3收到之后更新<code>matchIndex数组</code></strong>，</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">S1</th>
<th style="text-align:center">S2</th>
<th style="text-align:center">S4</th>
<th style="text-align:center">S5</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">nextIndex</td>
<td style="text-align:center">7</td>
<td style="text-align:center">7</td>
<td style="text-align:center">4</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td style="text-align:center">matchIndex</td>
<td style="text-align:center">0</td>
<td style="text-align:center">6</td>
<td style="text-align:center">3</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>并发送从<code>nextIndex</code>之后的数据(<code>entries</code>)</strong>，</p>
<table>
<thead>
<tr>
<th style="text-align:center">term</th>
<th style="text-align:center">prevIndex</th>
<th style="text-align:center">prevTerm</th>
<th style="text-align:center">entries</th>
<th style="text-align:center">commitIndex</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">3</td>
<td style="text-align:center">3</td>
<td style="text-align:center">[8]</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>S4再根据覆盖的原则，把自身的数据追平<code>leader</code>，并抛弃之后的数据</strong>。</p>
<p><img src="//blog.com/2019/05/06/ETCD背后的Raft一致性算法原理/4155740-c017a7412608145a.webp" alt="img"></p>
<p>​                                                        <strong>S4的index4同步为leader的内容</strong></p>
<p>这样<strong>消息往复，数据最终一致</strong>。</p>
<h3 id="一些其他的问题"><a href="#一些其他的问题" class="headerlink" title="一些其他的问题"></a>一些其他的问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一些值得注意的特殊情况，比如log的清理。<strong>log是以追加的方式递增的，随着系统的不断运行，log会越来越大</strong>。<strong>Raft通过log的<code>snapshot</code>方式，可以定期压缩log为一个<code>snapshot</code>，并且清除之前的log</strong>。压缩的具体策略可以参考原论文。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Raft</code>是一种基于<code>leader</code>选举的算法，用于保证分布式数据的一致性。所有节点在三个角色<code>（leader, follower和candidate）</code>之中切换。选举阶段<code>candidate</code>向其他节点发送<code>vote</code>请求，但是只有包括所有最新数据的节点可以变为<code>leader</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在数据同步阶段，leader通过一些标记<code>（commitIndex，term，prevTerm，prevIndex等等）</code>与follower不断协商<strong>最终达成一致</strong>。当有新的数据产生时，采用<strong><code>二阶段（twp-phase）</code>提交</strong>，先更新log，等大多数节点都做完之后再正式提交数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上的图片来自github上<a href="https://link.jianshu.com?t=https://raft.github.io/]" target="_blank" rel="noopener">raft算法</a>的算法动画的截图。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/06/分布式-Raft协议的理解与分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/06/分布式-Raft协议的理解与分析/" itemprop="url">分布式-Raft协议的理解与分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-06T12:12:57+08:00">
                2019-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/一致性协议/" itemprop="url" rel="index">
                    <span itemprop="name">一致性协议</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/一致性协议/Raft/" itemprop="url" rel="index">
                    <span itemprop="name">Raft</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分布式-Raft协议的理解与分析"><a href="#分布式-Raft协议的理解与分析" class="headerlink" title="分布式-Raft协议的理解与分析"></a>分布式-Raft协议的理解与分析</h1><blockquote>
<p>原文地址：<a href="http://tech.dianwoda.com/2018/08/24/raftfen-bu-shi-zhi-xing-xie-yi/?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">http://tech.dianwoda.com/2018/08/24/raftfen-bu-shi-zhi-xing-xie-yi/?utm_source=tuicool&amp;utm_medium=referral</a></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Paxos</code>是最早的分布式一致性算法，虽然出来了很多年，但因其不容易理解，且实现难度较大，目前比较成熟的<code>Multi-Paxos</code>实现依然比较少。<code>Raft</code>算法是近几年很火的一个分布式一致性算法，旨在提供分布式一致性的前提下，提高算法的可读性，降低实现的难度。它提供了和<code>Paxos</code>算法相同的功能和性能，但是它的算法结构和 <code>Paxos</code>不同，使得<code>Raft</code>算法更加容易理解并且更容易构建实际的系统。<strong>为了提升可理解性，Raft将一致性算法分解成了几个关键模块，例如领导人选举、日志复制和安全性</strong>。</p>
<h2 id="一、相关介绍"><a href="#一、相关介绍" class="headerlink" title="一、相关介绍"></a>一、相关介绍</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Raft集群服务器的状态有三种：领导人 (<code>Leader</code>)、候选人(<code>Candidate</code>)、跟随者(<code>Follower</code>)。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跟随者都是被动的，他们不会发送任何请求，只是简单的响应来自领导者或者候选人的请求。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;领导人处理所有的客户端请求（如果一个客户端和跟随者联系，那么跟随者会把请求重定向给领导人）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当跟随者长时间没接收到领导人的心跳包或候选人的<code>请求投票RPC</code>时（超时），便会成为候选人发起投票，直到成为领导人或收到新领导人的心跳包。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Raft</code>相关特性：</p>
<p><img src="//blog.com/2019/05/06/分布式-Raft协议的理解与分析/Raft7.jpg" alt="Raft6"></p>
<p>  </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Raft</code> 算法中服务器节点之间通信使用远程过程调用（<code>RPCs</code>），并且基本的一致性算法只需要两种类型的<code>RPCs</code>。<strong>请求投票<code>（RequestVote）RPCs</code>和附加条目<code>（AppendEntries）RPCs</code></strong> 。</p>
<ul>
<li><p><strong>请求投票<code>（RequestVote）RPCs</code>：由候选人在选举期间发起</strong>。</p>
<p><img src="//blog.com/2019/05/06/分布式-Raft协议的理解与分析/Raft8-1.jpg" alt="Raft8"></p>
</li>
</ul>
<p>  获得投票的条件：</p>
<ul>
<li><strong><code>term</code>（候选人任期号）&gt; <code>currentTerm</code>(服务器当前任期号)</strong>[ 选举安全特性]</li>
<li><p><strong>比较候选人最后日志条目的索引值和任期号，候选人的日志至少和自己一样新，才会投票</strong></p>
<blockquote>
<p><strong>跟随者投票后，则更新当前任期号，并记录投票候选人id，同一个任期，服务器最多只会投一次票</strong>[ 选举安全特性]。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>附加日志<code>RPC</code>：由领导人发起，用来复制日志和提供一种心跳机制</strong>。</p>
<p><img src="//blog.com/2019/05/06/分布式-Raft协议的理解与分析/Raft9.jpg" alt="Raft9"></p>
</li>
</ul>
<p>  处理要点：</p>
<ul>
<li>如果<code>term &lt; currentTerm</code>就返回<code>false</code>。</li>
<li>如果日志在<code>prevLogIndex</code>位置处的日志条目的任期号或<code>prevLogTerm</code>不匹配，则返回<code>false</code>。</li>
<li>如果已经存在的日志条目和新的产生冲突（索引值相同但是任期号不同），删除这一条和之后所有的。</li>
<li>如果<code>leaderCommit &gt; commitIndex</code>（<code>Follower</code>节点已提交日志条目的索引值），令<code>commitIndex</code>等于<code>leaderCommit</code>和新日志条目索引值中较小的一个，<code>commitIndex</code>更新会将相应的日志条目应用到状态机。</li>
<li>一旦<code>Candidate</code>成为<code>Leader</code>，会立即发送空的附加日志 <code>RPC</code>（心跳）给其他所有的服务器，来阻止其他<code>Follower</code>超时发起选举。</li>
</ul>
<h2 id="二、领导人选举"><a href="#二、领导人选举" class="headerlink" title="二、领导人选举"></a>二、领导人选举</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Raft</code>通过选举一个领导人，然后全权交给它来管理复制日志来实现一致性。领导人从客户端接收日志条目，把日志条目复制到其他服务器上，并且<strong>当保证安全性的时候告诉其他的服务器应用日志条目到他们的状态机中</strong>。拥有一个领导人大大简化了对复制日志的管理。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选举的流程：当<code>Follower</code>（服务器程序启动时，都是<code>Follower</code>）长时间未接受到有效的<code>Leader</code>或者<code>Candidate</code>的<code>RPCs</code>时，发生超时则会增加自身任期号，成为<code>Candidate</code>，然后并行的向集群中的其他服务器节点<code>发送请求投票的RPCs</code>，候选人会继续保持着当前状态直到以下三件事情之一发生：</p>
<p>(a) 获得大多数投票成为Leader</p>
<p>(b) 其他的服务器成为Leader</p>
<p>(c) 一段时间之后没有Leader产生。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>每一次选举都是一个任期（<code>term</code>），任期由整数表示，单调递增</strong>。<strong>每次选举都会分配一段随机的超时时间选举超时时间（<code>eg:150~300ms</code>）,若这段时间内未完成选举，则任期加1，开启新一轮的选举</strong>。（问题1：为什么分配一段”随机的”超时时间？文末统一回答☺）</p>
<p><img src="//blog.com/2019/05/06/分布式-Raft协议的理解与分析/Raft1.png" alt="Raft节点状态变迁图"></p>
<p>          <strong>Raft节点状态变迁图</strong></p>
<p><img src="//blog.com/2019/05/06/分布式-Raft协议的理解与分析/Raft2.png" alt="Raft任期变化图"></p>
<p>          <strong>Raft任期变化图</strong></p>
<h2 id="三、日志复制"><a href="#三、日志复制" class="headerlink" title="三、日志复制"></a>三、日志复制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Raft</code>是强<code>Leader</code>机制，日志只能从<code>Leader</code>复制到其他节点。日志项<code>LogEntry</code>包括<code>index，term，command</code>三个元素。其中<code>index为日志索引，term为任期，而command为具体的日志内容</code></strong>。日志格式如下图所示:</p>
<p><img src="//blog.com/2019/05/06/分布式-Raft协议的理解与分析/Raft3.png" alt="Raft"></p>
<p>通常的日志复制流程是这样的:</p>
<ul>
<li>客户端发送请求给<code>Leader</code>。</li>
<li><code>Leader</code>接收客户端请求，先将请求命令作为一个<code>日志项(LogEntry)`</code>append<code>到自己的</code>log`中。</li>
<li><code>Leader</code>发送 <code>Append Entries RPC</code>给<code>Follower</code>节点，当过半节点添加<code>log</code>成功后，则<strong><code>Leader</code>提交该日志给状态机（此时日志条目的状态为已提交），返回给客户端写入成功</strong>。</li>
<li><strong>在接下来的<code>Append Entries RPC</code>中通知其他节点提交该日志，<code>Follower</code>节点提交日志到自己的状态机中</strong>。</li>
</ul>
<p>关于日志复制的几个要点：</p>
<ul>
<li><p><strong>不同的服务器上面的提交的相同的索引和任期的日志项的<code>command</code>一定相同，而且这个日志项之前的所有日志项都相同</strong>。</p>
</li>
<li><p><strong>如果一个日志项被提交，则它之前索引的所有日志项也肯定已经提交</strong>。</p>
</li>
<li><p><strong><code>Leader</code>从来都不覆盖自己的日志</strong>。</p>
</li>
<li><p><strong><code>Leader</code>提交过的日志一定会出现将来新的<code>Leader</code>中</strong>。</p>
</li>
<li><p>若有<code>Follower</code>宕机或响应很慢怎么办？<strong><code>Leader</code>会不断重试 <code>RPC</code> 请求直到成功，并且不会影响系统的正常运转，Leader只需要收到大部分<code>Follwer</code>的响应即可</strong>。</p>
</li>
<li><p>若<code>Follower</code>节点与<code>Leader</code>节点日志出现不一致怎么办？（问题2，文末统一回答☺）</p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在正常的操作中，领导人和跟随者的日志保持一致性，然而，<strong>领导人崩溃的情况会使得日志处于不一致的状态（老的领导人可能还没有完全复制所有的日志条目）</strong>。这种不一致问题会在领导人和跟随者的一系列崩溃下加剧。如下图：每一个格子表示是一个日志条目，里面的数字表示任期号。</p>
<p><img src="//blog.com/2019/05/06/分布式-Raft协议的理解与分析/Raft4.png" alt="极端情况Raft日志状态"></p>
<p> 当一个领导人成功当选时，跟随者可能是任何情况（a-f）：</p>
<ul>
<li>跟随者可能会缺少一些日志条目（a-b）。</li>
<li>可能会有一些未被提交的日志条目（c-d）。</li>
<li>或者两种情况都存在（e-f）。</li>
</ul>
<blockquote>
<p>场景 f 可能会这样发生，某服务器在任期 2 的时候是领导人，已附加了一些日志条目到自己的日志中，但在提交之前就崩溃了；很快这个机器就被重启了，在任期 3 重新被选为领导人，并且又增加了一些日志条目到自己的日志中；在任期 2 和任期 3 的日志被提交之前，这个服务器又宕机了，并且在接下来的几个任期里一直处于宕机状态。</p>
</blockquote>
<h2 id="四、安全性"><a href="#四、安全性" class="headerlink" title="四、安全性"></a>四、安全性</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面描述了<code>Raft</code>是怎么选举和复制日志的，到目前为止描述的机制并不能充分的保证每一个状态机会按照相同的顺序执行相同的指令。因此，<code>Raft</code>增加了一些限制来保证安全性。有一些前面可能已经提过。</p>
<h3 id="1-选举限制"><a href="#1-选举限制" class="headerlink" title="1.选举限制"></a>1.选举限制</h3><p>  请求投票 <code>RPC</code> 实现了这样的限制： <strong><code>RPC</code> 中包含了候选人的日志信息，然后<code>Follower</code>会拒绝掉那些日志没有自己新的投票请求</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Raft</code>通过比较两份日志中最后一条日志条目的索引值和任期号来定义谁的日志比较新。</p>
<p><strong>1. 如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新</strong>。</p>
<p><strong>2. 如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>成为<code>Leader</code>需要获得大多数的投票，意味着需要比大多数节点的日志要新，而已提交的日志条目需要复制到大多数的节点，<code>Leade</code>r能获得大多数的投票就意味着一定包含已提交的日志</strong>。</p>
<h3 id="2-之前任期未提交日志处理"><a href="#2-之前任期未提交日志处理" class="headerlink" title="2.之前任期未提交日志处理"></a>2.之前任期未提交日志处理</h3><p>  <code>Raft</code>永远不会通过计算副本数目的方式去提交一个之前任期内的日志条目。只有领导人当前任期里的日志条目才会通过计算副本数目去提交。下面举例说明为什么：</p>
<p><img src="//blog.com/2019/05/06/分布式-Raft协议的理解与分析/Raft5.png" alt="Raft案例"></p>
<p>如图的时间序列展示了为什么领导人无法决定对老任期号的日志条目进行提交：</p>
<ul>
<li>在 (a) 中，S1 是领导者，部分的复制了索引位置 2 的日志条目。</li>
<li>在 (b) 中，S1 崩溃了，然后 S5 在任期 3 里通过<code>S3、S4</code> 和自己的选票赢得选举，然后从客户端接收了一条不一样的日志条目放在了索引 2 处。</li>
<li>在(c)中，S5 又崩溃了；S1 重新启动，选举成功，开始复制日志。在这时，来自任期 2 的那条日志已经被复制到了集群中的大多数机器上，但是还没有被提交。</li>
<li>在(d)中，S1又崩溃了，S5 可以重新被选举成功（通过来自 <code>S2，S3 和 S4</code>的选票），然后覆盖了他们在索引 2 处的日志。</li>
<li>反之，<strong>如果在崩溃之前，S1 把自己主导的新任期里产生的日志条目复制到了大多数机器上，就如 (e) 中那样，那么在后面任期里面这些新的日志条目就会被提交（因为S5 就不可能选举成功）</strong>。而且<strong>这样也同时保证了，之前的所有老的日志条目也会被提交</strong>。</li>
</ul>
<p>  所以，<strong>若之前任期的日志已复制到大多数节点，即使未提交，<code>Raft</code>也能保证最终会提交，并且，为了保证及时提交，新Leader上任后会立即往日志中追加一个空节点</strong>。</p>
<h3 id="3-Follower和Candidate崩溃"><a href="#3-Follower和Candidate崩溃" class="headerlink" title="3.Follower和Candidate崩溃"></a>3.Follower和Candidate崩溃</h3><p>  之前我们只讨论了<code>Leader</code>崩溃的情况，当<code>Follower</code>和<code>Candidate</code>崩溃时，<strong><code>Raft</code>会不断的重试，如果崩溃的机器重启了，那么这些 <code>RPC</code> 就会完整的成功</strong>。如果一个服务器在完成了一个<code>RPC</code>，但是还没有响应的时候崩溃了，那么在他重新启动之后就会再次收到同样的请求。<strong><code>Raft</code> 的<code>RPCs</code> 都是幂等的，所以这样重试不会造成任何问题</strong>。</p>
<h3 id="4-与客户端的交互问题"><a href="#4-与客户端的交互问题" class="headerlink" title="4.与客户端的交互问题"></a>4.与客户端的交互问题</h3><p>  与客户端的交互过程中，<code>Leader</code>可能会崩溃，或网络超时，客户端未收到响应而发起重试，这可能会引起指令重复执行等问题。所以，<strong>客户端对于每一条指令都赋予一个唯一的序列号。然后，状态机跟踪每条指令最新的序列号和相应的响应</strong>。<strong>如果接收到一条指令，它的序列号已经被执行了，那么就立即返回结果，而不重新执行指令</strong>。</p>
<h3 id="5-Raft稳定运行的要求和特性"><a href="#5-Raft稳定运行的要求和特性" class="headerlink" title="5.Raft稳定运行的要求和特性"></a>5.Raft稳定运行的要求和特性</h3><ul>
<li>在所有的非拜占庭将军条件下保证安全，包括网络延迟，分区，丢包，乱序等。</li>
<li>集群中的服务器超过半数可用。</li>
<li>广播时间（<code>broadcastTime</code>） &lt;&lt; 选举超时时间（<code>electionTimeout</code>） &lt;&lt; 平均故障间隔时间（<code>MTBF</code>）</li>
</ul>
<blockquote>
<p><strong>广播时间指的是从一个服务器并行的发送 RPCs 给集群中的其他服务器并接收响应的平均时间</strong>；</p>
<p><strong>选举超时时间就是选举时的超时时间限制</strong>；</p>
<p><strong>广播时间必须比选举超时时间小一个量级，这样领导人才能够发送稳定的心跳消息来阻止跟随者开始进入选举状态</strong>；</p>
</blockquote>
<h4 id="问题1：Leader选举，为什么要分配一段”随机的”超时时间？"><a href="#问题1：Leader选举，为什么要分配一段”随机的”超时时间？" class="headerlink" title="问题1：Leader选举，为什么要分配一段”随机的”超时时间？"></a>问题1：Leader选举，为什么要分配一段”随机的”超时时间？</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Raft</code> 算法使用随机选举超时时间的方法来确保很少会发生选票瓜分的情况</strong>，就算发生也能很快的解决。<strong>因为超时时间相同的话，一旦两个Candidate选举发生选票瓜分情况而无法选出<code>Leader</code>,并且后续也很可能继续发生选票瓜分</strong>。影响Raft的正常运行。<strong>而随机时间是最简单也最容易理解的解决方式</strong>。</p>
<h4 id="问题2：若Follower节点与Leader节点日志出现不一致怎么办？"><a href="#问题2：若Follower节点与Leader节点日志出现不一致怎么办？" class="headerlink" title="问题2：若Follower节点与Leader节点日志出现不一致怎么办？"></a>问题2：若Follower节点与Leader节点日志出现不一致怎么办？</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Leader</code>通过<code>Append Entries RPC</code>请求失败发现<code>Follower</code>节点与自己日志不一致，领导人针对每一个跟随者维护了一个<strong><code>nextIndex</code>，这表示下一个需要发送给跟随者的日志条目的索引地址</strong>。当一个领导人刚获得权力的时候，他<strong>初始化所有的<code>nextIndex</code>值为自己的最后一条日志的index加1</strong>。<strong>当<code>Append Entries RPC</code>失败时，领导人会不断减小 <code>nextIndex</code> 值并进行重试</strong>。<strong>最终 <code>nextIndex</code> 会在某个位置使得领导人和跟随者的日志达成一致</strong>。<strong>这时就会把跟随者冲突的日志条目全部删除并且加上领导人的日志</strong>。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>  最后用看到的一段话结尾：<code>Raft</code>就是一个在随机时间<code>Leader</code>选举基础上叠加了各种补丁的方案。从理论上来看，和简洁漂亮没有半毛钱关系。如果说<code>Paxos</code>是以不变应万变，告诉你一个究极真理，只要你有办法实现它告诉你的步骤，任何问题都有解，那么<code>Raft</code>就是一个手把手的构建指南，每一步都告诉你怎么具体怎么做，哪一步有漏洞，没关系，后续解法我也帮你想好了，没有究级的“道”，只有完善的“术”。</p>
<h2 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h2><ul>
<li>一个形象的动画演示 <a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">http://thesecretlivesofdata.com/raft/</a></li>
<li>英文论文 <a href="https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf" target="_blank" rel="noopener">https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf</a></li>
<li>中文翻译 <a href="https://github.com/maemual/raft-zh" target="_blank" rel="noopener">https://github.com/maemual/raft-zh</a><em>cn/blob/master/raft-zh</em>cn.md</li>
<li>Raft相关实现 <a href="https://raft.github.io/#implementations" target="_blank" rel="noopener">https://raft.github.io/#implementations</a></li>
<li><a href="https://toutiao.io/posts/hdufp0/preview" target="_blank" rel="noopener">https://toutiao.io/posts/hdufp0/preview</a></li>
<li><a href="https://juejin.im/entry/5b74e1f0f265da283479709f" target="_blank" rel="noopener">https://juejin.im/entry/5b74e1f0f265da283479709f</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/84/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/84/">84</a><span class="page-number current">85</span><a class="page-number" href="/page/86/">86</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/86/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
