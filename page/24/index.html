<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/page/24/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/page/24/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/07/26/MySQL列转行/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/26/MySQL列转行/" itemprop="url">MySQL列转行</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-26T12:12:57+08:00">
                2019-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/MySql/" itemprop="url" rel="index">
                    <span itemprop="name">MySql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MySQL列转行"><a href="#MySQL列转行" class="headerlink" title="MySQL列转行"></a>MySQL列转行</h1><h2 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE IF EXISTS `sales`;</span><br><span class="line">CREATE TABLE `sales`  (</span><br><span class="line">  `年` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `季度` int(255) NULL DEFAULT NULL,</span><br><span class="line">  `销售` int(255) NULL DEFAULT NULL</span><br><span class="line">) ENGINE = InnoDB CHARACTER SET = utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO `sales` VALUES (&apos;2018&apos;, 1, 111);</span><br><span class="line">INSERT INTO `sales` VALUES (&apos;2018&apos;, 2, 200);</span><br><span class="line">INSERT INTO `sales` VALUES (&apos;2019&apos;, 1, 200);</span><br><span class="line">INSERT INTO `sales` VALUES (&apos;2019&apos;, 2, 300);</span><br><span class="line">INSERT INTO `sales` VALUES (&apos;2018&apos;, 3, 400);</span><br><span class="line">INSERT INTO `sales` VALUES (&apos;2019&apos;, 4, 500);</span><br><span class="line">INSERT INTO `sales` VALUES (&apos;2019&apos;, 3, 600);</span><br><span class="line">INSERT INTO `sales` VALUES (&apos;2018&apos;, 4, 100);</span><br><span class="line">INSERT INTO `sales` VALUES (&apos;2017&apos;, 1, 1000);</span><br><span class="line">INSERT INTO `sales` VALUES (&apos;2017&apos;, 2, 3000);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">select * from sales;</span><br><span class="line">+------+------+------+</span><br><span class="line">| 年   | 季度 | 销售 |</span><br><span class="line">+------+------+------+</span><br><span class="line">| 2018 |    1 |  111 |</span><br><span class="line">| 2018 |    2 |  200 |</span><br><span class="line">| 2019 |    1 |  200 |</span><br><span class="line">| 2019 |    2 |  300 |</span><br><span class="line">| 2018 |    3 |  400 |</span><br><span class="line">| 2019 |    4 |  500 |</span><br><span class="line">| 2019 |    3 |  600 |</span><br><span class="line">| 2018 |    4 |  100 |</span><br><span class="line">| 2017 |    1 | 1000 |</span><br><span class="line">| 2017 |    2 | 3000 |</span><br><span class="line">+------+------+------+</span><br><span class="line">10 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure>
<h2 id="统计每季度总销售额"><a href="#统计每季度总销售额" class="headerlink" title="统计每季度总销售额"></a>统计每季度总销售额</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	年,</span><br><span class="line">	GROUP_CONCAT( 销售 ORDER BY 季度 ASC SEPARATOR &quot; &quot; ) AS &quot;一季度 二季度 三季度 四季度&quot; </span><br><span class="line">FROM</span><br><span class="line">	`sales` </span><br><span class="line">GROUP BY</span><br><span class="line">	年;</span><br><span class="line">+------+----------------------------+</span><br><span class="line">| 年   | 一季度 二季度 三季度 四季度 |</span><br><span class="line">+------+----------------------------+</span><br><span class="line">| 2017 | 1000 3000                  |</span><br><span class="line">| 2018 | 111 200 400 100             |</span><br><span class="line">| 2019 | 200 300 600 500             |</span><br><span class="line">+------+----------------------------+</span><br><span class="line">3 rows in set (0.04 sec)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	年,</span><br><span class="line">	SUM( CASE 季度 WHEN 1 THEN 销售 ELSE 0 END ) AS 一季度,</span><br><span class="line">	SUM( CASE 季度 WHEN 2 THEN 销售 ELSE 0 END ) AS 二季度,</span><br><span class="line">	SUM( CASE 季度 WHEN 3 THEN 销售 ELSE 0 END ) AS 三季度,</span><br><span class="line">	SUM( CASE 季度 WHEN 4 THEN 销售 else 0 END ) AS 四季度 </span><br><span class="line">FROM</span><br><span class="line">	sales </span><br><span class="line">GROUP BY</span><br><span class="line">	年;</span><br><span class="line">+------+--------+--------+--------+--------+</span><br><span class="line">| 年   | 一季度 | 二季度 | 三季度 | 四季度 |</span><br><span class="line">+------+--------+--------+--------+--------+</span><br><span class="line">| 2017 | 1000   | 3000   | 0      | 0      |</span><br><span class="line">| 2018 | 111    | 200    | 400    | 100    |</span><br><span class="line">| 2019 | 200    | 300    | 600    | 500    |</span><br><span class="line">+------+--------+--------+--------+--------+</span><br><span class="line">3 rows in set (0.06 sec)</span><br></pre></td></tr></table></figure>
<h2 id="插入一行"><a href="#插入一行" class="headerlink" title="插入一行"></a>插入一行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `test`.`sales`(`年`, `季度`, `销售`) VALUES (&apos;2017&apos;, 2, 7000)</span><br></pre></td></tr></table></figure>
<h2 id="统计每季度总销售额-1"><a href="#统计每季度总销售额-1" class="headerlink" title="统计每季度总销售额"></a>统计每季度总销售额</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	年,</span><br><span class="line">	SUM( CASE 季度 WHEN 1 THEN 销售 ELSE 0 END ) AS 一季度,</span><br><span class="line">	SUM( CASE 季度 WHEN 2 THEN 销售 ELSE 0 END ) AS 二季度,</span><br><span class="line">	SUM( CASE 季度 WHEN 3 THEN 销售 ELSE 0 END ) AS 三季度,</span><br><span class="line">	SUM( CASE 季度 WHEN 4 THEN 销售 else 0 END ) AS 四季度 </span><br><span class="line">FROM</span><br><span class="line">	sales </span><br><span class="line">GROUP BY</span><br><span class="line">	年;</span><br><span class="line">+------+--------+--------+--------+--------+</span><br><span class="line">| 年   | 一季度 | 二季度 | 三季度 | 四季度 |</span><br><span class="line">+------+--------+--------+--------+--------+</span><br><span class="line">| 2017 | 1000   | 10000  | 0      | 0      |</span><br><span class="line">| 2018 | 111    | 200    | 400    | 100    |</span><br><span class="line">| 2019 | 200    | 300    | 600    | 500    |</span><br><span class="line">+------+--------+--------+--------+--------+</span><br><span class="line">3 rows in set (0.06 sec)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT 年,</span><br><span class="line">	SUM(IF(季度 =&apos;1&apos;,销售,0)) &apos;一季度&apos;,</span><br><span class="line">	SUM(IF(季度 =&apos;2&apos;,销售,0)) &apos;一季度&apos;,</span><br><span class="line">	SUM(IF(季度 =&apos;3&apos;,销售,0)) &apos;一季度&apos;,</span><br><span class="line">	SUM(IF(季度 =&apos;4&apos;,销售,0)) &apos;一季度&apos;</span><br><span class="line">FROM sales GROUP BY 年;</span><br><span class="line">+------+--------+--------+--------+--------+</span><br><span class="line">| 年   | 一季度 | 一季度 | 一季度 | 一季度 |</span><br><span class="line">+------+--------+--------+--------+--------+</span><br><span class="line">| 2017 | 1000   | 10000  | 0      | 0      |</span><br><span class="line">| 2018 | 111    | 200    | 400    | 100    |</span><br><span class="line">| 2019 | 200    | 300    | 600    | 500    |</span><br><span class="line">+------+--------+--------+--------+--------+</span><br><span class="line">3 rows in set (0.07 sec)</span><br></pre></td></tr></table></figure>
<h2 id="统计每季度单次最大总销售额"><a href="#统计每季度单次最大总销售额" class="headerlink" title="统计每季度单次最大总销售额"></a>统计每季度单次最大总销售额</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	年,</span><br><span class="line">	MAX( CASE 季度 WHEN 1 THEN 销售 ELSE 0 END ) AS 一季度,</span><br><span class="line">	MAX( CASE 季度 WHEN 2 THEN 销售 ELSE 0 END ) AS 二季度,</span><br><span class="line">	MAX( CASE 季度 WHEN 3 THEN 销售 ELSE 0 END ) AS 三季度,</span><br><span class="line">	MAX( CASE 季度 WHEN 4 THEN 销售 else 0 END ) AS 四季度 </span><br><span class="line">FROM</span><br><span class="line">	sales </span><br><span class="line">GROUP BY</span><br><span class="line">	年;</span><br><span class="line">+------+--------+--------+--------+--------+</span><br><span class="line">| 年   | 一季度 | 二季度 | 三季度 | 四季度 |</span><br><span class="line">+------+--------+--------+--------+--------+</span><br><span class="line">| 2017 |   1000 |   7000 |      0 |      0 |</span><br><span class="line">| 2018 |    111 |    200 |    400 |    100 |</span><br><span class="line">| 2019 |    200 |    300 |    600 |    500 |</span><br><span class="line">+------+--------+--------+--------+--------+</span><br><span class="line">3 rows in set (0.06 sec)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT 年,</span><br><span class="line">    MAX(IF(季度 =&apos;1&apos;,销售,0)) &apos;一季度&apos;,</span><br><span class="line">    MAX(IF(季度 =&apos;2&apos;,销售,0)) &apos;一季度&apos;,</span><br><span class="line">    MAX(IF(季度 =&apos;3&apos;,销售,0)) &apos;一季度&apos;,</span><br><span class="line">    MAX(IF(季度 =&apos;4&apos;,销售,0)) &apos;一季度&apos;</span><br><span class="line">FROM sales GROUP BY 年;</span><br><span class="line">+------+--------+--------+--------+--------+</span><br><span class="line">| 年   | 一季度 | 一季度 | 一季度 | 一季度 |</span><br><span class="line">+------+--------+--------+--------+--------+</span><br><span class="line">| 2017 |   1000 |   7000 |      0 |      0 |</span><br><span class="line">| 2018 |    111 |    200 |    400 |    100 |</span><br><span class="line">| 2019 |    200 |    300 |    600 |    500 |</span><br><span class="line">+------+--------+--------+--------+--------+</span><br><span class="line">3 rows in set (0.07 sec)</span><br></pre></td></tr></table></figure>
<h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><p><a href="https://blog.csdn.net/hongyuancao/article/details/85220176" target="_blank" rel="noopener">https://blog.csdn.net/hongyuancao/article/details/85220176</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/07/26/微服务可靠性设计/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/26/微服务可靠性设计/" itemprop="url">微服务可靠性设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-26T12:12:57+08:00">
                2019-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/微服务/" itemprop="url" rel="index">
                    <span itemprop="name">微服务</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/微服务/分布式系统/" itemprop="url" rel="index">
                    <span itemprop="name">分布式系统</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/微服务/分布式系统/高可用/" itemprop="url" rel="index">
                    <span itemprop="name">高可用</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="微服务可靠性设计"><a href="#微服务可靠性设计" class="headerlink" title="微服务可靠性设计"></a>微服务可靠性设计</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://www.infoq.cn/article/micro-service-reliability-design" target="_blank" rel="noopener">https://www.infoq.cn/article/micro-service-reliability-design</a></p>
</blockquote>
<p><br></p>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微服务化之后，系统分布式部署，传统单个流程的本地 <code>API</code> 调用被拆分成多个微服务之间的跨网络调用，由于引入了网络通信、序列化和反序列化等操作，系统发生故障的概率提高了很多。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微服务故障，有些是由于业务自身设计或者编码不当导致，有些是底层的微服务化框架容错能力不足导致。在实际项目中，需要从业务和平台两方面入手，提升微服务的可靠性。</p>
<h3 id="1-1-无处不在的故障"><a href="#1-1-无处不在的故障" class="headerlink" title="1.1. 无处不在的故障"></a>1.1. 无处不在的故障</h3><h4 id="1-1-1-分布式部署和调用"><a href="#1-1-1-分布式部署和调用" class="headerlink" title="1.1.1. 分布式部署和调用"></a>1.1.1. 分布式部署和调用</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传统单体架构一个完整的业务流程往往在同一个进程内部完成处理，不需要进行分布式协作，它的工作原理如下所示：</p>
<p><img src="//blog.com/2019/07/26/微服务可靠性设计/3425b07d1b46e6f895e92efd6299dae5.png" alt="img"></p>
<p><em>图 1-1 传统单体架构本地方法调用</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微服务化之后，不同的微服务采用分布式集群部署方式，<strong>服务的消费者和提供者通常运行在不同的进程中，需要跨网络做 <code>RPC</code>调用</strong>，它的工作原理如下所示：</p>
<p><img src="//blog.com/2019/07/26/微服务可靠性设计/86fdc71a61674249f9478d074d6c1e9c.png" alt="img"></p>
<p><em>图 1-2 微服务分布式 RPC 调用</em></p>
<p>分布式调用之后，相比于传统单体架构的本地方法调用，主要引入了如下潜在故障点：</p>
<ul>
<li><strong>序列化与反序列化</strong>：微服务的请求和应答都需要经过序列化和反序列化，做消息的跨网络通信，由于数据结构不一致、不支持的数据类型、对方编解码错误等都会导致序列化和反序列化失败，进而导致微服务调用失败。</li>
<li><strong>网络问题</strong>：常见的包括网络超时、网络闪断、网络单通、网络拥塞等，都可能会导致微服务远程调用的失败。</li>
</ul>
<h4 id="1-1-2-大型系统微服务进程内合设"><a href="#1-1-2-大型系统微服务进程内合设" class="headerlink" title="1.1.2. 大型系统微服务进程内合设"></a>1.1.2. 大型系统微服务进程内合设</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;理想情况下，每个微服务都独立打包和部署，微服务之间天然就支持进程级隔离，但事实上，对于一个大规模的企业 IT 系统、或者大型网站，是由成百上千个微服务组成的，在实践中，微服务通常是不可能做到百分之百独立部署的，原因如下：</p>
<ol>
<li><strong>方便开发</strong>：通常会按照业务域划分团队，同一个业务域往往包含多个微服务，由一个团队负责开发。为了方便 <code>CI/CD</code>，同一业务域的微服务往往打包和部署在一起，而不是每个微服务独立打包部署。</li>
<li><strong>方便运维</strong>：海量的微服务进程（以 1000 个微服务 * 10 个进程实例为例），会增加部署、数据采集（性能 <code>KPI</code>和日志等）、告警、问题定位等成本，如果运维自动化程度不高，很难支撑大规模的微服务独立部署。</li>
<li><strong>提升性能</strong>：一些业务对时延非常敏感，如果该业务链上的所有微服务调用都跨网络通信，时延往往无法满足业务要求。通过将微服务合设在同一个进程之内，利用路由短路，把 <code>RPC</code> 调用转化成本地方法调用，可以极大的提升性能。</li>
<li><strong>简化分布式事务处理</strong>：分布式部署之后，会带来分布式事务问题。有时候业务为了简化分布式事务的处理，将事务相关的微服务部署在同一个进程中，把分布式事务转换成本地事务，简化事务处理。</li>
</ol>
<p>不同的微服务合设在同一个进程之中，就会引入一系列潜在的故障点，例如：</p>
<ul>
<li><strong>处理较慢的微服务会阻塞其它微服务</strong></li>
<li><strong>某个微服务故障蔓延，可能导致整个进程不可用</strong></li>
<li><strong>低优先级的微服务，抢占高优先级微服务的资源</strong></li>
</ul>
<h4 id="1-1-3-微服务健康度"><a href="#1-1-3-微服务健康度" class="headerlink" title="1.1.3. 微服务健康度"></a>1.1.3. 微服务健康度</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传统情况下，往往使用服务注册中心检测微服务的状态，当检测到服务提供者不可用时，会<strong>将故障的服务信息广播到集群所有节点，消费者接收到服务故障通知消息之后，根据故障信息中的服务名称、IP 地址等信息，对故障节点进行隔离</strong>。它的工作原理如下所示：</p>
<p><img src="//blog.com/2019/07/26/微服务可靠性设计/f2be286c0ef860cca4637b8f96e11de7.png" alt="img"></p>
<p><em>图 1-3 微服务状态检测</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用基于心跳或者会话的微服务状态检测，可以发现微服务所在进程宕机、网络故障等问题，但在实际业务中，微服务并非“非死即活”，它可能处于“亚健康状态”，服务调用失败率很高，但又不是全部失败。或者微服务已经处于过负荷流控状态，业务质量受损，但是又没有全部中断。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用简单的微服务状态检测，很难应对上述这些场景。通过对微服务的运行质量建模，利用微服务健康度模型，根据采集的各种指标对微服务健康度实时打分，依据打分结果采取相应的可靠性对策，可以更有针对性的保障系统的可靠性。</p>
<h4 id="1-1-4-同步的-I-O-操作"><a href="#1-1-4-同步的-I-O-操作" class="headerlink" title="1.1.4. 同步的 I/O 操作"></a>1.1.4. 同步的 I/O 操作</h4><p>在整个微服务调用过程中，主要会涉及到三类<code>I/O</code>操作：</p>
<ul>
<li><strong>网络 I/O 操作</strong>，涉及到网络读写</li>
<li><strong>磁盘 I/O 操作</strong>，主要是记录日志、话单、写本地文件等</li>
<li><strong>数据库访问</strong>，例如<code>Java</code>使用 <code>JDBC</code>驱动进行数据库操作</li>
</ul>
<p><img src="//blog.com/2019/07/26/微服务可靠性设计/14ba138d1c8bf65e920024d1ee780098.png" alt="img"></p>
<p><em>图 1-4 微服务涉及的主要 I/O 操作</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;凡是涉及到<code>I/O</code>操作的，如果<code>I/O</code> 操作是同步阻塞模式，例如 <code>Java</code> 的 <code>BIO</code>、文件 <code>File</code> 的读写操作、数据库访问的<code>JDBC</code>接口等，都是同步阻塞的。只要访问的网络、磁盘或者数据库实例比较慢，都会导致调用方线程的阻塞。由于线程是<code>Java</code>虚拟机比较重要的资源，当大量微服务调用线程被阻塞之后，系统的吞吐量将严重下降。</p>
<h4 id="1-1-5-第三方-SDK-API-调用"><a href="#1-1-5-第三方-SDK-API-调用" class="headerlink" title="1.1.5. 第三方 SDK API 调用"></a>1.1.5. 第三方 SDK API 调用</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在微服务中，调用第三方<code>SDK API</code>，也可能会引入新的故障点，例如通过 <code>FTP</code> 客户端访问远端的 <code>FTP</code>服务，或者使用 <code>MQ</code> 客户端访问<code>MQ</code>服务，如果这些客户端<code>API</code>的容错性设计不好，也会导致调用方的级联故障，这些故障是潜在和隐性的，在设计的时候往往容易被忽视，但它带来的风险和危害是巨大的。</p>
<h3 id="1-2-微服务可靠性"><a href="#1-2-微服务可靠性" class="headerlink" title="1.2. 微服务可靠性"></a>1.2. 微服务可靠性</h3><p>软件可靠性是指在给定时间内，特定环境下软件无错运行的概率。软件可靠性包含了以下三个要素：</p>
<p>1) <strong>规定的时间</strong>：软件可靠性只是体现在其运行阶段，所以将运行时间作为规定的时间的度量。运行时间包括软件系统运行后工作与挂起 (启动但空闲) 的累计时间。由于软件运行的环境与程序路径选取的随机性，软件的失效为随机事件，所以运行时间属于随机变量。</p>
<p>2) <strong>规定的环境条件</strong>: 环境条件指软件的运行环境。它涉及软件系统运行时所需的各种支持要素，如支持硬件、操作系统、其它支持软件、输入数据格式和范围以及操作规程等。</p>
<p>3) <strong>规定的功能</strong>: 软件可靠性还与规定的任务和功能有关。由于要完成的任务不同，则调用的子模块就不同 (即程序路径选择不同)，其可靠性也就可能不同。所以要准确度量软件系统的可靠性必须首先明确它的任务和功能。</p>
<h4 id="1-2-1-关键的可靠性因素"><a href="#1-2-1-关键的可靠性因素" class="headerlink" title="1.2.1. 关键的可靠性因素"></a>1.2.1. 关键的可靠性因素</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微服务的运行质量，除了自身的可靠性因素之外，还受到其它因素的影响，包括网络、数据库访问、其它相关联的微服务运行质量等。微服务的可靠性设计，需要考虑上述综合因素，总结如下：</p>
<p><img src="//blog.com/2019/07/26/微服务可靠性设计/86df30068322af1b27454fa84b386dc1.png" alt="img"></p>
<p><em>图 1-5 微服务可靠性设计模型</em></p>
<h2 id="2-异步-I-O-操作"><a href="#2-异步-I-O-操作" class="headerlink" title="2. 异步 I/O 操作"></a>2. 异步 I/O 操作</h2><h3 id="2-1-网络-I-O"><a href="#2-1-网络-I-O" class="headerlink" title="2.1. 网络 I/O"></a>2.1. 网络 I/O</h3><h4 id="2-1-1-使用同步阻塞-I-O-的问题"><a href="#2-1-1-使用同步阻塞-I-O-的问题" class="headerlink" title="2.1.1. 使用同步阻塞 I/O 的问题"></a>2.1.1. 使用同步阻塞 I/O 的问题</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以 <code>Java</code>为例，在 <code>JDK 1.4</code> 推出<code>JAVA NIO1.0</code>之前，基于<code>JAVA</code> 的所有<code>Socket</code>通信都采用了同步阻塞模式（<code>BIO</code>），这种一请求一应答的通信模型简化了上层的应用开发，但是在可靠性和性能方面存在巨大的弊端：</p>
<p><img src="//blog.com/2019/07/26/微服务可靠性设计/0b84748a80126ac7da8a7f0122cb978c.png" alt="img"></p>
<p><em>2-1 传统 Java 同步阻塞 I/O 模型</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用 <code>BIO</code> 通信模型的服务端，通常由一个独立的 <code>Acceptor</code>线程负责监听客户端的连接，接收到客户端连接之后为客户端连接创建一个新的线程处理请求消息，处理完成之后，返回应答消息给客户端，线程销毁，这就是典型的一请求一应答模型。该架构最大的问题就是<strong>不具备弹性伸缩能力，当并发访问量增加后，服务端的线程个数和并发访问数成线性正比</strong>，由于线程是<code>JAVA</code>虚拟机非常宝贵的系统资源，当线程数膨胀之后，系统的性能急剧下降，随着并发量的继续增加，可能会发生<strong>句柄溢出、线程堆栈溢出</strong>等问题，并导致服务器最终宕机。</p>
<h4 id="2-1-2-使用非阻塞-I-O-通信"><a href="#2-1-2-使用非阻塞-I-O-通信" class="headerlink" title="2.1.2. 使用非阻塞 I/O 通信"></a>2.1.2. 使用非阻塞 I/O 通信</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微服务进行远程通信时，通过使用非阻塞 <code>I/O</code>，可以解决由于网络时延大、高并发接入等导致的服务端线程数膨胀或者线程被阻塞等问题。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以 <code>Java</code>为例，从 <code>JDK1.4</code>开始，<code>JDK</code> 提供了一套专门的类库支持非阻塞<code>I/O</code>，可以在 <code>java.nio</code> 包及其子包中找到相关的类和接口。<code>JDK1.7</code> 之后，又提供了 <code>NIO2.0</code> 类库，支持异步 <code>I/O</code> 操作。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用<code>JDK</code>的异步非阻塞 <code>I/O</code>，可以实现一个 <code>I/O</code> 线程同时处理多个客户端链路，读写操作不会因为网络原因被阻塞，<code>I/O</code>线程可以高效的并发处理多个客户端链路，实现 <code>I/O</code>多路复用，它的工作原理如下所示：</p>
<p><img src="//blog.com/2019/07/26/微服务可靠性设计/168d6c59aa54ac27f0ef691ca6dc9e60.png" alt="img"></p>
<p><em>2-2 Java 非阻塞 I/O 模型</em></p>
<p>使用非阻塞 <code>I/O</code>进行通信，以 <code>Java</code> 语言为例，建议策略如下：</p>
<p>1) <code>TCP</code> 私有协议：建议直接基于 <code>Netty</code>开发。</p>
<p>2)<code>HTTP/Restful/SOAP</code> 等：选择支持非阻塞<code>I/O</code>的<code>Web</code>框架。也可以选择基于 <code>Netty</code> 构建的开源应用层协议栈框架，例如支持异步 <code>Restful</code>的 <code>RestExpress</code>。</p>
<h3 id="2-2-磁盘-I-O"><a href="#2-2-磁盘-I-O" class="headerlink" title="2.2. 磁盘 I/O"></a>2.2. 磁盘 I/O</h3><p>微服务对磁盘<code>I/O</code> 的操作分为两类：</p>
<ul>
<li><strong>直接文件操作</strong>：例如调用 File 的 <code>open</code>、<code>write</code>、<code>read</code>等接口，进行文件操作。</li>
<li><strong>间接文件操作</strong>：例如调用日志类库写日志，虽然微服务并没有直接操作日志文件，但是日志类库底层还是会进行文件的读写等操作。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实际项目中，最容易被忽视的就是日志操作。不同的日志类库，写日志的机制不同，以 <code>Log4j 1.2.X</code>版本为例，当日志队列满之后，有多种策略：</p>
<ul>
<li><strong>同步等待，直到新的日志消息能够入队列，它会阻塞当前业务线程</strong>。</li>
<li><strong>丢弃当前的日志消息，不会阻塞当前业务线程</strong>。</li>
<li><strong>不入队列，由当前调用写日志的业务线程执行日志 I/O 操作，如果此时磁盘 I/O 写入速度慢，则会阻塞当前业务线程</strong>。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实际生产环境中，我们就遇到过类似问题，在某些时段，磁盘 <code>WIO</code> 达到 10+ 持续几秒钟 -10 几秒钟，然后又恢复正常。<code>WIO</code> 较高的时段，需要写接口日志、话单等，由于系统默认采用的是同步等待策略，结果导致通信<code>I/O</code> 线程、微服务调度线程等都被阻塞，最终链路因为心跳超时被强制关闭、微服务被大量阻塞在消息队列中导致内存居高不小、响应超时等。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于偶现的<code>WIO</code>高导致同步写日志被阻塞，继而引起通信线程、微服务调用线程级联故障，定位起来非常困难，平时 <code>Code Review</code>也很难被注意到。所以，<strong>隐性的磁盘<code>I/O</code>操作，更需要格外关注</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要解决上面的问题，有三种策略：</p>
<ul>
<li><strong>使用非阻塞<code>I/O</code>, 对文件进行异步读写操作</strong>。</li>
<li><strong>业务层面封装一个异步的<code>I/O</code> 操作，最简单的策略就是由一个独立的线程或者线程池来执行磁盘<code>I/O</code> 操作</strong>。</li>
<li><strong>选择支持非阻塞方式调用的<code>I/O</code>类库</strong>，例如使用 <code>log4j</code>的异步日志 <code>API</code>。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以 <code>JDK1.7</code> 为例，它提供了异步的文件<code>I/O</code> 操作类库，基于该类库，就不需要担心磁盘 I/O 操作被阻塞：</p>
<p><img src="//blog.com/2019/07/26/微服务可靠性设计/3d0ab43793e1a9f3d82ebc5b0a734622.png" alt="img"></p>
<p><em>2-3 JDK1.7 异步非阻塞文件接口</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自己在上层封装异步<code>I/O</code>操作，也比较简单，它的优点是可以实现磁盘<code>I/O</code> 操作与微服务之间的线程隔离，但是底层仍然使用的是同步阻塞<code>I/O</code>，如果此时磁盘的<code>I/O</code>比较高，依然会阻塞写磁盘的<code>I/O</code>线程。它的原理如下所示：</p>
<p><img src="//blog.com/2019/07/26/微服务可靠性设计/d4d101543d1e4d9e94ecc779cf64dc4d.png" alt="img"></p>
<p><em>2-4 应用层封装的异步文件操作</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将文件 <code>I/O</code> 操作封装成一个<code>Task</code> 或者<code>Event</code>，投递到文件<code>I/O</code>线程池的消息队列中，根据投递结果，构造<code>I/O</code>操作相关联的<code>Future</code> 对象给微服务调用线程。通过向<code>Future</code> 对象注册 <code>Listener</code> 并实现 <code>callback</code> 接口，可以实现异步回调通知，这样微服务和文件 I/O 操作就实现了线程隔离。文件 I/O 操作耗时，并不会阻塞微服务调度线程。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当使用第三方文件<code>I/O</code>操作类库时，需要注意下相关 <code>API</code>，尽量使用支持异步非阻塞接口的 <code>API</code>，如果没有，则需要考虑是否做上层的异步封装。</p>
<h3 id="2-3-数据库操作"><a href="#2-3-数据库操作" class="headerlink" title="2.3. 数据库操作"></a>2.3. 数据库操作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;部分数据库访问支持非阻塞方式，例如 <code>Oracle</code> 的 <code>OCI</code>，它支持 <code>non-blocking</code> 模式和 <code>blocking</code>模式：阻塞方式就是当调用 <code>OCI</code> 操作时，必须等到此 <code>OCI</code> 操作完成后服务器才返回客户端相应的信息，不管是成功还是失败。非阻塞方式是当客户端提交<code>OCI</code> 操作给服务器后，服务器立即返回<code>OCI_STILL_EXECUTING</code>信息，而并不等待服务端的操作完成。对于 <code>non-blocking</code>方式，应用程序若收到一个<code>OCI</code>函数的返回值为 <code>OCI_STILL_EXECUTING</code> 时必须再次对每一个 <code>OCI</code>函数的返回值进行判断，判断其成功与否。 可通过设置服务器属性为 <code>OCI_ATTR_NONBLOCKING_MODE</code>来实现。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于<code>Java</code> 语言而言，由于<code>JDK</code> 本身提供了数据库连接驱动相关的接口定义，<code>JDBC</code> 驱动本身就是同步 <code>API</code>接口，因此，<code>Java</code> 语言的开源 <code>ORM</code>框架也都是同步阻塞的，例如<code>MyBatis</code>、<code>Hibernate</code>等。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管大部分数据库访问接口是同步阻塞的，但是<strong>由于数据库中间件的超时控制机制都比较成熟，因此通过合理设置超时时间，可以避免微服务的数据库访问被长时间挂住</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也可以在应用上层封装异步数据库操作层，实现微服务调度与数据库操作的线程级隔离，采用该方式同样存在两点不足：</p>
<ul>
<li><strong>排队现象</strong>：如果某个数据库操作非常耗时，超时时间配置的又比较大（例如 30S），会导致后续的数据库操作在队列中排队。</li>
<li><strong>无法充分发挥数据库效能</strong>：由于底层数据库访问采用同步阻塞的方式，所以不能高效发挥数据库的效能。</li>
</ul>
<h2 id="3-故障隔离"><a href="#3-故障隔离" class="headerlink" title="3. 故障隔离"></a>3. 故障隔离</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于大部分微服务采用同步接口调用，而且多个领域相关的微服务会部署在同一个进程中，很容易发生“<strong>雪崩效应</strong>”，即某个微服务提供者故障，导致调用该微服务的消费者、或者与故障微服务合设在同一个进程中的其它微服务发生级联故障，最终导致系统崩溃。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了避免“雪崩效应”的发生，需要支持多种维度的依赖和故障隔离，以实现微服务的 <strong><code>HA</code></strong>。</p>
<h3 id="3-1-通信链路隔离"><a href="#3-1-通信链路隔离" class="headerlink" title="3.1. 通信链路隔离"></a>3.1. 通信链路隔离</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于网络通信本身通常不是系统的瓶颈，因此大部分服务框架会采用多线程 + 单个通信链路的方式进行通信，原理如下所示：</p>
<p><img src="//blog.com/2019/07/26/微服务可靠性设计/7c072d10523b9567a260010296b997c5.png" alt="img"></p>
<p><em>3-1 多线程 - 单链路 P2P 通信模式</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于微服务使用异步非阻塞通信，单个<code>I/O</code> 线程可以同时并发处理多个链路的消息，而且网络读写都是非阻塞的，因此采用多线程 + 单链路的方式进行通信性能本身问题不大。但是从可靠性角度来看，只支持单链路本身又存在一些可靠性隐患，我们从下面的案例中看下问题所在。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;某互联网基地微服务架构上线之后，发现在一些时段，经常有业务超时，超时的业务没有固定规律。经定位发现当有较多的批量内容同步、语音和视频类微服务调用时，系统的整体时延就增高了很多，而且存在较突出的时延毛刺。由于这些操作获取的消息码流往往达到数 M 到数十兆，微服务之间又采用单链路的方式进行<code>P2P</code>通信，导致大码流的传输影响了其它消息的读写效率，增大了微服务的响应时延。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;问题定位出来之后，对微服务之间的通信机制做了优化，节点之间支持配置多链路，每个链路之间还可以实现不同策略的隔离，例如根据消息码流大小、根据微服务的优先级等策略，实现链路级的隔离，优化之后的微服务通信机制：</p>
<p><img src="//blog.com/2019/07/26/微服务可靠性设计/52a28ac01b88d6615052756048d67f91.png" alt="img"></p>
<p><em>图 3-2 支持多链路隔离</em></p>
<h3 id="3-2-调度资源隔离"><a href="#3-2-调度资源隔离" class="headerlink" title="3.2. 调度资源隔离"></a>3.2. 调度资源隔离</h3><h4 id="3-2-1-微服务之间隔离"><a href="#3-2-1-微服务之间隔离" class="headerlink" title="3.2.1. 微服务之间隔离"></a>3.2.1. 微服务之间隔离</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当多个微服务合设运行在同一个进程内部时，可以利用线程实现不同微服务之间的隔离。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于核心微服务，发布的时候可以独占一个线程 / 线程池，对于非核心微服务，则可以共享同一个大的线程池，在实现微服务隔离的同时，避免线程过于膨胀：</p>
<p><img src="//blog.com/2019/07/26/微服务可靠性设计/f529a1047385dd2b6e405e643455a58d.png" alt="img"></p>
<p><em>图 3-3 微服务之间故障隔离</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如非核心服务 3 发生故障，长时间阻塞线程池 1 的工作线程，其它与其共用线程池消息队列的非核心服务 1 和服务 2 只能在队列中排队等待，当服务 3 释放线程之后，排队的服务 1 和服务 2 可能已经超时，只能被丢弃掉，导致业务处理失败。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用线程池隔离的核心服务 1 和服务 2，由于各自独占线程池，拥有独立的消息队列，它的执行不受发生故障的非核心服务 1 影响，因此可以继续正常工作。<strong>通过独立线程池部署核心服务，可以防止故障扩散，保障核心服务的正常运行</strong>。</p>
<h4 id="3-2-2-第三方依赖隔离"><a href="#3-2-2-第三方依赖隔离" class="headerlink" title="3.2.2. 第三方依赖隔离"></a>3.2.2. 第三方依赖隔离</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在微服务中通常会调用第三方中间件服务，例如分布式缓存服务、分布式消息队列、<code>NoSQL</code>服务等。只要调用第三方服务，就会涉及跨网络操作，由于客户端 <code>SDK API</code> 的封装，很多故障都是隐性的，因此，它的可靠性需要额外关注。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整体而言，第三方依赖隔离可以采用<strong>线程池 + 响应式编程</strong>（例如 <code>RxJava</code>）的方式实现，它的原理如下所示：</p>
<p>1) 对第三方依赖进行分类，每种依赖对应一个独立的线程 / 线程池。</p>
<p>2) 微服务不直接调用第三方依赖的<code>API</code>，而是使用异步封装之后的 <code>API</code>接口。</p>
<p>3) 异步调用第三方依赖 <code>API</code> 之后，获取<code>Future</code>对象。利用响应式编程框架，可以订阅后续的事件，接收响应，针对响应进行编程。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用 <code>Netflix</code>开源的<code>hystrix + RxJava</code>，可以快速实现第三方依赖的隔离。</p>
<h3 id="3-3-进程级隔离"><a href="#3-3-进程级隔离" class="headerlink" title="3.3. 进程级隔离"></a>3.3. 进程级隔离</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于核心的微服务，例如商品购买、用户注册、计费等，可以采用独立部署的方式，实现高可用性。</p>
<h4 id="3-3-1-容器隔离"><a href="#3-3-1-容器隔离" class="headerlink" title="3.3.1. 容器隔离"></a>3.3.1. 容器隔离</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微服务鼓励软件开发者将整个软件解耦为功能单一的服务，并且这些服务能够独立部署、升级和扩容。如果微服务抽象的足够好，那么微服务的这一优点将能够提升应用的敏捷性和自治理能力。</p>
<p>利用 <code>Docker</code> 容器部署微服务，可以带来如下几个优点：</p>
<ul>
<li>高效：<code>Docker</code>容器的启动和停止不需要几分钟，只要几百毫秒就足够了。使用<code>Docker</code>部署微服务，微服务的启动和销毁速度非常快，在高压力时，可以实现秒级弹性伸缩。</li>
<li>高性能：<code>Docker</code> 容器的性能接近裸的物理机，比<code>VM</code>平均高 20%+。</li>
<li>隔离性：利用 <code>Docker</code>，可以实现 0.1 core 的隔离。基于细粒度的资源隔离机制，可以实现高密度的部署微服务，同时实现它们之间的资源层隔离，保障微服务的可靠性。</li>
<li>可移植性：在基于虚拟机的解决方案中，应用的可移植性通常来说会受到云提供商所提供的虚拟机格式限制。如果应用程序需要部署到不同类型的虚拟机中，需要针对特定的虚拟机格式做镜像文件，新增很多额外的开发和测试工作量。<code>Docker</code>容器的设计理念是“一次编写，到处运行”，这可以使开发者避免上面这种限制。</li>
</ul>
<p>基于 <code>Docker</code> 容器部署微服务，实现物理资源层隔离示意图如下所示：</p>
<p><img src="//blog.com/2019/07/26/微服务可靠性设计/c9798be7c26a7405c3d1645e6cc958f2.png" alt="img"></p>
<p><em>图 3-4  基于 Docker 容器的微服务隔离</em></p>
<h4 id="3-3-2-VM-隔离"><a href="#3-3-2-VM-隔离" class="headerlink" title="3.3.2. VM 隔离"></a>3.3.2. VM 隔离</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了 <code>Docker</code> 容器隔离，也可以使用<code>VM</code>对微服务进行故障隔离，相比于 <code>Docker</code>容器，使用 <code>VM</code>进行微服务隔离存在如下优势：</p>
<ol>
<li>微服务的资源隔离性更好，<code>CPU</code>、内存、网络等可以实现完全的资源隔离。</li>
<li>对于已经完成硬件虚拟化的遗留系统，可以直接使用已有的 <code>VM</code>，而不需要在 <code>VM</code> 中重新部署 <code>Docker</code> 容器。</li>
</ol>
<h2 id="4-集群容错"><a href="#4-集群容错" class="headerlink" title="4. 集群容错"></a>4. 集群容错</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当微服务不可用时，需要根据预置的策略做容错处理，大部分的容错能力和策略是公共的，因此可以下沉到服务框架中实现。</p>
<h4 id="4-1-路由容错"><a href="#4-1-路由容错" class="headerlink" title="4.1. 路由容错"></a>4.1. 路由容错</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当集群环境中微服务调用失败之后，利用<strong>路由容错机制</strong>，可以在底层实现微服务的自动容错处理，提升系统的可靠性。</p>
<p>常用的容错策略包括：</p>
<ul>
<li><strong>失败自动切换机制</strong>：微服务调用失败自动切换策略指的是当发生服务调用异常时，重新选路，查找下一个可用的微服务提供者。微服务发布的时候，可以指定服务的集群容错策略。消费者可以覆盖服务提供者的通用配置，实现个性化的容错策略。</li>
<li><strong>失败回调机制</strong>：微服务调用失败之后，提供异常回调接口，执行微服务消费者自定义的失败处理逻辑。</li>
<li><strong>快速失败机制</strong>：在业务高峰期，对于一些非核心的服务，希望只调用一次，失败也不再重试，为重要的核心服务节约宝贵的运行资源。此时，快速失败是个不错的选择。快速失败策略的设计比较简单，获取到服务调用异常之后，直接忽略异常，记录异常日志。</li>
</ul>
<h4 id="4-2-服务降级"><a href="#4-2-服务降级" class="headerlink" title="4.2. 服务降级"></a>4.2. 服务降级</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大促或者业务高峰时，为了保证核心服务的 <code>SLA</code>，往往需要<strong>停掉一些不太重要的业务</strong>，例如商品评论、论坛或者粉丝积分等。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外一种场景就是<strong>某些服务因为某种原因不可用，但是流程不能直接失败，需要本地 <code>Mock</code> 服务端实现，做流程放通</strong>。以图书阅读为例，如果用户登录余额鉴权服务不能正常工作，需要做业务放通，记录消费话单，允许用户继续阅读，而不是返回失败。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过服务治理的服务降级功能，即可以满足上述两种场景的需求。</p>
<h5 id="4-2-1-强制降级"><a href="#4-2-1-强制降级" class="headerlink" title="4.2.1. 强制降级"></a>4.2.1. 强制降级</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当外界的触发条件达到某个临界值时，由运维人员 / 开发人员决策，对某类或者某个服务进行强制降级。</p>
<p>强制降级的常用策略：</p>
<ol>
<li><strong>不发起远程服务调用，直接返回空</strong>。例如： <code>mock = force: return null</code>。</li>
<li><strong>不发起远程服务调用，直接抛出指定异常</strong>。例如： <code>mock = force: throw Exception</code>。</li>
<li><strong>不发起远程服务调用，直接执行本地模拟接口实现类</strong>。例如：<code>mock = force: execute Bean: &lt;Spring beanName&gt;</code>。</li>
</ol>
<h5 id="4-2-2-容错降级"><a href="#4-2-2-容错降级" class="headerlink" title="4.2.2. 容错降级"></a>4.2.2. 容错降级</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当非核心服务不可用时，可以对故障服务做业务逻辑放通，以保障核心服务的运行。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容错降级与屏蔽降级的主要差异是：</p>
<ol>
<li><p><strong>触发条件不同</strong>：容错讲解是根据服务调用结果，自动匹配触发的；而屏蔽降级往往是通过人工根据系统运行情况手工操作触发的。</p>
</li>
<li><p><strong>作用不同</strong>：容错降级是当服务提供者不可用时，让消费者执行业务放通；屏蔽降级的主要目的是将原属于降级业务的资源调配出来供核心业务使用。</p>
</li>
<li><p><strong>调用机制不同</strong>：一个发起远程服务调用，一个只做本地调用。</p>
</li>
</ol>
<p>容错降级的常用策略如下：</p>
<ol>
<li><strong>异常转义</strong>：<code>mock = fail: throw Exception</code>。</li>
<li><strong>自定义降级逻辑</strong>：<code>mock = fail: execute Bean: &lt;beanName&gt;</code>。将异常屏蔽掉，直接执行本地模拟接口实现类，返回 <code>Mock</code> 接口的执行结果。</li>
</ol>
<h5 id="4-2-3-服务降级-Portal"><a href="#4-2-3-服务降级-Portal" class="headerlink" title="4.2.3. 服务降级 Portal"></a>4.2.3. 服务降级 Portal</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用服务治理 <code>Portal</code>，可以在线的动态修改微服务的降级策略，实时生效，它的界面如下所示：</p>
<p><img src="//blog.com/2019/07/26/微服务可靠性设计/588ef837f15fd14ac0df4cb68dc94a18.png" alt="img"></p>
<p><em>图 4-1 服务降级配置界面</em></p>
<h4 id="4-3-熔断机制"><a href="#4-3-熔断机制" class="headerlink" title="4.3. 熔断机制"></a>4.3. 熔断机制</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;熔断机制（<code>Circuit Breaker</code>），也叫自动停盘机制，是指当股指波幅达到规定的熔断点时，交易所为控制风险采取的暂停交易措施。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在微服务领域，熔断机制是从消费端保护微服务提供者的措施，当微服务的运行质量低于某个临界值时，启动熔断机制，暂停微服务调用一段时间，以保障后端的微服务不会因为持续过负荷而宕机</strong>。</p>
<h5 id="4-3-1-工作原理"><a href="#4-3-1-工作原理" class="headerlink" title="4.3.1. 工作原理"></a>4.3.1. 工作原理</h5><p>微服务的熔断机制原理如下所示：</p>
<ol>
<li>微服务调用时，对熔断开关状态进行判断，当熔断器开关关闭时, 请求被允许通过熔断器。如果当前微服务健康度高于指定阈值, 开关继续保持关闭。否则开关切换为打开状态。</li>
<li>当熔断器开关打开时，微服务调用请求被禁止通过。调用失败，执行本地降级逻辑，如果没有实现降级逻辑，默认返回异常。</li>
<li>当熔断器开关处于打开状态时, 经过指定周期 T, 熔断器会自动进入半开状态, 这时熔断器会允许请求通过，当请求调用成功时, 熔断器恢复到关闭状态。若失败, 则继续保持打开状态。</li>
</ol>
<p>它的工作原理示意如下：</p>
<p><img src="//blog.com/2019/07/26/微服务可靠性设计/8380367f71011ef1b712adfcd416443a.png" alt="img"></p>
<p><em>图 4-2 微服务熔断器工作原理</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>熔断器机制能保证微服务消费者在微服务运行状态不佳时，快速返回结果，避免大量的同步等待</strong>。并且能在指定周期 T 后继续侦测微服务是否可用, 以实现故障恢复之后的自动感知。</p>
<h5 id="4-3-2-微服务健康度"><a href="#4-3-2-微服务健康度" class="headerlink" title="4.3.2. 微服务健康度"></a>4.3.2. 微服务健康度</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;熔断器开关的状态取决于微服务的运行质量，微服务的运行质量通常由多种因素决定，具有多个衡量因子。通过对微服务健康度建模，可以实现对微服务运行质量的 360°实时评估。</p>
<p>微服务健康度模型如下所示：</p>
<p><img src="//blog.com/2019/07/26/微服务可靠性设计/a18f45559ca3aaf1462f728c7708371a.png" alt="img"></p>
<p><em>图 4-3 微服务健康度模型</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微服务运维体系通过分布式日志采集系统、告警系统、性能 <code>KPI</code>数据采集等，利用在线大数据实时分析技术，通过健康度模型，对微服务的健康度按照周期进行实时打分，同时<strong>将微服务的得分通过消息队列订阅发布出去，各个节点订阅微服务的健康度得分，与熔断器阈值进行比较，修改熔断器开关的状态</strong>。</p>
<h2 id="5-流量控制"><a href="#5-流量控制" class="headerlink" title="5. 流量控制"></a>5. 流量控制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当资源成为瓶颈时，服务框架需要对消费者做限流，启动流控保护机制。流量控制有多种策略，比较常用的有：针对访问速率的静态流控、针对资源占用的动态流控等。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实践中，各种流量控制策略需要综合使用才能起到较好的效果。</p>
<h3 id="5-1-动态流控"><a href="#5-1-动态流控" class="headerlink" title="5.1. 动态流控"></a>5.1. 动态流控</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;动态流控的最终目标是为了保命，并不是对流量或者访问速度做精确控制。当系统负载压力非常大时，系统进入过负载状态，可能是 <code>CPU</code>、内存资源已经过载，也可能是应用进程内部的资源几乎耗尽，如果继续全量处理业务，可能会导致消息严重积压或者应用进程宕机。</p>
<p>动态流控检测的资源包括：</p>
<ul>
<li><p><strong>CPU 使用率</strong>。</p>
</li>
<li><p><strong>内存使用率</strong>（对于 <code>Java</code>，主要是<code>JVM</code>内存使用率）。</p>
</li>
<li><p><strong>队列积压率</strong>。</p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主机 <code>CPU</code>、内存使用率采集算法非常多，例如使用<code>java.lang.Process</code>执行 <code>top</code>、<code>sar</code>等外部命令获取系统资源使用情况，然后解析后计算获得资源使用率。也可以直接读取操作系统的系统文件获取相关数据，需要注意的是，无论是执行操作系统的本地命令，还是直接读取操作系统的资源使用率文件，都是操作系统本地相关的，不同的操作系统和服务器，命令和输出格式可能存在很大差异。在计算时需要首先判断操作系统类型，然后调用相关操作系统的资源采集接口实现类，通过这种方式就可以支持跨平台。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>动态流控是分级别的，不同级别拒掉的消息比例不同，这取决于资源的负载使用情况</strong>。例如当发生一级流控时，拒绝掉 1/4 的消息；发生二级流控时，拒绝掉 1/2 消息；发生三级流控时，所有的消息都被流控掉。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不同的级别有不同的流控阈值，系统上线后会提供默认的；流控阈值，不同流控因子的流控阈值不同，业务上线之后通常会根据现场的实际情况做阈值调优，因此<strong>流控阈值需要支持在线修改和动态生效</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要指出的是<strong>为了防止系统波动导致的偶发性流控，无论是进入流控状态还是从流控状态恢复，都需要连续采集 N 次并计算平均值，如果连续 N 次平均值大于流控阈值，则进入流控状态；同理，只有连续 N 次资源使用率平均值低于流控阈值，才能脱离流控恢复正常</strong>。</p>
<h3 id="5-2-静态流控"><a href="#5-2-静态流控" class="headerlink" title="5.2. 静态流控"></a>5.2. 静态流控</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>静态流控主要针对客户端访问速率进行控制，它通常根据服务质量等级协定（<code>SLA</code>）中约定的 <code>QPS</code> 做全局流量控制</strong>，例如计费服务的静态流控阈值为 200 <code>QPS</code>，则无论集群有多少个计费服务实例，它们总的处理速率之和不能超过 200 <code>QPS</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于微服务具备弹性伸缩、动态上线和下线等特性，因此集群中某个微服务实例的节点个数是动态变化的，采用传统的平均分配制无法做到精准的控制。</p>
<p>在实践中，比较成熟的集群静态流控策略是动态配额申请制，它的工作原理如下：</p>
<ol>
<li>系统部署的时候，根据微服务节点数和静态流控<code>QPS</code>阈值，拿出一定比例的配额做初始分配，剩余的配额放在配额资源池中。</li>
<li>哪个微服务节点使用完了配额，就主动向服务注册中心申请配额。配额的申请策略：如果流控周期为 T，则将周期 T 分成更小的周期 T/N（N 为经验值，默认值为 10），当前的服务节点数为 M 个，则申请的配额为 （总 QPS 配额 - 已经分配的 QPS 配额）/M * T/N。</li>
<li>总的配额如果被申请完，则返回 0 配额给各个申请配额的服务节点，服务节点对新接入的请求消息进行流控。</li>
</ol>
<h3 id="5-3-用户自定义流控机制"><a href="#5-3-用户自定义流控机制" class="headerlink" title="5.3. 用户自定义流控机制"></a>5.3. 用户自定义流控机制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不同的业务，存在不同的流控策略，例如基于微服务优先级的流控、基于节假日的流控、基于业务字段的流控等。底层的服务框架无法实现所有业务级的定制流控策略，因此，过于业务化的流控往往由业务通过自定义流控机制定制实现。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>服务框架提供服务调用入口的拦截点和切面接口，由业务实现自定义流控</strong>。也可以提供基础的流控框架，供业务实现流控条件判断、流控执行策略等，简化业务的定制工作量。</p>
<h2 id="6-使用-Hystrix-提升微服务可靠性"><a href="#6-使用-Hystrix-提升微服务可靠性" class="headerlink" title="6. 使用 Hystrix 提升微服务可靠性"></a>6. 使用 Hystrix 提升微服务可靠性</h2><h3 id="6-1-Hystrix-简介"><a href="#6-1-Hystrix-简介" class="headerlink" title="6.1. Hystrix 简介"></a>6.1. Hystrix 简介</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Hystrix</code>是 <code>Netflix</code>开源的一个可靠性组件，主要用于分布式环境中的依赖解耦，<code>Hystrix library</code>通过添加延迟容忍和容错逻辑来控制分布式服务之间的相互影响，通过服务之间访问的隔离点阻止连锁故障，并提供了失败回调机制，来改进系统的可靠性。</p>
<p><code>Hystrix</code> 提供如下机制来提升分布式系统的可靠性：</p>
<ul>
<li>保护通过第三方客户端 <code>API</code> 依赖访问，控制其延迟和故障</li>
<li>阻止级联故障和“雪崩效应”</li>
<li>提供熔断机制，快速失败和恢复</li>
<li>失败回调和优雅降级机制</li>
<li>近实时检测、报警和<code>KPI</code>指标展示</li>
</ul>
<h3 id="6-2-Hystrix-的核心功能"><a href="#6-2-Hystrix-的核心功能" class="headerlink" title="6.2. Hystrix 的核心功能"></a>6.2. Hystrix 的核心功能</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Hystrix</code> 提供了一些非常有价值、与具体微服务框架实现无关的特性，方便不同的分布式系统集成使用。</p>
<h4 id="6-2-1-依赖隔离"><a href="#6-2-1-依赖隔离" class="headerlink" title="6.2.1. 依赖隔离"></a>6.2.1. 依赖隔离</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Hystrix</code>使用命令模式 <code>HystrixCommand(Command)</code> 包装依赖调用逻辑，每个命令在单独线程 / 信号授权下执行。依赖调用的超时时间可配置，如果超时，则则返回失败或者执行 <code>fallback</code> 逻辑。原理如下所示：</p>
<p><img src="//blog.com/2019/07/26/微服务可靠性设计/34760c813b6285a9c650b45df91568e2.png" alt="img"></p>
<p><em>图 6-1 基于线程 / 信号的依赖隔离</em></p>
<h4 id="6-2-2-熔断器"><a href="#6-2-2-熔断器" class="headerlink" title="6.2.2. 熔断器"></a>6.2.2. 熔断器</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Hystrix</code>会先经过熔断器，此时如果熔断器的状态是打开，则说明已经熔断，这时将直接进行降级处理，不会继续将请求发到线程池。</p>
<p>熔断器的开关状态由熔断算法决定，它的原理如下：</p>
<ul>
<li>判断是否熔断：根据 <code>bucket</code>中记录的次数，计算错误率。如果错误率达到熔断预置的阈值，则开启熔断开关。</li>
<li>熔断恢复：对于被熔断的请求，暂停处理一段时间之后（<code>HystrixCommandProperties.circuitBreakerSleepWindowInMilliseconds()</code>），允许单个请求通过，若请求成功，则取消熔断，否则，继续熔断。</li>
</ul>
<p><code>Hystrix</code> 熔断器的工作原理如下所示：</p>
<p><img src="//blog.com/2019/07/26/微服务可靠性设计/c39acbafbe4df9ece2815c274a3b8ca3.png" alt="img"></p>
<p><em>图 6-2 Hystrix 熔断机制</em></p>
<h4 id="6-2-3-优雅降级"><a href="#6-2-3-优雅降级" class="headerlink" title="6.2.3. 优雅降级"></a>6.2.3. 优雅降级</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当微服务调用异常、超时，或者熔断时，可以通过回调 <code>Fallback（）</code>的方式实现业务的优雅降级，它的原理如下所示：</p>
<p><img src="//blog.com/2019/07/26/微服务可靠性设计/d201f40c066e6fa7bb039fe1b7ebaca3.png" alt="img"></p>
<p><em>图 6-3 Hystrix 优雅降级机制</em></p>
<h4 id="6-2-4-Reactive-编程"><a href="#6-2-4-Reactive-编程" class="headerlink" title="6.2.4. Reactive 编程"></a>6.2.4. Reactive 编程</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Hystrix</code>支持响应式编程，并提供了相关接口给用户，如下所示：</p>
<p><img src="//blog.com/2019/07/26/微服务可靠性设计/0e60773432e6cc5242095411398918d3.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用响应式编程，可以更加优雅和灵活的实现异步回调逻辑的处理。</p>
<h4 id="6-2-5-信号量隔离"><a href="#6-2-5-信号量隔离" class="headerlink" title="6.2.5. 信号量隔离"></a>6.2.5. 信号量隔离</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了降低线程资源的开销，<code>Hystrix</code>提供了信号量 <code>Semaphores</code>，用于实现轻量级的依赖隔离。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开发者可以限制系统对某一个依赖的最高并发数，这个基本上等同于并发流控策略。每次微服务调用依赖时都会检查一下是否到达信号量的限制值，如达到则拒绝。该隔离策略的优点是不新起线程，减少上下文切换和线程数，缺点是无法配置断路，每次都一定会去尝试获取信号量。</p>
<h3 id="6-3-集成-Hystrix"><a href="#6-3-集成-Hystrix" class="headerlink" title="6.3. 集成 Hystrix"></a>6.3. 集成 Hystrix</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 <code>Hystrix</code>与特定的分布式系统、微服务框架无关，是个通用的分布式系统可靠性组件，可以通过类库集成的方式方便的集成到已有的微服务架构体系中。</p>
<h4 id="6-3-1-集成架构"><a href="#6-3-1-集成架构" class="headerlink" title="6.3.1. 集成架构"></a>6.3.1. 集成架构</h4><p>在已有微服务体系中集成 <code>Hystrix</code> 的策略如下：</p>
<ol>
<li>微服务框架中，对于通用的微服务调用、磁盘 I/O 操作、数据库操作和网络 I/O 操作等使用 <code>HystrixCommand</code> 做一层异步包装，实现业务的微服务调用线程和第三方依赖的线程隔离。</li>
<li>对于非通用的第三方依赖，或者业务微服务自身引入的第三方依赖，直接基于 <code>HystrixCommand</code>做异步隔离。</li>
<li>对第三方依赖进行分类、分组管理，根据依赖的特点设置熔断策略、优雅降级策略、超时策略等，以实现差异化的处理。</li>
</ol>
<p>集成架构示例如下：</p>
<p><img src="//blog.com/2019/07/26/微服务可靠性设计/a2a23e1c242c6e16fc700e694a20cff7.png" alt="img"></p>
<p><em>图 6-4  集成 Hystrix 的微服务架构</em></p>
<h4 id="6-3-2-集成-Hystrix-带来的优点"><a href="#6-3-2-集成-Hystrix-带来的优点" class="headerlink" title="6.3.2. 集成 Hystrix 带来的优点"></a>6.3.2. 集成 Hystrix 带来的优点</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三方依赖隔离具备一定的通用性，例如数据库隔离、磁盘 I/O 隔离、第三方服务调用隔离等，如果各自构建一套隔离机制，除了增加工作量之外，后续维护起来也比较麻烦。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，业务微服务自身也会引入第三方依赖，如果没有通用的隔离机制，则业务需要自己构建业务级的隔离体系，相应的开发难度和工作量都较大，架构上也很难统一。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;集成 <code>Hystrix</code>，可以快速的构建微服务的隔离、熔断、优雅降级和响应式编程体系，提升系统的可靠性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，<code>Hystrix</code> 非常成熟，在 <code>Netflix</code> 已经经历过苛刻的生产环境考验，它的可靠性和成熟度完全能够满足大部分业务场景的需要。</p>
<h2 id="7-附录"><a href="#7-附录" class="headerlink" title="7. 附录"></a>7. 附录</h2><h3 id="7-1-参考文献"><a href="#7-1-参考文献" class="headerlink" title="7.1. 参考文献"></a>7.1. 参考文献</h3><p>Netflix Hystrix.</p>
<p><a href="https://github.com/Netflix/Hystrix/wiki/How-To-Use" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/wiki/How-To-Use</a></p>
<p><a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/wiki/How-it-Works</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/07/25/分布式系统原理介绍/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/25/分布式系统原理介绍/" itemprop="url">分布式系统原理介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-25T12:12:57+08:00">
                2019-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/分布式系统/" itemprop="url" rel="index">
                    <span itemprop="name">分布式系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分布式系统原理介绍"><a href="#分布式系统原理介绍" class="headerlink" title="分布式系统原理介绍"></a>分布式系统原理介绍</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="http://guanzhou.pub/2018/06/04/Distributed/" target="_blank" rel="noopener">http://guanzhou.pub/2018/06/04/Distributed/</a></p>
</blockquote>
<p><br></p>
<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><h3 id="1-1-模型"><a href="#1-1-模型" class="headerlink" title="1.1 模型"></a>1.1 模型</h3><h4 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h4><p>在具体的工程项目中，一个节点往往是一个操作系统上的进程。在本文的模型中，认为节点是一个完整的、不可分的整体，如果某个程序进程实际上由若干相对独立部分构成，则在模型中可以将一个进程划分为多个节点。</p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><ol>
<li><strong>机器宕机</strong>：机器宕机是最常见的异常之一。在大型集群中每日宕机发生的概率为千分之一左右，在实践中，一台宕机的机器恢复的时间通常认为是24 小时，一般需要人工介入重启机器。</li>
<li><strong>网络异常</strong>：消息丢失，两片节点之间彼此完全无法通信，即出现了“网络分化”；消息乱序，有一定的概率不是按照发送时的顺序依次到达目的节点，考虑使用序列号等机制处理网络消息的乱序问题，使得无效的、过期的网络消息不影响系统的正确性；数据错误；不可靠的TCP，TCP 协议为应用层提供了可靠的、面向连接的传输服务，但在分布式系统的协议设计中不能认为所有网络通信都基于TCP 协议则通信就是可靠的。TCP协议只能保证同一个TCP 链接内的网络消息不乱序，TCP 链接之间的网络消息顺序则无法保证。</li>
<li><strong>分布式三态</strong>：如果某个节点向另一个节点发起RPC(Remote procedure call)调用，即某个节点A 向另一个节点B 发送一个消息，节点B 根据收到的消息内容完成某些操作，并将操作的结果通过另一个消息返回给节点A，那么这个RPC 执行的结果有三种状态：“成功”、“失败”、“超时（未知）”，称之为分布式系统的三态。</li>
<li><strong>存储数据丢失</strong>:对于有状态节点来说，数据丢失意味着状态丢失，通常只能从其他节点读取、恢复存储的状态。</li>
<li><strong>异常处理原则</strong>：被大量工程实践所检验过的异常处理黄金原则是：任何在设计阶段考虑到的异常情况一定会在系统实际运行中发生，但在系统实际运行遇到的异常却很有可能在设计时未能考虑，所以，除非需求指标允许，在系统设计时不能放过任何异常情况。</li>
</ol>
<h3 id="1-2-副本"><a href="#1-2-副本" class="headerlink" title="1.2 副本"></a>1.2 副本</h3><p>副本（replica/copy）指在分布式系统中为数据或服务提供的冗余。对于数据副本指在不同的节点上持久化同一份数据，当出现某一个节点的存储的数据丢失时，可以从副本上读到数据。数据副本是分布式系统解决数据丢失异常的唯一手段。另一类副本是服务副本，指数个节点提供某种相同的服务，这种服务一般并不依赖于节点的本地存储，其所需数据一般来自其他节点。</p>
<p>副本协议是贯穿整个分布式系统的理论核心。</p>
<h4 id="副本一致性"><a href="#副本一致性" class="headerlink" title="副本一致性"></a>副本一致性</h4><p>分布式系统通过副本控制协议，使得从系统外部读取系统内部各个副本的数据在一定的约束条件下相同，称之为副本一致性(consistency)。副本一致性是针对分布式系统而言的，不是针对某一个副本而言。</p>
<ol>
<li><strong>强一致性(strong consistency)</strong>：任何时刻任何用户或节点都可以读到最近一次成功更新的副本数据。强一致性是程度最高的一致性要求，也是实践中最难以实现的一致性。</li>
<li><strong>单调一致性(monotonic consistency)</strong>：任何时刻，任何用户一旦读到某个数据在某次更新后的值，这个用户不会再读到比这个值更旧的值。单调一致性是弱于强一致性却非常实用的一种一致性级别。因为通常来说，用户只关心从己方视角观察到的一致性，而不会关注其他用户的一致性情况。</li>
<li><strong>会话一致性(session consistency)</strong>：任何用户在某一次会话内一旦读到某个数据在某次更新后的值，这个用户在这次会话过程中不会再读到比这个值更旧的值。会话一致性通过引入会话的概念，在单调一致性的基础上进一步放松约束，会话一致性只保证单个用户单次会话内数据的单调修改，对于不同用户间的一致性和同一用户不同会话间的一致性没有保障。实践中有许多机制正好对应会话的概念，例如php 中的session 概念。</li>
<li><strong>最终一致性(eventual consistency)</strong>：最终一致性要求一旦更新成功，各个副本上的数据最终将达 到完全一致的状态，但达到完全一致状态所需要的时间不能保障。对于最终一致性系统而言，一个 用户只要始终读取某一个副本的数据，则可以实现类似单调一致性的效果，但一旦用户更换读取的 副本，则无法保障任何一致性。</li>
<li><strong>弱一致性(week consistency)</strong>：一旦某个更新成功，用户无法在一个确定时间内读到这次更新的 值，且即使在某个副本上读到了新的值，也不能保证在其他副本上可以读到新的值。弱一致性系统 一般很难在实际中使用，使用弱一致性系统需要应用方做更多的工作从而使得系统可用。</li>
</ol>
<h3 id="1-3-衡量分布式系统的指标"><a href="#1-3-衡量分布式系统的指标" class="headerlink" title="1.3 衡量分布式系统的指标"></a>1.3 衡量分布式系统的指标</h3><ol>
<li><strong>性能</strong>：系统的吞吐能力，指系统在某 一时间可以处理的数据总量，通常可以用系统每秒处理的总的数据量来衡量；系统的响应延迟，指 系统完成某一功能需要使用的时间；系统的并发能力，指系统可以同时完成某一功能的能力，通常 也用QPS(query per second)来衡量。上述三个性能指标往往会相互制约，追求高吞吐的系统，往往 很难做到低延迟；系统平均响应时间较长时，也很难提高QPS。</li>
<li><strong>可用性</strong>：系统的可用性(availability)指系统在面对各种异常时可以正确提供服务的能力。系统的可用性可 以用系统停服务的时间与正常服务的时间的比例来衡量，也可以用某功能的失败次数与成功次数的 比例来衡量。可用性是分布式的重要指标，衡量了系统的鲁棒性，是系统容错能力的体现。</li>
<li><strong>可扩展性</strong>： 系统的可扩展性(scalability)指分布式系统通过扩展集群机器规模提高系统性能（吞吐、延迟、 并发）、存储容量、计算能力的特性。 好的分布式系统总在追求“线性扩 展性”，也就是使得系统的某一指标可以随着集群中的机器数量线性增长。</li>
<li><strong>一致性</strong>： 分布式系统为了提高可用性，总是不可避免的使用副本的机制，从而引发副本一致性的问题。 越是强的一致的性模型，对于用户使用来说使用起来越简单。</li>
</ol>
<h2 id="2-分布式系统原理"><a href="#2-分布式系统原理" class="headerlink" title="2 分布式系统原理"></a>2 分布式系统原理</h2><h3 id="2-1-数据分布方式"><a href="#2-1-数据分布方式" class="headerlink" title="2.1 数据分布方式"></a>2.1 数据分布方式</h3><p>所谓分布式系统顾名思义就是利用多台计算机协同解决单台计算机所不能解决的计算、存储等 问题。单机系统与分布式系统的最大的区别在于问题的规模，即计算、存储的数据量的区别。将一 个单机问题使用分布式解决，首先要解决的就是如何将问题拆解为可以使用多机分布式解决，使得 分布式系统中的每台机器负责原问题的一个子集。由于无论是计算还是存储，其问题输入对象都是 数据，所以如何拆解分布式系统的输入数据成为分布式系统的基本问题。</p>
<h4 id="哈希方式"><a href="#哈希方式" class="headerlink" title="哈希方式"></a>哈希方式</h4><p><img src="//blog.com/2019/07/25/分布式系统原理介绍/WX20180605-212819@2x.png" alt="img"></p>
<p>哈希分布数据的缺点同样明显，突出表现为可扩展性不高，一旦集群规模需要扩展，则几乎所 有的数据需要被迁移并重新分布。工程中，扩展哈希分布数据的系统时，往往使得集群规模成倍扩 展，按照数据重新计算哈希，这样原本一台机器上的数据只需迁移一半到另一台对应的机器上即可 完成扩展。</p>
<p>针对哈希方式扩展性差的问题，一种思路是不再简单的将哈希值与机器做除法取模映射，而是 将对应关系作为元数据由专门的元数据服务器管理.同时，哈希值取模个数往往大于机器个数，这样同一台机器上需 要负责多个哈希取模的余数。但需要以较复杂的机制维护大量的元数据。哈希分布数据的另一个缺点是，一旦某数据特征值的数据严重不均，容易出现“数据倾斜”（data skew）问题。</p>
<p>哈希分布数据的另一个缺点是，一旦某数据特征值的数据严重不均，容易出现“数据倾斜”（data skew）问题</p>
<p><img src="//blog.com/2019/07/25/分布式系统原理介绍/2.png" alt="img"></p>
<h4 id="按数据范围分布"><a href="#按数据范围分布" class="headerlink" title="按数据范围分布"></a>按数据范围分布</h4><p>按数据范围分布是另一个常见的数据分布式，将数据按特征值的值域范围划分为不同的区间， 使得集群中每台（组）服务器处理不同区间的数据。</p>
<p><img src="//blog.com/2019/07/25/分布式系统原理介绍/3.png" alt="img"></p>
<p>工程中，为了数据迁移等负载均衡操作的方便， 往往利用动态划分区间的技术，使得每个区间中服务的数据量尽量的一样多。当某个区间的数据量 较大时，通过将区间“分裂”的方式拆分为两个区间，使得每个数据区间中的数据量都尽量维持在 一个较为固定的阈值之下。</p>
<p>一般的，往往需要使用专门的服务器在内存中维护数据分布信息， 称这种数据的分布信息为一种元信息。甚至对于大规模的集群，由于元信息的规模非常庞大，单台 计算机无法独立维护，需要使用多台机器作为元信息服务器。</p>
<h4 id="按数据量分布"><a href="#按数据量分布" class="headerlink" title="按数据量分布"></a>按数据量分布</h4><p>数据量分布数据与具体的数据特征无关，而是将数据视为一个顺序增长的文件，并将这个文件按照某 一较为固定的大小划分为若干数据块（chunk），不同的数据块分布到不同的服务器上。与按数据范 围分布数据的方式类似的是，按数据量分布数据也需要记录数据块的具体分布情况，并将该分布信 息作为元数据使用元数据服务器管理。</p>
<p>由于与具体的数据内容无关，按数据量分布数据的方式一般没有数据倾斜的问题，数据总是被 均匀切分并分布到集群中。当集群需要重新负载均衡时，只需通过迁移数据块即可完成。集群扩容 也没有太大的限制，只需将部分数据库迁移到新加入的机器上即可以完成扩容。按数据量划分数据 的缺点是需要管理较为复杂的元信息，与按范围分布数据的方式类似，当集群规模较大时，元信息 的数据量也变得很大，高效的管理元信息成为新的课题。</p>
<h4 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h4><p>一致性哈希（consistent hashing）是另一个种在工程中使用较为广泛的数据分布方式。一致性哈 希最初在P2P 网络中作为分布式哈希表（DHT）的常用数据分布算法。一致性哈希的基本方式是使 用一个哈希函数计算数据或数据特征的哈希值，令该哈希函数的输出值域为一个封闭的环，即哈希 函数输出的最大值是最小值的前序。将节点随机分布到这个环上，每个节点负责处理从自己开始顺 时针至下一个节点的全部哈希值域上的数据。</p>
<p><img src="//blog.com/2019/07/25/分布式系统原理介绍/4.png" alt="img"></p>
<p>使用一致性哈希的方式需要将节点在一致性哈希环上的位置作为元信息加以管理，这点比直接 使用哈希分布数据的方式要复杂。然而，节点的位置信息只于集群中的机器规模相关，其元信息的 量通常比按数据范围分布数据和按数据量分布数据的元信息量要小很多。</p>
<p>为此一种常见的改进算法是引入虚节点（virtual node）的概念，系统初始时就创建许多虚节点， 虚节点的个数一般远大于未来集群中机器的个数，将虚节点均匀分布到一致性哈希值域环上，其功 能与基本一致性哈希算法中的节点相同。为每个节点分配若干虚节点。操作数据时，首先通过数据 的哈希值在环上找到对应的虚节点，进而查找元数据找到对应的真实节点。使用虚节点改进有多个 优点。首先，一旦某个节点不可用，该节点将使得多个虚节点不可用，从而使得多个相邻的真实节 点负载失效节点的压里。同理，一旦加入一个新节点，可以分配多个虚节点，从而使得新节点可以 负载多个原有节点的压力，从全局看，较容易实现扩容时的负载均衡。</p>
<h4 id="副本与数据分布"><a href="#副本与数据分布" class="headerlink" title="副本与数据分布"></a>副本与数据分布</h4><p>分布式系统容错、提高可用性的基本手段就是使用副本。对于数据副本的分布方式主要影响系统的可扩展性。 一种基本的数据副本策略是以机器为单位，若干机器互为副本，副本机器之间的数据完全相同。 这种策略适用于上述各种数据分布方式。其优点是非常简单，其缺点是恢复数据的效率不高、可扩 展性也不高。</p>
<p>更合适的做法不是以机器作为副本单位，而是将数据拆为较合理的数据段，以数据段为单位作 为副本。实践中，常常使得每个数据段的大小尽量相等且控制在一定的大小以内。数据段有很多不 同的称谓，segment，fragment，chunk，partition 等等。数据段的选择与数据分布方式直接相关。对 于哈希分数据的方式，每个哈希分桶后的余数可以作为一个数据段，为了控制数据段的大小，常常 使得分桶个数大于集群规模。 一旦将数据分为数据段，则可以以数据段为单位管理副本，从而副本与机器不再硬相关，每台 机器都可以负责一定数据段的副本。</p>
<p><img src="//blog.com/2019/07/25/分布式系统原理介绍/5.png" alt="img"></p>
<p>一旦副本分布与机器无关，数据丢失后的恢复效率将非常高。这是因为，一旦某台机器的数据 丢失，其上数据段的副本将分布在整个集群的所有机器中，而不是仅在几个副本机器中，从而可以 从整个集群同时拷贝恢复数据，而集群中每台数据源机器都可以以非常低的资源做拷贝。作为恢复 数据源的机器即使都限速1MB/s，若有100 台机器参与恢复，恢复速度也能达到100MB/s。再者， 副本分布与机器无关也利于集群容错。如果出现机器宕机，由于宕机机器上的副本分散于整个集群， 其压力也自然分散到整个集群。最后，副本分布与机器无关也利于集群扩展。理论上，设集群规模 为N 台机器，当加入一台新的机器时，只需从各台机器上迁移1/N – 1/N+1 比例的数据段到新机器 即实现了新的负载均衡。由于是从集群中各机器迁移数据，与数据恢复同理，效率也较高。 工程中，完全按照数据段建立副本会引起需要管理的元数据的开销增大，副本维护的难度也相 应增大。一种折中的做法是将某些数据段组成一个数据段分组，按数据段分组为粒度进行副本管理。 这样做可以将副本粒度控制在一个较为合适的范围内。</p>
<h4 id="本地化计算"><a href="#本地化计算" class="headerlink" title="本地化计算"></a>本地化计算</h4><p>在分布式系统中， 数据的分布方式也深深影响着计算的分布方式。 在分布式系统中计算节点和保存计算数据的存储节点可以在同一台物理机器上，也可以位于不 同的物理机器。如果计算节点和存储节点位于不同的物理机器则计算的数据需要通过网络传输，此 种方式的开销很大，甚至网络带宽会成为系统的总体瓶颈。另一种思路是，将计算尽量调度到与存 储节点在同一台物理机器上的计算节点上进行，这称之为本地化计算。本地化计算是计算调度的一 种重要优化，其体现了一种重要的分布式调度思想：“移动数据不如移动计算”。</p>
<h4 id="数据分布方式的选择"><a href="#数据分布方式的选择" class="headerlink" title="数据分布方式的选择"></a>数据分布方式的选择</h4><p>在实际工程实践中，可以根据需求 及实施复杂度合理选择数据分布方式。另外，数据分布方式是可以灵活组合使用的，往往可 以兼备各种方式的优点，收到较好的综合效果。</p>
<p>例：数据倾斜问题，在按哈希分数据的基础上引入按数据量分布 数据的方式，解决该数据倾斜问题。按用户id 的哈希值分数据，当某个用户id 的数据量特别大时， 该用户的数据始终落在某一台机器上。此时，引入按数据量分布数据的方式，统计用户的数据量， 并按某一阈值将用户的数据切为多个均匀的数据段，将这些数据段分布到集群中去。由于大部分用 户的数据量不会超过阈值，所以元数据中仅仅保存超过阈值的用户的数据段分布信息，从而可以控 制元数据的规模。这种哈希分布数据方式与按数据量分布数据方式组合使用的方案，在某真实系统 中使用，取得了较好的效果。</p>
<h3 id="2-2-基本副本协议"><a href="#2-2-基本副本协议" class="headerlink" title="2.2 基本副本协议"></a>2.2 基本副本协议</h3><p>副本控制协议指按特定的协议流程控制副本数据的读写行为，使得副本满足一定的可用性和一 致性要求的分布式协议。副本控制协议要具有一定的对抗异常状态的容错能力，从而使得系统具有 一定的可用性，同时副本控制协议要能提供一定一致性级别。由CAP 原理（在2.9 节详细分析）可 知，要设计一种满足强一致性，且在出现任何网络异常时都可用的副本协议是不可能的。为此，实 际中的副本控制协议总是在可用性、一致性与性能等各要素之间按照具体需求折中。</p>
<p>副本控制协议可以分为两大类：“中心化(centralized)副本控制协议”和“去中心化(decentralized) 副本控制协议”。</p>
<h4 id="中心化副本控制协议"><a href="#中心化副本控制协议" class="headerlink" title="中心化副本控制协议"></a>中心化副本控制协议</h4><p>中心化副本控制协议的基本思路是由一个中心节点协调副本数据的更新、维护副本之间的一致 性。图给出了中心化副本协议的通用架构。中心化副本控制协议的优点是协议相对较为简单， 所有的副本相关的控制交由中心节点完成。并发控制将由中心节点完成，从而使得一个分布式并发 控制问题，简化为一个单机并发控制问题。所谓并发控制，即多个节点同时需要修改副本数据时， 需要解决“写写”、“读写”等并发冲突。单机系统上常用加锁等方式进行并发控制。对于分布式并 发控制，加锁也是一个常用的方法，但如果没有中心节点统一进行锁管理，就需要完全分布式化的 锁系统，会使得协议非常复杂。中心化副本控制协议的缺点是系统的可用性依赖于中心化节点，当 中心节点异常或与中心节点通信中断时，系统将失去某些服务（通常至少失去更新服务），所以中心 化副本控制协议的缺点正是存在一定的停服务时间。</p>
<p><img src="//blog.com/2019/07/25/分布式系统原理介绍/6.png" alt="img"></p>
<h4 id="primary-secondary-协议"><a href="#primary-secondary-协议" class="headerlink" title="primary-secondary 协议"></a>primary-secondary 协议</h4><p>在primary-secondary 类型的协议中，副本被分为两大类，其中有且仅有一个副本作为primary 副本， 除primary 以外的副本都作为secondary 副本。维护primary 副本的节点作为中心节点，中心节点负 责维护数据的更新、并发控制、协调副本的一致性。</p>
<p>Primary-secondary 类型的协议一般要解决四大类问题：数据更新流程、数据读取方式、Primary 副本的确定和切换、数据同步（reconcile）。</p>
<h5 id="数据更新基本流程"><a href="#数据更新基本流程" class="headerlink" title="数据更新基本流程"></a>数据更新基本流程</h5><ol>
<li>数据更新都由primary 节点协调完成。</li>
<li>外部节点将更新操作发给primary 节点</li>
<li>primary 节点进行并发控制即确定并发更新操作的先后顺序</li>
<li>primary 节点将更新操作发送给secondary 节点</li>
<li>primary 根据secondary 节点的完成情况决定更新是否成功并将结果返回外部节点</li>
</ol>
<p><img src="//blog.com/2019/07/25/分布式系统原理介绍/7.png" alt="img"></p>
<p>在工程实践中，如果由primary 直接同时发送给其他N 个副本发送数据，则每个 secondary 的更新吞吐受限于primary 总的出口网络带宽，最大为primary 网络出口带宽的1/N。为了 解决这个问题，有些系统（例如，GFS），使用接力的方式同步数据，即primary 将更新发送给第一 个secondary 副本，第一个secondary 副本发送给第二secondary 副本，依次类推。</p>
<h5 id="数据读取方式"><a href="#数据读取方式" class="headerlink" title="数据读取方式"></a>数据读取方式</h5><p>数据读取方式也与一致性高度相关。如果只需要最终一致性，则读取任何副本都可以满足需求。如果需要会 话一致性，则可以为副本设置版本号，每次更新后递增版本号，用户读取副本时验证版本号，从而 保证用户读到的数据在会话范围内单调递增。使用primary-secondary 比较困难的是实现强一致性。</p>
<ol>
<li>由于数据的更新流程都是由primary 控制的，primary 副本上的数据一定是最新的，所以 如果始终只读primary 副本的数据，可以实现强一致性。如果只读primary 副本，则secondary 副本 将不提供读服务。实践中，如果副本不与机器绑定，而是按照数据段为单位维护副本，仅有primary 副本提供读服务在很多场景下并不会造出机器资源浪费。</li>
</ol>
<p>将副本分散到集群中个，假设primary 也是随机的确定的，那么每台机器 上都有一些数据的primary 副本，也有另一些数据段的secondary 副本。从而某台服务器实际都提供 读写服务。</p>
<ol>
<li>由primary 控制节点secondary 节点的可用性。当primary 更新某个secondary 副本不成功 时，primary 将该secondary 副本标记为不可用，从而用户不再读取该不可用的副本。不可用的 secondary 副本可以继续尝试与primary 同步数据，当与primary 完成数据同步后，primary 可以副本 标记为可用。这种方式使得所有的可用的副本，无论是primary 还是secondary 都是可读的，且在一 个确定的时间内，某secondary 副本要么更新到与primary 一致的最新状态，要么被标记为不可用， 从而符合较高的一致性要求。这种方式依赖于一个中心元数据管理系统，用于记录哪些副本可用， 哪些副本不可用。某种意义上，该方式通过降低系统的可用性来提高系统的一致性。</li>
</ol>
<h5 id="primary-副本的确定与切换"><a href="#primary-副本的确定与切换" class="headerlink" title="primary 副本的确定与切换"></a>primary 副本的确定与切换</h5><p>在primary-secondary 类型的协议中，另一个核心的问题是如何确定primary 副本，尤其是在原 primary 副本所在机器出现宕机等异常时，需要有某种机制切换primary 副本，使得某个secondary 副本成为新的primary 副本。</p>
<p>通常的，在primary-secondary 类型的分布式系统中，哪个副本是primary 这一信息都属于元信 息，由专门的元数据服务器维护。执行更新操作时，首先查询元数据服务器获取副本的primary 信 息，从而进一步执行数据更新流程。</p>
<p>由于分布式系统中可靠的发现节点异常是需要一定的探测时间的，这样的探测时间通常是10 秒级别，这也意味着一旦primary 异常，最多需要10 秒级别的 发现时间，系统才能开始primary 的切换，在这10 秒时间内，由于没有primary，系统不能提供更 新服务，如果系统只能读primary 副本，则这段时间内甚至不能提供读服务。从这里可以看到， primary-backup 类副本协议的最大缺点就是由于primary 切换带来的一定的停服务时间。</p>
<h5 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h5><p>不一致的secondary 副本需要与primary 进行同步（reconcile）。</p>
<p>通常不一致的形式有三种：一、由于网络分化等异常，secondary 上的数据落后于primary 上的 数据。二、在某些协议下，secondary 上的数据有可能是脏数据，需要被丢弃。所谓脏数据是由于 primary 副本没有进行某一更新操作，而secondary 副本上反而进行的多余的修改操作，从而造成 secondary 副本数据错误。三、secondary 是一个新增加的副本，完全没有数据，需要从其他副本上 拷贝数据。</p>
<p>对于第一种secondary 数据落后的情况，常见的同步方式是回放primary 上的操作日志（通常是 redo 日志），从而追上primary 的更新进度。对于脏数据的情况， 较好的做法是设计的分布式协议不产生脏数据。如果协议一定有产生脏数据的可能，则也应该使得 产生脏数据的概率降到非常低得情况，从而一旦发生脏数据的情况可以简单的直接丢弃有脏数据的 副本，这样相当于副本没有数据。另外，也可以设计一些基于undo 日志的方式从而可以删除脏数据。 如果secondary 副本完全没有数据，则常见的做法是直接拷贝primary 副本的数据，这种方法往往比 回放日志追更新进度的方法快很多。但拷贝数据时primary 副本需要能够继续提供更新服务，这就 要求primary 副本支持快照(snapshot)功能。即对某一刻的副本数据形成快照，然后拷贝快照，拷贝 完成后使用回放日志的方式追快照形成后的更新操作。</p>
<h4 id="去中心化副本控制协议"><a href="#去中心化副本控制协议" class="headerlink" title="去中心化副本控制协议"></a>去中心化副本控制协议</h4><p>去中心化副本控制协议没有中心节点，协议中所有的节点都是完全对等的，节点之间通过平等协商 达到一致。从而去中心化协议没有因为中心化节点异常而带来的停服务等问题。</p>
<p>去中心化协议的最大的缺点是协议过程通常比较复杂。尤其当 去中心化协议需要实现强一致性时，协议流程变得复杂且不容易理解。由于流程的复杂，去中心化 协议的效率或者性能一般也较中心化协议低。一个不恰当的比方就是，中心化副本控制协议类似专 制制度，系统效率高但高度依赖于中心节点，一旦中心节点异常，系统受到的影响较大；去中心化 副本控制协议类似民主制度，节点集体协商，效率低下，但个别节点的异常不会对系统总体造成太 大影响。</p>
<p><img src="//blog.com/2019/07/25/分布式系统原理介绍/8.png" alt="img"></p>
<h3 id="2-3-Lease-机制"><a href="#2-3-Lease-机制" class="headerlink" title="2.3 Lease 机制"></a>2.3 Lease 机制</h3><p>Lease 机制是最重要的分布式协议，广泛应用于各种实际的分布式系统中。</p>
<h4 id="基于lease-的分布式cache-系统"><a href="#基于lease-的分布式cache-系统" class="headerlink" title="基于lease 的分布式cache 系统"></a>基于lease 的分布式cache 系统</h4><p>基本的问题背景如下：在一个分布式系统中，有一个中心服务器节点，中心服务器存储、维护 着一些数据，这些数据是系统的元数据。系统中其他的节点通过访问中心服务器节点读取、修改其 上的元数据。由于系统中各种操作都依赖于元数据，如果每次读取元数据的操作都访问中心服务器 节点，那么中心服务器节点的性能成为系统的瓶颈。为此，设计一种元数据cache，在各个节点上 cache 元数据信息，从而减少对中心服务器节点的访问，提高性能。另一方面，系统的正确运行严 格依赖于元数据的正确，这就要求各个节点上cache 的数据始终与中心服务器上的数据一致，cache 中的数据不能是旧的脏数据。最后，设计的cache 系统要能最大可能的处理节点宕机、网络中断等 异常，最大程度的提高系统的可用性。</p>
<p>为此，利用lease 机制设计一套cache 系统，其基本原理为如下。中心服务器在向各节点发送数 据时同时向节点颁发一个lease。每个lease 具有一个有效期，和信用卡上的有效期类似，lease 上的 有效期通常是一个明确的时间点，例如12:00:10，一旦真实时间超过这个时间点，则lease 过期失效。 这样lease 的有效期与节点收到lease 的时间无关，节点可能收到lease 时该lease 就已经过期失效。 这里首先假设中心服务器与各节点的时钟是同步的，下节中讨论时钟不同步对lease 的影响。中心服 务器发出的lease 的含义为：在lease 的有效期内，中心服务器保证不会修改对应数据的值。因此， 节点收到数据和lease 后，将数据加入本地Cache，一旦对应的lease 超时，节点将对应的本地cache 数据删除。中心服务器在修改数据时，首先阻塞所有新的读请求，并等待之前为该数据发出的所有 lease 超时过期，然后修改数据的值。</p>
<p>基于lease 的cache，客户端节点读取元数据</p>
<ol>
<li>判断元数据是否已经处于本地cache 且lease 处于有效期内 1.1 是：直接返回cache 中的元数据 1.2 否：向中心服务器节点请求读取元数据信息 1.2.1 服务器收到读取请求后，返回元数据及一个对应的lease 1.2.2 客户端是否成功收到服务器返回的数据 1.2.2.1 失败或超时：退出流程，读取失败，可重试 1.2.2.2 成功：将元数据与该元数据的lease 记录到内存中，返回元数据</li>
<li>基于lease 的cache，客户端节点修改元数据流程 2.1 节点向服务器发起修改元数据请求。 2.2 服务器收到修改请求后，阻塞所有新的读数据请求，即接收读请求，但不返回数据。 2.3 服务器等待所有与该元数据相关的lease 超时。 2.4 服务器修改元数据并向客户端节点返回修改成功。</li>
</ol>
<p>上述机制可以保证各个节点上的cache 与中心服务器上的中心始终一致。这是因为中心服务器 节点在发送数据的同时授予了节点对应的lease，在lease 有效期内，服务器不会修改数据，从而客 户端节点可以放心的在lease 有效期内cache 数据。上述lease 机制可以容错的关键是：服务器一旦 发出数据及lease，无论客户端是否收到，也无论后续客户端是否宕机，也无论后续网络是否正常， 服务器只要等待lease 超时，就可以保证对应的客户端节点不会再继续cache 数据，从而可以放心的 修改数据而不会破坏cache 的一致性。</p>
<p>上述基础流程有一些性能和可用性上的问题，但可以很容易就优化改性。优化点一：服务器在 修改元数据时首先要阻塞所有新的读请求，造成没有读服务。这是为了防止发出新的lease 从而引起 不断有新客户端节点持有lease 并缓存着数据，形成“活锁”。优化的方法很简单，服务器在进入修 改数据流程后，一旦收到读请求则只返回数据但不颁发lease。从而造成在修改流程执行的过程中， 客户端可以读到元数据，只是不能缓存元数据。进一步的优化是，当进入修改流程，服务器颁发的 lease 有效期限选择为已发出的lease 的最大有效期限。这样做，客户端可以继续在服务器进入修改 流程后继续缓存元数据，但服务器的等待所有lease 过期的时间也不会因为颁发新的lease 而不断延 长。</p>
<p>最后，=cache 机制与多副本机制的区别。Cache 机制与多副本机制的相似之处都 是将一份数据保存在多个节点上。但Cache 机制却要简单许多，对于cache 的数据，可以随时删除 丢弃，并命中cache 的后果仅仅是需要访问数据源读取数据；然而副本机制却不一样，副本是不能 随意丢弃的，每失去一个副本，服务质量都在下降，一旦副本数下降到一定程度，则往往服务将不 再可用。</p>
<h5 id="lease-机制的分析"><a href="#lease-机制的分析" class="headerlink" title="lease 机制的分析"></a>lease 机制的分析</h5><p>lease 的定义：Lease 是由颁发者授予的在某一有效期内的承诺。颁发者一旦发 出lease，则无论接受方是否收到，也无论后续接收方处于何种状态，只要lease 不过期，颁发者一 定严守承诺；另一方面，接收方在lease 的有效期内可以使用颁发者的承诺，但一旦lease 过期，接 收方一定不能继续使用颁发者的承诺。</p>
<p>Lease 机制具有很高的容错能力。首先，通过引入有效期，Lease 机制能否非常好的容错网络异 常。Lease 颁发过程只依赖于网络可以单向通信，即使接收方无法向颁发者发送消息，也不影响lease 的颁发。由于lease 的有效期是一个确定的时间点，lease 的语义与发送lease 的具体时间无关，所以 同一个lease 可以被颁发者不断重复向接受方发送。即使颁发者偶尔发送lease 失败，颁发者也可以 简单的通过重发的办法解决。一旦lease 被接收方成功接受，后续lease 机制不再依赖于网络通信， 即使网络完全中断lease 机制也不受影响。再者，Lease 机制能较好的容错节点宕机。如果颁发者宕 机，则宕机的颁发者通常无法改变之前的承诺，不会影响lease 的正确性。在颁发者机恢复后，如果 颁发者恢复出了之前的lease 信息，颁发者可以继续遵守lease 的承诺。如果颁发者无法恢复lease 信息，则只需等待一个最大的lease 超时时间就可以使得所有的lease 都失效，从而不破坏lease 机制。</p>
<p>例如上节中的cache 系统的例子中，一旦服务器宕机，肯定不会修改元数据，重新恢复后，只需等 待一个最大的lease 超时时间，所有节点上的缓存信息都将被清空。对于接受方宕机的情况，颁发者 不需要做更多的容错处理，只需等待lease 过期失效，就可以收回承诺，实践中也就是收回之前赋予 的权限、身份等。最后，lease 机制不依赖于存储。颁发者可以持久化颁发过的lease 信息，从而在 宕机恢复后可以使得在有效期的lease 继续有效。但这对于lease 机制只是一个优化，如之前的分析， 即使颁发者没有持久化lease 信息，也可以通过等待一个最大的lease 时间的方式使得之前所有颁发 的lease 失效，从而保证机制继续有效。</p>
<p>Lease 机制依赖于有效期，这就要求颁发者和接收者的时钟是同步的。一方面，如果颁发者的 时钟比接收者的时钟慢，则当接收者认为lease 已经过期的时候，颁发者依旧认为lease 有效。接收 者可以用在lease 到期前申请新的lease 的方式解决这个问题。另一方面，如果颁发者的时钟比接收 者的时钟快，则当颁发者认为lease 已经过期的时候，接收者依旧认为lease 有效，颁发者可能将lease 颁发给其他节点，造成承诺失效，影响系统的正确性。对于这种时钟不同步，实践中的通常做法是 将颁发者的有效期设置得比接收者的略大，只需大过时钟误差就可以避免对lease 的有效性的影响。</p>
<h5 id="基于lease-机制确定节点状态"><a href="#基于lease-机制确定节点状态" class="headerlink" title="基于lease 机制确定节点状态"></a>基于lease 机制确定节点状态</h5><p>分布式协议依赖于对节点状态认知的全局一致性，即一旦节点Q 认为某个节点 A 异常，则节点A 也必须认为自己异常，从而节点A 停止作为primary，避免“双主”问题的出现。 解决这种问题有两种思路，第一、设计的分布式协议可以容忍“双主”错误，即不依赖于对节点状 态的全局一致性认识，或者全局一致性状态是全体协商后的结果；第二、利用lease 机制。对于第一 种思路即放弃使用中心化的设计，而改用去中心化设计，超过本节的讨论范畴。下面着重讨论利用 lease 机制确定节点状态。</p>
<p>由中心节点向其他节点发送lease，若某个节点持有有效的lease，则认为该节点正常可以提供服 务。用于例2.3.1 中，节点A、B、C 依然周期性的发送heart beat 报告自身状态，节点Q 收到heart beat 后发送一个lease，表示节点Q 确认了节点A、B、C 的状态，并允许节点在lease 有效期内正常工 作。节点Q 可以给primary 节点一个特殊的lease，表示节点可以作为primary 工作。一旦节点Q 希 望切换新的primary，则只需等前一个primary 的lease 过期，则就可以安全的颁发新的lease 给新的 primary 节点，而不会出现“双主”问题。</p>
<p>在实际系统中，若用一个中心节点发送lease 也有很大的风险，一旦该中心节点宕机或网络异常， 则所有的节点没有lease，从而造成系统高度不可用。为此，实际系统总是使用多个中心节点互为副 本，成为一个小的集群，该小集群具有高可用性，对外提供颁发lease 的功能。chubby 和zookeeper 都是基于这样的设计。</p>
<h5 id="lease-的有效期时间选择"><a href="#lease-的有效期时间选择" class="headerlink" title="lease 的有效期时间选择"></a>lease 的有效期时间选择</h5><p>工程中，常选择的lease 时长是10 秒级别，这是一个经 过验证的经验值，实践中可以作为参考并综合选择合适的时长。</p>
<h3 id="2-4-Quorum-机制"><a href="#2-4-Quorum-机制" class="headerlink" title="2.4 Quorum 机制"></a>2.4 Quorum 机制</h3><p>先做这样的约定：更新操作（write）是一系列顺序的过程，通过其他机制 确定更新操作的顺序（例如primary-secondary 架构中由primary 决定顺序），每个更新操作记为wi， i 为更新操作单调递增的序号，每个wi 执行成功后副本数据都发生变化，称为不同的数据版本，记 作vi。假设每个副本都保存了历史上所有版本的数据。</p>
<h4 id="write-all-read-one"><a href="#write-all-read-one" class="headerlink" title="write-all-read-one"></a>write-all-read-one</h4><p>Write-all-read-one（简称WARO）是一种最简单的副本控制规则，顾名思义即在更新时写所有 的副本，只有在所有的副本上更新成功，才认为更新成功，从而保证所有的副本一致，这样在读取 数据时可以读任一副本上的数据。</p>
<p>由于更新操作需要在所有的N 个副本上都成功，更新操作才能成 功，所以一旦有一个副本异常，更新操作失败，更新服务不可用。对于更新服务，虽然有N 个副本， 但系统无法容忍任何一个副本异常。另一方面，N 个副本中只要有一个副本正常，系统就可以提供 读服务。对于读服务而言，当有N 个副本时，系统可以容忍N-1 个副本异常。 从上述分析可以发现WARO 读服务的可用性较高，但更新服务的可用性不高，甚至虽然使用了 副本，但更新服务的可用性等效于没有副本。</p>
<h4 id="Quorum-定义"><a href="#Quorum-定义" class="headerlink" title="Quorum 定义"></a>Quorum 定义</h4><p>在Quorum 机制下，当某次更新操作wi 一旦在所有N 个副本中的W 个副本上都成功，则就称 该更新操作为“成功提交的更新操作”，称对应的数据为“成功提交的数据”。令R&gt;N-W，由于更新 操作wi 仅在W 个副本上成功，所以在读取数据时，最多需要读取R 个副本则一定能读到wi 更新后 的数据vi 。如果某次更新wi 在W 个副本上成功，由于W+R&gt;N，任意R 个副本组成的集合一定与 成功的W个副本组成的集合有交集，所以读取R 个副本一定能读到wi 更新后的数据vi。如图 2-10， Quorum 机制的原理可以文森图表示。</p>
<p><img src="//blog.com/2019/07/25/分布式系统原理介绍/9.png" alt="img"></p>
<p>某系统有5 个副本，W=3，R=3，最初5 个副本的数据一致，都是v1，某次更新操作 w2 在前3 副本上成功，副本情况变成（v2 v2 v2 v1 v1）。此时，任意3 个副本组成的集合中一定包括 v2。 在上述定义中，令W=N，R=1，就得到WARO，即WARO 是Quorum 机制的一种特例。 与分析WARO 相似，分析Quorum 机制的可用性。限制Quorum 参数为W+R=N+1。由于更新 操作需要在W 个副本上都成功，更新操作才能成功，所以一旦N-W+1 个副本异常，更新操作始终 无法在W 个副本上成功，更新服务不可用。另一方面，一旦N-R+1 个副本异常，则无法保证一定 可以读到与W 个副本有交集的副本集合，则读服务的一致性下降。</p>
<p>再次强调：仅仅依赖quorum 机制是无法保证强一致性的。因为仅有quorum 机制时无法确 定最新已成功提交的版本号，除非将最新已提交的版本号作为元数据由特定的元数据服务器或元数 据集群管理，否则很难确定最新成功提交的版本号。在下一节中，将讨论在哪些情况下，可以仅仅 通过quorum 机制来确定最新成功提交的版本号。</p>
<p>Quorum 机制的三个系统参数N、W、R 控制了系统的可用性，也是系统对用户的服务承诺：数 据最多有N 个副本，但数据更新成功W 个副本即返回用户成功。对于一致性要求较高的Quorum 系 统，系统还应该承诺任何时候不读取未成功提交的数据，即读取到的数据都是曾经在W 个副本上成 功的数据。</p>
<h4 id="读取最新成功提交的数据"><a href="#读取最新成功提交的数据" class="headerlink" title="读取最新成功提交的数据"></a>读取最新成功提交的数据</h4><p>Quorum 机制只需成功更新N 个副本中的W 个，在读取R 个副本时，一定可以读到最新的成功 提交的数据。但由于有不成功的更新情况存在，仅仅读取R 个副本却不一定能确定哪个版本的数据 是最新的已提交的数据。对于一个强一致性Quorum 系统，</p>
<p>若存在个数据少于W 个，假设为X 个，则继续读取其他副本，直若成功读取到W 个 该版本的副本，则该数据为最新的成功提交的数据；如果在所有副本中该数据的个数肯定不满 足W 个，则R 中版本号第二大的为最新的成功提交的副本。 例: 在读取到（v2 v1 v1）时，继续读取剩余的副本，若读到剩余两个副本 为（v2 v2）则v2 是最新的已提交的副本；若读到剩余的两个副本为（v2 v1）或（v1 v1）则v1 是最新 成功提交的版本；若读取后续两个副本有任一超时或失败，则无法判断哪个版本是最新的成功提交 的版本。</p>
<p>可以看出，在单纯使用Quorum 机制时，若要确定最新的成功提交的版本，最多需要读取R+ （W-R-1）=N 个副本，当出现任一副本异常时，读最新的成功提交的版本这一功能都有可能不可用。 实际工程中，应该尽量通过其他技术手段，回避通过Quorum 机制读取最新的成功提交的版本。例 如，当quorum 机制与primary-secondary 控制协议结合使用时，可以通过读取primary 的方式读取到 最新的已提交的数据。</p>
<h4 id="基于Quorum-机制选择primary副本"><a href="#基于Quorum-机制选择primary副本" class="headerlink" title="基于Quorum 机制选择primary副本"></a>基于Quorum 机制选择primary副本</h4><p>读取数据时依照一致性要求的不 同可以有不同的做法：如果需要强一致性的立刻读取到最新的成功提交的数据，则可以简单的只读 取primary 副本上的数据即可，也可以通过上节的方式读取；如果需要会话一致性，则可以根据之 前已经读到的数据版本号在各个副本上进行选择性读取；如果只需要弱一致性，则可以选择任意副 本读取。</p>
<p>在primary-secondary 协议中，当primary 异常时，需要选择出一个新的primary，之后secondary 副本与primary 同步数据。通常情况下，选择新的primary 的工作是由某一中心节点完成的，在引入 quorum 机制后，常用的primary 选择方式与读取数据的方式类似，即中心节点读取R 个副本，选择 R 个副本中版本号最高的副本作为新的primary。新primary 与至少W 个副本完成数据同步后作为新 的primary 提供读写服务。首先，R 个副本中版本号最高的副本一定蕴含了最新的成功提交的数据。 再者，虽然不能确定最高版本号的数是一个成功提交的数据，但新的primary 在随后与secondary 同 步数据，使得该版本的副本个数达到W，从而使得该版本的数据成为成功提交的数据。</p>
<p>例：在N=5，W=3，R=3 的系统中，某时刻副本最大版本号为（v2 v2 v1 v1 v1），此时v1 是 系统的最新的成功提交的数据，v2 是一个处于中间状态的未成功提交的数据。假设此刻原primary 副本异常，中心节点进行primary 切换工作。这类“中间态”数据究竟作为“脏数据”被删除，还 是作为新的数据被同步后成为生效的数据，完全取决于这个数据能否参与新primary 的选举。下面 分别分析这两种情况。</p>
<p><img src="//blog.com/2019/07/25/分布式系统原理介绍/10.png" alt="img"></p>
<p>第一、如图 2-12，若中心节点与其中3 个副本通信成功，读取到的版本号为（v1 v1 v1），则任 选一个副本作为primary，新primary 以v1 作为最新的成功提交的版本并与其他副本同步，当与第1、 第2 个副本同步数据时，由于第1、第2 个副本版本号大于primary，属于脏数据，可以按照2.2.2.4 节中介绍的处理脏数据的方式解决。实践中，新primary 也有可能与后两个副本完成同步后就提供 数据服务，随后自身版本号也更新到v2，如果系统不能保证之后的v2 与之前的v2 完全一样，则新 primary 在与第1、2 个副本同步数据时不但要比较数据版本号还需要比较更新操作的具体内容是否 一样。</p>
<p><img src="//blog.com/2019/07/25/分布式系统原理介绍/11.png" alt="img"></p>
<p>第二、若中心节点与其他3 个副本通信成功，读取到的版本号为（v2 v1 v1），则选取版本号为 v2 的副本作为新的primary，之后，一旦新primary 与其他2 个副本完成数据同步，则符合v2 的副 本个数达到W 个，成为最新的成功提交的副本，新primary 可以提供正常的读写服务。</p>
<h3 id="2-5-日志技术"><a href="#2-5-日志技术" class="headerlink" title="2.5 日志技术"></a>2.5 日志技术</h3><p>日志技术是宕机恢复的主要技术之一。日志技术最初使用在数据库系统中。严格来说日志技 术不是一种分布式系统的技术，但在分布式系统的实践中，却广泛使用了日志技术做宕机恢复，甚 至如BigTable 等系统将日志保存到一个分布式系统中进一步增强了系统容错能力。</p>
<h4 id="Redo-Log-与Check-point"><a href="#Redo-Log-与Check-point" class="headerlink" title="Redo Log 与Check point"></a>Redo Log 与Check point</h4><p>设计一个高速的单机查询系 统，将数据全部存放在内存中以实现高速的数据查询，每次更新操作更新一小部分数据（例如 key-value 中的某一个key）。现在问题为利用日志技术实现该内存查询系统的宕机恢复。与数据库的 事务不同的是，这个问题模型中的每个成功的更新操作都会生效。这也等效为数据库的每个事务只 有一个更新操作，且每次更新操作都可以也必须立即提交（Auto commit）。</p>
<h5 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h5><ol>
<li>将更新操作的结果（例如Set K1=1，则记录K1=1）以追加写（append）的方式写入磁盘的 日志文件</li>
<li>按更新操作修改内存中的数据</li>
<li>返回更新成功</li>
</ol>
<p>从Redo Log 的流程可以看出，Redo 写入日志的是更新操作完成后的结果（虽然本文不讨论Undo Log，这点是与Undo Log 的区别之一），且由于是顺序追加写日志文件，在磁盘等对顺序写有力的 存储设备上效率较高。</p>
<p>用Redo Log 进行宕机恢复非常简单，只需要“回放”日志即可。</p>
<p>流程2.5.2：Redo Log 的宕机恢复</p>
<ol>
<li>从头读取日志文件中的每次更新操作的结果，用这些结果修改内存中的数据。</li>
</ol>
<p>从Redo Log 的宕机恢复流程也可以看出，只有写入日志文件的更新结果才能在宕机后恢复。这 也是为什么在Redo Log 流程中需要先更新日志文件再更新内存中的数据的原因。假如先更新内存中 的数据，那么用户立刻就能读到更新后的数据，一旦在完成内存修改与写入日志之间发生宕机，那 么最后一次更新操作无法恢复，但之前用户可能已经读取到了更新后的数据，从而引起不一致的问 题。</p>
<h5 id="Check-point"><a href="#Check-point" class="headerlink" title="Check point"></a>Check point</h5><p>。在简化的模型下，check point 技术的过程即将内存中的数据以某种易于重新加载的数据组织方式完整的dump 到磁盘，从而 减少宕机恢复时需要回放的日志数据。 流程：check point</p>
<ol>
<li>向日志文件中记录“Begin Check Point”</li>
<li>将内存中的数据以某种易于重新加载的数据组织方式dump 到磁盘上</li>
<li>向日志文件中记录“End Check Point” 在check point 流程中，数据可以继续按照流程2.5.1 被更新，这段过程中新更新的数据可以dump 到磁盘也可以不dump 到磁盘，具体取决于实现。例如，check point 开始时k1=v1，check point 过程 中某次更新为k1 = v2，那么dump 到磁盘上的k1 的值可以是v1 也可以是v2。</li>
</ol>
<p>流程：基于check point 的宕机恢复流程</p>
<ol>
<li>将dump 到磁盘的数据加载到内存。</li>
<li>从后向前扫描日志文件，寻找最后一个“End Check Point”日志。</li>
<li>从最后一个“End Check Point”日志向前找到最近的一个“Begin Check Point”日志，并回 放该日志之后的所有更新操作日志。</li>
</ol>
<h4 id="No-Undo-No-Redo-log"><a href="#No-Undo-No-Redo-log" class="headerlink" title="No Undo/No Redo log"></a>No Undo/No Redo log</h4><p>若数据维护在磁盘中， 某批更新由若干个更新操作组成，这些更新操作需要原子生效，即要么同时生效，要么都不生效。</p>
<p><img src="//blog.com/2019/07/25/分布式系统原理介绍/12.png" alt="img"></p>
<p>0/1 目录技术中有两个目录结构，称为目录0(Directory 0)和目录1(Directory 1)。另有一个结构 称为主记录（Master record）记录当前正在使用的目录称为活动目录。主记录中要么记录使用目录0， 要么记录使用目录1。目录0 或目录1 中记录了各个数据的在日志文件中的位置。 0/1 目录的数据更新过程始终在非活动目录上进行，只是在数据生效前，将主记录中的0、1 值 反转，从而切换主记录。</p>
<p>流程：0/1 目录数据更新流程</p>
<ol>
<li>将活动目录完整拷贝到非活动目录。</li>
<li>对于每个更新操作，新建一个日志项纪录操作后的值，并在非活动目录中将相应数据的位置 修改为新建的日志项的位置。</li>
<li>原子性修改主记录：反转主记录中的值，使得非活动目录生效。</li>
</ol>
<p>0/1 目录的更新流程非常简单，通过0、1 目录的主记录切换使得一批修改的生效是原子的。 0/1 目录将批量事务操作的原子性通过目录手段归结到主记录的原子切换。由于多条记录的原 子修改一般较难实现而单条记录的原子修改往往可以实现，从而降低了问题实现的难度。在工程中 0/1 目录的思想运用非常广泛，其形式也不局限在上述流程中，可以是内存中的两个数据结构来回 切换，也可以是磁盘上的两个文件目录来回生效切换。</p>
<h3 id="2-6-两阶段提交协议"><a href="#2-6-两阶段提交协议" class="headerlink" title="2.6 两阶段提交协议"></a>2.6 两阶段提交协议</h3><p>两阶段提交协议是一种经典的强一致性中心化副本控制协议。虽然在工程中该协议有较多 的问题，但研究该协议能很好的理解分布式系统的几个典型问题。</p>
<h4 id="流程描述"><a href="#流程描述" class="headerlink" title="流程描述"></a>流程描述</h4><p>两阶段提交协议是一种典型的“中心化副本控制”协议。在该协议中，参与的 节点分为两类：一个中心化协调者节点（coordinator）和N 个参与者节点（participant）。每个参与 者节点即上文背景介绍中的管理数据库副本的节点。</p>
<p>两阶段提交的思路比较简单，在第一阶段，协调者询问所有的参与者是否可以提交事务（请参 与者投票），所有参与者向协调者投票。在第二阶段，协调者根据所有参与者的投票结果做出是否事 务可以全局提交的决定，并通知所有的参与者执行该决定。在一个两阶段提交流程中，参与者不能 改变自己的投票结果。两阶段提交协议的可以全局提交的前提是所有的参与者都同意提交事务，只 要有一个参与者投票选择放弃(abort)事务，则事务必须被放弃。</p>
<p>流程：两阶段提交协调者流程</p>
<ol>
<li>写本地日志“begin_commit”， 并进入WAIT 状态；</li>
<li>向所有参与者发送“prepare 消息”；</li>
<li>等待并接收参与者发送的对“prepare 消息”的响应； 3.1 若收到任何一个参与者发送的“vote-abort 消息”； 3.1.1 写本地“global-abort”日志，进入ABORT； 3.1.2 向所有的参与者发送“global-abort 消息”； 3.1.3 进入ABORT 状态； 3.2 若收到所有参与者发送的“vote-commit”消息； 3.2.1 写本地“global-commit”日志，进入COMMIT 状态； 3.1.2 向所有的参与者发送“global-commit 消息”；</li>
<li>等待并接收参与者发送的对“global-abort 消息”或“global-commit 消息”的确认响应消息， 一旦收到所有参与者的确认消息，写本地“end_transaction” 日志流程结束。</li>
</ol>
<p>流程：两阶段提交协调者流程</p>
<ol>
<li>写本地日志“init”记录，进入INIT 状态</li>
<li>等待并接受协调者发送的“prepare 消息”，收到后 2.1 若参与者可以提交本次事务 2.1.1 写本地日志“ready”，进入READY 状态 2.1.2 向协调者发送“vote-commit”消息 2.1.4 等待协调者的消息 2.1.4.1 若收到协调者的“global-abort”消息 2.1.4.1.1 写本地日志“abort”，进入ABORT 状态 2.1.4.1.2 向协调者发送对“global-abort”的确认消息 2.1.4.2 若收到协调者的“global-commit”消息 2.1.4.1.1 写本地日志“commit”，进入COMMIT 状态 2.1.4.1.2 向协调者发送对“global-commit”的确认消息 2.2 若参与者无法提交本次事务 2.2.1 写本地日志“abort”，进入ABORT 状态 2.2.2 向协调者发送“vote-abort”消息 2.2.3 流程对该参与者结束 2.2.4 若后续收到协调者的“global-abort”消息可以响应</li>
<li>即使流程结束，但任何时候收到协调者发送的“global-abort”消息或“global-commit”消息 也都要发送一个对应的确认消息。</li>
</ol>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><h5 id="宕机恢复"><a href="#宕机恢复" class="headerlink" title="宕机恢复"></a>宕机恢复</h5><ol>
<li>协调者宕机恢复 协调者宕机恢复后，首先通过日志查找到宕机前的状态。 如果日志中最后是“begin_commit”记录，说明宕机前协调者处于WAIT 状态，协调者可能已经 发送过“prepare 消息”也可能还没发送，但协调者一定还没有发送过“global-commit 消息”或 “global-abort 消息”，即事务的全局状态还没有确定。此时，协调者可以重新发送“prepare 消息” 继续两阶段提交流程，即使参与者已经发送过对“prepare 消息”的响应，也不过是再次重传之前的 响应而不会影响协议的一致性。 如果日志中最后是“global-commit”或“global-abort”记录，说明宕机前协调者处于COMMIT 或ABORT 状态。此时协调者只需重新向所有的参与者发送“global-commit 消息”或“global-abort 消息”就可以继续两阶段提交流程。</li>
<li>参与者宕机恢复 参与者宕机恢复后，首先通过日志查找宕机前的状态。 如果日志中最后是“init”记录，说明参与者处于INIT 状态，还没有对本次事务做出投票选择， 参与者可以继续流程等待协调者发送的“prepare 消息”。 如果日志中最后是“ready”记录，说明参与者处于REDAY 状态，此时说明参与者已经就本次 事务做出了投票选择，但宕机前参与者是否已经向协调者发送“vote-commit”消息并不可知。所以 此时参与者可以向协调者重发“vote-commit”，并继续协议流程。 如果日志中最后是“commit”或“abort”记录，说明参与者已经收到过协调者的“global-commit 消息”（处于COMMIT 状态）或者“global-abort 消息”（处于ABORT 状态）。至于是否向协调者发 送过对“global-commit”或“global-abort”的确认消息则未知。但即使没有发送过确认消息，由于 协调者会不断重发“global-commit”或“global-abort”，只需在收到这些消息时发送确认消息既可， 不影响协议的全局一致性。</li>
</ol>
<h4 id="协议分析"><a href="#协议分析" class="headerlink" title="协议分析"></a>协议分析</h4><p>两阶段提交协议在工程实践中真正使用的较少，主要原因有以下几点：</p>
<ol>
<li>两阶段提交协议的容错能力较差。从上文的分析可以看出，两阶段提交协议在某些情况 下存在流程无法执行下去的情况，且也无法判断流程状态。在工程中好的分布式协议往往总是可以 在即使发生异常的情况下也能执行下去。例如，回忆Lease 机制（2.3 ），一旦lease 发出，无论出 现任何异常，Lease 服务器节点总是可以通过时间判定出Lease 是否有效，也可以用等待Lease 超时 的方法收回Lease 权限，整个Lease 协议的流程不存在任何流程被阻塞而无法执行下去的情况。与 Lease 机制的简单有效相比，两阶段提交的协议显得较为复杂且容错能力差。</li>
<li>两阶段提交协议的性能较差。一次成功的两阶段提交协议流程中，协调者与每个参与者 之间至少需要两轮交互4 个消息“prepare”、“vote-commit”、“global-commit”、“确认global-commit”。 过多的交互次数会降低性能。另一方面，协调者需要等待所有的参与者的投票结果，一旦存在较慢 的参与者，会影响全局流程执行速度。</li>
</ol>
<p>虽然存在一些改进的两阶段提交协议可以提高容错能力和性能，然而这类协议依旧是在工程中 使用较少的一类协议，其理论价值大于实践意义。</p>
<h3 id="2-7-MVCC"><a href="#2-7-MVCC" class="headerlink" title="2.7 MVCC"></a>2.7 MVCC</h3><p>MVCC(Multi-version Cocurrent Control，多版本并发控制)技术。MVCC 技术最初也是在数据库 系统中被提出，但这种思想并不局限于单机的分布式系统，在分布式系统中同样有效。</p>
<p>MVCC 即多个不同版本的数据实现并发控制的技术，其基本思想是为每次事务生成 一个新版本的数据，在读数据时选择不同版本的数据即可以实现对事务结果的完整性读取。在使用 MVCC 时，每个事务都是基于一个已生效的基础版本进行更新，事务可以并行进行，从而可以产生 一种图状结构。 <img src="//blog.com/2019/07/25/分布式系统原理介绍/12.png" alt="img"></p>
<p>，基础数据的版本为1，同时产生了两个事务：事务A 与事务B。这两个事务都 各自对数据进行了一些本地修改（这些修改只有事务自己可见，不影响真正的数据），之后事务A 首先提交，生成数据版本2；基于数据版本2，又发起了事务C，事务C 继续提交，生成了数据版 本3；最后事务B 提交，此时事务B 的结果需要与事务C 的结果合并，如果数据没有冲突，即事务 B 没有修改事务A 与事务C 修改过的变量，那么事务B 可以提交，否则事务B 提交失败。 MVCC 的流程过程非常类似于SVN 等版本控制系统的流程，或者说SVN 等版本控制系统就是 使用的MVCC 思想。 事务在基于基础数据版本做本地修改时，为了不影响真正的数据，通常有两种做法，一是将基 础数据版本中的数据完全拷贝出来再修改，SVN 即使用了这种方法，SVN check out 即是拷贝的过 程；二是每个事务中只记录更新操作，而不记录完整的数据，读取数据时再将更新操作应用到用基 础版本的数据从而计算出结果，这个过程也类似SVN 的增量提交。</p>
<h3 id="2-8-Paxos协议"><a href="#2-8-Paxos协议" class="headerlink" title="2.8 Paxos协议"></a>2.8 Paxos协议</h3><p>Paxos 协议是少数在工程实践中证实的强一致性、高可用的去中心化分布式协议。 Paxos 协议的流程较为复杂，但其基本思想却不难理解，类似于人类社会的投票过程。Paxos 协 议中，有一组完全对等的参与节点（称为accpetor），这组节点各自就某一事件做出决议，如果某个 决议获得了超过半数节点的同意则生效。Paxos 协议中只要有超过一半的节点正常，就可以工作， 能很好对抗宕机、网络分化等异常情况。</p>
<h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p>Proposer：提案者。Proposer 可以有多个，Proposer 提出议案（value）。所谓value，在工程中可 以是任何操作，例如“修改某个变量的值为某个值”、“设置当前primary 为某个节点”等等。Paxos 协议中统一将这些操作抽象为value。不同的Proposer 可以提出不同的甚至矛盾的value，例如某个 Proposer 提议“将变量X 设置为1”，另一个Proposer 提议“将变量X 设置为2”，但对同一轮Paxos 过程，最多只有一个value 被批准。 Acceptor：批准者。Acceptor 有N 个，Proposer 提出的value 必须获得超过半数(N/2+1)的Acceptor 批准后才能通过。Acceptor 之间完全对等独立。 Learner：学习者。Learner 学习被批准的value。所谓学习就是通过读取各个Proposer 对value 的选择结果，如果某个value 被超过半数Proposer 通过，则Learner 学习到了这个value。回忆（2.4 ） 不难理解，这里类似Quorum 机制，某个value 需要获得W=N/2 + 1 的Acceptor 批准，从而学习者 需要至少读取N/2+1 个Accpetor，至多读取N 个Acceptor 的结果后，能学习到一个通过的value。 上述三类角色只是逻辑上的划分，实践中一个节点可以同时充当这三类角色。</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>Paxos 协议一轮一轮的进行，每轮都有一个编号。每轮Paxos 协议可能会批准一个value，也可 能无法批准一个value。如果某一轮Paxos 协议批准了某个value，则以后各轮Paxos 只能批准这个 value。上述各轮协议流程组成了一个Paxos 协议实例，即一次Paxos 协议实例只能批准一个value， 这也是Paxos 协议强一致性的重要体现。 每轮Paxos 协议分为阶段，准备阶段和批准阶段，在这两个阶段Proposer 和Acceptor 有各自的 处理流程。</p>
<p>流程：Proposer 的流程 （准备阶段）</p>
<ol>
<li>向所有的Acceptor 发送消息“Prepare(b)”； 这里b 是Paxos 的轮数，每轮递增</li>
<li>如果收到任何一个Acceptor 发送的消息“Reject(B)”，则对于这个Proposer 而言本轮Paxos 失败， 将轮数b 设置为B+1 后重新步骤1； （批准阶段，根据收到的Acceptor 的消息作出不同选择）</li>
<li>如果接收到的Acceptor 的“Promise(b, v_i)”消息达到N/2+1 个（N 为Acceptor 总数，除法取整， 下同）；v_i 表示Acceptor 最近一次在i 轮批准过value v。 3.1 如果收到的“Promise(b, v)”消息中，v 都为空，Proposer 选择一个value v，向所有Acceptor 广播Accept(b, v)； 3.2 否则，在所有收到的“Promise(b, v_i)”消息中，选择i 最大的value v，向所有Acceptor 广 播消息Accept(b，v)；</li>
<li>如果收到Nack(B)，将轮数b 设置为B+1 后重新步骤1；</li>
</ol>
<p>流程：Accpetor 流程 （准备阶段）</p>
<ol>
<li>接受某个Propeser 的消息Prepare(b)。 参数B 是该Acceptor 收到的最大Paxos 轮数编号；V 是Acceptor 批准的value，可以为空 1.1 如果b&gt;B，回复Promise(b, V_B)，设置B=b; 表示保证不再接受编号小于b 的提案。 1.2 否则，回复Reject(B) （批准阶段）</li>
<li>接收Accept(b, v)， 2.1 如果b &lt; B, 回复Nack(B)，暗示proposer 有一个更大编号的提案被这个Acceptor 接收了 2.2 否则设置V=v。表示这个Acceptor 批准的Value 是v。广播Accepted 消息。</li>
</ol>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>基本例子里有5 个Acceptor，1 个Proposer，不存在任何网络、宕机异常。我们着重考察各个 Accpetor 上变量B 和变量V 的变化，及Proposer 上变量b 的变化。</p>
<ol>
<li>初始状态 <img src="//blog.com/2019/07/25/分布式系统原理介绍/14.png" alt="img"></li>
<li>Proposer 向所有Accpetor 发送“Prepare(1)”，所有Acceptor 正确处理，并回复Promise(1, NULL) <img src="//blog.com/2019/07/25/分布式系统原理介绍/15.png" alt="img"></li>
<li>Proposer 收到5 个Promise(1, NULL)，满足多余半数的Promise 的value 为空，此时发送 Accept(1, v1)，其中v1 是Proposer 选择的Value。 <img src="//blog.com/2019/07/25/分布式系统原理介绍/16.png" alt="img"></li>
<li>此时，v1 被超过半数的Acceptor 批准，v1 即是本次Paxos 协议实例批准的Value。如果Learner 学习value，学到的只能是v1</li>
</ol>
<p>在同一个Paxos 实例中，批准的Value 是无法改变的，即使后续Proposer 以更高的序号发起Paxos 协议也无法改变value。 Paxos 协议的核心就在与“批准的value 无法改变”，这也是整个协议正确性的基础。</p>
<p>Paxos 协议是被人为设计出来，其设计过程也是协议的推导过程。Paxos 协议利用了Quorom 机 制，选择的W=R=N/2+1。简单而言，协议就是Proposer 更新Acceptor 的过程，一旦某个Acceptor 成功更新了超过半数的Acceptor，则更新成功。Learner 按Quorum 去读取Acceptor，一旦某个value 在超过半数的Proposer 上被成功读取，则说明这是一个被批准的value。协议通过引入轮次，使得高 轮次的提议抢占低轮次的提议来避免死锁。 协议设计关键点是如何满足“在一次Paxos 算法实例过程中只批准一个Value”这一约束条件。</p>
<h3 id="2-9-CAP"><a href="#2-9-CAP" class="headerlink" title="2.9 CAP"></a>2.9 CAP</h3><p>CAP 理论的定义很简单，CAP 三个字母分别代表了分布式系统中三个相互矛盾的属性：</p>
<ul>
<li>Consistency (一致性)：CAP 理论中的副本一致性特指强一致性（1.3.4 ）；</li>
<li>Availiablity(可用性)：指系统在出现异常时已经可以提供服务；</li>
<li>Tolerance to the partition of network (分区容忍)：指系统可以对网络分区（1.1.4.2 ）这种异常情 况进行容错处理；</li>
</ul>
<p>CAP 理论指出：无法设计一种分布式协议，使得同时完全具备CAP 三个属性，即1)该种协议 下的副本始终是强一致性，2)服务始终是可用的，3)协议可以容忍任何网络分区异常；分布式系统 协议只能在CAP 这三者间所有折中。</p>
<p>热力学第二定律说明了永动机是不可能存在的，不要去妄图设计永动机。与之类似，CAP 理论 的意义就在于明确提出了不要去妄图设计一种对CAP 三大属性都完全拥有的完美系统，因为这种系 统在理论上就已经被证明不存在。</p>
<ul>
<li>Lease 机制: Lease 机制牺牲了部分异常情况下的A，从而获得了完全的C 与很好的P。</li>
<li>Quorum 机制: Quorum 机制，在CAP 三大因素中都各做了折中，有一定的C，有较好 的A，也有较好的P，是一种较为平衡的分布式协议。</li>
<li>两阶段提交协议: 两阶段提交系统具有完全的C，很糟糕的A，很糟糕的P。</li>
<li>Paxos 协议： 同样是强一致性协议，Paxos 在CAP 三方面较之两阶段提交协议要优秀得多。Paxos 协议具有 完全的C，较好的A，较好的P。Paxos 的A 与P 的属性与Quorum 机制类似，因为Paxos 的协议本 身就具有Quorum 机制的因素。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/07/25/你一定能看懂的分布式系统容错架构设计/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/25/你一定能看懂的分布式系统容错架构设计/" itemprop="url">你一定能看懂的分布式系统容错架构设计</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-25T12:12:57+08:00">
                2019-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/分布式系统/" itemprop="url" rel="index">
                    <span itemprop="name">分布式系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="你一定能看懂的分布式系统容错架构设计"><a href="#你一定能看懂的分布式系统容错架构设计" class="headerlink" title="你一定能看懂的分布式系统容错架构设计"></a>你一定能看懂的分布式系统容错架构设计</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s/8C9eEQfcbT_S45hM2E4y6g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/8C9eEQfcbT_S45hM2E4y6g</a></p>
</blockquote>
<p><br></p>
<h2 id="1、TB级数据放在一台机器上：难啊！"><a href="#1、TB级数据放在一台机器上：难啊！" class="headerlink" title="1、TB级数据放在一台机器上：难啊！"></a>1、TB级数据放在一台机器上：难啊！</h2><p>咱们就用分布式存储系统举例，来聊一下容错架构的设计。</p>
<p>首先，我们来瞧瞧，到底啥是分布式存储系统呢？</p>
<p>其实特别的简单，咱们就用数据库里的一张表来举例。</p>
<p>比如你手头有个数据库，数据库里有一张特别大的表，里面有几十亿，甚至上百亿的数据。</p>
<p>更进一步说，假设这一张表的数据量多达几十个TB，甚至上百个TB，这时你觉得咋样？</p>
<p>当然是内心感到恐慌和无助了，因为如果你用MySQL之类的数据库，单台数据库服务器上的磁盘可能都不够放这一张表的数据！</p>
<p>咱们就来看看下面的这张图，来感受一下。</p>
<p><img src="//blog.com/2019/07/25/你一定能看懂的分布式系统容错架构设计/1.png" alt="img"></p>
<h2 id="2、到底啥是分布式存储？"><a href="#2、到底啥是分布式存储？" class="headerlink" title="2、到底啥是分布式存储？"></a>2、到底啥是分布式存储？</h2><p>所以，假如你手头有一个超大的数据集，几百TB！那你还是别考虑传统的数据库技术来存放了。</p>
<p>因为用一台数据库服务器可能根本都放不下，所以我们考虑一下分布式存储技术？对了！这才是解决这个问题的办法。</p>
<p>咱们完全可以搞多台机器嘛！比如搞20台机器，每台机器上就放1/20的数据。</p>
<p>举个例子，比如总共20TB的数据，在每台机器上只要把1TB就可以了，1TB应该还好吧？每台机器都可以轻松加愉快的放下这么多数据了。</p>
<p>所以说，把一个超大的数据集拆分成多片，给放到多台机器上去，这就是所谓的<strong>分布式存储</strong>。</p>
<p>咱们再看看下面的图。</p>
<p><img src="//blog.com/2019/07/25/你一定能看懂的分布式系统容错架构设计/2.webp" alt="img"></p>
<h2 id="3、啥又是分布式存储系统？"><a href="#3、啥又是分布式存储系统？" class="headerlink" title="3、啥又是分布式存储系统？"></a>3、啥又是分布式存储系统？</h2><p>分布式存储系统，当然就是负责把一个超大数据集拆分成多块，然后放到多台机器上来存储，接着统一管理这些分散在多台机器上存储的数据的一套系统。</p>
<p>比如说经典的hadoop就是这类系统，然后fastdfs也是类似的。</p>
<p>如果你可以脑洞打开，从思想本质共通的层面出发，那你会发现，其实类似elasticsearch、redis cluster等等系统，他本质都是如此。</p>
<p>这些都是基于分布式的系统架构，把超大数据拆分成多片给你存放在多台机器上。</p>
<p>咱们这篇文章是从分布式系统架构层面出发，不拘泥于任何一种技术，所以姑且可以设定：这套分布式存储系统，有两种进程。</p>
<p><strong>一个进程是Master节点，就在一台机器上，负责统一管控分散在多台机器上的数据</strong>。</p>
<p><strong>另外一批进程叫做Slave节点，每台机器上都有一个Slave节点，负责管理那台机器上的数据，跟Master节点进行通信</strong>。</p>
<p>咱们看看下面的图，通过图再来直观的看看上面的描述。</p>
<p><img src="//blog.com/2019/07/25/你一定能看懂的分布式系统容错架构设计/3.webp" alt="img"></p>
<h2 id="4、某台机器宕机了咋办？"><a href="#4、某台机器宕机了咋办？" class="headerlink" title="4、某台机器宕机了咋办？"></a>4、某台机器宕机了咋办？</h2><p>这个时候又有一个问题了，那么万一上面那20台机器上，其中1台机器宕机了咋整呢？</p>
<p>这就尴尬了，兄弟，这会导致本来完整的一份20TB的数据，最后有19TB还在了，有1TB的数据就搞丢了，因为那台机器宕机了啊。</p>
<p>所以说你当然不能允许这种情况的发生，这个时候就必须做一个<strong>数据副本</strong>的策略。</p>
<p>比如说，我们完全可以给每一台机器上的那1TB的数据做2个副本的冗余，放在别的机器上，然后呢，万一说某一台机器宕机，没事啊，因为其他机器上还有他的副本。</p>
<p>我们来看看这种多副本冗余的架构设计图。</p>
<p><img src="//blog.com/2019/07/25/你一定能看懂的分布式系统容错架构设计/4.webp" alt="img"></p>
<p>上面那个图里的浅蓝色的“1TB数据01”，代表的是20TB数据集中的第一个1TB数据分片。</p>
<p>图中可以看到，他就有3个副本，分别在三台机器中都有浅蓝色的方块，代表了他的三个副本。</p>
<p>这样的话，一份数据就有了3个副本了。其他的数据也是类似。</p>
<p>这个时候我们假设有一台机器宕机了，比如下面这台机器宕机，必然会导致“1TB数据01”这个数据分片的其中一个数据副本丢失。如下图所示：</p>
<p><img src="//blog.com/2019/07/25/你一定能看懂的分布式系统容错架构设计/5.webp" alt="img"></p>
<p>那这个时候要紧吗？不要紧，因为“1TB数据01”这个数据分片，他还有另外2个副本在存活的两台机器上呢！</p>
<p>所以如果有人要读取数据，完全可以从另外两台机器上随便挑一个副本来读取就可以了，数据不会丢的，不要紧张，大兄弟。</p>
<h2 id="5、Master节点如何感知到数据副本消失？"><a href="#5、Master节点如何感知到数据副本消失？" class="headerlink" title="5、Master节点如何感知到数据副本消失？"></a>5、Master节点如何感知到数据副本消失？</h2><p>现在有一个问题，比如说有个兄弟要读取“1TB数据01”这个数据分片，那么他就会找Master节点，说：</p>
<p>“你能不能告诉我“1TB数据01”这个数据分片人在哪里啊？在哪台机器上啊？我需要读他啊！”</p>
<p>我们来看看下面的图。</p>
<p><img src="//blog.com/2019/07/25/你一定能看懂的分布式系统容错架构设计/6.webp" alt="img"></p>
<p>那么这个时候，Master节点就需要从“1TB数据01”的3个副本里选择一个出来，告诉人家说：</p>
<p>“兄弟，在哪台哪台机器上，有1个副本，你可以去那台机器上读“1TB数据01”的一个副本就ok了。”</p>
<p>但是现在的问题是，Master节点此时还不知道“1TB数据01”的副本3已经丢失了，那万一Master节点还是通知人家去读取一个已经丢失的副本3，肯定是不可以的。</p>
<p>我们怎么才能让Master节点知道副本3已经丢失了呢？</p>
<p>其实也很简单，<strong>每台机器上负责管理数据的Slave节点，都每隔几秒（比如说1秒）给Master节点发送一个心跳</strong>。</p>
<p>那么，一旦Master节点发现一段时间（比如说30秒内）没收到某个Slave节点发送过来的心跳，此时就会认为这个Slave节点所在机器宕机了，那台机器上的数据副本都丢失了，然后Master节点就不会告诉别人去读那个丢失的数据副本。</p>
<p>大家看看下面的图，一旦Slave节点宕机，Master节点收不到心跳，就会认为那台机器上的副本3就已经丢失了，此时绝对不会让别人去读那台宕机机器上的副本3。</p>
<p><img src="//blog.com/2019/07/25/你一定能看懂的分布式系统容错架构设计/7.webp" alt="img"></p>
<p>那么此时，Master节点就可以通知人家去读“1TB数据01”的副本1或者副本2，哪个都行，因为那两个副本其实还是在的。</p>
<p>举个例子，比如可以通知客户端去读副本1，此时客户端就可以找那台机器上的Slave节点说要读取那个副本1。</p>
<p>整个过程如下图所示。</p>
<p><img src="//blog.com/2019/07/25/你一定能看懂的分布式系统容错架构设计/8.webp" alt="img"></p>
<h2 id="6、复制副本保持足够副本数量"><a href="#6、复制副本保持足够副本数量" class="headerlink" title="6、复制副本保持足够副本数量"></a>6、复制副本保持足够副本数量</h2><p>这个时候又有另外一个问题，那就是“1TB数据01”这个数据分片此时只有副本1和副本2这两个副本了，这就不足够3个副本啊。</p>
<p>因为我们预设的是每个数据分片都得有3个副本的。大家想想，此时如何给这个数据分片增加1个副本呢？</p>
<p>很简单，Master节点一旦感知到某台机器宕机，就能感知到某个数据分片的副本数量不足了。</p>
<p>此时，就会<strong>生成一个副本复制的任务，挑选另外一台机器来从有副本的机器去复制一个副本</strong>。</p>
<p>比如看下面的图，可以挑选第四台机器从第二台机器去复制一个副本。</p>
<p><img src="//blog.com/2019/07/25/你一定能看懂的分布式系统容错架构设计/9.webp" alt="img"></p>
<p>但是，现在这个复制任务是有了，我们怎么让机器4知道呢？</p>
<p>其实也很简单，机器4不是每秒都会发送一次心跳么？当机器4发送心跳过去的时候，<strong>Master节点就通过心跳响应把这个复制任务下发给机器4，让机器4从机器2复制一个副本好了</strong>。</p>
<p>同样，我们来一张图，看看这个过程：</p>
<p><img src="//blog.com/2019/07/25/你一定能看懂的分布式系统容错架构设计/10.webp" alt="img"></p>
<p>看上图，现在机器4上是不是又多了一个“1TB数据01”的副本3 ？那么“1TB数据01”这个数据分片是不是又变成3个副本了？</p>
<h2 id="7、删除多余副本"><a href="#7、删除多余副本" class="headerlink" title="7、删除多余副本"></a>7、删除多余副本</h2><p>那反过来，如果说此时机器3突然恢复了，他上面也有一个“1TB数据01”的副本3，相当于此时“1TB数据01”就有4个副本了，副本不就多余了吗？</p>
<p>没关系，一旦Master节点感知到机器3复活，会发现副本数量过多，此时会生成一个删除副本任务。</p>
<p>他会在机器3发送心跳的时候，下发一个删除副本的指令，让机器3删除自己本地多余的副本就可以了。这样，就可以保持副本数量只有3个。</p>
<p>一样的，大家来看看下面的图。</p>
<p><img src="//blog.com/2019/07/25/你一定能看懂的分布式系统容错架构设计/11.webp" alt="img"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/07/22/微服务API设计的实践与思考总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/22/微服务API设计的实践与思考总结/" itemprop="url">微服务API设计的实践与思考总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-22T12:12:57+08:00">
                2019-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/API设计/" itemprop="url" rel="index">
                    <span itemprop="name">API设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="微服务API设计的实践与思考总结"><a href="#微服务API设计的实践与思考总结" class="headerlink" title="微服务API设计的实践与思考总结"></a>微服务API设计的实践与思考总结</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="http://tech.dianwoda.com/2019/06/28/wei-fu-wu-apishe-ji-de-shi-jian-yu-si-kao-zong-jie/" target="_blank" rel="noopener">http://tech.dianwoda.com/2019/06/28/wei-fu-wu-apishe-ji-de-shi-jian-yu-si-kao-zong-jie/</a></p>
</blockquote>
<p><br></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随着微服务的越来越流行，越来的越多的公司开始实行微服务架构，相对于单一应用架构，微服务将复杂性拆分并且打散到一个个粒度更加细分的应用中，极大了减少了开发中单个服务的复杂性，开发人员只需要面向专注单一业务场景编程，从技术开发角度，单一服务代码量上减少很多，从业务角度上，业务复杂性的降低降低了需求的沟通成本，然而，整体业务复杂性依然存在，当我们需要接入或者依赖其他服务时，通常作为接入方来说，我们不需要深入了解服务提供方的业务，此时<code>API</code>成为了开发人员间的沟通语言。 良好的<code>API</code>设计，能极大的减少沟通成本，甚至有时候可以代替文档，尤其是对于基础性服务来说，服务的可扩展性有时候体现在<code>API</code>的可扩展性，我曾经参与过一个基础业务微服务的业务升级，由于旧版本的<code>API</code>划分不够清晰，部分<code>API</code>存在重复性，后面不得不对大部分<code>API</code>进行重构（替换为新版本的<code>API</code>），仅仅在服务消费方升级这个阶段就持续1-2个月之久，在这个过程中也不断对<code>API</code>设计中存在的一些问题以及应该遵循哪些原则进行了一些思考。</p>
<h2 id="API先行"><a href="#API先行" class="headerlink" title="API先行"></a>API先行</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在敏捷开发的大浪潮下，产品上通常要求快速迭代，面对一个新的需求，<strong>如果需要开发新的接口，通常在表结构完成设计后，开发人员就需要完成<code>API</code>设计并交付消费方（即服务的调用方或者依赖方，文中其余部分均表示此含义），在技术联调前，消费方可以<code>Mock</code>接口来完成调试</strong>。所以通常来说，<code>API</code>先与服务交付，之后再完成编码，测试，调试等工作。当然，由于可能在需求细节，技术实现方面可能在实现过程中发现需求需要调整，或者<code>API</code>接口的调整，最初版本的<code>API</code>可能是不成熟的，导致我们经常在<code>API</code>调整或者演化过程中在<code>API</code>维护方面存在很多遗漏，所以<code>API</code>最初交付后的维护是持续性的工作。</p>
<h2 id="API设计常见问题"><a href="#API设计常见问题" class="headerlink" title="API设计常见问题"></a>API设计常见问题</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们设计<code>API</code>过程中由于存在经验的缺失，或者由于多次交接，或者由于经历多次需求的变更，导致服务的<code>API</code>慢慢腐化，带来以下常见的问题。</p>
<h3 id="被遗忘的注释"><a href="#被遗忘的注释" class="headerlink" title="被遗忘的注释"></a>被遗忘的注释</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注释通常描述了<code>API</code>的功能以及参数说明，以及如何接入，甚至给出简单示例，过于详细的注释会带来一定的反作用，例如因为新需求带来了内部逻辑的调整，但是由于未及时对<code>API</code>的注释进行更新，会给新接入的调用方带来潜在的风险。所以不仅仅需要为<code>API</code>提供完整清晰的注释，当内部逻辑变更时，作为开发人员通常也需要评估<code>API</code>层面的变更，包括注释。</p>
<h3 id="接口数量持续膨胀"><a href="#接口数量持续膨胀" class="headerlink" title="接口数量持续膨胀"></a>接口数量持续膨胀</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有很多原因带来接口数量的膨胀，可能是接口升级，但是旧接口无法直接下线，所以会提供一个功能类似的新接口；可能是新接管一个服务由于对业务不了解，面对新需求直接开发新接口；可能是接口分类划分不合理，或者数据模型混乱导致<code>API</code>划分混乱，出现<code>API</code>功能重复，最后导致一个场景多个<code>API</code>接口都可以满足，这样很明显是应该避免的。解决这些问题都需要建立在对业务充分理解的基础上，下文的设计原则会针对这类问题给出解决方案。</p>
<h3 id="缺乏有效测试"><a href="#缺乏有效测试" class="headerlink" title="缺乏有效测试"></a>缺乏有效测试</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多开发人员往往忽略对于接口的测试，无论是内部逻辑细节的单元测试，还是接口层面的测试，都是服务健壮性的一个有效保证，如果无法对接口进行有效测试，不仅是不负责任的提现，而且还会经常被线上<code>bug</code>困扰。</p>
<h2 id="API设计的原则"><a href="#API设计的原则" class="headerlink" title="API设计的原则"></a>API设计的原则</h2><h3 id="简单且专注"><a href="#简单且专注" class="headerlink" title="简单且专注"></a>简单且专注</h3><h4 id="简单"><a href="#简单" class="headerlink" title="简单"></a>简单</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在面向对象设计原则中，第一条是单一职责原则，同样适用于<code>API</code>设计，我们的主体对象就是业务模型，<code>API</code>就是封装内部逻辑后对外界开放的功能。保证<code>API</code>的简单和职责单一，能够避免解决上文中提到的接口数量膨胀问题。那如何才能实现<code>API</code>职责单一，需要我们在定义接口时能够准确识别出接口之间的关联性和边界，对于<code>API</code>如何划分可以通过以下角度：</p>
<ol>
<li><p>按照业务主体划分，不一样的业务主体采用不一样的接口类 </p>
</li>
<li><p>查询类修改类的接口分离</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常来说我们对于数据的查询场景远大于修改的场景，而且查询有多种多样的业务场景，对于数据的修改请求通常来源于业务后台人员对数据进行修改，此时的业务逻辑也通常会更加特殊（例如有很多额外数据校验），所以建议修改类和查询类<code>API</code>尽量分离，甚至可以将业务配置后台类查询和普通业务查询分离以至于能够适应各自的业务变更。</p>
</li>
</ol>
<h4 id="专注"><a href="#专注" class="headerlink" title="专注"></a>专注</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个单一接口的场景是基于业务抽象后专注于某一个场景并且互相不重合的，这样才能保证接口的粒度足够小，尤其是对于基础类服务，接口粒度的划分能保证接口是纯粹的且互相独立的，这样才不至于在需求变化是涉及过多接口的变动（除非是对业务模型有较大的调整），另外要说明的是，内部逻辑的业务数据模型（<code>POJO</code>类）和<code>API</code>数据模型（<code>DTO</code>）有时候出现差异，否则可能需要消费者理解服务的业务模型才能正确的使用接口，这就要求在<code>API</code>设计中开发人员需要明确应该提供哪些数据模型给消费者，在此前提下更加有助于我们保证单一接口的专注。</p>
<h3 id="良好的注释"><a href="#良好的注释" class="headerlink" title="良好的注释"></a>良好的注释</h3><ul>
<li>注释应该包含哪些；接口的使用场景，参数的说明，在接口类说明中可以给出接口文档链接地址，方便调用方查看</li>
<li>参数的说明；包含参数代表的含义，参数的类型按照Javadoc link规范，参数是否为空，特殊值说明</li>
<li>过期说明；如果接口已经过期，需要给出过期说明，对于Java来时就是@Deprecated注解，并给出切换接口说明，如果条件允许可以推动调用方进行接口迁移，后续对旧接口下线</li>
</ul>
<h3 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;唯一不变的是变化，接口也会一直演化，我们不提倡过度提前设计，但是在演化过程中要始终保持接口的可扩展性。</p>
<h4 id="多参数结构与单一参数类结构"><a href="#多参数结构与单一参数类结构" class="headerlink" title="多参数结构与单一参数类结构"></a>多参数结构与单一参数类结构</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常来说，如果一个接口的参数小于三个，那么建议使用多参数接口，这样做到直观简洁 如果一个接口的参数较多而且后续可能经常出现变动，为了便于扩展和兼容，会将参数封装到一个类结构中，记得同样对每个字段给出完整的注释说明</p>
<h4 id="类复用噩梦"><a href="#类复用噩梦" class="headerlink" title="类复用噩梦"></a>类复用噩梦</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在单一参数类结构下，我经常看到多个存在明显功能差异的接口频繁复用一个结构体，甚至接口参数和返回值都复用一个<code>DTO</code>，为了保证兼容，又不得不在同一个<code>DTO</code>内不断加字段，久而久之维护成本持续增高，这是一种不合理的类设计，如果遵守专注原则，这个问题很多时候可以避免</p>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><h4 id="逻辑兼容"><a href="#逻辑兼容" class="headerlink" title="逻辑兼容"></a>逻辑兼容</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接口逻辑或者参数变更时，需要对旧的接口保持兼容，这个是<code>API</code>变更时一定要遵守的原则之一，而且要通过接口测试来验证兼容性</p>
<h4 id="是否要新增接口"><a href="#是否要新增接口" class="headerlink" title="是否要新增接口"></a>是否要新增接口</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当面对一个新的需求时，为了避免对旧接口直接修改，有的开发人员会统一提供新的接口，如果并非逻辑上发生较大的变更，这样做会提高<code>API</code>的维护成本，后续如果不对<code>API</code>进行重构，新增加的维护成本将远大于最开始节省的开发成本，例如需要对某个参数增加有效校验，那么我们需要对两个接口的<code>API</code>实现都做修改，而且是重复性的代码，而且我们的影响范围已经成了两个接口，这样影响范围的扩大也带来了更多的潜在风险。 当然在某些场景例如接口逻辑出现大的调整，<code>API</code>重构等情况下，更好的方法是提供新的接口，并推动服务消费者使用新的<code>API</code>，最后慢慢下线旧的<code>API</code>，这样才能遵循简单和专注的原则。</p>
<h3 id="完善的测试"><a href="#完善的测试" class="headerlink" title="完善的测试"></a>完善的测试</h3><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完善的单元测试能保证代码的健壮性，提前在编码阶段发现并解决潜在的bug，单元测试是一个开发人员的必备能力。</p>
<h4 id="接口和场景测试"><a href="#接口和场景测试" class="headerlink" title="接口和场景测试"></a>接口和场景测试</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接口测试包含内部逻辑验证，异常输入，并发等场景下对单一接口的验证，如果要对<code>API</code>进行完整的逻辑验证，需要开发人员构造完整的测试数据（通常包含<code>scheme.sql</code>和<code>data.sql</code>文件），尤其是对于基础服务，需要对某些复杂业务场景下联合多个接口完成某个场景的测试，并对中间的数据和输出进行<code>Assert</code>确认，这样也会代码一定的测试代码维护成本，需要开发人员进行利弊权衡。</p>
<h3 id="重视文档"><a href="#重视文档" class="headerlink" title="重视文档"></a>重视文档</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;良好的注释和文档能减少大部分和服务消费者的沟通工作，也避免了一些错误的接口调使用。没有人希望每次都需要在<code>IM</code>工具上浪费大量口水或者需要当面询问才知道如何正确使用<code>API</code>，也没有开发者愿意每天重复回答如何调用提供的接口。对于接口文档，可以是采用<code>Javadoc</code>这样简单的方式，也可以是通过<code>wiki</code>来集中管理，可以是<code>markdown</code>文档，也有很多的开源系统例如<code>swagger，yapi，eolinker</code>等；微服务的架构极大的加强了沟通的成本，这也是微服务架构的一个弊端，但是合理的利用工具可以减少不必要的沟通。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为微服务之间的桥梁，<code>API</code>设计和维护是微服务架构中很重要的一个环节，每个开发人员不仅仅需要良好的代码规范，也需要建立并遵守<code>API</code>设计规范。<code>API</code>设计能力在微服务架构中作为软实力的一个部分，需要开发人员有一定的设计经验的积累，同时，只有不断的思考和总结才能更加深入的理解。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/23/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><span class="page-number current">24</span><a class="page-number" href="/page/25/">25</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/25/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
