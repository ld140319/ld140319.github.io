<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/page/104/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/page/104/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/04/04/Leaf——美团点评分布式ID生成系统/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/04/Leaf——美团点评分布式ID生成系统/" itemprop="url">Leaf——美团点评分布式ID生成系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-04T12:12:57+08:00">
                2019-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/分布式ID生成/" itemprop="url" rel="index">
                    <span itemprop="name">分布式ID生成</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Leaf——美团点评分布式ID生成系统"><a href="#Leaf——美团点评分布式ID生成系统" class="headerlink" title="Leaf——美团点评分布式ID生成系统"></a>Leaf——美团点评分布式ID生成系统</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识。如在美团点评的金融、支付、餐饮、酒店、猫眼电影等产品的系统中，数据日渐增长，对数据分库分表后需要有一个唯一ID来标识一条数据或消息，数据库的自增ID显然不能满足需求；特别一点的如订单、骑手、优惠券也都需要有唯一ID做标识。此时一个能够生成全局唯一ID的系统是非常必要的。概括下来，那业务系统对ID号的要求有哪些呢？</p>
<ol>
<li><strong>全局唯一性</strong>：不能出现重复的ID号，既然是唯一标识，这是最基本的要求。</li>
<li><strong>趋势递增</strong>：在MySQL InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用B-tree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。</li>
<li><strong>单调递增</strong>：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求。</li>
<li><strong>信息安全</strong>：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。</li>
</ol>
<p>上述123对应三类不同的场景，<strong>3和4需求还是互斥的，无法使用同一个方案满足</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;同时除了对ID号码自身的要求，业务还对ID号生成系统的可用性要求极高，想象一下，如果ID生成系统瘫痪，整个美团点评支付、优惠券发券、骑手派单等关键动作都无法执行，这就会带来一场灾难。</p>
<p>由此总结下一个ID生成系统应该做到如下几点：</p>
<ol>
<li><strong>平均延迟和TP999延迟都要尽可能低</strong>；</li>
<li>可用性5个9；</li>
<li>高QPS。</li>
</ol>
<h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<code>UUID(Universally Unique Identifier)</code>的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的36个字符，示例：<code>550e8400-e29b-41d4-a716-446655440000</code>，到目前为止业界一共有5种方式生成UUID，详情见IETF发布的UUID规范 <a href="http://www.ietf.org/rfc/rfc4122.txt" target="_blank" rel="noopener">A Universally Unique IDentifier (UUID) URN Namespace</a>。</p>
<p>优点：</p>
<ul>
<li><strong>性能非常高</strong>：本地生成，没有网络消耗。</li>
</ul>
<p>缺点：</p>
<ul>
<li><p><strong>不易于存储</strong>：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。</p>
</li>
<li><p>信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</p>
</li>
<li><p><strong>ID作为主键时在特定的环境会存在一些问题</strong>，比如做DB主键的场景下，UUID就非常不适用：</p>
<p>① MySQL官方有明确的建议主键要尽量越短越好[4]，36个字符长度的UUID不符合要求。</p>
</li>
</ul>
<blockquote>
<p>All indexes other than the clustered index are known as secondary indexes. In InnoDB, each record in a secondary index contains the primary key columns for the row, as well as the columns specified for the secondary index. InnoDB uses this primary key value to search for the row in the clustered index.<strong><em> If the primary key is long, the secondary indexes use more space, so it is advantageous to have a short primary key</em></strong>.</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;② 对MySQL索引不利：如果作为数据库主键，在InnoDB引擎下，UUID的无序性可能会引起数据位置频繁变动，严重影响性能。</p>
<h3 id="类snowflake方案"><a href="#类snowflake方案" class="headerlink" title="类snowflake方案"></a>类snowflake方案</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;这种方案大致来说是一种以划分命名空间（UUID也算，由于比较常见，所以单独分析）来生成ID的一种算法，这种方案把64-bit分别划分成多段，分开来标示机器、时间等，比如在snowflake中的64-bit分别表示如下图（图片来自网络）所示：</p>
<p><img src="//blog.com/2019/04/04/Leaf——美团点评分布式ID生成系统/eee18df9.png" alt="image"></p>
<blockquote>
<p>41-bit的时间可以表示（1L&lt;&lt;41）/(1000L<em>3600</em>24*365)=69年的时间</p>
<p>10-bit机器可以分别表示1024台机器。如果我们对IDC划分有需求，还可以将10-bit分5-bit给IDC，分5-bit给工作机器。这样就可以表示32个IDC，每个IDC下可以有32台机器，可以根据自身需求定义。</p>
<p>12个自增序列号可以表示2^12个ID</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;理论上snowflake方案的<code>QPS</code>约为409.6w/s，这种分配方式可以保证在任何一个IDC的任何一台机器在任意毫秒内生成的ID都是不同的。</p>
<p>这种方式的优缺点是：</p>
<p>优点：</p>
<ul>
<li>毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。</li>
<li>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。</li>
<li>可以根据自身业务特性分配bit位，非常灵活。</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>强依赖机器时钟</strong>，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</li>
</ul>
<h4 id="应用举例Mongdb-objectID"><a href="#应用举例Mongdb-objectID" class="headerlink" title="应用举例Mongdb objectID"></a>应用举例Mongdb objectID</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://docs.mongodb.com/manual/reference/method/ObjectId/#description" target="_blank" rel="noopener">MongoDB官方文档 ObjectID</a>可以算作是和snowflake类似方法，通过“时间+机器码+pid+inc”共12个字节，通过4+3+2+3的方式最终标识成一个24长度的十六进制字符。</p>
<h3 id="数据库生成"><a href="#数据库生成" class="headerlink" title="数据库生成"></a>数据库生成</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;以MySQL举例，利用给字段设置<code>auto_increment_increment</code>和<code>auto_increment_offset</code>来保证ID自增，每次业务使用下列SQL读写MySQL得到ID号。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">REPLACE</span> <span class="keyword">INTO</span> Tickets64 (stub) <span class="keyword">VALUES</span> (<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LAST_INSERT_ID</span>();</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
<p><img src="//blog.com/2019/04/04/Leaf——美团点评分布式ID生成系统/8a4de8e8.png" alt="image"></p>
<p>image</p>
<p>这种方案的优缺点如下：</p>
<p>优点：</p>
<ul>
<li>非常简单，利用现有数据库系统的功能实现，成本小，有DBA专业维护。</li>
<li>ID号单调自增，可以实现一些对ID有特殊要求的业务。</li>
</ul>
<p>缺点：</p>
<ul>
<li><strong>强依赖DB</strong>，当DB异常时整个系统不可用，属于致命问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。</li>
<li><strong>ID发号性能瓶颈限制在单台MySQL的读写性能</strong>。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;对于MySQL性能问题，可用如下方案解决：<strong>在分布式系统中我们可以多部署几台机器，每台机器设置不同的初始值，且步长和机器数相等</strong>。比如有两台机器。设置步长step为2，TicketServer1的初始值为1（1，3，5，7，9，11…）、TicketServer2的初始值为2（2，4，6，8，10…）。这是Flickr团队在2010年撰文介绍的一种主键生成策略（<a href="http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" target="_blank" rel="noopener">Ticket Servers: Distributed Unique Primary Keys on the Cheap </a>）。如下所示，为了实现上述方案分别设置两台机器对应的参数，TicketServer1从1开始发号，TicketServer2从2开始发号，两台机器每次发号之后都递增2。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TicketServer1:</span><br><span class="line">auto-increment-increment = 2</span><br><span class="line">auto-increment-offset = 1</span><br><span class="line"></span><br><span class="line">TicketServer2:</span><br><span class="line">auto-increment-increment = 2</span><br><span class="line">auto-increment-offset = 2</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;假设我们要部署N台机器，步长需设置为N，每台的初始值依次为0,1,2…N-1那么整个架构就变成了如下图所示：</p>
<p><img src="//blog.com/2019/04/04/Leaf——美团点评分布式ID生成系统/6d2c9ec8.png" alt="image"></p>
<p>image</p>
<p>这种架构貌似能够满足性能的需求，但有以下几个缺点：</p>
<ul>
<li><strong>系统水平扩展比较困难</strong>，比如定义好了步长和机器台数之后，如果要添加机器该怎么做？假设现在只有一台机器发号是1,2,3,4,5（步长是1），这个时候需要扩容机器一台。可以这样做：把第二台机器的初始值设置得比第一台超过很多，比如14（假设在扩容时间之内第一台不可能发到14），同时设置步长为2，那么这台机器下发的号码都是14以后的偶数。然后摘掉第一台，把ID值保留为奇数，比如7，然后修改第一台的步长为2。让它符合我们定义的号段标准，对于这个例子来说就是让第一台以后只能产生奇数。扩容方案看起来复杂吗？貌似还好，现在想象一下如果我们线上有100台机器，这个时候要扩容该怎么做？简直是噩梦。所以系统水平扩展方案复杂难以实现。</li>
<li><strong>ID没有了单调递增的特性，只能趋势递增</strong>，这个缺点对于一般业务需求不是很重要，可以容忍。</li>
<li><strong>数据库压力还是很大</strong>，每次获取ID都得读写一次数据库，只能靠堆机器来提高性能。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Leaf这个名字是来自德国哲学家、数学家莱布尼茨的一句话： &gt;There are no two identical leaves in the world &gt; “世界上没有两片相同的树叶”</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;综合对比上述几种方案，每种方案都不完全符合我们的要求。所以Leaf分别在上述第二种和第三种方案上做了相应的优化，实现了Leaf-segment和Leaf-snowflake方案。</p>
<h3 id="Leaf-segment数据库方案"><a href="#Leaf-segment数据库方案" class="headerlink" title="Leaf-segment数据库方案"></a>Leaf-segment数据库方案</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;第一种Leaf-segment方案，在使用数据库的方案上，做了如下改变： - 原方案每次获取ID都得读写一次数据库，造成数据库压力大。改为<strong>利用proxy server批量获取，每次获取一个segment(step决定大小)号段的值</strong>。<strong>用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力</strong>。 <strong>各个业务不同的发号需求用biz_tag字段来区分，每个biz-tag的ID获取相互隔离，互不影响</strong>。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对biz_tag分库分表就行。</p>
<p>数据库表设计如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line">| Field       | Type         | Null | Key | Default           | Extra                       |</span><br><span class="line">+<span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br><span class="line">| biz_tag     | varchar(128) | NO   | PRI |                   |                             |</span><br><span class="line">| max_id      | bigint(20)   | NO   |     | 1                 |                             |</span><br><span class="line">| step        | int(11)      | NO   |     | NULL              |                             |</span><br><span class="line">| desc        | varchar(256) | YES  |     | NULL              |                             |</span><br><span class="line">| update_time | timestamp    | NO   |     | CURRENT_TIMESTAMP | on <span class="keyword">update</span> <span class="keyword">CURRENT_TIMESTAMP</span> |</span><br><span class="line">+<span class="comment">-------------+--------------+------+-----+-------------------+-----------------------------+</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;重要字段说明：<strong>biz_tag用来区分业务，max_id表示该biz_tag目前所被分配的ID号段的最大值，step表示每次分配的号段长度</strong>。原来获取ID每次都需要写数据库，现在只需要把step设置得足够大，比如1000。那么只有当1000个号被消耗完了之后才会去重新读写一次数据库。读写数据库的频率从1减小到了1/step，大致架构如下图所示：</p>
<p><img src="//blog.com/2019/04/04/Leaf——美团点评分布式ID生成系统/5e4ff128.png" alt="image"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;test_tag在第一台Leaf机器上是1~1000的号段，当这个号段用完时，会去加载另一个长度为step=1000的号段，假设另外两台号段都没有更新，这个时候第一台机器新加载的号段就应该是3001~4000。同时数据库对应的biz_tag这条数据的max_id会从3000被更新成4000，更新号段的SQL语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Begin</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">table</span> <span class="keyword">SET</span> max_id=max_id+step <span class="keyword">WHERE</span> biz_tag=xxx</span><br><span class="line"><span class="keyword">SELECT</span> tag, max_id, step <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> biz_tag=xxx</span><br><span class="line"><span class="keyword">Commit</span></span><br></pre></td></tr></table></figure>
<p>这种模式有以下优缺点：</p>
<p>优点：</p>
<ul>
<li>Leaf服务可以很方便的线性扩展，性能完全能够支撑大多数业务场景。</li>
<li>ID号码是趋势递增的8byte的64位数字，满足上述数据库存储的主键要求。</li>
<li>容灾性高：Leaf服务内部有号段缓存，即使DB宕机，短时间内Leaf仍能正常对外提供服务。</li>
<li>可以自定义max_id的大小，非常方便业务从原有的ID方式上迁移过来。</li>
</ul>
<p>缺点：</p>
<ul>
<li>ID号码不够随机，能够泄露发号数量的信息，不太安全。</li>
<li>TP999数据波动大，当号段使用完之后还是会hang在更新数据库的I/O上，tg999数据会出现偶尔的尖刺。</li>
<li>DB宕机会造成整个系统不可用。</li>
</ul>
<h3 id="双buffer优化"><a href="#双buffer优化" class="headerlink" title="双buffer优化"></a>双buffer优化</h3><p>对于第二个缺点，Leaf-segment做了一些优化，简单的说就是：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Leaf 取号段的时机是在号段消耗完的时候进行的，也就意味着号段临界点的ID下发时间取决于下一次从DB取回号段的时间，并且在这期间<strong>进来的请求也会因为DB号段没有取回来，导致线程阻塞</strong>。如果请求DB的网络和DB的性能稳定，这种情况对系统的影响是不大的，但是假如取DB的时候网络发生抖动，或者DB发生慢查询就会导致整个系统的响应时间变慢。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;为此，我们希望DB取号段的过程能够做到无阻塞，不需要在DB取号段的时候阻塞请求线程，即<strong>当号段消费到某个点时就异步的把下一个号段加载到内存中</strong>。<strong>而不需要等到号段用尽的时候才去更新号段</strong>。这样做就可以很大程度上的降低系统的TP999指标。详细实现如下图所示：</p>
<p><img src="//blog.com/2019/04/04/Leaf——美团点评分布式ID生成系统/f2625fac.png" alt="image"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;采用双buffer的方式，<strong>Leaf服务内部有两个号段缓存区segment。当前号段已下发10%时，如果下一个号段未更新，则另启一个更新线程去更新下一个号段</strong>。<strong>当前号段全部下发完后，如果下个号段准备好了则切换到下个号段为当前segment接着下发，循环往复</strong>。</p>
<ul>
<li>每个biz-tag都有消费速度监控，<strong>通常推荐segment长度设置为服务高峰期发号QPS的600倍（10分钟）</strong>，这样即使DB宕机，Leaf仍能持续发号10-20分钟不受影响。</li>
<li>每次请求来临时都会判断下个号段的状态，从而更新此号段，所以偶尔的网络抖动不会影响下个号段的更新。</li>
</ul>
<h3 id="Leaf高可用容灾"><a href="#Leaf高可用容灾" class="headerlink" title="Leaf高可用容灾"></a>Leaf高可用容灾</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;对于第三点“DB可用性”问题，我们目前采用一主两从的方式，同时分机房部署，Master和Slave之间采用<strong>半同步方式[5]</strong>同步数据。同时使用公司Atlas数据库中间件(已开源，改名为<a href="http://tech.meituan.com/dbproxy-introduction.html" target="_blank" rel="noopener">DBProxy</a>)做主从切换。当然这种方案在一些情况会退化成异步模式，甚至在<strong>非常极端</strong>情况下仍然会造成数据不一致的情况，但是出现的概率非常小。如果你的系统要保证100%的数据强一致，可以选择使用“类Paxos算法”实现的强一致MySQL方案，如MySQL 5.7前段时间刚刚GA的<a href="https://dev.mysql.com/doc/refman/5.7/en/group-replication.html" target="_blank" rel="noopener">MySQL Group Replication</a>。但是运维成本和精力都会相应的增加，根据实际情况选型即可。</p>
<p><img src="//blog.com/2019/04/04/Leaf——美团点评分布式ID生成系统/0de883dd.png" alt="image"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;同时Leaf服务分IDC部署，内部的服务化框架是“MTthrift RPC”。服务调用的时候，根据负载均衡算法会优先调用同机房的Leaf服务。在该IDC内Leaf服务不可用的时候才会选择其他机房的Leaf服务。同时服务治理平台OCTO还提供了针对服务的过载保护、一键截流、动态流量分配等对服务的保护措施。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>Leaf-segment方案可以生成趋势递增的ID，同时ID号是可计算的，不适用于订单ID生成场景，比如竞对在两天中午12点分别下单，通过订单id号相减就能大致计算出公司一天的订单量，这个是不能忍受的</strong>。面对这一问题，我们提供了 Leaf-snowflake方案。</p>
<p><img src="//blog.com/2019/04/04/Leaf——美团点评分布式ID生成系统/721ceeff.png" alt="image"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Leaf-snowflake方案完全沿用snowflake方案的bit位设计，即是<strong>“1+41+10+12”</strong>的方式组装ID号。对于workerID的分配，当服务集群数量较小的情况下，完全可以手动配置。Leaf服务规模较大，动手配置成本太高。所以使用Zookeeper持久顺序节点的特性自动对snowflake节点配置wokerID。Leaf-snowflake是按照下面几个步骤启动的：</p>
<ol>
<li>启动Leaf-snowflake服务，连接Zookeeper，在leaf_forever父节点下检查自己是否已经注册过（是否有该顺序子节点）。</li>
<li>如果有注册过直接取回自己的workerID（<strong>zk顺序节点生成的int类型ID号</strong>），启动服务。</li>
<li>如果没有注册过，就在该父节点下面创建一个<strong>持久顺序节点</strong>，创建成功后取回顺序号当做自己的workerID号，启动服务。</li>
</ol>
<p><img src="//blog.com/2019/04/04/Leaf——美团点评分布式ID生成系统/a3f985a8.png" alt="image"></p>
<h3 id="弱依赖ZooKeeper"><a href="#弱依赖ZooKeeper" class="headerlink" title="弱依赖ZooKeeper"></a>弱依赖ZooKeeper</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;除了每次会去ZK拿数据以外，也会<strong>在本机文件系统上缓存一个workerID文件</strong>。当ZooKeeper出现问题，恰好机器出现问题需要重启时，能保证服务能够正常启动。这样做到了对三方组件的弱依赖。一定程度上提高了SLA</p>
<h3 id="解决时钟问题"><a href="#解决时钟问题" class="headerlink" title="解决时钟问题"></a>解决时钟问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;因为这种方案依赖时间，如果机器的时钟发生了回拨，那么就会有可能生成重复的ID号，需要解决时钟回退的问题。</p>
<p><img src="//blog.com/2019/04/04/Leaf——美团点评分布式ID生成系统/1453b4e9.png" alt="image"></p>
<p>参见上图整个启动流程图，服务启动时首先检查自己是否写过ZooKeeper leaf_forever节点：</p>
<ol>
<li>若写过，则用自身系统时间与leaf_forever/${self}节点记录时间做比较，若小于leaf_forever/${self}时间则认为机器时间发生了大步长回拨，服务启动失败并报警。</li>
<li>若未写过，证明是新服务节点，直接创建持久节点leaf_forever/${self}并写入自身系统时间，接下来综合对比其余Leaf节点的系统时间来判断自身系统时间是否准确，具体做法是取leaf_temporary下的所有临时节点(所有运行中的Leaf-snowflake节点)的服务IP：Port，然后通过RPC请求得到所有节点的系统时间，计算sum(time)/nodeSize。</li>
<li>若abs( 系统时间-sum(time)/nodeSize ) &lt; 阈值，认为当前系统时间准确，正常启动服务，同时写临时节点leaf_temporary/${self} 维持租约。</li>
<li>否则认为本机系统时间发生大步长偏移，启动失败并报警。</li>
<li>每隔一段时间(3s)上报自身系统时间写入leaf_forever/${self}。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;由于强依赖时钟，对时间的要求比较敏感，在机器工作时NTP同步也会造成秒级别的回退，建议可以直接关闭NTP同步。要么在时钟回拨的时候直接不提供服务直接返回ERROR_CODE，等时钟追上即可。<strong>或者做一层重试，然后上报报警系统，更或者是发现有时钟回拨之后自动摘除本身节点并报警</strong>，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发生了回拨，此刻时间小于上次发号时间</span></span><br><span class="line"><span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line"> 			  </span><br><span class="line">           <span class="keyword">long</span> offset = lastTimestamp - timestamp;</span><br><span class="line">           <span class="keyword">if</span> (offset &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">               	<span class="comment">//时间偏差大小小于5ms，则等待两倍时间</span></span><br><span class="line">                   wait(offset &lt;&lt; <span class="number">1</span>);<span class="comment">//wait</span></span><br><span class="line">                   timestamp = timeGen();</span><br><span class="line">                   <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">                      <span class="comment">//还是小于，抛异常并上报</span></span><br><span class="line">                       throwClockBackwardsEx(timestamp);</span><br><span class="line">                     &#125;    </span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </span><br><span class="line">                  <span class="keyword">throw</span>  e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//throw</span></span><br><span class="line">               throwClockBackwardsEx(timestamp);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//分配ID</span></span><br></pre></td></tr></table></figure>
<p><strong>从上线情况来看，在2017年闰秒出现那一次出现过部分机器回拨，由于Leaf-snowflake的策略保证，成功避免了对业务造成的影响。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/04/04/Tinyid——滴滴分布式ID生成系统/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/04/Tinyid——滴滴分布式ID生成系统/" itemprop="url">Tinyid——滴滴分布式ID生成系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-04T12:12:57+08:00">
                2019-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/分布式ID生成/" itemprop="url" rel="index">
                    <span itemprop="name">分布式ID生成</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Tinyid——滴滴分布式ID生成系统"><a href="#Tinyid——滴滴分布式ID生成系统" class="headerlink" title="Tinyid——滴滴分布式ID生成系统"></a>Tinyid——滴滴分布式ID生成系统</h1><h2 id="Id生成系统要点"><a href="#Id生成系统要点" class="headerlink" title="Id生成系统要点"></a>Id生成系统要点</h2><p> 在简单系统中，我们常常使用db的id自增方式来标识和保存数据，随着系统的复杂，数据的增多，分库分表成为了常见的方案，db自增已无法满足要求。这时候全局唯一的id生成系统就派上了用场。当然这只是id生成其中的一种应用场景。那么id生成系统有哪些要求呢？</p>
<ol>
<li><strong>全局唯一的id</strong>:无论怎样都不能重复，这是最基本的要求了</li>
<li><strong>高性能</strong>:基础服务尽可能耗时少，如果能够本地生成最好</li>
<li><strong>高可用</strong>:虽说很难实现100%的可用性，但是也要无限接近于100%的可用性</li>
<li>简单易用: 能够拿来即用，接入方便，同时在系统设计和实现上要尽可能的简单</li>
</ol>
<h2 id="tinyid的原理"><a href="#tinyid的原理" class="headerlink" title="tinyid的原理"></a>tinyid的原理</h2><ul>
<li><code>tinyid</code>是基于数据库发号算法实现的，简单来说是<strong>数据库中保存了可用的id号段，tinyid会将可用号段加载到内存中，之后生成id会直接内存中产生</strong>。</li>
<li>可用号段在第一次获取id时加载，如<strong>当前号段使用达到一定量时，会异步加载下一可用号段，保证内存中始终有可用号段</strong>。</li>
<li>(如可用号段1~1000被加载到内存，则获取id时，会从1开始递增获取，当使用到一定百分比时，如20%(默认)，即200时，会异步加载下一可用号段到内存，假设新加载的号段是1001~2000,则此时内存中可用号段为200~1000,1001~2000)，当id递增到1000时，<strong>当前号段使用完毕，下一号段会替换为当前号段</strong>。依次类推。</li>
</ul>
<h2 id="tinyid系统架构图"><a href="#tinyid系统架构图" class="headerlink" title="tinyid系统架构图"></a>tinyid系统架构图</h2><p><img src="//blog.com/2019/04/04/Tinyid——滴滴分布式ID生成系统/tinyid.png" alt=""></p>
<p>下面是一些关于这个架构图的说明:</p>
<ul>
<li><code>nextId</code>和<code>getNextSegmentId</code>是<code>tinyid-server</code>对外提供的两个http接口</li>
<li><code>nextId</code>是获取下一个id，当调用<code>nextId</code>时，会传入<code>bizType</code>，每个<code>bizType</code>的id数据是隔离的，生成id会使用该<code>bizType</code>类型生成的<code>IdGenerator</code>。</li>
<li><code>getNextSegmentId</code>是获取下一个可用号段，<code>tinyid-client</code>会通过此接口来获取可用号段</li>
<li><code>IdGenerator</code>是id生成的接口</li>
<li><code>dGeneratorFactory</code>是生产具体<code>IdGenerator</code>的工厂，每个<code>biz_type</code>生成一个<code>IdGenerator</code>实例。通过工厂，我们可以随时在db中新增<code>biz_type</code>，而不用重启服务</li>
<li><code>IdGeneratorFactory</code>实际上有两个子类<code>IdGeneratorFactoryServer</code>和<code>IdGeneratorFactoryClient</code>，区别在于，<code>etNextSegmentId</code>的不同，一个是<code>DbGet</code>,一个是<code>HttpGet</code></li>
<li><code>CachedIdGenerator</code>则是具体的id生成器对象，持有<code>currentSegmentId</code>和<code>nextSegmentId</code>对象，负责<code>nextId</code>的核心流程。<code>nextId</code>最终通过<code>AtomicLong.andAndGet(delta)</code>方法产生。</li>
</ul>
<h2 id="Tinyid的实现原理"><a href="#Tinyid的实现原理" class="headerlink" title="Tinyid的实现原理"></a>Tinyid的实现原理</h2><p> 我们先来看一下最常见的id生成方式，db的<code>auto_increment</code>，相信大家都非常熟悉，我也见过一些同学在实战中使用这种方案来获取一个id，这个方案的优点是简单，缺点是<strong>每次只能向db获取一个id，性能比较差，对db访问比较频繁，db的压力会比较大</strong>。那么是不是可以对这种方案优化一下呢，可否一次向db获取一批id呢？答案当然是可以的。<br> 一批id，我们可以看成是一个id范围，例如(1000,2000]，这个1000到2000也可以称为<strong>一个”号段”，我们一次向db申请一个号段，加载到内存中，然后采用自增的方式来生成id，这个号段用完后，再次向db申请一个新的号段，这样对db的压力就减轻了很多，同时内存中直接生成id，性能则提高了很多</strong>。那么保存db号段的表该怎设计呢？</p>
<h3 id="DB号段算法描述"><a href="#DB号段算法描述" class="headerlink" title="DB号段算法描述"></a>DB号段算法描述</h3><table>
<thead>
<tr>
<th>id</th>
<th>start_id</th>
<th>end_id</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1000</td>
<td>2000</td>
</tr>
</tbody>
</table>
<p> 如上表，我们很容易想到的是db直接存储一个范围(start_id,end_id]，当这批id使用完毕后，我们做一次update操作，update start_id=2000(end_id), end_id=3000(end_id+1000)，update成功了，则说明获取到了下一个id范围。仔细想想，实际上start_id并没有起什么作用，<strong>新的号段总是(end_id,end_id+1000]</strong>。所以这里我们更改一下，db设计应该是这样的</p>
<table>
<thead>
<tr>
<th>id</th>
<th>biz_type</th>
<th>max_id</th>
<th>step</th>
<th>version</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1000</td>
<td>2000</td>
<td>1000</td>
<td>0</td>
</tr>
</tbody>
</table>
<ul>
<li>这里我们<strong>增加了biz_type，这个代表业务类型，不同的业务的id隔离</strong></li>
<li>max_id则是上面的end_id了，代表<strong>当前最大的可用id</strong></li>
<li><strong>step代表号段的长度</strong>，可以根据每个业务的qps来设置一个合理的长度</li>
<li><strong>version是一个乐观锁</strong>，每次更新都加上version，能够保证并发更新的正确性</li>
</ul>
<p> 那么我们可以通过如下几个步骤来获取一个可用的号段，</p>
<ul>
<li>A.查询当前的max_id信息：<code>select id, biz_type, max_id, step, version from tiny_id_info where</code>biz_type=’test’;</li>
<li>B.计算新的max_id: <code>new_max_id = max_id + step</code></li>
<li>C.更新DB中的max_id：<code>update tiny_id_info set max_id=#{new_max_id} , verison=version+1 where id=#{id} and max_id=#{max_id} and version=#{version}</code></li>
<li>D.如果更新成功，则可用号段获取成功，新的可用号段为<code>max_id, new_max_id]</code></li>
<li>E.如果更新失败，则号段可能被其他线程获取，回到步骤A，进行重试</li>
</ul>
<h3 id="号段生成方案的简单架构"><a href="#号段生成方案的简单架构" class="headerlink" title="号段生成方案的简单架构"></a>号段生成方案的简单架构</h3><p> 如上我们已经完成了号段生成逻辑，那么我们的id生成服务架构可能是这样的</p>
<p><img src="//blog.com/2019/04/04/Tinyid——滴滴分布式ID生成系统/tinyid-easy.png" alt=""></p>
<p> <strong>id生成系统向外提供http服务，请求经过我们的负载均衡router，到达其中一台tinyid-server，从事先加载好的号段中获取一个id，如果号段还没有加载，或者已经用完，则向db再申请一个新的可用号段，多台server之间因为号段生成算法的原子性，而保证每台server上的可用号段不重，从而使id生成不重</strong>。<br> <strong>可以看到如果tinyid-server如果重启了，那么号段就作废了，会浪费一部分id；同时id也不会连续；每次请求可能会打到不同的机器上，id也不是单调递增的，而是趋势递增的，不过这对于大部分业务都是可接受的</strong>。</p>
<h3 id="简单架构的问题"><a href="#简单架构的问题" class="headerlink" title="简单架构的问题"></a>简单架构的问题</h3><p> 到此一个简单的id生成系统就完成了，那么是否还存在问题呢？回想一下我们最开始的id生成系统要求，高性能、高可用、简单易用，在上面这套架构里，至少还存在以下问题:</p>
<ul>
<li>当id用完时需要访问db加载新的号段，<strong>db更新也可能存在version冲突，此时id生成耗时明显增加</strong></li>
<li><strong>db是一个单点</strong>，虽然db可以建设主从等高可用架构，但始终是一个单点</li>
<li><strong>使用http方式获取一个id，存在网络开销，性能和可用性都不太好</strong></li>
</ul>
<h3 id="优化办法"><a href="#优化办法" class="headerlink" title="优化办法"></a>优化办法</h3><h4 id="双号段缓存"><a href="#双号段缓存" class="headerlink" title="双号段缓存"></a>双号段缓存</h4><p> 对于号段用完需要访问db，我们很容易想到<strong>在号段用到一定程度的时候，就去异步加载下一个号段，保证内存中始终有可用号段，则可避免性能波动</strong>。</p>
<h4 id="增加多db支持"><a href="#增加多db支持" class="headerlink" title="增加多db支持"></a>增加多db支持</h4><p> db只有一个master时，如果db不可用(down掉或者主从延迟比较大)，则获取号段不可用。实际上我们可以支持多个db，比如2个db，A和B，我们获取号段可以随机从其中一台上获取。那么如果A,B都获取到了同一号段，我们怎么保证生成的id不重呢？tinyid是这么做的，<strong>让A只生成偶数id，B只生产奇数id，对应的db设计增加了两个字段</strong>，如下所示</p>
<table>
<thead>
<tr>
<th>id</th>
<th>biz_type</th>
<th>max_id</th>
<th>step</th>
<th>delta</th>
<th>remainder</th>
<th>version</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1000</td>
<td>2000</td>
<td>1000</td>
<td>2</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p> <strong>delta代表id每次的增量，remainder代表余数</strong>，例如<strong>可以将A，B都delta都设置2，remainder分别设置为0，1则，A的号段只生成偶数号段，B是奇数号段</strong>。 通过delta和remainder两个字段我们可以根据使用方的需求灵活设计db个数，同时也可以为使用方提供只生产类似奇数的id序列。</p>
<p>如两个db，如果要生成1,2,3,4….序列的数据，则db中的数据设置如下:</p>
<table>
<thead>
<tr>
<th>biz_type</th>
<th>delta</th>
<th>remainder</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>test</td>
<td>2</td>
<td>0</td>
<td>生成2,4,6,8序列的数据…</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>biz_type</th>
<th>delta</th>
<th>remainder</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>test</td>
<td>2</td>
<td>1</td>
<td>生成1,3,5,7序列的数据…</td>
</tr>
</tbody>
</table>
<ul>
<li>如果primary db挂掉(remainder=0)，则仍能正常服务，但只能产生1,3,5,7..的序列</li>
<li>注:不用介意max_id的初始值是奇数还是偶数，都能生成正确的序列</li>
</ul>
<p>如上两个db，如果要生成1,3,5,7….序列的数据，则db中的数据设置如下:</p>
<table>
<thead>
<tr>
<th>biz_type</th>
<th>delta</th>
<th>remainder</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>test</td>
<td>4</td>
<td>1</td>
<td>生成1,5,9,13序列的数据…</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>biz_type</th>
<th>delta</th>
<th>remainder</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>test</td>
<td>4</td>
<td>3</td>
<td>生成3,7,11,15序列的数据…</td>
</tr>
</tbody>
</table>
<p><strong>正常配置：delta==db数量  remainder从0……n</strong></p>
<h4 id="增加tinyid-client"><a href="#增加tinyid-client" class="headerlink" title="增加tinyid-client"></a>增加tinyid-client</h4><p> 使用http获取一个id，存在网络开销，是否可以本地生成id？为此我们提供了tinyid-client，我们可以<strong>向tinyid-server发送请求来获取可用号段，之后在本地构建双号段、id生成，如此id生成则变成纯本地操作，性能大大提升，因为本地有双号段缓存，则可以容忍tinyid-server一段时间的down掉，可用性也有了比较大的提升</strong>。</p>
<h4 id="tinyid最终架构"><a href="#tinyid最终架构" class="headerlink" title="tinyid最终架构"></a>tinyid最终架构</h4><p> 最终我们的架构可能是这样的</p>
<p><img src="//blog.com/2019/04/04/Tinyid——滴滴分布式ID生成系统/tinyid_final.png" alt=""></p>
<ul>
<li>tinyid提供http和tinyid-client两种方式接入</li>
<li>tinyid-server内部缓存两个号段</li>
<li>号段基于db生成，具有原子性</li>
<li>db支持多个</li>
<li>tinyid-server内置easy-router选择db</li>
</ul>
<h2 id="推荐使用方式"><a href="#推荐使用方式" class="headerlink" title="推荐使用方式"></a>推荐使用方式</h2><ul>
<li>tinyid-server推荐部署到多个机房的多台机器<ul>
<li>多机房部署可用性更高，http方式访问需使用方考虑延迟问题</li>
</ul>
</li>
<li>推荐使用tinyid-client来获取id，好处如下:<ul>
<li>id为本地生成(调用AtomicLong.addAndGet方法)，性能大大增加</li>
<li>client对server访问变的低频，减轻了server的压力</li>
<li>因为低频，即便client使用方和server不在一个机房，也无须担心延迟</li>
<li>即便所有server挂掉，因为client预加载了号段，依然可以继续使用一段时间</li>
</ul>
</li>
<li>推荐db配置两个或更多:<ul>
<li>db配置多个时，只要有1个db存活，则服务可用 <a href="https://github.com/didi/tinyid/wiki/Tinyid-server-config#%E5%A4%9Adb%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">多db配置</a>，如配置了两个db，则每次新增业务需在两个db中都写入相关数据</li>
</ul>
</li>
</ul>
<h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `tiny_id_info` (</span><br><span class="line">  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &apos;自增主键&apos;,</span><br><span class="line">  `biz_type` varchar(63) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;业务类型，唯一&apos;,</span><br><span class="line">  `begin_id` bigint(20) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;开始id，仅记录初始值，无其他含义。初始化时begin_id和max_id应相同&apos;,</span><br><span class="line">  `max_id` bigint(20) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;当前最大id&apos;,</span><br><span class="line">  `step` int(11) DEFAULT &apos;0&apos; COMMENT &apos;步长&apos;,</span><br><span class="line">  `delta` int(11) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;每次id增量&apos;,</span><br><span class="line">  `remainder` int(11) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;余数&apos;,</span><br><span class="line">  `create_time` timestamp NOT NULL DEFAULT &apos;2010-01-01 00:00:00&apos; COMMENT &apos;创建时间&apos;,</span><br><span class="line">  `update_time` timestamp NOT NULL DEFAULT &apos;2010-01-01 00:00:00&apos; COMMENT &apos;更新时间&apos;,</span><br><span class="line">  `version` bigint(20) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;版本号&apos;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uniq_biz_type` (`biz_type`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT &apos;id信息表&apos;;</span><br><span class="line"></span><br><span class="line">CREATE TABLE `tiny_id_token` (</span><br><span class="line">  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT &apos;自增id&apos;,</span><br><span class="line">  `token` varchar(255) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;token&apos;,</span><br><span class="line">  `biz_type` varchar(63) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;此token可访问的业务类型标识&apos;,</span><br><span class="line">  `remark` varchar(255) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;备注&apos;,</span><br><span class="line">  `create_time` timestamp NOT NULL DEFAULT &apos;2010-01-01 00:00:00&apos; COMMENT &apos;创建时间&apos;,</span><br><span class="line">  `update_time` timestamp NOT NULL DEFAULT &apos;2010-01-01 00:00:00&apos; COMMENT &apos;更新时间&apos;,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT &apos;token信息表&apos;;</span><br></pre></td></tr></table></figure>
<h2 id="关键点代码"><a href="#关键点代码" class="headerlink" title="关键点代码"></a>关键点代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">     * 这个方法主要为了1,4,7,10...这种序列准备的</span><br><span class="line">     * 设置好初始值之后，会以delta的方式递增，保证无论开始id是多少都能生成正确的序列</span><br><span class="line">     * 如当前是号段是(1000,2000]，delta=3, remainder=0，则经过这个方法后，currentId会先递增到1002,之后每次增加delta</span><br><span class="line">     * 因为currentId会先递增，所以会浪费一个id，所以做了一次减delta的操作，实际currentId会从999开始增，第一个id还是1002</span><br><span class="line">     */</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        if (isInit) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (isInit) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            long id = currentId.get();</span><br><span class="line">            if (id % delta == remainder) &#123;</span><br><span class="line">                isInit = true;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i = 0; i &lt;= delta; i++) &#123;</span><br><span class="line">                id = currentId.incrementAndGet();</span><br><span class="line">                if (id % delta == remainder) &#123;</span><br><span class="line">                    // 避免浪费 减掉系统自己占用的一个id</span><br><span class="line">                    currentId.addAndGet(0 - delta);</span><br><span class="line">                    isInit = true;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	public Result nextId() &#123;</span><br><span class="line">        init();</span><br><span class="line">        long id = currentId.addAndGet(delta);</span><br><span class="line">        if (id &gt; maxId) &#123;</span><br><span class="line">            return new Result(ResultCode.OVER, id);</span><br><span class="line">        &#125;</span><br><span class="line">        if (id &gt;= loadingId) &#123;</span><br><span class="line">            return new Result(ResultCode.LOADING, id);</span><br><span class="line">        &#125;</span><br><span class="line">        return new Result(ResultCode.NORMAL, id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">// init -3  nextId +3保证每次拿到的不会浪费第一个值  如：1000~2000 delta=3, remainder=0  1002第一个满足  init后 currentId为999 nextId后currentId 1002</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public SegmentId getNextSegmentId(String bizType) &#123;</span><br><span class="line">        // 获取nextTinyId的时候，有可能存在version冲突，需要重试</span><br><span class="line">        for (int i = 0; i &lt; Constants.RETRY; i++) &#123;</span><br><span class="line">            TinyIdInfo tinyIdInfo = tinyIdInfoDAO.queryByBizType(bizType);</span><br><span class="line">            if (tinyIdInfo == null) &#123;</span><br><span class="line">                throw new TinyIdSysException(&quot;can not find biztype:&quot; + bizType);</span><br><span class="line">            &#125;</span><br><span class="line">            Long newMaxId = tinyIdInfo.getMaxId() + tinyIdInfo.getStep();</span><br><span class="line">            Long oldMaxId = tinyIdInfo.getMaxId();</span><br><span class="line">            int row = tinyIdInfoDAO.updateMaxId(tinyIdInfo.getId(), newMaxId, oldMaxId, tinyIdInfo.getVersion());</span><br><span class="line">            if (row == 1) &#123;</span><br><span class="line">                tinyIdInfo.setMaxId(newMaxId);</span><br><span class="line">                SegmentId segmentId = convert(tinyIdInfo);</span><br><span class="line">                logger.info(&quot;getNextSegmentId success tinyIdInfo:&#123;&#125; current:&#123;&#125;&quot;, tinyIdInfo, segmentId);</span><br><span class="line">                return segmentId;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                logger.info(&quot;getNextSegmentId conflict tinyIdInfo:&#123;&#125;&quot;, tinyIdInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new TinyIdSysException(&quot;get next segmentId conflict&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> public SegmentId convert(TinyIdInfo idInfo) &#123;</span><br><span class="line">        SegmentId segmentId = new SegmentId();</span><br><span class="line">        segmentId.setCurrentId(new AtomicLong(idInfo.getMaxId() - idInfo.getStep()));</span><br><span class="line">        segmentId.setMaxId(idInfo.getMaxId());</span><br><span class="line">        segmentId.setRemainder(idInfo.getRemainder() == null ? 0 : idInfo.getRemainder());</span><br><span class="line">        segmentId.setDelta(idInfo.getDelta() == null ? 1 : idInfo.getDelta());</span><br><span class="line">        // 默认20%加载</span><br><span class="line">        segmentId.setLoadingId(segmentId.getCurrentId().get() + idInfo.getStep() * Constants.LOADING_PERCENT / 100);</span><br><span class="line">        return segmentId;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/04/04/Go如何在方法中传递多个参数，返回多个值？/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/04/Go如何在方法中传递多个参数，返回多个值？/" itemprop="url">Go如何在方法中传递多个参数，返回多个值？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-04T12:12:57+08:00">
                2019-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Go如何在方法中传递多个参数，返回多个值？"><a href="#Go如何在方法中传递多个参数，返回多个值？" class="headerlink" title="Go如何在方法中传递多个参数，返回多个值？"></a>Go如何在方法中传递多个参数，返回多个值？</h1><h2 id="传递多个参数"><a href="#传递多个参数" class="headerlink" title="传递多个参数"></a>传递多个参数</h2><h3 id="传递特定类型的参数"><a href="#传递特定类型的参数" class="headerlink" title="传递特定类型的参数"></a>传递特定类型的参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(vals ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">// 在函数内部 vals 作为slice []int的存在而使用</span></span><br><span class="line">    total := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, val := <span class="keyword">range</span> vals &#123;</span><br><span class="line">        total += val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum()  <span class="comment">// 0</span></span><br><span class="line">sum(<span class="number">3</span>) <span class="comment">// 3</span></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果你的slic已经有了多个值，想把它们作为参数使用，要这样调用func(slic...)</span></span><br><span class="line">nums := []<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>&#125;</span><br><span class="line">sum(nums...) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<h3 id="传递任意类型的参数"><a href="#传递任意类型的参数" class="headerlink" title="传递任意类型的参数"></a>传递任意类型的参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">(input ... <span class="keyword">interface</span>&#123;&#125;)</span></span>  &#123;</span><br><span class="line">	fmt.Println(input)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	display(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// [1 2 3]</span></span><br><span class="line">	display(<span class="string">"abc"</span>, <span class="string">"1,2,3"</span>, []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;) <span class="comment">// [abc 1,2,3 [1 2 3 4 5]]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h2><h3 id="特定类型的多返回值"><a href="#特定类型的多返回值" class="headerlink" title="特定类型的多返回值"></a>特定类型的多返回值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(int，int)代表这个函数返回两个int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">vals</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">3</span>,<span class="number">7</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">//通过多赋值来操作这两个不同的返回值</span></span><br><span class="line">	a,b := vals()</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果只返回其中一个值，可以使用空白符_</span></span><br><span class="line">	_,c := vals()</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="任意类型的多返回值"><a href="#任意类型的多返回值" class="headerlink" title="任意类型的多返回值"></a>任意类型的多返回值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">(input ... <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">len</span>(input) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>,<span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">len</span>(input)&gt;<span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> input[<span class="number">0</span>],<span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> input[<span class="number">0</span>],input[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	resp1, resp2 := display(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">	fmt.Println(resp1, resp2)  <span class="comment">// 1 &lt;nil&gt;</span></span><br><span class="line">	resp1, resp2 = display(<span class="string">"abc"</span>, <span class="string">"1,2,3"</span>, []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;)</span><br><span class="line">	fmt.Println(resp1, resp2)  <span class="comment">// abc &lt;nil&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">(input ... <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不支持这种不定返回值个数的返回方式</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/04/04/channel关闭之后，是否可以继续读写？/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/04/channel关闭之后，是否可以继续读写？/" itemprop="url">channel关闭之后，是否可以继续读写？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-04T12:12:57+08:00">
                2019-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/Go并发/" itemprop="url" rel="index">
                    <span itemprop="name">Go并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="channel关闭之后，是否可以继续读写？"><a href="#channel关闭之后，是否可以继续读写？" class="headerlink" title="channel关闭之后，是否可以继续读写？"></a>channel关闭之后，是否可以继续读写？</h1><blockquote>
<p>A receive operation on a closed channel can always proceed immediately, yielding the element type’s zero value after any previously sent values have been received.</p>
</blockquote>
<h2 id="关闭channel，是否可以继续写？"><a href="#关闭channel，是否可以继续写？" class="headerlink" title="关闭channel，是否可以继续写？"></a>关闭channel，是否可以继续写？</h2><p><strong>不可继续写</strong></p>
<blockquote>
<p>panic: send on closed channel</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		err_info := <span class="built_in">recover</span>()</span><br><span class="line">		fmt.Println(err_info)  <span class="comment">// send on closed channel</span></span><br><span class="line">	&#125;()</span><br><span class="line">	channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="built_in">close</span>(channel)</span><br><span class="line">	channel &lt;- <span class="literal">true</span></span><br><span class="line">	channel &lt;- <span class="literal">true</span></span><br><span class="line">	channel &lt;- <span class="literal">false</span></span><br><span class="line">	channel &lt;- <span class="literal">true</span></span><br><span class="line">	channel &lt;- <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关闭channel，是否可以继续读？"><a href="#关闭channel，是否可以继续读？" class="headerlink" title="关闭channel，是否可以继续读？"></a>关闭channel，是否可以继续读？</h2><p><strong>可以继续读</strong></p>
<blockquote>
<p>可以继续读取channel, 读取完后， &lt;-channel_name 返回对应类型默认值</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">4</span>)</span><br><span class="line">	channel &lt;- <span class="literal">true</span></span><br><span class="line">	channel &lt;- <span class="literal">false</span></span><br><span class="line">	channel &lt;- <span class="literal">true</span></span><br><span class="line">	channel &lt;- <span class="literal">false</span></span><br><span class="line">	<span class="built_in">close</span>(channel)</span><br><span class="line">	<span class="keyword">for</span> val := <span class="keyword">range</span> channel &#123;</span><br><span class="line">		fmt.Println(val)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	channel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">4</span>)</span><br><span class="line">	channel &lt;- <span class="literal">true</span></span><br><span class="line">	channel &lt;- <span class="literal">false</span></span><br><span class="line">	channel &lt;- <span class="literal">true</span></span><br><span class="line">	channel &lt;- <span class="literal">false</span></span><br><span class="line">	<span class="built_in">close</span>(channel)</span><br><span class="line">	fmt.Println(&lt;-channel)</span><br><span class="line">	fmt.Println(&lt;-channel)</span><br><span class="line">	fmt.Println(&lt;-channel)</span><br><span class="line">	fmt.Println(&lt;-channel)</span><br><span class="line"></span><br><span class="line">	fmt.Println(&lt;-channel)</span><br><span class="line">	fmt.Println(&lt;-channel)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"><span class="comment">//true</span></span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	channel_number := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">	channel_number &lt;- <span class="number">1</span></span><br><span class="line">	channel_number &lt;- <span class="number">2</span></span><br><span class="line">	channel_number &lt;- <span class="number">3</span></span><br><span class="line">	channel_number &lt;- <span class="number">4</span></span><br><span class="line">	<span class="built_in">close</span>(channel_number)</span><br><span class="line">	<span class="keyword">for</span> number_val := <span class="keyword">range</span> channel_number &#123;</span><br><span class="line">		fmt.Println(number_val)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&lt;-channel_number)</span><br><span class="line">	fmt.Println(&lt;-channel_number)</span><br><span class="line">	fmt.Println(&lt;-channel_number)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<h2 id="channel关闭后，可以继续读，那如何退出呢？"><a href="#channel关闭后，可以继续读，那如何退出呢？" class="headerlink" title="channel关闭后，可以继续读，那如何退出呢？"></a>channel关闭后，可以继续读，那如何退出呢？</h2><h3 id="for-range"><a href="#for-range" class="headerlink" title="for range"></a>for range</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	channel_number := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">	channel_number &lt;- <span class="number">1</span></span><br><span class="line">	channel_number &lt;- <span class="number">2</span></span><br><span class="line">	channel_number &lt;- <span class="number">3</span></span><br><span class="line">	channel_number &lt;- <span class="number">4</span></span><br><span class="line">	<span class="built_in">close</span>(channel_number)</span><br><span class="line">	fmt.Println(<span class="string">"channel关闭，读取开始"</span>)</span><br><span class="line">	<span class="keyword">for</span> number_val := <span class="keyword">range</span> channel_number &#123;</span><br><span class="line">		fmt.Println(number_val)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"channel关闭，读取结束"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//channel关闭，读取开始</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//channel关闭，读取结束</span></span><br></pre></td></tr></table></figure>
<h3 id="lt-多返回值"><a href="#lt-多返回值" class="headerlink" title="&lt;- 多返回值"></a>&lt;- 多返回值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	channel_number := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">4</span>)</span><br><span class="line">	channel_number &lt;- <span class="number">1</span></span><br><span class="line">	channel_number &lt;- <span class="number">2</span></span><br><span class="line">	channel_number &lt;- <span class="number">3</span></span><br><span class="line">	channel_number &lt;- <span class="number">4</span></span><br><span class="line">	<span class="built_in">close</span>(channel_number)</span><br><span class="line">	fmt.Println(<span class="string">"channel关闭，读取开始"</span>)</span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		val,ok := &lt;-channel_number</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(val)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"channel关闭，读取结束"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//channel关闭，读取开始</span></span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//channel关闭，读取结束</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/04/04/五种 IO 模型/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/04/五种 IO 模型/" itemprop="url">五种 IO 模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-04T12:12:57+08:00">
                2019-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/" itemprop="url" rel="index">
                    <span itemprop="name">异步与同步</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/" itemprop="url" rel="index">
                    <span itemprop="name">IO</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/" itemprop="url" rel="index">
                    <span itemprop="name">Reactor</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/事件模型/" itemprop="url" rel="index">
                    <span itemprop="name">事件模型</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/事件模型/网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="五种-IO-模型"><a href="#五种-IO-模型" class="headerlink" title="五种 IO 模型"></a>五种 IO 模型</h1><p>在编写服务器端网络程序时，我们最常见到阻塞、非阻塞、同步和异步这四个词。它们的解释分别如下：</p>
<ul>
<li>阻塞： 阻塞调用是指调用返回之前，当前线程会被挂起，只有当调用得到结果后才返回。</li>
<li>非阻塞：与阻塞相反，非阻塞调用是指在不能立即得到结果之前，该函数不会将当前线程阻塞，而是立即返回。</li>
<li>同步：所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。等前一件做完了才能做下一件事。</li>
<li>异步：异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</li>
</ul>
<p>  常常有人弄不清阻塞/非阻塞与同步/异步之间的关系，容易将他们混为一谈。阻塞/非阻塞更多的用来形容某次调用的属性（比如 read(),write() 是否是阻塞/非阻塞 ）所以应用范围比较窄；而同步/异步则更上层，通常指各个功能/线程之间的关系（比如 Thread1 和 Thread2 是同步执行还是异步执行）。</p>
<h3 id="五种-IO-模型-1"><a href="#五种-IO-模型-1" class="headerlink" title="五种 IO 模型"></a>五种 IO 模型</h3><p>  服务器端 IO 主要分为两种：磁盘 IO 和网络 IO，在讲服务器端高性能网络编程时更多时候我们讲的是网络 IO 模型。一次完整的服务器端处理网络请求流程图如下（简化版，以 Web 服务器为例）：</p>
<p><img src="//blog.com/2019/04/04/五种 IO 模型/169e3925f324afc6.png" alt="img"></p>
<p>  这张图比较简单，但是很多人在没看到这张图之前肯定都以为每次网络读(recvfrom())或者写(sendto())都是在网卡与用户进程之间进行操作，其实不是。从上图可以看出，<strong>数据无论从网卡到用户空间还是从用户空间到网卡都需要经过内核</strong>。从磁盘上读写数据也是如此。所以就有了 mmap 技术，感兴趣的可以自行百度。应用进程（Web 服务器也属于应用进程，这里需要再统一几个概念：用户进程、应用程序、Web 服务器程序，它们相对于内核来说都是应用进程，所以后面文章中统一成应用进程）需要通过系统调用（例如recvfrom/sendto）向内核读写数据，内核再进一步操作网卡。</p>
<p>  根据应用进程系统调用方式的阻塞、非阻塞，操作系统在处理应用程序请求时处理方式的同步、异步处理的不同，参考《UNIX 网络编程卷 I》可以分为 5 种 IO 模型：</p>
<h4 id="1、阻塞-IO-模型（blocking-IO）"><a href="#1、阻塞-IO-模型（blocking-IO）" class="headerlink" title="1、阻塞 IO 模型（blocking IO）"></a>1、阻塞 IO 模型（blocking IO）</h4><p><img src="//blog.com/2019/04/04/五种 IO 模型/169e39401e6dbbb7.png" alt="img"></p>
<p>   描述：应用程序进行 recvfrom 系统调用时将阻塞在此调用，直到该套接字上有数据并且复制到用户空间缓冲区。该模式一般配合多线程使用，应用进程每接收一个连接，为此连接创建一个线程来处理该连接上的读写以及业务处理。</p>
<p>  优点：编程简单，适合教学。《UNIX网络编程卷I》上很多例子都是基于这种模式。   缺点：如果套接字上没有数据，进程将一直阻塞。这时其他套接字上有数据也不能进行及时处理。如果是多线程方式，除非连接关闭否则线程会一直存在，而线程的创建、维护和销毁非常消耗资源，所以能建立的连接数量非常有限。</p>
<h4 id="2、非阻塞-IO-模型（nonblocking-IO）"><a href="#2、非阻塞-IO-模型（nonblocking-IO）" class="headerlink" title="2、非阻塞 IO 模型（nonblocking IO）"></a>2、非阻塞 IO 模型（nonblocking IO）</h4><p><img src="//blog.com/2019/04/04/五种 IO 模型/169e394edc9f7d7f.png" alt="img"></p>
<p>   描述：应用进程每次调用 recvfrom 即使没有数据准备好也不会阻塞，会继续往下执行，避免了进程阻塞在某个连接上的弊端。</p>
<p>  优点：代码编写相对简单，进程不会阻塞，可以在同一线程中处理所有连接。</p>
<p>  缺点：需要频繁的轮询，比较耗CPU，在并发量很大的时候将花费大量时间在没有任何数据的连接上轮询。所以该模型只在专门提供某种功能的系统中才会出现。</p>
<h4 id="3、IO-复用模型（IO-multiplexing）"><a href="#3、IO-复用模型（IO-multiplexing）" class="headerlink" title="3、IO 复用模型（IO multiplexing）"></a>3、IO 复用模型（IO multiplexing）</h4><p><img src="//blog.com/2019/04/04/五种 IO 模型/169e3a2fc92ed74c.png" alt="img"></p>
<p>   描述：应用进程阻塞于 select/poll/epoll 等系统函数等待某个连接变成可读（有数据过来），再调用 recvfrom 从连接上读取数据。虽然此模式也会阻塞在 select/poll/epoll 上，但与阻塞IO 模型不同它阻塞在等待多个连接上有读（写）事件的发生，明显提高了效率且增加了单线程/单进程中并行处理多连接的可能。</p>
<p>  优点：统一管理连接，不一定采用多线程的方式，同时也不需要轮询。只需要阻塞于 select 即可，可以同时管理多个连接。</p>
<p>  缺点：当 select/poll/epoll 管理的连接数过少时，这种模型将退化成阻塞 IO 模型。并且还多了一次系统调用：一次 select/poll/epoll 一次 recvfrom。</p>
<h4 id="4、信号驱动-IO-模型（signal-driven-IO）"><a href="#4、信号驱动-IO-模型（signal-driven-IO）" class="headerlink" title="4、信号驱动 IO 模型（signal-driven IO）"></a>4、信号驱动 IO 模型（signal-driven IO）</h4><p><img src="//blog.com/2019/04/04/五种 IO 模型/169e39631959aa02.png" alt="img">)</p>
<p>   描述：应用进程创建 SIGIO 信号处理程序，此程序可处理连接上数据的读写和业务处理。并向操作系统安装此信号，进程可以往下执行。当内核数据准备好会向应用进程发送信号，触发信号处理程序的执行。再在信号处理程序中进行 recvfrom 和业务处理。</p>
<p>  优点：非阻塞</p>
<p>  缺点：在前一个通知信号没被处理的情况下，后一个信号来了也不能被处理。所以在信号量大的时候会导致后面的信号不能被及时感知。</p>
<h4 id="5、异步-IO-模型（asynchronous-IO）"><a href="#5、异步-IO-模型（asynchronous-IO）" class="headerlink" title="5、异步 IO 模型（asynchronous IO）"></a>5、异步 IO 模型（asynchronous IO）</h4><p><img src="//blog.com/2019/04/04/五种 IO 模型/169e396d205b5440.png" alt="img"></p>
<p>   描述：应用进程通过 aio_read 告知内核启动某个操作，并且在整个操作完成之后再通知应用进程，包括把数据从内核空间拷贝到用户空间。信号驱动 IO 是内核通知我们何时可以启动一个 IO 操作，而异步 IO 模型是由内核通知我们 IO 操作何时完成。</p>
<blockquote>
<p>注：前 4 种模型都是带有阻塞部分的，有的阻塞在等待数据准备好，有的阻塞在从内核空间拷贝数据到用户空间。而这种模型应用进程从调用 aio_read 到数据被拷贝到用户空间，不用任何阻塞，所以该种模式叫异步 IO 模型。这五种模型的取名和并列方式我是保留意见的，感觉容易迷惑读者。</p>
</blockquote>
<p>  优点：没有任何阻塞，充分利用系统内核将 IO 操作与计算逻辑并行。</p>
<p>  缺点：编程复杂、操作系统支持不好。目前只有 windows 下的 iocp 实现了真正的 AIO。linux 下在 2.6 版本中才引入，目前并不完善，所以 Linux 下一般采用多路复用模型。</p>
<h3 id="各-IO-模型对比"><a href="#各-IO-模型对比" class="headerlink" title="各 IO 模型对比"></a>各 IO 模型对比</h3><p>  前四种模型的主要区别于第一阶段，因为他们的第二阶段都是一样的：在数据从内核拷贝到应用进程的缓冲区期间，进程阻塞于 recvfrom 调用。相反，异步 IO 模型在这两个阶段都需要处理，从而不同于其他四种模型。 </p>
<p><img src="//blog.com/2019/04/04/五种 IO 模型/169e39e007562c15.png" alt="img"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/103/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/103/">103</a><span class="page-number current">104</span><a class="page-number" href="/page/105/">105</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/105/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
