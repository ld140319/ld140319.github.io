<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/page/18/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/page/18/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/08/28/性能优化指南/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/28/性能优化指南/" itemprop="url">性能优化指南</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-28T12:12:57+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/性能优化/" itemprop="url" rel="index">
                    <span itemprop="name">性能优化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="性能优化指南"><a href="#性能优化指南" class="headerlink" title="性能优化指南"></a>性能优化指南</h1><blockquote>
<p>原文地址：<a href="https://cloud.tencent.com/developer/article/1478922" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1478922</a></p>
</blockquote>
<h2 id="一般性原则"><a href="#一般性原则" class="headerlink" title="一般性原则"></a>一般性原则</h2><h3 id="依据数据而不是凭空猜测"><a href="#依据数据而不是凭空猜测" class="headerlink" title="依据数据而不是凭空猜测"></a>依据数据而不是凭空猜测</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是性能优化的第一原则，当我们怀疑性能有问题的时候，应该通过测试、日志、profillig来分析出哪里有问题，有的放矢，而不是凭感觉、撞运气。一个系统有了性能问题，瓶颈有可能是CPU，有可能是内存，有可能是IO（磁盘IO，网络IO），大方向的定位可以使用top以及stat系列来定位（vmstat，iostat，netstat…），针对单个进程，可以使用pidstat来分析。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本文中，主要讨论的是CPU相关的性能问题。按照80/20定律，绝大多数的时间都耗费在少量的代码片段里面，找出这些代码唯一可靠的办法就是profile，我所知的编程语言，都有相关的profile工具，熟练使用这些profile工具是性能优化的第一步。</p>
<h3 id="忌过早优化"><a href="#忌过早优化" class="headerlink" title="忌过早优化"></a>忌过早优化</h3><blockquote>
<p>The real problem is that programmers have spent far too much time worrying about efficiency in the wrong places and at the wrong times; premature optimization is the root of all evil (or at least most of it) in programming.</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我并不十分清楚Donald Knuth说出这句名言的上下文环境，但我自己是十分认同这个观念的。在我的工作环境（以及典型的互联网应用开发）与编程模式下，追求的是快速的迭代与试错，过早的优化往往是无用功。而且，过早的优化很容易拍脑袋，优化的点往往不是真正的性能瓶颈。</p>
<h3 id="忌过度优化"><a href="#忌过度优化" class="headerlink" title="忌过度优化"></a>忌过度优化</h3><blockquote>
<p>As performance is part of the specification of a program – a program that is unusably slow is not fit for purpose</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;性能优化的目标是追求合适的性价比。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在不同的阶段，我们对系统的性能会有一定的要求，比如吞吐量要达到多少多少。如果达不到这个指标，就需要去优化。如果能满足预期，那么就无需花费时间精力去优化，比如只有几十个人使用的内部系统，就不用按照十万在线的目标去优化。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而且，后面也会提到，一些优化方法是“有损”的，可能会对代码的可读性、可维护性有副作用。这个时候，就更不能过度优化。</p>
<h3 id="深入理解业务"><a href="#深入理解业务" class="headerlink" title="深入理解业务"></a>深入理解业务</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码是服务于业务的，也许是服务于最终用户，也许是服务于其他程序员。不了解业务，很难理解系统的流程，很难找出系统设计的不足之处。后面还会提及对业务理解的重要性。</p>
<h3 id="性能优化是持久战"><a href="#性能优化是持久战" class="headerlink" title="性能优化是持久战"></a>性能优化是持久战</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当核心业务方向明确之后，就应该开始关注性能问题，当项目上线之后，更应该持续的进行性能检测与优化。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在的互联网产品，不再是一锤子买卖，在上线之后还需要持续的开发，用户的涌入也会带来性能问题。因此需要自动化的检测性能问题，保持稳定的测试环境，持续的发现并解决性能问题，而不是被动地等到用户的投诉。</p>
<h3 id="选择合适的衡量指标、测试用例、测试环境"><a href="#选择合适的衡量指标、测试用例、测试环境" class="headerlink" title="选择合适的衡量指标、测试用例、测试环境"></a>选择合适的衡量指标、测试用例、测试环境</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正因为性能优化是一个长期的行为，所以需要固定衡量指标、测试用例、测试环境，这样才能客观反映性能的实际情况，也能展现出优化的效果。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;衡量性能有很多指标，比如系统响应时间、系统吞吐量、系统并发量。不同的系统核心指标是不一样的，首先要明确本系统的核心性能诉求，固定测试用例；其次也要兼顾其他指标，不能顾此失彼。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试环境也很重要，有一次突然发现我们的QPS高了许多，但是程序压根儿没优化，查了半天，才发现是换了一个更牛逼的物理机做测试服务器。</p>
<h2 id="性能优化的层次"><a href="#性能优化的层次" class="headerlink" title="性能优化的层次"></a>性能优化的层次</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照我的理解可以分为需求阶段，设计阶段，实现阶段；越上层的阶段优化效果越明显，同时也更需要对业务、需求的深入理解。</p>
<h3 id="需求阶段"><a href="#需求阶段" class="headerlink" title="需求阶段"></a>需求阶段</h3><blockquote>
<p>不战而屈人之兵，善之善者也</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序员的需求可能来自PM、UI的业务需求（或者说是功能性需求），也可能来自Team Leader的需求。当我们拿到一个需求的时候，首先需要的是思考、讨论需求的合理性，而不是立刻去设计、去编码。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>需求是为了解决某个问题，问题是本质，需求是解决问题的手段。</strong>那么需求是否能否真正的解决问题，程序员也得自己去思考，在之前的文章也提到过，产品经理（特别是知道一点技术的产品经理）的某个需求可能只是某个问题的解决方案，他认为这个方法可以解决他的问题，于是把解决方案当成了需求，而不是真正的问题。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需求讨论的前提对业务的深入了解，如果不了解业务，根本没法讨论。<strong>即使需求已经实现了，当我们发现有性能问题的时候，首先也可以从需求出发。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需求分析对性能优化有什么帮助呢，第一，为了达到同样的目的，解决同样问题，也许可以有性能更优（消耗更小）的办法。这种优化是无损的，即不改变需求本质的同时，又能达到性能优化的效果；第二种情况，有损的优化，即在不明显影响用户的体验，稍微修改需求、放宽条件，就能大大解决性能问题。PM退步一小步，程序前进一大步。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需求讨论也有助于设计时更具扩展性，应对未来的需求变化，这里按下不表。</p>
<h3 id="设计阶段"><a href="#设计阶段" class="headerlink" title="设计阶段"></a>设计阶段</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;高手都是花80%时间思考，20%时间实现；新手写起代码来很快，但后面是无穷无尽的修bug</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设计的概念很宽泛，包括架构设计、技术选型、接口设计等等。架构设计约束了系统的扩展、技术选型决定了代码实现。编程语言、框架都是工具，不同的系统、业务需要选择适当的工具集。如果设计的时候做的不够好，那么后面就很难优化，甚至需要推到重来。</p>
<h3 id="实现阶段"><a href="#实现阶段" class="headerlink" title="实现阶段"></a>实现阶段</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实现是把功能翻译成代码的过程，这个层面的优化，主要是针对一个调用流程，一个函数，一段代码的优化。各种profile工具也主要是在这个阶段生效。除了静态的代码的优化，还有编译时优化，运行时优化。后二者要求就很高了，程序员可控性较弱。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>代码层面，造成性能瓶颈的原因通常是高频调用的函数、或者单次消耗非常高的函数、或者二者的结合。</strong></p>
<h2 id="一般性方法"><a href="#一般性方法" class="headerlink" title="一般性方法"></a>一般性方法</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没有什么性能问题是缓存解决不了的，如果有，那就再加一级缓存</p>
<blockquote>
<p>a cache /kæʃ/ KASH,[1] is a hardware or software component that stores data so future requests for that data can be served faster; the data stored in a cache might be the result of an earlier computation, or the duplicate of data stored elsewhere.</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缓存的本质是加速访问，访问的数据要么是其他数据的副本 – 让数据离用户更近；要么是之前的计算结果 – 避免重复计算.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缓存需要用空间换时间，在缓存空间有限的情况下，需要优秀的置换换算来保证缓存有较高的命中率。</p>
<h4 id="数据的缓存"><a href="#数据的缓存" class="headerlink" title="数据的缓存"></a>数据的缓存</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是我们最常见的缓存形式，<strong>将数据缓存在离使用者更近的地方</strong>。比如操作系统中的CPU cache、disk cache。对于一个web应用，前端会有浏览器缓存，有<a href="https://cloud.tencent.com/product/cdn?from=10680" target="_blank" rel="noopener">CDN</a>，有反向代理提供的静态内容缓存；后端则有本地缓存、分布式缓存。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>数据的缓存，很多时候是设计层面的考虑。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于数据缓存，需要考虑的是缓存一致性问题。对于分布式系统中有强一致性要求的场景，可行的解决办法有lease，版本号。</p>
<h4 id="计算结果的缓存"><a href="#计算结果的缓存" class="headerlink" title="计算结果的缓存"></a>计算结果的缓存</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于消耗较大的计算，可以将计算结果缓存起来，下次直接使用。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道，对递归代码的一个有效优化手段就是缓存中间结果，lookup table，避免了重复计算。python中的method cache就是这种思想。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于可能重复创建、销毁，且创建销毁代价很大的对象，比如进程、线程，也可以缓存，对应的缓存形式如单例、资源池（连接池、线程池）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于计算结果的缓存，也需要考虑缓存失效的情况，对于pure function，固定的输入有固定的输出，缓存是不会失效的。但如果计算受到中间状态、环境变量的影响，那么缓存的结果就可能失效，比如这篇文章讲到的：</p>
<blockquote>
<p><a href="http://www.cnblogs.com/xybaby/p/8403461.html#_label_6" target="_blank" rel="noopener">http://www.cnblogs.com/xybaby/p/8403461.html#_label_6</a></p>
</blockquote>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>一个人干不完的活，那就找两个人干。并发既增加了系统的吞吐，又减少了用户的平均等待时间。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的并发是指广义的并发，粒度包括多机器（集群）、多进程、多线程。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于<strong>无状态</strong>（状态是指需要维护的上下文环境，用户请求依赖于这些上下文环境）的服务，采用集群就能很好的伸缩，增加系统的吞吐，比如挂载nginx之后的web server</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于有状态的服务，也有两种形式，<strong>每个节点提供同样的数据</strong>，如mysql的读写分离；<strong>每个节点只提供部分数据</strong>，如mongodb中的sharding</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>分布式存储系统中，partition（sharding）和replication（backup）都有助于并发。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绝大多数web server，要么使用多进程，要么使用多线程来处理用户的请求，以充分利用多核CPU，再有IO阻塞的地方，也是适合使用多线程的。比较新的协程（Python greenle、goroutine）也是一种并发。</p>
<h3 id="惰性"><a href="#惰性" class="headerlink" title="惰性"></a>惰性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将计算推迟到必需的时刻，这样很可能避免了多余的计算，甚至根本不用计算，参见：</p>
<blockquote>
<p><a href="http://www.cnblogs.com/xybaby/p/6425735.html" target="_blank" rel="noopener">http://www.cnblogs.com/xybaby/p/6425735.html</a></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CopyOnWrite这个思想真牛逼！</p>
<h3 id="批量，合并"><a href="#批量，合并" class="headerlink" title="批量，合并"></a>批量，合并</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在有IO（网络IO，磁盘IO）的时候，<strong>合并操作、批量操作</strong>往往能提升吞吐，提高性能。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们最常见的是批量读：每次读取数据的时候多读取一些，以备不时之需。如GFS client会从GFS master多读取一些chunk信息；如分布式系统中，如果集中式节点复杂全局ID生成，俺么应用就可以一次请求一批id。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>特别是系统中有单点存在的时候，缓存和批量本质上来说减少了与单点的交互，是减轻单点压力的经济有效的方法</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前端开发中，经常会有<strong>资源的压缩和合并</strong>，也是这种思想。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当涉及到网络请求的时候，网络传输的时间可能远大于请求的处理时间，因此<strong>合并网络请求</strong>就很有必要，比如mognodb的bulk operation，redis 的pipeline。写文件的时候也可以批量写，以减少IO开销，GFS中就是这么干的</p>
<h3 id="更高效的实现"><a href="#更高效的实现" class="headerlink" title="更高效的实现"></a>更高效的实现</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同一个算法，肯定会有不同的实现，那么就会有不同的性能；有的实现可能是时间换空间，有的实现可能是空间换时间，那么就需要根据自己的实际情况权衡。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>程序员都喜欢造轮子，用于练手无可厚非，但在项目中，使用成熟的、经过验证的轮子往往比自己造的轮子性能更好。</strong>当然不管使用别人的轮子，还是自己的工具，当出现性能的问题的时候，要么优化它，要么替换掉他。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如，我们有一个场景，有大量复杂的嵌套对象的序列化、反序列化，开始的时候是使用python（Cpython）自带的json模块，即使发现有性能问题也没法优化，网上一查，替换成了ujson，性能好了不少。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面这个例子是无损的，但一些更高效的实现也可能是有损的，比如对于python，如果发现性能有问题，那么很可能会考虑C扩展，但也会带来维护性与灵活性的丧失，面临crash的风险。</p>
<h3 id="缩小解空间"><a href="#缩小解空间" class="headerlink" title="缩小解空间"></a>缩小解空间</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缩小解空间的意思是说，<strong>在一个更小的数据范围内进行计算，而不是遍历全部数据</strong>。最常见的就是索引，通过索引，能够很快定位数据，对数据库的优化绝大多数时候都是对索引的优化。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有本地缓存，那么使用索引也会大大加快访问速度。不过，索引比较适合读多写少的情况，毕竟索引的构建也是需有消耗的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外在游戏服务端，使用的分线和AOI（格子算法）也都是缩小解空间的方法。</p>
<h2 id="性能优化与代码质量"><a href="#性能优化与代码质量" class="headerlink" title="性能优化与代码质量"></a>性能优化与代码质量</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多时候，好的代码也是高效的代码，各种语言都会有一本类似的书《effective xx》。比如对于python，pythonic的代码通常效率都不错，如使用迭代器而不是列表（python2.7 dict的iteritems(), 而不是items())。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>衡量代码质量的标准是可读性、可维护性、可扩展性，但性能优化有可能会违背这些特性</strong>，比如为了屏蔽实现细节与使用方式，我们会可能会加入接口层（虚拟层），这样可读性、可维护性、可扩展性会好很多，但是额外增加了一层函数调用，如果这个地方调用频繁，那么也是一笔开销；又如前面提到的C扩展，也是会降低可维护性、</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>这种有损代码质量的优化，应该放到最后，不得已而为之，同时写清楚注释与文档。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了追求可扩展性，我们经常会引入一些设计模式，如状态模式、策略模式、模板方法、装饰器模式等，但这些模式不一定是性能友好的。所以，为了性能，我们可能写出一些反模式的、定制化的、不那么优雅的代码，这些代码其实是脆弱的，需求的一点点变动，对代码逻辑可能有至关重要的影响，所以还是回到前面所说，不要过早优化，不要过度优化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>来张脑图总结一下</p>
<p><img src="//blog.com/2019/08/28/性能优化指南/dycgyhcs4v.jpeg" alt="img"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/08/27/Git分支管理策略/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/27/Git分支管理策略/" itemprop="url">Git分支管理策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-27T12:12:57+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/分支策略/" itemprop="url" rel="index">
                    <span itemprop="name">分支策略</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Git分支管理策略"><a href="#Git分支管理策略" class="headerlink" title="Git分支管理策略"></a>Git分支管理策略</h1><blockquote>
<p>原文地址：<a href="http://arganzheng.life/git-branch-strategy.html" target="_blank" rel="noopener">http://arganzheng.life/git-branch-strategy.html</a></p>
</blockquote>
<p>在使用 Git 时通常会遇到的一个问题是采用何种分支管理实践，即如何管理仓库中作用不同的各类分支。</p>
<h2 id="GitFlow-演进"><a href="#GitFlow-演进" class="headerlink" title="GitFlow 演进"></a>GitFlow 演进</h2><h3 id="洪荒时代-——-单主干开发-Trunk-based-development-TBD"><a href="#洪荒时代-——-单主干开发-Trunk-based-development-TBD" class="headerlink" title="洪荒时代 —— 单主干开发 (Trunk-based development, TBD)"></a>洪荒时代 —— 单主干开发 (Trunk-based development, TBD)</h3><p>单主干的分支实践（Trunk-based development, TBD）在 SVN 中比较流行。trunk 是 SVN 中主干分支的名称，对应到 Git 中则是 master 分支。</p>
<p>在项目初期，一切都是从0开始，不存在多分支并行开发一说，所以基本上都是基于主干开发和发布。</p>
<p><strong>Pros</strong></p>
<ul>
<li>简单，只需要维护一个分支</li>
<li>冲突第一时间发现和解决</li>
</ul>
<p><strong>Crons</strong></p>
<ul>
<li>主干一直在变化，没有一个稳定的版本来进行测试和发布</li>
<li>因为主干分支是所有开发人员公用的，一个开发人员引入的 bug 可能对其他很多人造成影响。</li>
<li>没有发布分支，主干是一直在变化的，无法知道线上的代码版本，排查线上问题对不上。</li>
<li>没有一个稳定的版本，新同学拉下来的代码可能是没法运行的。</li>
</ul>
<h3 id="演进1-——-引入发布分支"><a href="#演进1-——-引入发布分支" class="headerlink" title="演进1 —— 引入发布分支"></a>演进1 —— 引入发布分支</h3><p>还是采用主干开发方式，团队所有人都在 trunk 开发新功能，但是在 『迭代功能完成』的时候需要拉一个测试分支，用于修复测试中发现的缺陷，以及最后的发布。而主干则继续开发新功能。</p>
<p>根据发布分支和主干的合并机制，又有如下三种策略：</p>
<ol>
<li>发布分支发布之后合并回主干</li>
<li>发布分支每修复一个缺陷就合并回主干</li>
<li>发布分支上做修改后，就要根据实际情况进行分析，是否要合并回主干。如果需要合并，应该立即进行。</li>
</ol>
<p><strong>release 分支</strong></p>
<ul>
<li>release 为预发布分支，它是指发布正式版本之前（即合并到Master分支之前），我们需要有一个预发布的版本进行测试和发布</li>
<li>临时分支，发布后以 tag 形式合并 master 分支（gitflow 模式下还要合并到 develop 分支）后删除</li>
<li>命名规范: 可以采用 <code>release-*</code> 的形式命名</li>
</ul>
<p><strong>Pros</strong></p>
<ul>
<li>保留了单主干开发的优点</li>
<li>解决了单主干开发的缺点</li>
</ul>
<p><strong>Crons</strong></p>
<ul>
<li>如果有多个项目迭代并行，单主干作为开发分支，无法定义『迭代功能完成』</li>
<li>发布分支太多，不方便维护</li>
<li>主干仍然没有一个稳定的版本可以作为基准</li>
</ul>
<h3 id="演进2-——-引入功能分支或者个人仓库"><a href="#演进2-——-引入功能分支或者个人仓库" class="headerlink" title="演进2 —— 引入功能分支或者个人仓库"></a>演进2 —— 引入功能分支或者个人仓库</h3><p>单个开发分支并行度还是有限，不能很好的支持多个项目并行开发。一种解决方案就是引入多个开发分支，根据开发分支的粒度，可以分为以下几种策略:</p>
<ul>
<li>feature branch : 按照功能维度隔离切分；临时分支。</li>
<li>personal repository/branch : 按照人员维度隔离切分；长期分支。这种模式其实就是 GithubFlow/GitlabFlow 模式。</li>
</ul>
<p><strong>feature 分支</strong></p>
<ul>
<li>为了开发某种特定功能，从 master/develop 分支上面分出来的</li>
<li>临时分支，合并到发布分支后（gitflow 模式下还要合并到 develop 分支）删除</li>
<li>命名规范: 可以以 <code>feature-*</code> 形式命名</li>
</ul>
<p><strong>Pros</strong></p>
<ul>
<li>提高开发的并行度和隔离性</li>
</ul>
<p><strong>Crons</strong></p>
<ul>
<li>功能分支/个人仓库 之间互相不可见，需要确定合并的机制。</li>
</ul>
<p>现在功能开发都在各自的分支或者仓库上开发了，那么怎么进行功能合并和发布呢？</p>
<p>根据其合并机制可以衍生出两个分支管理模式:</p>
<ol>
<li>开发的时候合并 : 显然不能直接合并到 master 去，但是需要一个类似于 master 功能的『长期分支』 —— develop 分支，这样，所有的功能分支都可以合并到这个主干去，发布分支就可以直接从这个分支拉出来进行测试发布了。</li>
<li>发布的时候合并<ol>
<li>直接合并到 master : GithubFlow 模式</li>
<li>合并到 Release 分支 : 这个分支和操作流程前面已经介绍过了，这里就不赘述。</li>
</ol>
</li>
</ol>
<p><strong>说明</strong></p>
<p>1、develop 分支</p>
<ul>
<li>develop 为开发分支，始终保持最新完成以及bug修复后的代码</li>
<li>在 gitlab 模式下，开发新功能时，feature分支都是基于develop分支下创建的，并且会不断的合并会 develop 分支。</li>
</ul>
<p>2、GithubFlow</p>
<p>GithubFlow 模式，其实就是在 TrunkBased 的基础上，增加了个人仓库和 Pull Request 合并代码的操作，与在同一个仓库里增加个人分支的做法类似，从实用的意义来说，它更合适分布式团队。GithubFlow 也有演进版本，例如强调了多环境部署和将仓库或分支与环境关联的 GitlabFlow 模式。</p>
<p><img src="//blog.com/2019/08/27/Git分支管理策略/github-flow.png" alt="github-flow.png"></p>
<h3 id="演进3-——-引入-hotfix-分支"><a href="#演进3-——-引入-hotfix-分支" class="headerlink" title="演进3 —— 引入 hotfix 分支"></a>演进3 —— 引入 hotfix 分支</h3><p>如果线上发现有紧急 bug 这时候应该怎么修复呢？前面讨论过的 master 分支、develop 分支、release 分支和 feature 分支显然都适合做这个事情。于是我们引入另一种分支 —— hotfix 分支。</p>
<p><strong>hotfix 分支</strong></p>
<ul>
<li>线上出现紧急问题时，需要及时修复，以 master 分支为基线，创建 hotfix 分支进行故障修复。</li>
<li>临时分支，跟 release 分支非常类似，测试发布完成后，需要以 tag 形式合并到 master 分支（gitflow 模式下还要合并到 develop 分支）后删除</li>
<li>命名规范 : 可以以 <code>hotfix-*</code> 命名</li>
</ul>
<h2 id="GitFlow-简化"><a href="#GitFlow-简化" class="headerlink" title="GitFlow 简化"></a>GitFlow 简化</h2><p>前面我们介绍了从最简单的单主干开发逐渐演进到复杂的 GitFlow 分支管理模式，是一个加法的过程。</p>
<p>GitFlow 模式是若干模式的集大成者，包含一个主干分支、一个开发分支、许多的特性分支、许多的发布分支和 Hotfix 分支，以及许多繁琐的合并规则。由于对每个阶段的每项操作定义十分明确，它曾经是很多重视流程的企业眼里的香馍馍。但它流程复杂，使用起来并不是很容易。</p>
<p><img src="//blog.com/2019/08/27/Git分支管理策略/gitflow.png" alt="gitflow.png"></p>
<p>但是与软件开发中的其他实践一样，Git 分支管理并没有普遍适用的最佳做法，而只有对每个团队和项目而言最适合的做法。不同的团队应该根据自己团队人员组成和意愿、项目的发布周期等因素选择最适合的策略，找到最适合团队的管理方式。现在我们来看一下怎么简化 GitFlow。</p>
<h3 id="简化1-——-取消-develop-分支"><a href="#简化1-——-取消-develop-分支" class="headerlink" title="简化1 —— 取消 develop 分支"></a>简化1 —— 取消 develop 分支</h3><p>develop 分支是为了让功能分支能够尽快的进行合并以及作为发布分支的基准。但是也正因为功能分支要随时合并回 develop 分支，这就导致 develop 分支不稳定。这就带来一下几个问题:</p>
<ol>
<li>因为 develop 分支是所有开发人员公用的，一个开发人员引入的 bug 可能对其他很多人造成影响。</li>
<li>开发分支没有一个稳定的版本，新拉的 feature 分支可能是没法运行的</li>
<li>基于不稳定的 develop 分支拉 release 分支，会把未完成的 feature 分支也一起发布上线，弥补的措施是 FeatureToggle 以及频繁的集成和足够的测试覆盖，这对开发团队的能力提出了比较高的要求。</li>
<li>很多合并都需要同时合并 master 和 develop，增加操作的复杂度。</li>
</ol>
<p>综合对比之下，我们觉得：</p>
<ol>
<li>从不稳定的 develop 分支拉取 feature 分支，还不如从 稳定的 master 分支拉取；虽然代码及时性相对 develop 分支落后一些。</li>
<li>从不稳定的 develop 分支拉取 release 分支，还不如从 稳定的 master 分支拉取，并且需要上线的 feature 分支自己选择合并过去，确保只发布完善的 feature 分支。带来的问题就是发布前合并，冲突解决偏后。</li>
</ol>
<p>综上，我们决定废除 develop 分支，引入搭车发布的分支开发模式:</p>
<p><img src="//blog.com/2019/08/27/Git分支管理策略/gitflow_simplify.png" alt="gitflow_simplify.png"></p>
<p><strong>使用流程</strong></p>
<p>相比 git flow，最大的改动在于去掉了 develop 分支。</p>
<p>1、功能迭代：</p>
<p>开发新功能时，先从 master 分支拉取 feature 功能分支，是否推送到远端，看是否需要多人协作，功能开发测试完成后，合并到 release 发布分支，删除分支；</p>
<p>2、版本发布：</p>
<p>功能开发到里程碑之后，或者接近版本迭代周期时(固定发版时间前一天)，从最新的 master 分支拉取 release 发布分支，merge 本次需要发布的所有 feature 分支，发布测试基于 release 分支，测试的 bug 直接在 release 分支修复，release 分支一旦开始测试，后续 checkout 的 feature 功能分支不能再合并到该分支，需要放到下一次 release 分支。 版本发布成功后，合并 release 分支到 master 分支，master 分支需要打上 tag 号。合并后删除 release 分支。</p>
<p>3、Bug 修复</p>
<p>线上 bug 需要修复时，从master分支(生产运行的最新代码)拉取 hotfix 修复分支，是否推送到远端，看是否需要多人协作，修复完成后，合并分支到 master 分支，同时 master 分支需要打上 tag 号。</p>
<p><strong>原则</strong></p>
<ul>
<li>Master 分支不做直接修改，只 merge 其它分支，push 远端，每一次合并都需要打 tag，包括 release 和 hotfix。</li>
<li>Feature 分支从 Master 分支 checkout，功能完成 merge 到 release 分支。</li>
<li>Release 分支从 Master 分支 checkout，一旦提交测试，不在 merge 后续的 feature 分支，确定版本稳定发布后，merge 到 master 分支。</li>
<li>Hotfix 分支从 maser 分支 checkout，确定修复发版后，merge 回 master 分支，同时必须打上 tag。</li>
<li>简化版策略清晰可控，适合“版本发布”的开发模式，同时也没有 gitflow 策略复杂。</li>
</ul>
<p><strong>存在问题</strong></p>
<ul>
<li>因为没有 develop 分支汇总 feature 改动，多个 feature 分支之间的代码改动（包括 hotfix），在 merge 到 release 分支之前，代码需要相互合并才能可见。</li>
</ul>
<h3 id="简化2-——-弱化-release-分支"><a href="#简化2-——-弱化-release-分支" class="headerlink" title="简化2 —— 弱化 release 分支"></a>简化2 —— 弱化 release 分支</h3><p>简化后的分支开发模式比原来要简单很多，但是实际运行过程中我们发现搭车发布的方式比较适合于有严格迭代计划和发布周期的开发模式，不适合敏捷开发持续发布的开发模式。于是我们把整个流程又做了一次精简，直接让每个功能分支直接作为 release 分支发布，发布之前周知一下，如果有其他特性分支要一起发布的话就合并在一起发，否则就自己单独发布。</p>
<p><img src="//blog.com/2019/08/27/Git分支管理策略/git-branch-cd.png" alt="git-branch-cd.png"></p>
<p><strong>说明</strong></p>
<ul>
<li>每个人拉自己的功能或者修复分支</li>
<li>需要发布时先在群里同步有版本需要发布</li>
<li>如果有别人的功能和修复也需要发布，等待搭车的分支合并到自己分支</li>
<li>发布前合并最新的 master 分支</li>
<li>发布后群里通知，相关的同学自己验证功能</li>
<li>合并到 master 分支，打上 tag 号</li>
<li>删除当前功能分支</li>
<li>在 wiki 上记录发布信息</li>
</ul>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol>
<li><a href="https://infoq.cn/article/2011/03/ci-branch-strategy" target="_blank" rel="noopener">持续集成之“分支策略”</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-git-mange/index.html" target="_blank" rel="noopener">Git 分支管理最佳实践</a></li>
<li><a href="https://yq.aliyun.com/articles/573549" target="_blank" rel="noopener">在阿里，我们如何管理代码分支？</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="noopener">Git分支管理策略</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/08/25/Redis面试经典问题集锦/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/25/Redis面试经典问题集锦/" itemprop="url">Redis面试经典问题集锦</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-25T12:12:57+08:00">
                2019-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redis面试经典问题集锦"><a href="#Redis面试经典问题集锦" class="headerlink" title="Redis面试经典问题集锦"></a>Redis面试经典问题集锦</h1><h2 id="Redis有哪些数据结构？"><a href="#Redis有哪些数据结构？" class="headerlink" title="Redis有哪些数据结构？"></a>Redis有哪些数据结构？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串<code>String</code>、字典<code>Hash</code>、列表<code>List</code>、集合<code>Set</code>、有序集合<code>SortedSet</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你是<code>Redis</code>中高级用户，还需要加上下面几种数据结构<code>HyperLogLog</code>、<code>Geo</code>、<code>Pub/Sub</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你说还玩过<code>Redis Module</code>，像<code>BloomFilter</code>，<code>RedisSearch</code>，<code>Redis-ML</code>，面试官得眼睛就开始发亮了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近还支持了流<code>Stream</code></p>
<h2 id="数据结构而非类型"><a href="#数据结构而非类型" class="headerlink" title="数据结构而非类型"></a>数据结构而非类型</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>redis</code>里存的都是二进制数据，其实就是<strong>字节数组（<code>byte[]</code>）</strong>，这些字节数据是没有数据类型的，只有把它们按照合理的格式<strong>解码后，可以变成一个字符串，整数或对象，此时才具有数据类型</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一点必须要记住。所以任何东西只要能转化成字节数组（<code>byte[]</code>）的，都可以存到<code>redis</code>里。管你是字符串、数字、对象、图片、声音、视频、还是文件，只要变成<code>byte</code>数组。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此<code>redis</code>里的<code>String</code>指的并不是字符串，它其实表示的是一种最简单的数据结构，即一个<code>key</code>只能对应一个<code>value</code>。这里的<code>key</code>和<code>value</code>都是<code>byte</code>数组，只不过<code>key</code>一般是由一个字符串转换成的<code>byte</code>数组，<code>value</code>则根据实际需要而定。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在特定情况下，对<code>value</code>也会有一些要求，比如要进行自增或自减操作，那<code>value</code>对应的<code>byte</code>数组必须要能被解码成一个数字才行，否则会报错。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>List</code>这种数据结构，其实表示一个<code>key</code>可以对应多个<code>value</code>，且<code>value</code>之间是有先后顺序的，<code>value</code>值可以重复。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Set</code>这种数据结构，表示一个<code>key</code>可以对应多个<code>value</code>，且<code>value</code>之间是没有先后顺序的，<code>value</code>值也不可以重复。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Hash</code>这种数据结构，表示一个<code>key</code>可以对应多个<code>key-value</code>对，此时这些<code>key-value</code>对之间的先后顺序一般意义不大，这是一个按照名称语义来访问的数据结构，而非位置语义。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Sorted Set</code>这种数据结构，表示一个key可以对应多个<code>value</code>，<code>value</code>之间是有大小排序的，<code>value</code>值不可以重复。每个<code>value</code>都和一个浮点数相关联，该浮点数叫<code>score</code>。元素排序规则是：先按<code>score</code>排序，再按<code>value</code>排序。</p>
<h2 id="Redis常见数据结构的用法"><a href="#Redis常见数据结构的用法" class="headerlink" title="Redis常见数据结构的用法"></a>Redis常见数据结构的用法</h2><p><code>string</code>             =&gt; 缓存、计数器（频率控制）、分布式锁</p>
<p><code>sortedset</code>      =&gt; 排行榜、分页、延时队列</p>
<p><code>list</code>                =&gt; 队列  </p>
<p><code>set</code>                  =&gt; 标签存储、集合运算</p>
<p><code>hash</code>               =&gt; 对象存储</p>
<p><code>bitmap</code>          =&gt; 统计（签到天数） </p>
<p><code>pub/sub</code>        =&gt; 通知、队列</p>
<p>布隆过滤器</p>
<p>流</p>
<p>模糊计数</p>
<h2 id="使用过Redis分布式锁么，它是什么回事？"><a href="#使用过Redis分布式锁么，它是什么回事？" class="headerlink" title="使用过Redis分布式锁么，它是什么回事？"></a>使用过Redis分布式锁么，它是什么回事？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时候对方会告诉你说你回答得不错，然后接着问如果在<code>setnx</code>之后执行<code>expire</code>之前进程意外<code>crash</code>或者要重启维护了，那会怎么样？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后回答：我记得<strong>set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！</strong>（如果版本不支持，可以通过<code>lua script</code>来实现）</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对方这时会显露笑容，心里开始默念：摁，这小子还不错。</p>
<h2 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用<code>keys</code>指令可以扫出指定模式的<code>key</code>列表。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对方接着追问：如果这个redis正在给线上的业务提供服务，那使用<code>keys</code>指令会有什么问题？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个时候你要回答<code>redis</code>关键的一个特性：<code>redis</code>的单线程的。<strong><code>keys</code>指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个时候可以<strong>使用<code>scan</code>指令，<code>scan</code>指令可以无阻塞的提取出指定模式的<code>key</code>列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用<code>keys</code>指令长</strong>。（迭代器模式）</p>
<h2 id="使用过Redis做异步队列么，你是怎么用的？"><a href="#使用过Redis做异步队列么，你是怎么用的？" class="headerlink" title="使用过Redis做异步队列么，你是怎么用的？"></a>使用过Redis做异步队列么，你是怎么用的？</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般使用list结构作为队列，<code>rpush</code>生产消息，<code>lpop</code>消费消息。当<code>lpop</code>没有消息的时候，要适当<code>sleep</code>一会再重试。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果对方追问可不可以不用<code>sleep</code>呢？list还有个指令叫<code>blpop</code>，在没有消息的时候，它会阻塞住直到消息到来。</p>
<h3 id="pub-sub"><a href="#pub-sub" class="headerlink" title="pub/sub"></a>pub/sub</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果对方追问能不能<strong>生产一次消费多次</strong>呢？使用<code>pub/sub</code>主题订阅者模式，可以实现<code>1:N</code>的消息队列。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果对方追问<code>pub/sub</code>有什么缺点？<strong>在消费者下线的情况下，生产的消息会丢失</strong>，得使用专业的消息队列如<code>rabbitmq</code>等。</p>
<h3 id="sortedset"><a href="#sortedset" class="headerlink" title="sortedset"></a>sortedset</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果对方追问<code>redis</code>如何实现<strong>延时队列</strong>？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是你很克制，然后神态自若的回答道：<strong>使用<code>sortedset</code>，拿时间戳作为<code>score</code>，消息内容作为<code>value</code>调用<code>zadd</code>来生产消息，消费者用<code>zrangebyscore</code>指令获取N秒之前的数据轮询进行处理</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</p>
<h2 id="如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果大量的<code>key</code>过期时间设置的过于集中，到过期的那个时间点，<code>redis</code>可能会出现短暂的卡顿现象。<strong>一般需要在时间上加一个随机值，使得过期时间分散一些</strong>。</p>
<h2 id="Redis如何做持久化的？"><a href="#Redis如何做持久化的？" class="headerlink" title="Redis如何做持久化的？"></a>Redis如何做持久化的？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>bgsave</code>做镜像全量持久化，<code>aof</code>做增量持久化</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为<code>bgsave</code>会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要<code>aof</code>来配合使用。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>redis</code>实例重启时，会使用<code>bgsave</code>持久化文件重新构建内存，再使用<code>aof</code>重放近期的操作指令来实现完整恢复重启之前的状态。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对方追问那如果突然机器掉电会怎样？<strong>取决于<code>aof</code>日志<code>sync</code>属性的配置</strong>，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是在高性能的要求下每次都<code>sync</code>是不现实的，<strong>一般都使用定时<code>sync</code>，比如1s 1次，这个时候最多就会丢失1s的数据</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对方追问<code>bgsave</code>的原理是什么？你给出两个词汇就可以了，<strong>fork和cow</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>fork</code>是指<code>redis</code>通过创建子进程来进行<code>bgsave</code>操作，<code>cow</code>指的是<code>copy on write</code>，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来</strong>。</p>
<h2 id="Redis-是如何持久化的"><a href="#Redis-是如何持久化的" class="headerlink" title="Redis 是如何持久化的"></a>Redis 是如何持久化的</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis</code> 的持久化有两种机制，一个是 <code>RDB</code>，也就是快照，快照就是一次全量的备份，会把所有<code>Redis</code> 的内存数据进行二进制的序列化存储到磁盘。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一种是<code>AOF</code> 日志，<code>AOF</code>日志记录的是数据操作修改的指令记录日志，可以类比 <code>MySQL</code> 的 <code>Binlog</code>，<code>AOF</code> 日期随着时间的推移只会无限增量。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在对 <code>Redis</code>进行恢复时，<code>RDB</code>快照直接读取磁盘即可恢复，而 AOF 需要对所有的操作指令进行重放进行恢复，这个过程有可能非常漫长。</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825172905.jpg" alt="img"></p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis</code> 在进行 <code>RDB</code> 的快照生成有两种方法，一种是 <code>Save</code>，由于 <code>Redis</code>是单进程单线程，直接使用 <code>Save</code>，<code>Redis</code> 会进行一个庞大的文件 <code>IO</code>操作。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于单进程单线程势必会阻塞线上的业务，一般的话不会直接采用 <code>Save</code>，而是采用<code>Bgsave</code>，之前一直说 <code>Redis</code>是单进程单线程，其实不然。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在使用 <code>Bgsave</code> 的时候，<code>Redis</code> 会<code>Fork</code> 一个子进程，快照的持久化就交给子进程去处理，而父进程继续处理线上业务的请求</strong>。</p>
<h4 id="Fork-机制"><a href="#Fork-机制" class="headerlink" title="Fork 机制"></a>Fork 机制</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想要弄清楚 <code>RDB</code> 快照的生成原理就必须弄清楚 <code>Fork</code>机制，<code>Fork</code> 机制是 <code>Linux</code> 操作系统的一个进程机制。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>当父进程<code>Fork</code> 出来一个子进程，子进程和父进程拥有共同的内存数据结构，子进程刚刚产生时，它和父进程共享内存里面的代码段和数据段</strong>。</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825172927.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一开始两个进程都具备了相同的内存段，<strong>子进程在做数据持久化时，不会去修改现在的内存数据，而是会采用 <code>COW(Copy On Write)</code>的方式将数据段页面进行分离</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>当父进程修改了某一个数据段时，被共享的页面就会复制一份分离出来，然后父进程再在新的数据段进行修改</strong>。</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825172953.jpg" alt="img"></p>
<h4 id="分裂"><a href="#分裂" class="headerlink" title="分裂"></a>分裂</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个过程也成为分裂的过程，<strong>本来父子进程都指向很多相同的内存块，但是如果父进程对其中某个内存块进行该修改，就会将其复制出来，进行分裂再在新的内存块上面进行修改</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为子进程在 <code>Fork</code> 的时候就可以固定内存，这个时间点的数据将不会产生变化。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以我们可以安心的产生快照不用担心快照的内容受到父进程业务请求的影响。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外可以想象，如果在 <code>Bgsave</code> 的过程中，<code>Redis</code> 没有任何操作，父进程没有接收到任何业务请求也没有任何的背后例如过期移除等操作，父进程和子进程将会使用相同的内存块。</p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>AOF</code>是 <code>Redis</code>操作指令的日志存储，类同于 <code>MySQL</code> 的 <code>Binlog</code>，假设 <code>AOF</code>从 <code>Redis</code> 创建以来就一直执行，那么 <code>AOF</code> 就记录了所有的<code>Redis</code> 指令的记录。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要恢复<code>Redis</code>，可以对 <code>AOF</code>进行指令重放，便可修复整个 <code>Redis</code>实例。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过 <code>AOF</code> 日志也有两个比较大的问题：</p>
<ul>
<li><p>一个是<code>AOF</code> 的日志会随着时间递增，如果一个数据量大运行的时间久，<code>AOF</code> <strong>日志量将变得异常庞大</strong>。</p>
</li>
<li><p>另一个问题是 <code>AOF</code> 在做数据恢复时，由于重放的量非常庞大，<strong>恢复的时间将会非常的长</strong>。</p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>AOF</code> 写操作是在 <code>Redis</code> 处理完业务逻辑之后，按照一定的策略才会进行些 <code>AOF</code>日志存盘</strong>，这点跟 <code>MySQL</code>的<code>Redo log</code>和 <code>Binlog</code>有很大的不同。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也因为此原因，<strong><code>Redis</code> 因为处理逻辑在前而记录操作日志在后，也是导致 <code>Redis</code> 无法进行回滚的一个原因</strong>。</p>
<p><code>bgrewriteaof</code>：针对上述的问题，<code>Redis</code> 在 2.4 之后也使用了<code>bgrewriteaof</code> 对<code>AOF</code> 日志进行瘦身。</p>
<p><code>bgrewriteaof</code>命令用于异步执行一个<code>AOF</code> 文件重写操作。重写会创建一个当前<code>AOF</code> 文件的体积优化版本。</p>
<h3 id="RDB-和-AOF-混合搭配模式"><a href="#RDB-和-AOF-混合搭配模式" class="headerlink" title="RDB 和 AOF 混合搭配模式"></a>RDB 和 AOF 混合搭配模式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在对<code>Redis</code>进行恢复的时候，如果我们采用了 <code>RDB</code>的方式，因为 <code>Bgsave</code> 的策略，可能会导致我们丢失大量的数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们采用了<code>AOF</code>的模式，通过 <code>AOF</code> 操作日志重放恢复，重放 <code>AOF</code>日志比<code>RDB</code>要长久很多。</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825173821.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis 4.0</code> 之后，为了解决这个问题，引入了新的持久化模式，混合持久化，将<code>RDB</code>的文件和局部增量的 <code>AOF</code> 文件相结合。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>RDB</code> 可以使用相隔较长的时间保存策略，<code>AOF</code> 不需要是全量日志，只需要保存前一次<code>RDB</code>存储开始到这段时间增量<code>AOF</code>日志即可</strong>，一般来说，这个日志量是非常小的。</p>
<h2 id="Pipeline有什么好处，为什么要用pipeline？"><a href="#Pipeline有什么好处，为什么要用pipeline？" class="headerlink" title="Pipeline有什么好处，为什么要用pipeline？"></a>Pipeline有什么好处，为什么要用pipeline？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以将<strong>多次<code>IO</code>往返的时间缩减为一次，前提是<code>pipeline</code>执行的指令之间没有因果相关性</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用<code>redis-benchmark</code>进行压测的时候可以发现影响<code>redis</code>的<code>QPS</code>峰值的一个重要因素是<code>pipeline</code>批次指令的数目。</p>
<h2 id="Redis的同步机制了解么？"><a href="#Redis的同步机制了解么？" class="headerlink" title="Redis的同步机制了解么？"></a>Redis的同步机制了解么？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis</code>可以使用主从同步，从从同步。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存<code>buffer</code>，待完成后将<code>rdb</code>文件全量同步到复制节点，复制节点接受完成后将<code>rdb</code>镜像加载到内存。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p>
<h2 id="Redis-是如何实现主从复制"><a href="#Redis-是如何实现主从复制" class="headerlink" title="Redis 是如何实现主从复制"></a>Redis 是如何实现主从复制</h2><p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825174147.jpg" alt="img"></p>
<p>几个定义：</p>
<ul>
<li><strong><code>runID</code>：服务器运行的 ID</strong>。</li>
<li><strong><code>Offset</code>：主服务器的复制偏移量和从服务器复制的偏移量</strong>。</li>
<li><strong><code>Replication backlog</code>：主服务器的复制积压缓冲区</strong>。</li>
</ul>
<p>在 <code>Redis 2.8</code>之后，使用 <code>Psync</code>命令代替<code>Sync</code>命令来执行复制的同步操作。</p>
<p><code>Psync</code>命令具有完整重同步和部分重同步两种模式：</p>
<ul>
<li><p><strong>完整同步用于处理初次复制情况</strong>：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完整重同步的执行步骤和 <code>Sync</code> 命令执行步骤一致，都是<strong>通过让主服务器创建并发送 <code>RDB</code> 文件，以及向从服务器发送保存在缓冲区的写命令来进行同步</strong>。</p>
</li>
<li><p><strong>部分重同步是用于处理断线后重复制情况</strong>：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当从服务器在断线后重新连接主服务器时，<strong>主服务可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令</strong>，就可以将数据库更新至主服务器当前所处的状态。</p>
</li>
</ul>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825174522.jpg" alt="img"></p>
<h3 id="完整重同步"><a href="#完整重同步" class="headerlink" title="完整重同步"></a>完整重同步</h3><p>完整重同步：</p>
<ul>
<li><code>Slave</code> 发送 <code>Psync</code> 给 <code>Master</code>，由于是第一次发送，不带上<code>runID</code> 和 <code>Offset</code>。</li>
<li><code>Master</code> 接收到请求，发送 <code>Master</code> 的<code>runID</code> 和 <code>Offset</code>给从节点。</li>
<li><code>Master</code> 生成保存 <code>RDB</code> 文件。</li>
<li><code>Master</code>发送 <code>RDB</code> 文件给 <code>Slave</code>。</li>
<li>在发送 <code>RDB</code>这个操作的同时，写操作会复制到缓冲区 <code>Replication Backlog Buffer</code> 中，并从 <code>Buffer</code>区发送到 <code>Slave</code>。</li>
<li><code>Slave</code>将 <code>RDB</code> 文件的数据装载，并更新自身数据。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果网络的抖动或者是短时间的断链也需要进行完整同步就会导致大量的开销，这些开销包括了，<code>Bgsave</code> 的时间，<code>RDB</code> 文件传输的时间，<code>Slave</code> 重新加载<code>RDB</code> 时间，如果 <code>Slave</code> 有 <code>AOF</code>，还会导致 <code>AOF</code> 重写。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些都是大量的开销，所以在<code>Redis 2.8</code> 之后也实现了<strong>部分重同步</strong>的机制。</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825175223.jpg" alt="img"></p>
<h3 id="部分重同步"><a href="#部分重同步" class="headerlink" title="部分重同步"></a>部分重同步</h3><p>部分重同步：</p>
<ul>
<li><p>网络发生错误，<code>Master</code> 和<code>Slave</code> 失去连接。</p>
</li>
<li><p><strong><code>Master</code> 依然向<code>Buffer</code>缓冲区写入数据</strong>。</p>
</li>
<li><p><code>Slave</code> 重新连接上 <code>Master</code>。</p>
</li>
<li><p><strong><code>Slave</code> 向 <code>Master</code> 发送自己目前的 <code>runID</code>和 <code>Offset</code></strong>。</p>
</li>
<li><p><strong><code>Master</code> 会判断 <code>Slave</code> 发送给自己的<code>Offset</code>是否存在 <code>Buffer</code>队列中</strong>。</p>
</li>
<li><p><strong>如果存在，则发送<code>Continue</code> 给<code>Slave</code></strong></p>
<p>如果不存在，意味着可能错误了太多的数据，缓冲区已经被清空，这个时候就需要重新进行全量的复制</p>
</li>
<li><p><strong><code>Master</code> 发送从 <code>Offset</code>偏移后的缓冲区数据给 <code>Slave</code></strong>。</p>
</li>
<li><p><code>Slave</code> 获取数据更新自身数据。</p>
</li>
</ul>
<h2 id="是否使用过Redis集群，集群的原理是什么？"><a href="#是否使用过Redis集群，集群的原理是什么？" class="headerlink" title="是否使用过Redis集群，集群的原理是什么？"></a>是否使用过Redis集群，集群的原理是什么？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Redis Sentinal</code>着眼于高可用</strong>，在<code>master</code>宕机时会自动将<code>slave</code>提升为<code>master</code>，继续提供服务。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Redis Cluster</code>着眼于扩展性</strong>，在单个<code>redis</code>内存不足时，使用<code>Cluster</code>进行分片存储。</p>
<h2 id="集群带来的问题与解决思路"><a href="#集群带来的问题与解决思路" class="headerlink" title="集群带来的问题与解决思路"></a>集群带来的问题与解决思路</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;集群带来的好处是显而易见的，比如容量增加、处理能力增强，还可以按需要进行动态的扩容、缩容。但同时也会引入一些新的问题，至少会有下面这两个：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一是<strong>数据分配：存数据时应该放到哪个节点上，取数据时应该去哪个节点上找</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二是<strong>数据移动：集群扩容，新增加节点时，该节点上的数据从何处来；集群缩容，要剔除节点时，该节点上的数据往何处去</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面这两个问题有一个共同点就是，<strong>如何去描述和存储数据与节点的映射关系</strong>。又因为数据的位置是由<code>key</code>决定的，所以问题就演变为<strong>如何建立起各个<code>key</code>和集群所有节点的关联关系</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;集群的节点是相对固定和少数的，虽然有增加节点和剔除节点。但集群里存储的<code>key</code>，则是完全随机、没有规律、不可预测、数量庞多，还非常琐碎。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就好比一所大学和它的所有学生之间的关系。如果大学和学生直接挂钩的话，一定会比较混乱。现实是它们之间又加入了好几层，首先有院系，其次有专业，再者有年级，最后还有班级。经过这四层映射之后，关系就清爽很多了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这其实是一个非常重要的结论，这个世界上没有什么问题是不能通过加入一层来解决的。如果有，那就再加入一层。计算机里也是这样的。</p>
<h3 id="Redis-Cluster的原理"><a href="#Redis-Cluster的原理" class="headerlink" title="Redis Cluster的原理"></a>Redis Cluster的原理</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>redis</code>在数据和节点之间又加入了一层，把这层称为槽（<code>slot</code>），因该槽主要和哈希有关，又叫哈希槽</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后变成了，<strong>节点上放的是槽，槽里放的是数据</strong>。<strong>槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动</strong>。<strong>哈希解决的是映射问题，使用<code>key</code>的哈希值来计算所在的槽，便于数据分配</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以这样来理解，你的学习桌子上堆满了书，乱的很，想找到某本书非常困难。于是你买了几个大的收纳箱，把这些书按照书名的长度放入不同的收纳箱，然后把这些收纳箱放到桌子上。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样就变成了，桌子上是收纳箱，收纳箱里是书籍。这样书籍移动很方便，搬起一个箱子就走了。寻找书籍也很方便，只要数一数书名的长度，去对应的箱子里找就行了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实我们也没做什么，只是买了几个箱子，按照某种规则把书装入箱子。就这么简单的举动，就彻底改变了原来一盘散沙的状况。是不是有点小小的神奇呢。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>一个集群只能有<code>16384</code>个槽，编号<code>0-16383</code>。这些槽会分配给集群中的所有主节点，分配策略没有要求。可以指定哪些编号的槽分配给哪个主节点</strong>。<strong>集群会记录节点和槽的对应关系</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来就需要<strong>对key求哈希值，然后对16384取余，余数是几，key就落入对应的槽里。<code>slot = CRC16(key) % 16384</code></strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用哈希函数计算出<code>key</code>的哈希值，这样就可以算出它对应的槽，然后利用集群存储的槽和节点的映射关系查询出槽所在的节点，于是数据和节点就映射起来了，这样数据分配问题就解决了。</p>
<h3 id="集群对命令操作的取舍"><a href="#集群对命令操作的取舍" class="headerlink" title="集群对命令操作的取舍"></a>集群对命令操作的取舍</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端只要和集群中的一个节点建立链接后，就可以获取到整个集群的所有节点信息。此外还会获取所有哈希槽和节点的对应关系信息，这些信息数据都会在客户端缓存起来，因为这些信息相当有用。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端可以向任何节点发送请求，那么拿到一个<code>key</code>后到底该向哪个节点发请求呢？其实就是z<strong>把集群里的那套<code>key</code>和节点的映射关系理论搬到客户端</strong>来就行了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以客户端需要实现一个和集群端一样的哈希函数，先计算出<code>key</code>的哈希值，然后再对<code>16384</code>取余，这样就找到了该<code>key</code>对应的哈希槽，利用客户端缓存的槽和节点的对应关系信息，就可以找到该<code>key</code>对应的节点了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来发送请求就可以了。还可以把<code>key</code>和节点的映射关系缓存起来，下次再请求该<code>key</code>时，直接就拿到了它对应的节点，不用再计算一遍了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;理论和现实总是有差距的，<strong>集群已经发生了变化，客户端的缓存还没来得及更新</strong>。肯定会出现拿到一个<code>key</code>向对应的节点发请求，其实这个<code>key</code>已经不在那个节点上了。此时这个节点应该怎么办？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个节点可以去<code>key</code>实际所在的节点上拿到数据再返回给客户端，也可以直接告诉客户端<code>key</code>已经不在我这里了，同时<strong>附上<code>key</code>现在所在的节点信息，让客户端再去请求一次，类似于<code>HTTP</code>的<code>302</code>重定向</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这其实是个选择问题，也是个哲学问题。结果就是<code>redis</code>集群选择了后者。因此，<strong>节点只处理自己拥有的<code>key</code>，对于不拥有的key将返回重定向错误，即-MOVED key 127.0.0.1:6381，客户端重新向这个新节点发送请求</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以说选择是一种哲学，也是个智慧。稍后再谈这个问题。先来看看另一个情况，和这个问题有些相同点。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>redis</code>有一种命令可以一次带多个<code>key</code>，如<code>MGET</code>，我把这些称为多<code>key</code>命令。这个多<code>key</code>命令的请求被发送到一个节点上，这里有一个潜在的问题，不知道大家有没有想到，就是这个命令里的多个<code>key</code>一定都位于那同一个节点上吗？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就分为两种情况了，如果多个<code>key</code>不在同一个节点上，此时节点只能返回重定向错误了，但是多个<code>key</code>完全可能位于多个不同的节点上，此时返回的重定向错误就会非常乱，所以<code>redis</code>集群选择不支持此种情况。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果多个<code>key</code>位于同一个节点上呢，理论上是没有问题的，<code>redis</code>集群是否支持就和<code>redis</code>的版本有关系了，具体使用时自己测试一下就行了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个过程中我们发现了一件颇有意义的事情，就是让一组相关的<code>key</code>映射到同一个节点上是非常有必要的，这样可以提高效率，通过多<code>key</code>命令一次获取多个值。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么问题来了，如何给这些<code>key</code>起名字才能让他们落到同一个节点上，难不成都要先计算个哈希值，再取个余数，太麻烦了吧。当然不是这样了，<code>redis</code>已经帮我们想好了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以来简单推理下，要想让两个<code>key</code>位于同一个节点上，它们的哈希值必须要一样。要想哈希值一样，传入哈希函数的字符串必须一样。那我们只能传进去两个一模一样的字符串了，那不就变成同一个<code>key</code>了，后面的会覆盖前面的数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的问题是我们都是拿整个<code>key</code>去计算哈希值，这就导致<code>key</code>和参与计算哈希值的字符串耦合了，需要将它们解耦才行，就是<code>key</code>和参与计算哈希值的字符串有关但是又不一样。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>redis</code>基于这个原理为我们提供了方案，叫做key哈希标签。先看例子，<code>{user1000}.following</code>，<code>{user1000}.followers</code>，相信你已经看出了门道，就是仅使用Key中的位于{和}间的字符串参与计算哈希值</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样可以保证哈希值相同，落到相同的节点上。但是<code>key</code>又是不同的，不会互相覆盖。使用哈希标签把一组相关的<code>key</code>关联了起来，问题就这样被轻松愉快地解决了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相信你已经发现了，要解决问题靠的是巧妙的奇思妙想，而不是非要用牛逼的技术牛逼的算法。这就是小强，小而强大。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后再来谈选择的哲学。<code>redis</code>的核心就是以最快的速度进行常用数据结构的<code>key/value</code>存取，以及围绕这些数据结构的运算。对于与核心无关的或会拖累核心的都选择弱化处理或不处理，这样做是为了保证核心的简单、快速和稳定。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实就是在广度和深度面前，<code>redis</code>选择了深度。所以<strong>节点不去处理自己不拥有的<code>key</code>，集群不去支持多<code>key</code>命令</strong>。这样<strong>一方面可以快速地响应客户端，另一方面可以避免在集群内部有大量的数据传输与合并</strong>。</p>
<h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a><strong>单线程模型</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>redis</code>集群的每个节点里只有一个线程负责接受和执行所有客户端发送的请求。技术上使用多路复用<code>I/O</code>，使用<code>Linux</code>的<code>epoll</code>函数，这样一个线程就可以管理很多<code>socket</code>连接。</p>
<p>除此之外，选择单线程还有以下这些原因：</p>
<p>1、<strong><code>redis</code>都是对内存的操作</strong>，速度极快（10W+QPS）</p>
<p>2、<strong>整体的时间主要都是消耗在了网络的传输上</strong></p>
<p>3、如果使用了多线程，则需要<strong>多线程同步，这样实现起来会变的复杂</strong></p>
<p>4、<strong>线程的加锁时间甚至都超过了对内存操作的时间</strong></p>
<p>5、<strong>多线程上下文频繁的切换需要消耗更多的<code>CPU</code>时间</strong></p>
<p>6、还有就是<strong>单线程天然支持原子操作</strong>，而且单线程的代码写起来更简单  </p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务大家都知道，就是把多个操作捆绑在一起，要么都执行（成功了），要么一个也不执行（回滚了）。<code>redis</code>也是支持事务的，但可能和你想要的不太一样，一起来看看吧。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>redis</code>的事务可以分为两步，定义事务和执行事务。使用<code>multi</code>命令开启一个事务，然后把要执行的所有命令都依次排上去。这就定义好了一个事务。此时使用<code>exec</code>命令来执行这个事务，或使用<code>discard</code>命令来放弃这个事务。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能希望在你的事务开始前，你关心的<code>key</code>不想被别人操作，那么可以使用<code>watch</code>命令来监视这些<code>key</code>，如果开始执行前这些<code>key</code>被其它命令操作了则会取消事务的。也可以使用<code>unwatch</code>命令来取消对这些key的监视。</p>
<p><code>redis</code>事务具有以下特点：</p>
<p>1、<strong>如果开始执行事务前出错，则所有命令都不执行</strong></p>
<p>2、<strong>一旦开始，则保证所有命令一次性按顺序执行完而不被打断</strong></p>
<p>3、<strong>如果执行过程中遇到错误，会继续执行下去，不会停止的</strong></p>
<p>4、<strong>对于执行过程中遇到错误，是不会进行回滚的</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看完这些，真想问一句话，你这能叫事务吗？很显然，这并不是我们通常认为的事务，因为它连原子性都保证不了。<strong>保证不了原子性是因为<code>redis</code>不支持回滚</strong>，不过它也给出了不支持的理由。</p>
<p>不支持回滚的理由：</p>
<p>1、<code>redis</code>认为，<strong>失败都是由命令使用不当造成</strong></p>
<p>2、<code>redis</code>这样做，是<strong>为了保持内部实现简单快速</strong></p>
<p>3、<code>redis</code>还认为，<strong>回滚并不能解决所有问题</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哈哈，这就是霸王条款，因此，好像使用<code>redis</code>事务的不太多</p>
<h2 id="Redis-究竟有没有-ACID-事务"><a href="#Redis-究竟有没有-ACID-事务" class="headerlink" title="Redis 究竟有没有 ACID 事务"></a><strong>Redis 究竟有没有 ACID 事务</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要弄清楚 <code>Redis</code> 有没有事务，其实很简单，上 <code>Redis</code>的官网查看文档，发现：</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825161205.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis</code> 确实是有事务，不过按照传统的事务定义 <code>ACID</code>来看，<code>Redis</code>是不是都具备了 <code>ACID</code> 的特性。</p>
<p><code>ACID</code> 指的是：</p>
<ul>
<li><strong>原子性</strong></li>
<li><strong>一致性</strong></li>
<li><strong>隔离性</strong></li>
<li><strong>持久性</strong></li>
</ul>
<p>我们将使用以上 <code>Redis</code> 事务的命令来检验是否<code>Redis</code>都具备了 <code>ACID</code> 的各个特征。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务具备原子性指的是，数据库将事务中多个操作当作一个整体来执行，服务要么执行事务中所有的操作，要么一个操作也不会执行。</p>
<h4 id="事务队列"><a href="#事务队列" class="headerlink" title="事务队列"></a>事务队列</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先弄清楚 <code>Redis</code>开始事务<code>multi</code>命令后，<code>Redis</code> 会为这个事务生成一个队列，每次操作的命令都会按照顺序插入到这个队列中。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个队列里面的命令不会被马上执行，直到 <code>exec</code>命令提交事务，所有队列里面的命令会被一次性，并且排他的进行执行。</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825161236.jpg" alt="img"></p>
<p>对应如下图：</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825161309.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面的例子可以看出，当执行一个成功的事务，事务里面的命令都是按照队列里面顺序的并且排他的执行。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但<strong>原子性又一个特点就是要么全部成功，要么全部失败，也就是我们传统 DB 里面说的回滚</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们执行一个失败的事务：</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825161331.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以发现，就算中间出现了失败，<code>set abc x</code>这个操作也已经被执行了，并没有进行回滚，<strong>从严格的意义上来说<code>Redis</code> 并不具备原子性</strong>。</p>
<h4 id="为何-Redis-不支持回滚"><a href="#为何-Redis-不支持回滚" class="headerlink" title="为何 Redis 不支持回滚"></a>为何 Redis 不支持回滚</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个其实跟 <code>Redis</code> 的定位和设计有关系，先看看为何我们的 <code>MySQL</code> 可以支持回滚</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个还是跟写<code>Log</code> 有关系，<strong><code>Redis</code> 是完成操作之后才会进行<code>AOF</code> 日志记录，<code>AOF</code> 日志的定位只是记录操作的指令记录</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而 <code>MySQL</code> 有完善的 <code>Redo log</code>，并且是在事务进行 <code>Commit</code>之前就会写完成 <code>Redo log，Binlog</code>：</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825161353.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要知道 <code>MySQL</code> 为了能进行回滚是花了不少的代价，<code>Redis</code>应用的场景更多是对抗高并发具备高性能，所以 <code>Redis</code> 选择更简单，更快速无回滚的方式处理事务也是符合场景。</p>
<blockquote>
<p>1、<code>redis</code>认为，<strong>失败都是由命令使用不当造成</strong></p>
<p>2、<code>redis</code>这样做，是<strong>为了保持内部实现简单快速</strong></p>
<p>3、<code>redis</code>还认为，<strong>回滚并不能解决所有问题</strong></p>
</blockquote>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务具备一致性指的是，如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否成功，数据库也应该是一致的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从<code>Redis</code>来说可以从 2 个层面看，一个是执行错误是否有确保一致性，另一个是宕机时，<code>Redis</code>是否有确保一致性的机制。</p>
<h4 id="执行错误是否有确保一致性"><a href="#执行错误是否有确保一致性" class="headerlink" title="执行错误是否有确保一致性"></a>执行错误是否有确保一致性</h4><p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825163136.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依然去执行一个错误的事务，在事务执行的过程中会识别出来并进行错误处理，这些错误并不会对数据库作出修改，也不会对事务的一致性产生影响。</p>
<h4 id="宕机对一致性的影响"><a href="#宕机对一致性的影响" class="headerlink" title="宕机对一致性的影响"></a>宕机对一致性的影响</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;暂不考虑分布式高可用的 <code>Redis</code> 解决方案，先从单机看宕机恢复是否能满意数据完整性约束。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论是 <code>RDB</code>还是 <code>AOF</code> 持久化方案，可以使用 <code>RDB</code> 文件或<code>AOF</code> 文件进行恢复数据，从而将数据库还原到一个一致的状态。</p>
<h4 id="再议一致性"><a href="#再议一致性" class="headerlink" title="再议一致性"></a>再议一致性</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面执行错误和宕机对一致性的影响的观点摘自黄健宏 《<code>Redis</code>设计与实现》。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当在读这章的时候还是有一些存疑的点，归根到底 <code>Redis</code> 并非关系型数据库。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果仅仅就<code>ACID</code> 的表述上来说，一致性就是从 A 状态经过事务到达 B 状态没有破坏各种约束性，仅就 <code>Redis</code> 而言不谈实现的业务，那显然就是满意一致性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但如果加上业务去谈一致性，例如，A 转账给 B，A 减少 10 块钱，B 增加 10 块钱，因为<code>Redis</code> 并不具备回滚，也就不具备传统意义上的原子性，所以<code>Redis</code>也应该不具备传统的一致性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实，这里只是简单讨论下 <code>Redis</code> 在传统<code>ACID</code> 上的概念怎么进行对接，或许，有可能是我想多了，用传统关系型数据库的 <code>ACID</code>去审核<code>Redis</code>是没有意义的，<code>Redis</code>本来就没有意愿去实现<code>ACID</code> 的事务。</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;隔离性指的是，数据库中有多个事务并发的执行，各个事务之间不会相互影响，并且在并发状态下执行的事务和串行执行的事务产生的结果是完全相同的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Redis</code>因为是单线程操作，所以在隔离性上有天生的隔离机制</strong>，当<code>Redis</code>执行事务时，<code>Redis</code>的服务端保证在执行事务期间不会对事务进行中断，所以，<code>Redis</code>事务总是以串行的方式运行，事务也具备隔离性。</p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务的持久性指的是，当一个事务执行完毕，执行这个事务所得到的结果被保存在持久化的存储中，即使服务器在事务执行完成后停机了，执行的事务的结果也不会被丢失。</p>
<p><strong>Redis 是否具备持久化，这个取决于 Redis 的持久化模式</strong>：</p>
<ul>
<li>纯内存运行，不具备持久化，服务一旦停机，所有数据将丢失。</li>
<li><code>RDB</code> 模式，取决于 <code>RDB</code> 策略，只有在满足策略才会执行 <code>Bgsave</code>，异步执行并不能保证<code>Redis</code>具备持久化。</li>
<li><code>AOF</code> 模式，只有将 <code>appendfsync</code> 设置为<code>always</code>，程序才会在执行命令同步保存到磁盘，这个模式下，<code>Redis</code>具备持久化。(将 <code>appendfsync</code> 设置为<code>always</code>，只是在理论上持久化可行，但一般不会这么操作)</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>Redis</code> 具备了一定的原子性，但不支持回滚</strong>。</li>
<li><strong><code>Redis</code> 不具备 <code>ACID</code> 中一致性的概念</strong>。(或者说<code>Redis</code>在设计时就无视这点)</li>
<li><code>Redis</code> 具备隔离性。</li>
<li><code>Redis</code> 通过一定策略可以保证持久性。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis</code>和 <code>ACID</code> 纯属站在使用者的角度去思想，<code>Redis</code>设计更多的是追求简单与高性能，不会受制于传统 ACID 的束缚。</p>
<h2 id="Redis-的乐观锁-Watch-是怎么实现的"><a href="#Redis-的乐观锁-Watch-是怎么实现的" class="headerlink" title="Redis 的乐观锁 Watch 是怎么实现的"></a>Redis 的乐观锁 Watch 是怎么实现的</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们一提到乐观锁就会想起 <code>CAS(Compare And Set)</code>，<code>CAS</code>操作包含三个操作数：</p>
<ul>
<li>内存位置的值(V)</li>
<li>预期原值(A)</li>
<li>新值(B)</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值。否则，处理器不做任何操作。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Redis</code> 的事务中使用 <code>Watch</code> 实现，<code>Watch</code>会在事务开始之前盯住 1 个或多个关键变量。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当事务执行时，也就是服务器收到了 <code>exec</code> 指令要顺序执行缓存的事务队列时，<code>Redis</code>会检查关键变量自 <code>Watch</code>之后，是否被修改了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdaaD23JRv9Ekia9yACEasZN2u5KbESkSQOmlxK0vkBsib7nr49iaGVMfdvrrGlhJRV3LMMiavLLT4PxOA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h3 id="Java-的-AtomicXXX-的乐观锁机制"><a href="#Java-的-AtomicXXX-的乐观锁机制" class="headerlink" title="Java 的 AtomicXXX 的乐观锁机制"></a>Java 的 AtomicXXX 的乐观锁机制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>Java</code> 中我们也经常的使用到一些乐观锁的参数，例如 <code>AtomicXXX</code>，这些机制的背后是怎么去实现的，是否 <code>Redis</code>也跟 <code>Java</code> 的<code>CAS</code> 实现机制一样?</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先来看看<code>Java</code> 的 <code>Atomic</code> 类，我们追一下源码，可以看到它的背后其实是 <code>Unsafe_CompareAndSwapObject</code>：</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825164627.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看见 <code>compareAndSwapObject</code>是 <code>Native</code>方法，需要在继续追查，可以下载源码或打开 ：<a href="http://hg.openjdk.java.net/jdk8u/。" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk8u/。</a></p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825164647.jpg" alt="img"></p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825164708.jpg" alt="img"></p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825164752.jpg" alt=""></p>
<p><strong>Cmpxchg</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以发现追查到最终<code>CAS</code>，“比较并修改”，本来是两个语意，但是最终确实一条 <code>CPU</code>指令 <code>Cmpxchg</code> 完成。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Cmpxchg</code>是<strong>一条<code>CPU</code> 指令的命令而不是多条 <code>CPU</code> 指令，所以它不会被多线程的调度所打断，所以能够保证 <code>CAS</code>的操作是一个原子操作</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然 <code>Cmpxchg</code>的机制其实<strong>存在 <code>ABA</code>还有多次重试的问题</strong>，这个不在这里讨论。</p>
<h3 id="Redis-的-Watch-机制"><a href="#Redis-的-Watch-机制" class="headerlink" title="Redis 的 Watch 机制"></a>Redis 的 Watch 机制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis</code> 的<code>Watch</code>也是使用<code>Cmpxchg</code> 吗，两者存在相似之处在用法上也有一些不同</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Redis</code> 的<code>Watch</code> 不存在 <code>ABA</code> 问题</strong>，也没有多次重试机制，其中有一个重大的不同是：<code>Redis</code>事务执行其实是串行的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单追一下源码：摘录出来的源码可能有些凌乱，不过可以简单总结出来数据结构图和简单的流程图，之后再看源码就会清晰很多。</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825164830.jpg" alt="img"></p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825164849.jpg" alt="img"></p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825164941.jpg" alt="img"></p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825165009.jpg" alt="img"></p>
<p>存储如下图：</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825165033.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>RedisDb</code>存放了一个<code>watched_keys</code> 的 <code>Dcit</code>结构，每个被<code>Watch</code>的<code>Key</code> 的值是一个链表结构，存放的是一组 <code>Redis</code> 客户端标志</strong>。</p>
<p>流程如下图：</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825165101.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一次<code>Watch</code>，<code>Multi</code>，<code>Exec</code> 时都会去查询这个 <code>watched_keys</code>结构进行判断，<strong>每次<code>Touch</code> 到被 <code>Watch</code> 的 <code>Key</code>时都会标志为 <code>CLIENT_DIRTY_CAS</code></strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为在 <code>Redis</code> 中所有的事务都是串行的，假设有客户端 A 和客户端 B 都 <code>Watch</code> 同一个<code>Key</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>当客户端 A 进行 <code>Touch</code> 修改或者 A 率先执行完，会把客户端 A 从这个 <code>watched_keys</code> 的这个<code>Key</code> 的列表删除，然后把这个列表所有的客户端都设置成 <code>CLIENT_DIRTY_CAS</code></strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>当后面的客户端 B 开始执行时，判断到自己的状态是<code>CLIENT_DIRTY_CAS</code>，便 <code>discardTransaction</code>终止事务</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Redis</code> 的 <code>Watch</code> 机制，更多是利用了 <code>Redis</code> 本身单线程的机制，采用了 <code>watched_keys</code> 的数据结构和串行流程实现了乐观锁机制</strong>。</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端和集群的交互过程是<strong>串行化阻塞式</strong>的，即客户端发送了一个命令后必须等到响应回来后才能发第二个命令，这一来一回就是一个往返时间。如果你有很多的命令，都这样一个一个的来进行，会变得很慢。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>redis</code>提供了一种管道技术，可以<strong>让客户端一次发送多个命令，期间不需要等待服务器端的响应，等所有的命令都发完了，再依次接收这些命令的全部响应</strong>。这就极大地节省了许多时间，提升了效率。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;聪明的你是不是意识到了另外一个问题，多个命令就是多个<code>key</code>啊，这不就是上面提到的多<code>key</code>操作嘛，那么问题来了，你如何保证这多个<code>key</code>都是同一个节点上的啊，哈哈，<strong><code>redis</code>集群又放弃了对管道的支持</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过可以在客户端模拟实现，就是使用多个连接往多个节点同时发送命令，然后等待所有的节点都返回了响应，再把它们按照发送命令的顺序整理好，返回给用户代码。哎呀，好麻烦呀。</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>简单了解下<code>redis</code>的协议，知道<code>redis</code>的数据传输格式。</p>
<p>发送请求的协议：</p>
<p><code>*参数个数CRLF$参数1的字节数CRLF参数1的数据CRLF...$参数N的字节数CRLF参数N的数据CRLF</code></p>
<p>例如，<code>SET name lixinjie</code>，实际发送的数据是：</p>
<p><code>*3\r\n$3\r\nSET\r\n$4\r\nname\r\n$8\r\nlixinjie\r\n</code></p>
<p>接受响应的协议：</p>
<p>单行回复，第一个字节是+</p>
<p>错误消息，第一个字节是-</p>
<p>整型数字，第一个字节是:</p>
<p>批量回复，第一个字节是$</p>
<p>多个批量回复，第一个字节是*</p>
<p>例如，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+OK\r\n</span><br><span class="line"></span><br><span class="line">-ERR Operation against\r\n</span><br><span class="line"></span><br><span class="line">:1000\r\n</span><br><span class="line"></span><br><span class="line">$6\r\nfoobar\r\n</span><br><span class="line"></span><br><span class="line">*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n</span><br></pre></td></tr></table></figure>
<p>可见<code>redis</code>的协议设计的非常简单。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis</code>的通讯协议是<strong>文本协议</strong>，是的，<code>Redis</code> 服务器与客户端通过 <code>RESP(Redis Serialization Protocol)</code>协议通信。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没错，文本协议确实是会<strong>浪费流量</strong>，不过它的优点在于<strong>直观，非常的简单，解析性能极其的好</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们不需要一个特殊的 <code>Redis</code> 客户端仅靠 <code>Telnet</code> 或者是文本流就可以跟 <code>Redis</code> 进行通讯。</p>
<p>客户端的命令格式：</p>
<ul>
<li>简单字符串 Simple Strings，以 “+”加号开头。</li>
<li>错误 Errors，以”-“减号开头。</li>
<li>整数型 Integer，以 “:” 冒号开头。</li>
<li>大字符串类型 Bulk Strings，以 “$”美元符号开头。</li>
<li>数组类型 Arrays，以 “*”星号开头。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set hello abc</span><br><span class="line">一个简单的文本流就可以是redis的客户端</span><br></pre></td></tr></table></figure>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825155844.jpg" alt="img"></p>
<p>简单总结：具体可以见：</p>
<p><a href="https://redis.io/topics/protocol" target="_blank" rel="noopener">https://redis.io/topics/protocol</a> ，</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis</code>文档认为简单的实现，快速的解析，直观理解是采用 <code>RESP</code> 文本协议最重要的地方，有可能文本协议会造成一定量的流量浪费，但却在性能上和操作上快速简单，这中间也是一个权衡和协调的过程。</p>
<h2 id="Redis-是怎么制定过期删除策略的"><a href="#Redis-是怎么制定过期删除策略的" class="headerlink" title="Redis 是怎么制定过期删除策略的"></a>Redis 是怎么制定过期删除策略的</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一个键处于过期的状态，其实在 <code>Redis</code> 中这个内存并不是实时就被从内存中进行摘除，而是<code>Redis</code>通过一定的机制去把一些处于过期键进行移除，进而达到内存的释放</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么当一个键处于过期，<code>Redis</code> 会在什么时候去删除?</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;几时被删除存在三种可能性，这三种可能性也代表了<code>Redis</code> 的三种不同的删除策略。</p>
<ul>
<li><strong>定时删除</strong>：在设置键过去的时间同时，创建一个定时器，让定时器在键过期时间来临，立即执行对键的删除操作。</li>
<li><strong>惰性删除</strong>：放任键过期不管，但是每次从键空间获取键时，都会检查该键是否过期，如果过期的话，就删除该键。</li>
<li><strong>定期删除</strong>：每隔一段时间，程序都要对数据库进行一次检查，删除里面的过期键，至于要删除多少过期键，由算法而定。</li>
</ul>
<h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置键的过期时间，创建定时器，一旦过期时间来临，就立即对键进行操作。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种<strong>对内存是友好的，但是对<code>CPU</code>的时间是最不友好的，特别是在业务繁忙，过期键很多的时候，删除过期键这个操作就会占据很大一部分<code>CPU</code> 的时间</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要知道 <code>Redis</code>是单线程操作，在内存不紧张而 <code>CPU</code>紧张的时候，将 <code>CPU</code> 的时间浪费在与业务无关的删除过期键上面，会对 <code>Redis</code>的服务器的响应时间和吞吐量造成影响。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，创建一个定时器需要用到 <code>Redis</code>服务器中的时间事件，而当前时间事件的实现方式是无序链表，时间复杂度为 <code>O(n)</code>，让服务器大量创建定时器去实现定时删除策略，会产生较大的性能影响</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，定时删除并不是一种好的删除策略。</p>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定时删除相反，惰性删除策略对 <code>CPU</code> 来说是最友好的，<strong>程序只有在取出键的时候才会进行检查，是一种被动的过程</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与此同时，<strong>惰性删除对内存来说又是最不友好的</strong>，一个键过期，只要不再被取出，这个过期键就不会被删除，它占用的内存也不会被释放。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很明显，惰性删除也不是一个很好的策略，<code>Redis</code>是非常依赖内存和较好内存的，如果一些长期键长期没有被访问，就会造成大量的内存垃圾，甚至会操成内存的泄漏。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在对执行数据写入时，通过<code>expireIfNeeded</code> 函数对写入的 <code>Key</code>进行过期判断。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中<code>expireIfNeeded</code> 在内部做了三件事情，分别是：</p>
<ul>
<li>查看<code>Key</code> 是否过期。</li>
<li>向 <code>Slave</code>节点传播执行过去<code>Key</code> 的动作。</li>
<li>删除过期 <code>Key</code>。</li>
</ul>
<h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面两种删除策略，无论是定时删除和惰性删除，这两种删除方式在单一的使用上都存在明显的缺陷，要么占用太多 CPU 时间，要么浪费太多内存。</p>
<p>定期删除策略是前两种策略的一个整合和折中：</p>
<ul>
<li>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时间和频率来减少删除操作对 <code>CPU</code> 时间的影响。</li>
<li>通过合理的删除执行的时长和频率，来达到合理的删除过期键。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>Redis</code>选择的是<strong>定期删除+惰性删除</strong>相结合的方式。</p>
<h2 id="Redis-在内存使用上是如何开源节流"><a href="#Redis-在内存使用上是如何开源节流" class="headerlink" title="Redis 在内存使用上是如何开源节流"></a>Redis 在内存使用上是如何开源节流</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis</code> 跟其他传统数据库不同，<code>Redis</code>是一个纯内存的数据库，并且存储了都是一些数据结构的数据</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不对内存加以控制的话，<code>Redis</code>很可能会因为数据量过大导致系统的奔溃。</p>
<h3 id="Ziplist"><a href="#Ziplist" class="headerlink" title="Ziplist"></a>Ziplist</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdaaD23JRv9Ekia9yACEasZN2ic4WBOYib1gJ0aIVTzOtmYO4ialqY0gibgxqM36SpicbBp8wKqXKwe9bibjA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>当最开始尝试开启一个小数据量的 <code>Hash</code> 结构和一个<code>Zset</code> 结构时，发现他们在<code>Redis</code>里面的真正结构类型是一个 <code>Ziplist</code></strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Ziplist</code> 是一个紧凑的数据结构，每一个元素之间都是连续的内存，如果在 <code>Redis</code>中，<code>Redis</code>启用的数据结构数据量很小时，<code>Redis</code>就会切换到使用紧凑存储的形式来进行压缩存储。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdaaD23JRv9Ekia9yACEasZN2crrTA4ryGLQeZ7LjS9ibCFohrBFQakKIOMTYrbGXagQagaUOicLFCpJg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，上面的例子，我们采用了<code>Hash</code>结构进行存储，<code>Hash</code>结构是一个二维的结构，是一个典型的用空间换取时间的结构。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是如果使用的数据量很小，使用二维结构反而浪费了空间，在时间的性能上也并没有得到太大的提升，还不如直接使用一维结构进行存储。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在查找的时候，虽然复杂度是 <code>O(n)</code>，但是因为数据量少遍历也非常快，增至比<code>Hash</code> 结构本身的查询更快。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果当集合对象的元素不断的增加，或者某个 <code>Value</code> 的值过大，这种小对象存储也会升级生成标准的结构。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis</code> 也可以在配置中进行定义紧凑结构和标准结构的转换参数：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdaaD23JRv9Ekia9yACEasZN28tEgX78RooNTI4cw8SpoHWLYjFNFN1ROluUia69quEUtI4l4Y5pniatg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h3 id="Quicklist"><a href="#Quicklist" class="headerlink" title="Quicklist"></a>Quicklist</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdaaD23JRv9Ekia9yACEasZN2VKmER3ReJboExfFzO0V1RbZEB7gttwHoAZx61VjUrLu9icLqIN6jvCg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Quicklist</code>数据结构是 <code>Redis</code> 在<code>3.2</code>才引入的一个双向链表的数据结构，确实来说是一个 <code>Ziplist</code>的双向链表。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Quicklist</code> 的每一个数据节点是一个 <code>Ziplist</code>，<code>Ziplist</code>本身就是一个紧凑列表。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假使，<code>Quicklist</code> 包含了 5 个 Ziplist 的节点，每个 <code>Ziplist</code>列表又包含了 5 个数据，那么在外部看来，这个 <code>Quicklist</code> 就包含了 25 个数据项。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdaaD23JRv9Ekia9yACEasZN2luG8JfOic61h6dytADBSiaRichm29fje6lTXiar0C7Q0zL06SaHQyKAXDQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p><code>Quicklist</code> 的结构设计简单总结起来，是一个空间和时间的折中方案：</p>
<ul>
<li>双向链表可以在两端进行 <code>Push</code>和<code>Pop</code> 操作，但是它在每一个节点除了保存自身的数据外，还要保存两个指针，增加额外的内存开销。</li>
</ul>
<p>其次是由于每个节点都是独立的，在内存地址上并不连续，节点多了容易产生内存碎片。</p>
<ul>
<li><code>Ziplist</code> 本身是一块连续的内存，存储和查询效率很高，但是，它不利于修改操作，每次数据变动时都会引发内存 <code>Realloc</code>，如果<code>Ziplist</code>长度很长时，一次 <code>Realloc</code>会导致大批量数据拷贝。</li>
</ul>
<p>所以，结合 <code>Ziplist</code> 和双向链表的优点，<code>Quciklist</code>就孕育而生。</p>
<h3 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis</code>在自己的对象系统中构建了一个引用计数方法，通过这个方法程序可以跟踪对象的引用计数信息，除了可以在适当的时候进行对象释放，还可以用来作为对象共享。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举个例子，假使键 A 创建了一个整数值 100 的字符串作为值对象，这个时候键 B 也创建保存同样整数值 100 的字符串对象作为值对象。</p>
<p>那么在 <code>Redis</code> 的操作时：</p>
<ul>
<li>讲数据库键的指针指向一个现有的值对象。</li>
<li>讲被共享的值对象引用计数加一。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假使，我们的数据库中指向整数值 100 的键不止键 A 和键 B，而是有几百个，那么<code>Redis</code> 服务器中只需要一个字符串对象的内存就可以保存原本需要几百个字符串对象的内存才能保存的数据。</p>
<h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><p><a href="https://mp.weixin.qq.com/s/-6yesAyNmbYtXpnmp14UKA" target="_blank" rel="noopener">吃透了这些Redis知识点，面试官一定觉得你很NB</a></p>
<p><a href="https://mp.weixin.qq.com/s/pnK7-OtEZxncp8mnIz1IaQ" target="_blank" rel="noopener">当面试遇到 Redis，我作为一个面试官是这么“刁难”你的！</a></p>
<p><a href="https://mp.weixin.qq.com/s/LBCgGDFQr4_5KmLx0ytB2A" target="_blank" rel="noopener">你好 Redis，能回答我 7 个问题吗？</a></p>
<p><a href="https://mp.weixin.qq.com/s/mvAkPXBayAzT_RWFdsOt5A" target="_blank" rel="noopener">深圳 GIAC 技术大会 Redis 演讲文字稿</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/08/22/朋友圈微博feed流，推拉实践/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/22/朋友圈微博feed流，推拉实践/" itemprop="url">朋友圈微博feed流，推拉实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-22T12:12:57+08:00">
                2019-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/feed/" itemprop="url" rel="index">
                    <span itemprop="name">feed</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/feed/业务设计/" itemprop="url" rel="index">
                    <span itemprop="name">业务设计</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/feed/业务设计/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="朋友圈微博feed流，推拉实践"><a href="#朋友圈微博feed流，推拉实践" class="headerlink" title="朋友圈微博feed流，推拉实践"></a>朋友圈微博feed流，推拉实践</h1><blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961230&amp;idx=1&amp;sn=b2ab831a72f54950498d43ac01e26453&amp;chksm=bd2d02528a5a8b444050c242729f764d6435185feb015f81631d75b018b9760b1a90a467e817&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961230&amp;idx=1&amp;sn=b2ab831a72f54950498d43ac01e26453&amp;chksm=bd2d02528a5a8b444050c242729f764d6435185feb015f81631d75b018b9760b1a90a467e817&amp;scene=21#wechat_redirect</a></p>
</blockquote>
<h2 id="哪些产品是feed流典型业务？"><a href="#哪些产品是feed流典型业务？" class="headerlink" title="哪些产品是feed流典型业务？"></a><strong>哪些产品是feed流典型业务？</strong></h2><p><strong>答</strong>：微博，微信朋友圈，Pinterest是典型的feed流业务，系统中的每一条消息就是一个feed。</p>
<p>这类业务的特点是：</p>
<ul>
<li><p>有好友关系，例如关注，粉丝</p>
</li>
<li><p>我们的主页由别人发布的feed组成</p>
</li>
</ul>
<p>这类业务的典型动作是：</p>
<ul>
<li>关注，取关</li>
<li>发布feed</li>
<li>拉取自己的主页feed流</li>
</ul>
<p>这类业务的核心元数据是：</p>
<ul>
<li>关系数据</li>
<li>feed数据</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>feed流业务最大的特点是“我们的主页由别人发布的feed组成”，获得朋友圈消息feed流集合</strong>，从技术上说，主要有“拉取”与“推送”两种方式。feed流的推与拉主要指的是这里。</p>
<h2 id="一、拉模式-“读扩散”方案简介"><a href="#一、拉模式-“读扩散”方案简介" class="headerlink" title="一、拉模式 “读扩散”方案简介"></a><strong>一、拉模式 “读扩散”方案简介</strong></h2><p>例如：某feed系统里有ABCD四个用户，其中：</p>
<ul>
<li>A关注了BC，D关注了B</li>
</ul>
<p><img src="//blog.com/2019/08/22/朋友圈微博feed流，推拉实践/Dev\PHP\phpStudy\WWW\Blog_ReConstruct\架构\朋友圈微博feed流，推拉实践\1.webp" alt="img"></p>
<p>其关系存储又包含关注关系与粉丝关系，“A关注了BC，D关注了B”的潜台词是“B有两个粉丝AD，C有一个粉丝A”。</p>
<ul>
<li>B发布过四条feed：msg1, msg3, msg5, msg10</li>
<li>C发布过两条feed：msg2, msg8</li>
</ul>
<p><img src="//blog.com/2019/08/22/朋友圈微博feed流，推拉实践/Dev\PHP\phpStudy\WWW\Blog_ReConstruct\架构\朋友圈微博feed流，推拉实践\2.webp" alt="img"></p>
<p>每一个用户，都有一个feed队列，记录自己曾经发布的所有feed数据。</p>
<p><strong>在拉模式中</strong>，发布一条feed的流程非常简单，例如C新发布了一条msg12：</p>
<p><img src="//blog.com/2019/08/22/朋友圈微博feed流，推拉实践/Dev\PHP\phpStudy\WWW\Blog_ReConstruct\架构\朋友圈微博feed流，推拉实践\3.webp" alt="img"></p>
<p>此时只需往C的feed队列里加入一条feed即可。</p>
<p><strong>在拉模式中</strong>，取消关注的流程也非常简单，例如A取消关注C：</p>
<p><img src="//blog.com/2019/08/22/朋友圈微博feed流，推拉实践/Dev\PHP\phpStudy\WWW\Blog_ReConstruct\架构\朋友圈微博feed流，推拉实践\4.webp" alt="img"></p>
<p>此时只需要在A的关注列表里删除C，并在C的粉丝列表里删除A即可。</p>
<p><strong>在拉模式中</strong>，用户A获取“由别人发布的feed组成的主页”的过程比较复杂，此时需要：</p>
<ul>
<li>获取A的关注列表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list&lt;gz_uid&gt; = select uid from GZ where uid=A</span><br></pre></td></tr></table></figure>
<ul>
<li>获取所关注的用户发布的feed</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">list&lt;msg&gt; = NULL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(uid in list&lt;gz_uid&gt;) &#123;</span><br><span class="line"></span><br><span class="line">        list&lt;some_msg&gt; = </span><br><span class="line"></span><br><span class="line">        select * from F where uid=$uid offset | limit</span><br><span class="line"></span><br><span class="line">         list&lt;msg&gt; += list&lt;some_msg&gt;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对消息进行rank排序（假设按照发布时间排序），分页取出对应的一页feeds</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sort_msg_by_time(list&lt;msg&gt;);</span><br><span class="line"></span><br><span class="line">get_one_page(list&lt;msg&gt;, page_num);</span><br></pre></td></tr></table></figure>
<p><strong>feed流的拉模式（“读扩散”）有什么优缺点？</strong></p>
<p><strong>优点</strong>：</p>
<ul>
<li>存储结构简单，数据存储量较小，<strong>关系数据与feed数据都只存一份</strong></li>
<li>取消关注，发布feed的业务流程非常简单</li>
<li>存储结构，业务流程都比较容易理解，<strong>非常适合项目早期用户量、数据量、并发量不大时的快速实现</strong></li>
</ul>
<p><strong>缺点</strong>也显而易见：</p>
<ul>
<li><strong>拉取朋友圈feed流列表的业务流程非常复杂</strong></li>
<li><strong>有多次数据访问，并且要进行大量的内存计算，大量数据的网络传输，性能较低</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在拉模式中，<strong>系统的瓶颈容易出现在“用户所发布feed列表”的读取上</strong>，而每个用户发布feed的频率其实是很低的，此时，<strong>架构优化的核心是通过缓存降低数据存储磁盘IO</strong>。</p>
<h2 id="二、推模式-“写扩散”方案简介"><a href="#二、推模式-“写扩散”方案简介" class="headerlink" title="二、推模式 “写扩散”方案简介"></a>二、推模式 “写扩散”方案简介</h2><p>推模式（写扩散），<strong>关系数据的存储</strong>与拉模式（读扩散）完全一样。</p>
<p><img src="//blog.com/2019/08/22/朋友圈微博feed流，推拉实践/Dev\PHP\phpStudy\WWW\Blog_ReConstruct\架构\朋友圈微博feed流，推拉实践\5.webp" alt="img"></p>
<p>feed数据，每个用户也存储自己<strong>发布的feed</strong>。</p>
<p><img src="//blog.com/2019/08/22/朋友圈微博feed流，推拉实践/Dev\PHP\phpStudy\WWW\Blog_ReConstruct\架构\朋友圈微博feed流，推拉实践\6.webp" alt="img"></p>
<p>如上图：</p>
<ul>
<li>B曾经发布过1，3，5，10</li>
<li>C曾经发布过2，8</li>
</ul>
<p><em>画外音：不妨设，这里的msgid按照feed的发布时间偏序。</em></p>
<p>feed数据存储，与拉（读扩散）不同的是，每个用户还需要存储自己<strong>收到的feed流</strong>。</p>
<p><img src="//blog.com/2019/08/22/朋友圈微博feed流，推拉实践/Dev\PHP\phpStudy\WWW\Blog_ReConstruct\架构\朋友圈微博feed流，推拉实践\7.webp" alt="img"></p>
<p>如上图：</p>
<ul>
<li>A关注了BC，所以A的接收队列是1，2，3，5，8，10</li>
<li>D关注了B，所以D的接受队列是1，3，5，10</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在推模式（写扩散）中，获取“由别人发布的feed组成的主页”会变得异常简单，假设一页消息为3条feed，A如果要看自己朋友圈的第二页消息，直接返回1，2，3即可。</p>
<p><em>画外音：第一页朋友圈是<strong>最新</strong>的消息，即5，8，10。</em></p>
<p>在推模式（写扩散）中，发布一条feed的流程会更复杂一点。</p>
<p><img src="//blog.com/2019/08/22/朋友圈微博feed流，推拉实践/Dev\PHP\phpStudy\WWW\Blog_ReConstruct\架构\朋友圈微博feed流，推拉实践\8.webp" alt="img"></p>
<p>例如B新发布了一条msg12：</p>
<ul>
<li>在B的发布feed存储里加入消息12</li>
<li>查询B全部粉丝AD</li>
<li>在粉丝AD的接收feed存储里也加入消息12</li>
</ul>
<p>之所以该方案称为推模式（写扩散），就是因为，用户发布feed的时候：</p>
<ul>
<li><strong>直接将feed推到了粉丝的接收列表里，故称为“推模式”</strong></li>
<li><strong>不止写发布feed存储，而且要写多个粉丝的接收feed存储，故称为“写扩散”</strong></li>
</ul>
<p>在推模式（写扩散）中，添加关注的流程也会变得复杂。</p>
<p><img src="//blog.com/2019/08/22/朋友圈微博feed流，推拉实践/Dev\PHP\phpStudy\WWW\Blog_ReConstruct\架构\朋友圈微博feed流，推拉实践\9.webp" alt="img"></p>
<p>例如D新增关注C：</p>
<ul>
<li>在D的关注存储里添加C</li>
<li>在C的粉丝存储里添加D</li>
<li>在D的接收feed存储里加入C发布的feed</li>
</ul>
<p><em>画外音：有些产品有这样的逻辑，<strong>“关注之后才能看到feed”，这样的话就不需要第三步，旧feed无需插入</strong>。</em></p>
<p>在推模式（写扩散）中，取消关注的流程也会变得复杂。</p>
<p><img src="//blog.com/2019/08/22/朋友圈微博feed流，推拉实践/Dev\PHP\phpStudy\WWW\Blog_ReConstruct\架构\朋友圈微博feed流，推拉实践\10.webp" alt="img"></p>
<p>例如A取消关注C：</p>
<ul>
<li>在A的关注存储里删除C</li>
<li>在C的粉丝存储里删除A</li>
<li>在A的接收feed存储里删除C发布的feed </li>
</ul>
<p>feed流的推模式（写扩散）的优点是：</p>
<ul>
<li><strong>消除了拉模式（读扩散）的IO集中点，每个用户都读自己的数据，高并发下锁竞争少</strong></li>
</ul>
<p><em>画外音：拉模式（读扩散）中，用户发布feed存储容易称为IO瓶颈。</em></p>
<ul>
<li>拉取朋友圈feed流列表的业务流程异常简单，速度很快</li>
<li><strong>拉取朋友圈feed流列表，不需要进行大量的内存计算，网络传输，性能很高</strong></li>
</ul>
<p><em>画外音：<strong>feed业务是典型的读多写少业务场景，读写比甚至高于100：1，即平均发布1条消息，有至少100次阅读</strong>。</em></p>
<p>其缺点是：</p>
<ul>
<li>极大极大消耗<strong>存储资源</strong>，feed数据会存储很多份，例如杨幂5KW粉丝，她每次一发博文，消息会冗余5KW份</li>
</ul>
<p><em>画外音：有朋友提出，<strong>可以存储一份消息实体，只冗余msgid，这样的话，拉取feed流列表时，还要再次拉取实体，网络时延会更长，所以很多公司选择直接冗余消息实体</strong>，当然，这是一个用户体验与存储量的折衷设计。</em></p>
<ul>
<li>新增关注，取消关注，发布feed的业务流会更复杂</li>
<li>如果发布者是大V的话，写入粉丝发布的feed这一步会非常耗时，因为粉丝的数量太大</li>
</ul>
<h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p>feed流业务的推拉模式小结：</p>
<ul>
<li>拉模式，<strong>读扩散，feed存一份，存储小，用户集中访问数据，性能差</strong></li>
<li>推模式，<strong>写扩散，feed存多份，用冗余存储换锁冲突，性能高</strong></li>
</ul>
<h2 id="四、如何选择"><a href="#四、如何选择" class="headerlink" title="四、如何选择"></a>四、如何选择</h2><p><strong>大V采取拉模式，普通用户采取推模式</strong>    =》  <strong>推拉结合</strong></p>
<h3 id="发布Feed流程"><a href="#发布Feed流程" class="headerlink" title="发布Feed流程"></a>发布Feed流程</h3><p>当你发布一条<code>Feed</code>消息的时候，流程是这样的：</p>
<ol>
<li><code>Feed</code>消息先进入一个队列服务。</li>
<li>先从关注列表中读取到自己的粉丝列表，以及判断自己是否是大V。</li>
<li>将自己的<code>Feed</code>消息写入个人页<code>Timeline</code>（发件箱）。如果是大V，写入流程到此就结束了。</li>
<li>如果是普通用户，还需要将自己的<code>Feed</code>消息写给自己的粉丝，如果有100个粉丝，那么就要写给100个用户，包括<code>Feed</code>内容和<code>Feed ID</code>。</li>
<li>第三步和第四步可以合并在一起，使用<code>BatchWriteRow</code>接口一次性将多行数据写入<code>TableStore</code>。</li>
<li>发布<code>Feed</code>的流程到此结束。</li>
</ol>
<h3 id="读取Feed流流程"><a href="#读取Feed流流程" class="headerlink" title="读取Feed流流程"></a>读取Feed流流程</h3><p>当刷新自己的<code>Feed</code>流的时候，流程是这样的：</p>
<ol>
<li>先去读取自己关注的大V列表</li>
<li>去读取自己的收件箱，只需要一个<code>GetRange</code>读取一个范围即可，范围起始位置是上次读取到的最新<code>Feed</code>的<code>ID</code>，结束位置可以使当前时间，也可以是<code>MAX</code>，建议是<code>MAX</code>值。由于之前使用了主键自增功能，所以这里可以使用<code>GetRange</code>读取。</li>
<li>如果有关注的大V，则再次并发读取每一个大V的发件箱，如果关注了10个大V，那么则需要10次访问。</li>
<li>合并2和3步的结果，然后按时间排序，返回给用户。</li>
</ol>
<p>至此，使用推拉结合方式的发布，读取<code>Feed</code>流的流程都结束了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/08/22/进程内缓存/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/22/进程内缓存/" itemprop="url">进程内缓存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-22T12:12:57+08:00">
                2019-08-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/数据一致性问题/" itemprop="url" rel="index">
                    <span itemprop="name">数据一致性问题</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/数据一致性问题/数据库与缓存/" itemprop="url" rel="index">
                    <span itemprop="name">数据库与缓存</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/数据一致性问题/数据库与缓存/缓存/" itemprop="url" rel="index">
                    <span itemprop="name">缓存</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="进程内缓存"><a href="#进程内缓存" class="headerlink" title="进程内缓存"></a>进程内缓存</h1><blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961296&amp;idx=1&amp;sn=883a46db0e4b4fe8bd2de5a370e3304e&amp;chksm=bd2d020c8a5a8b1a2938b07da1a42648d562c559d573b5700e48ea5318dac3ee246b2e6ce908&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651961296&amp;idx=1&amp;sn=883a46db0e4b4fe8bd2de5a370e3304e&amp;chksm=bd2d020c8a5a8b1a2938b07da1a42648d562c559d573b5700e48ea5318dac3ee246b2e6ce908&amp;scene=21#wechat_redirect</a></p>
</blockquote>
<h2 id="什么是进程内缓存？"><a href="#什么是进程内缓存？" class="headerlink" title="什么是进程内缓存？"></a>什么是进程内缓存？</h2><p><strong>答</strong>：将一些数据缓存在站点，或者服务的进程内，这就是进程内缓存。</p>
<p>进程内缓存的实现载体，最简单的，可以是一个<strong>带锁的Map</strong>。又或者，可以使用<strong>第三方库</strong></p>
<h2 id="进程内缓存能存储啥？"><a href="#进程内缓存能存储啥？" class="headerlink" title="进程内缓存能存储啥？"></a>进程内缓存能存储啥？</h2><p><strong>答</strong>：<code>redis/memcache</code>等进程外缓存服务能存什么，进程内缓存就能存什么。</p>
<p><img src="//blog.com/2019/08/22/进程内缓存/1.webp" alt="img"></p>
<p>如上图，可以存储<code>json</code>数据，可以存储<code>html</code>页面，可以存储对象。</p>
<h2 id="进程内缓存有什么好处？"><a href="#进程内缓存有什么好处？" class="headerlink" title="进程内缓存有什么好处？"></a>进程内缓存有什么好处？</h2><p><strong>答</strong>：<strong>与没有缓存相比</strong>，进程内缓存的好处是，数据读取不再需要访问后端，例如数据库。</p>
<p><img src="//blog.com/2019/08/22/进程内缓存/2.webp" alt="img"></p>
<p>如上图，整个访问流程要经过1,2,3,4四个步骤。</p>
<p>如果引入进程内缓存，</p>
<p><img src="//blog.com/2019/08/22/进程内缓存/3.webp" alt="img"></p>
<p>如上图，整个访问流程只要经过1,2两个步骤。</p>
<p><strong>与进程外缓存相比</strong>（例如<code>redis/memcache</code>），进程内缓存省去了网络开销，所以一来<strong>节省了内网带宽</strong>，二来响应<strong>时延会更低</strong>。</p>
<h2 id="进程内缓存有什么缺点？"><a href="#进程内缓存有什么缺点？" class="headerlink" title="进程内缓存有什么缺点？"></a>进程内缓存有什么缺点？</h2><p><strong>答</strong>：统一缓存服务虽然<strong>多一次网络交互，但仍是统一存储</strong>。</p>
<p><img src="//blog.com/2019/08/22/进程内缓存/4.webp" alt="img"></p>
<p>如上图，站点和服务中的多个节点访问统一的缓存服务，数据统一存储，容易保证数据的一致性。</p>
<p><img src="//blog.com/2019/08/22/进程内缓存/5.webp" alt="img"></p>
<p>而进程内缓存，如上图，如果<strong>数据缓存在站点和服务的多个节点内，数据存了多份，一致性比较难保障</strong>。</p>
<h2 id="如何保证进程内缓存的数据一致性？"><a href="#如何保证进程内缓存的数据一致性？" class="headerlink" title="如何保证进程内缓存的数据一致性？"></a>如何保证进程内缓存的数据一致性？</h2><p><strong>答</strong>：保障进程内缓存一致性，有几种方案。</p>
<p><img src="//blog.com/2019/08/22/进程内缓存/6.webp" alt="img"></p>
<p><strong>第一种方案</strong>，可以<strong>通过单节点通知其他节点</strong>。如上图：写请求发生在<code>server1</code>，在修改完自己内存数据与数据库中的数据之后，可以主动通知其他<code>server</code>节点，也修改内存的数据。</p>
<p>这种方案的<strong>缺点</strong>是：同一功能的一个集群的多个节点，相互耦合在一起，特别是节点较多时，网状连接关系极其复杂。</p>
<p><img src="//blog.com/2019/08/22/进程内缓存/7.webp" alt="img"></p>
<p><strong>第二种方案</strong>，可以<strong>通过<code>MQ</code>通知其他节点</strong>。如上图，写请求发生在<code>server1</code>，在修改完自己内存数据与数据库中的数据之后，给<code>MQ</code>发布数据变化通知，其他<code>server</code>节点订阅<code>MQ</code>消息，也修改内存数据。</p>
<p>这种方案虽然解除了节点之间的耦合，但引入了<code>MQ</code>，使得系统更加复杂。</p>
<p>前两种方案，节点数量越多，数据冗余份数越多，数据同时更新的原子性越难保证，一致性也就越难保证。</p>
<p><img src="//blog.com/2019/08/22/进程内缓存/8.webp" alt="img"></p>
<p><strong>第三种方案</strong>，为了避免耦合，降低复杂性，干脆放弃了“实时一致性”，<strong>每个节点启动一个timer，定时从后端拉取最新的数据，更新内存缓存</strong>。在有节点更新后端数据，而其他节点通过<code>timer</code>更新数据之间，会读到脏数据。</p>
<h2 id="为什么不能频繁使用进程内缓存？"><a href="#为什么不能频繁使用进程内缓存？" class="headerlink" title="为什么不能频繁使用进程内缓存？"></a>为什么不能频繁使用进程内缓存？</h2><p><strong>答</strong>：<strong>分层架构设计，有一条准则：站点层、服务层要做到无数据无状态，这样才能任意的加节点水平扩展，数据和状态尽量存储到后端的数据存储服务</strong>，例如数据库服务或者缓存服务。</p>
<p>可以看到，站点与服务的<strong>进程内缓存，实际上违背了分层架构设计的无状态准则，故一般不推荐使用</strong>。</p>
<h2 id="什么时候可以使用进程内缓存？"><a href="#什么时候可以使用进程内缓存？" class="headerlink" title="什么时候可以使用进程内缓存？"></a>什么时候可以使用进程内缓存？</h2><p><strong>答</strong>：以下情况，可以考虑使用进程内缓存。</p>
<p><strong>情况一</strong>，<strong>只读数据，可以考虑在进程启动时加载到内存</strong>。</p>
<p><em>画外音：此时也可以把数据加载到<code>redis / memcache</code>，进程外缓存服务也能解决这类问题。</em></p>
<p><strong>情况二</strong>，极其高并发的，如果透传后端压力极大的场景，可以考虑使用进程内缓存。</p>
<p>例如，秒杀业务，并发量极高，需要站点层挡住流量，可以使用内存缓存。</p>
<p><strong>情况三</strong>，<strong>一定程度上允许数据不一致业务</strong>。</p>
<p>例如，有一些计数场景，运营场景，页面对数据一致性要求较低，可以考虑使用进程内页面缓存。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/17/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/19/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
