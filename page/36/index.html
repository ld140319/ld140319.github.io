<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/page/36/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/page/36/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/23/select和epoll的对比/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/23/select和epoll的对比/" itemprop="url">select和epoll的对比</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-23T12:12:57+08:00">
                2019-06-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/" itemprop="url" rel="index">
                    <span itemprop="name">异步与同步</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/" itemprop="url" rel="index">
                    <span itemprop="name">IO</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/" itemprop="url" rel="index">
                    <span itemprop="name">Reactor</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/事件模型/" itemprop="url" rel="index">
                    <span itemprop="name">事件模型</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/事件模型/网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="select和epoll的对比"><a href="#select和epoll的对比" class="headerlink" title="select和epoll的对比"></a>select和epoll的对比</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://www.zhihu.com/question/20122137/answer/146866418" target="_blank" rel="noopener">https://www.zhihu.com/question/20122137/answer/146866418</a></p>
</blockquote>
<p><br></p>
<h2 id="第一部分：select和epoll的任务"><a href="#第一部分：select和epoll的任务" class="headerlink" title="第一部分：select和epoll的任务"></a>第一部分：select和epoll的任务</h2><h3 id="关键词：应用程序-文件句柄-用户态-内核态-监控者"><a href="#关键词：应用程序-文件句柄-用户态-内核态-监控者" class="headerlink" title="关键词：应用程序 文件句柄 用户态 内核态  监控者"></a>关键词：应用程序 文件句柄 用户态 内核态  监控者</h3><p>要比较<code>epoll</code>相比较<code>select</code>高效在什么地方，就需要比较二者做相同事情的方法。</p>
<p>要完成对<code>I/O</code>流的复用需要完成如下几个事情：</p>
<p>1.用户态怎么将文件句柄传递到内核态？</p>
<p>2.内核态怎么判断<code>I/O</code>流可读可写？</p>
<p>3.内核怎么通知监控者有<code>I/O</code>流可读可写？</p>
<p>4.监控者如何找到可读可写的<code>I/O</code>流并传递给用户态应用程序？</p>
<p>5.继续循环时监控者怎样重复上述步骤？</p>
<p>搞清楚上述的步骤也就能解开<code>epoll</code>高效的原因了。</p>
<h3 id="select的做法"><a href="#select的做法" class="headerlink" title="select的做法"></a>select的做法</h3><p>步骤1的解法：<code>select</code>创建3个文件描述符集，并将这些文件描述符拷贝到内核中，这里限制了文件描述符的最大的数量为1024，原因是出于对性能的考虑—轮询遍历（注意是全部传入—第一次拷贝）；</p>
<p>步骤2的解法：内核针对读缓冲区和写缓冲区来判断是否可读可写,这个动作和<code>select</code>无关；</p>
<p>步骤3的解法：内核在检测到文件句柄可读/可写时就产生中断通知监控者<code>select</code>，<code>select</code>被内核触发之后，就返回可读可写的文件句柄的总数；</p>
<p>步骤4的解法：<code>select</code>会将之前传递给内核的文件句柄再次从内核传到用户态（第2次拷贝），<code>select</code>返回给用户态的只是可读可写的文件句柄总数，再使用<code>FD_ISSET</code>宏函数来检测哪些文件<code>I/O</code>可读可写（遍历）；</p>
<p>步骤5的解法：<code>select</code>对于事件的监控是建立在内核的修改之上的，也就是说经过一次监控之后，内核会修改位，因此再次监控时需要再次从用户态向内核态进行拷贝（第N次拷贝）</p>
<h3 id="epoll的做法"><a href="#epoll的做法" class="headerlink" title="epoll的做法"></a>epoll的做法</h3><p>步骤1的解法：首先执行<code>epoll_create</code>在内核专属于<code>epoll</code>的高速<code>cache</code>区，并在该缓冲区建立红黑树和就绪链表，用户态传入的文件句柄将被放到红黑树中（第一次拷贝）。</p>
<p>步骤2的解法：内核针对读缓冲区和写缓冲区来判断是否可读可写，这个动作与<code>epoll</code>无关；</p>
<p>步骤3的解法：<code>epoll_ctl</code>执行<code>add</code>动作时除了将文件句柄放到红黑树上之外，还向内核注册了该文件句柄的回调函数，内核在检测到某句柄可读可写时则调用该回调函数，回调函数将文件句柄放到就绪链表。</p>
<p>步骤4的解法：<code>epoll_wait</code>只监控就绪链表就可以如果就绪链表有文件句柄，则表示该文件句柄可读可写，并返回到用户态（少量的拷贝）；</p>
<p>步骤5的解法：由于内核不修改文件句柄的位，因此只需要在第一次传入就可以重复监控，直到使用<code>epoll_ctl</code>删除，否则不需要重新传入，因此无多次拷贝。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单说：<code>epoll</code>是继承了<code>select/poll</code>的<code>I/O</code>复用的思想，并在二者的基础上从监控<code>IO</code>流、查找<code>I/O</code>事件等角度来提高效率，具体地说就是内核句柄列表、红黑树、就绪<code>list</code>链表来实现的。</p>
<h2 id="第二部分：epoll详解"><a href="#第二部分：epoll详解" class="headerlink" title="第二部分：epoll详解"></a>第二部分：epoll详解</h2><h3 id="epoll函数调用"><a href="#epoll函数调用" class="headerlink" title="epoll函数调用"></a>epoll函数调用</h3><p>先简单回顾下如何使用C库封装的3个<code>epoll</code>系统调用吧。</p>
<ol>
<li><strong>int</strong> <code>epoll_create</code>(<strong>int</strong> size);  </li>
<li><strong>int</strong> <code>epoll_ctl</code>(<strong>int</strong> epfd, <strong>int</strong> op, <strong>int</strong> fd, <strong>struct</strong> epoll_event *event);  </li>
<li><strong>int</strong> <code>epoll_wait</code>(<strong>int</strong> epfd, <strong>struct</strong> epoll_event *events,<strong>int</strong> maxevents, <strong>int</strong> timeout);  </li>
</ol>
<p>使用起来很清晰：</p>
<p>A.<code>epoll_create</code>建立一个<code>epoll</code>对象。参数<code>size</code>是内核保证能够正确处理的最大句柄数，多于这个最大数时内核可不保证效果。</p>
<p>B.<code>epoll_ctl</code>可以操作上面建立的<code>epoll</code>，例如，将刚建立的<code>socket</code>加入到<code>epoll</code>中让其监控，或者把 <code>epoll</code>正在监控的某个<code>socket</code>句柄移出<code>epoll</code>，不再监控它等等(<strong>也就是将I/O流放到内核</strong>)。</p>
<p>C.<code>epoll_wait</code>在调用时，在给定的<code>timeout</code>时间内，当在监控的所有句柄中有事件发生时，就返回用户态的进程（<strong>也就是在内核层面捕获可读写的I/O事件</strong>）。</p>
<p>从上面的调用方式就可以看到<code>epoll</code>比<code>select/poll</code>的优越之处：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为后者<strong>每次调用时都要传递你所要监控的所有socket给select/poll系统调用，这意味着需要将用户态的socket列表copy到内核态</strong>，如果以万计的句柄会导致每次都要copy几十几百KB的内存到内核态，非常低效。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而我们调用<code>epoll_wait</code>时就相当于以往调用<code>select/poll</code>，但是这时却不用传递<code>socket</code>句柄给内核，因为内核已经在<code>epoll_ctl</code>中拿到了要监控的句柄列表。</p>
<p>====&gt;<em>select监控的句柄列表在用户态，每次调用都需要从用户态将句柄列表拷贝到内核态，但是epoll中句柄就是建立在内核中的，这样就减少了内核和用户态的拷贝，高效的原因之一。</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，实际上在你调用<code>epoll_create</code>后，内核就已经在内核态开始准备帮你存储要监控的句柄了，每次调用<code>epoll_ctl</code>只是在往内核的<strong>数据结构</strong>里塞入新的<code>socket</code>句柄。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在内核里，一切皆文件。所以，<code>epoll</code>向内核注册了一个文件系统，用于存储上述的被监控<code>socket</code>。当你调用<code>epoll_create</code>时，就会在这个虚拟的<code>epoll</code>文件系统里创建一个file结点。当然这个<code>file</code>不是普通文件，它只服务于<code>epoll</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>epoll</code>在被内核初始化时（<strong>操作系统</strong>启动），同时会开辟出<code>epoll</code>自己的内核高速<code>cache</code>区，用于安置每一个我们想监控的<code>socket</code>，这些<code>socket</code>会以红黑树的形式保存在内核<code>cache</code>里，以支持快速的查找、插入、删除。这个内核高速<code>cache</code>区，就是建立连续的物理内存页，然后在之上建立<code>slab</code>层，简单的说，就是物理上分配好你想要的<code>size</code>的内存对象，每次使用时都是使用空闲的已分配好的对象。</p>
<h3 id="epoll高效的原因"><a href="#epoll高效的原因" class="headerlink" title="epoll高效的原因"></a>epoll高效的原因</h3><p><strong>epoll高效的原因：</strong> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是由于<strong>我们在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket外，还会再建立一个list链表，用于存储准备就绪的事件.</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当<strong>epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效</strong>。而且，通常情况下即使我们要监控百万计的句柄，大多一次也只返回很少量的准备就绪句柄而已，所以，<strong><code>epoll_wait</code>仅需要从内核态copy少量的句柄到用户态而已</strong>.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，这个准备就绪<code>list</code>链表是怎么维护的呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们执行<code>epoll_ctl</code>时，除了把<code>socket</code>放到<code>epoll</code>文件系统里<code>file</code>对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪<code>list</code>链表里。所以，<strong>当一个<code>socket</code>上有数据到了，内核在把网卡上的数据copy到内核中后就来把<code>socket</code>插入到准备就绪链表里了</strong>。</p>
<h3 id="epoll综合的执行过程"><a href="#epoll综合的执行过程" class="headerlink" title="epoll综合的执行过程"></a>epoll综合的执行过程</h3><p><strong>epoll综合的执行过程：</strong> </p>
<p>​      如此，一棵红黑树，一张准备就绪句柄链表，少量的内核<code>cache</code>，就帮我们解决了大并发下的<code>socket</code>处理问题。执行<code>epoll_create</code>时，创建了红黑树和就绪链表，执行<code>epoll_ctl</code>时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据。执行<code>epoll_wait</code>时立刻返回准备就绪链表里的数据即可。</p>
<h3 id="epoll水平触发和边缘触发的实现"><a href="#epoll水平触发和边缘触发的实现" class="headerlink" title="epoll水平触发和边缘触发的实现"></a>epoll水平触发和边缘触发的实现</h3><p><strong>epoll水平触发和边缘触发的实现：</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一个<code>socket</code>句柄上有事件时，内核会把该句柄插入上面所说的准备就绪<code>list</code>链表，这时我们调用<code>epoll_wait</code>，会把准备就绪的<code>socket</code>拷贝到用户态内存，然后清空准备就绪<code>list</code>链表， 最后，<code>epoll_wait</code>干了件事，就是检查这些<code>socket</code>，如果不是ET模式（就是LT模式的句柄了），并且这些<code>socket</code>上确实有未处理的事件时，又把该句柄放回到刚刚清空的准备就绪链表了，所以，<strong>非ET的句柄，只要它上面还有事件，<code>epoll_wait</code>每次都会返回</strong>。<strong>而ET模式的句柄，除非有新中断到，即使<code>socket</code>上的事件没有处理完，也是不会次次从<code>epoll_wait</code>返回的</strong>。</p>
<p><em>====&gt;区别就在于epoll_wait将socket返回到用户态时是否情况就绪链表。</em>  </p>
<h2 id="第三部分：epoll高效的本质"><a href="#第三部分：epoll高效的本质" class="headerlink" title="第三部分：epoll高效的本质"></a>第三部分：epoll高效的本质</h2><p><strong>1.减少用户态和内核态之间的文件句柄拷贝；</strong></p>
<p><strong>2.减少对可读可写文件句柄的遍历；</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/23/epoll的原理是什么/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/23/epoll的原理是什么/" itemprop="url">epoll的原理是什么</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-23T12:12:57+08:00">
                2019-06-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/" itemprop="url" rel="index">
                    <span itemprop="name">异步与同步</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/" itemprop="url" rel="index">
                    <span itemprop="name">IO</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/" itemprop="url" rel="index">
                    <span itemprop="name">Reactor</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/事件模型/" itemprop="url" rel="index">
                    <span itemprop="name">事件模型</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/事件模型/网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="epoll的原理是什么"><a href="#epoll的原理是什么" class="headerlink" title="epoll的原理是什么"></a>epoll的原理是什么</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://www.zhihu.com/question/20122137/answer/14049112" target="_blank" rel="noopener">https://www.zhihu.com/question/20122137/answer/14049112</a></p>
</blockquote>
<p><br></p>
<h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先我们来定义流的概念，一个流可以是文件，<code>socket</code>，<code>pipe</code>等等可以进行<code>I/O</code>操作的内核对象。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不管是文件，还是套接字，还是管道，我们都可以把他们看作流。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后我们来讨论<code>I/O</code>的操作，通过<code>read</code>，我们可以从流中读入数据；通过<code>write</code>，我们可以往流写入数据。现在假定一个情形，我们需要从流中读数据，</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是流中还没有数据，（典型的例子为，客户端要从<code>socket</code>读如数据，但是服务器还没有把数据传回来），这时候该怎么办？</p>
<ul>
<li><strong>阻塞</strong>。阻塞是个什么概念呢？比如某个时候你在等快递，但是你不知道快递什么时候过来，而且你没有别的事可以干（或者说接下来的事要等快递来了才能做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）。</li>
<li><strong>非阻塞忙轮询</strong>。接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他挂个电话：“你到了没？”</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很明显一般人不会用第二种做法，不仅显很无脑，浪费话费不说，还占用了快递员大量的时间。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大部分程序也不会用第二种做法，因为<strong>第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片了</strong>。</p>
<h2 id="内核缓冲区的四种状态"><a href="#内核缓冲区的四种状态" class="headerlink" title="内核缓冲区的四种状态"></a>内核缓冲区的四种状态</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了了解阻塞是如何进行的，我们来讨论缓冲区，以及内核缓冲区，最终把<code>I/O</code>事件解释清楚。缓冲区的引入是为了减少频繁<code>I/O</code>操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。</p>
<p>假设有一个管道，进程A为管道的写入方，Ｂ为管道的读出方：</p>
<ol>
<li>假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变到非空状态，内核就会产生一个事件告诉Ｂ该醒来了，这个事件姑且称之为<strong>“缓冲区非空”</strong>。</li>
<li>但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候会产生一个I/O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为<strong>“缓冲区满”</strong>。</li>
<li>假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从长眠中醒来了，继续写数据了，我们把这个事件叫做<strong>“缓冲区非满”</strong></li>
<li>也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。这个时候内核就告诉B，你需要阻塞了！，我们把这个时间定为<strong>“缓冲区空”</strong>。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这四个情形涵盖了四个<code>I/O</code>事件，缓冲区满，缓冲区空，缓冲区非空，缓冲区非满（注都是说的内核缓冲区，且这四个术语都是我生造的，仅为解释其原理而造）。这四个<code>I/O</code>事件是进行阻塞同步的根本。（如果不能理解“同步”是什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。</p>
<h2 id="阻塞I-O"><a href="#阻塞I-O" class="headerlink" title="阻塞I/O"></a>阻塞I/O</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后我们来说说阻塞<code>I/O</code>的缺点。但是<strong>阻塞<code>I/O</code>模式下，一个线程只能处理一个流的<code>I/O</code>事件</strong>。<strong>如果想要同时处理多个流，要么多进程<code>(fork)</code>，要么多线程<code>(pthread_create)</code>，很不幸这两种方法效率都不高</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是再来考虑<strong>非阻塞忙轮询</strong>的<code>I/O</code>方式，我们发现我们可以同时处理多个流了（把一个流从阻塞模式切换到非阻塞模式再此不予讨论）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i in stream[]; &#123;</span><br><span class="line">      <span class="keyword">if</span> i has data</span><br><span class="line">        read until unavailable</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为<strong>如果所有的流都没有数据，那么只会白白浪费CPU</strong>。这里要补充一点，<strong>阻塞模式下，内核对于I/O事件的处理是阻塞或者唤醒，而非阻塞模式下则把I/O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略</strong>。</p>
<h2 id="select-poll"><a href="#select-poll" class="headerlink" title="select/poll"></a>select/poll</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了避免<code>CPU</code>空转，可以引进了一个代理（一开始有一位叫做<code>select</code>的代理，后来又有一位叫做<code>poll</code>的代理，不过两者的本质是一样的）。这个代理比较厉害，可以同时观察许多流的<code>I/O</code>事件，<strong>在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流</strong>（于是我们可以把“忙”字去掉了）。代码长这样:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line"></span><br><span class="line">  select(streams[])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> i in streams[] &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> i has data</span><br><span class="line"></span><br><span class="line">       read until unavailable</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是，如果没有<code>I/O</code>事件产生，我们的程序就会阻塞在<code>select</code>处。但是依然有个问题，我们<strong>从<code>select</code>那里仅仅知道了，有<code>I/O</code>事件发生了，但却并不知道是那几个流</strong>（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>使用<code>select</code>，我们有O(n)的无差别轮询复杂度，同时处理的流越多，每一次无差别轮询时间就越长</strong>。</p>
<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>epoll</code>可以理解为<code>event poll</code>，不同于忙轮询和无差别轮询，<strong><code>epoll</code>之会把哪个流发生了怎样的I/O事件通知我们</strong>。此时我们对这些流的操作都是有意义的。（<strong>复杂度降低到了<code>O(k)</code>，k为产生I/O事件的流的个数</strong>）</p>
<p>在讨论<code>epoll</code>的实现细节之前，先把<code>epoll</code>的相关操作列出：</p>
<ul>
<li><code>epoll_create</code> 创建一个<code>epoll</code>对象，一般<code>epollfd = epoll_create()`</code></li>
<li><code></code>epoll_ctl （epoll_add/epoll_del的合体）<code>，往</code>epoll<code>对象中增加/删除某一个流的某一个事件
比如</code>epoll_ctl(epollfd, EPOLL_CTL_ADD, socket, EPOLLIN)<code>;//有缓冲区内有数据时</code>epoll_wait<code>返回</code>epoll_ctl(epollfd, EPOLL_CTL_DEL, socket, EPOLLOUT);<code>//缓冲区可写入时</code>epoll_wait`返回</li>
<li><code>epoll_wait(epollfd,...)</code>等待直到注册的事件发生</li>
</ul>
<p>（注：当对一个非阻塞流的读写发生缓冲区满或缓冲区空，<code>write/read</code>会返回-1，并设置<code>errno=EAGAIN</code>。<code>epoll</code>只关心缓冲区非满和缓冲区非空事件）。</p>
<p>一个<code>epoll</code>模式的代码大概的样子是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line"></span><br><span class="line">    active_stream[] = epoll_wait(epollfd)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i in active_stream[] &#123;</span><br><span class="line"></span><br><span class="line">        read <span class="keyword">or</span> write till unavailable</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/23/nginx、swoole高并发原理初探/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/23/nginx、swoole高并发原理初探/" itemprop="url">nginx、swoole高并发原理初探</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-23T12:12:57+08:00">
                2019-06-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/" itemprop="url" rel="index">
                    <span itemprop="name">异步与同步</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/" itemprop="url" rel="index">
                    <span itemprop="name">IO</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/" itemprop="url" rel="index">
                    <span itemprop="name">Reactor</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/事件模型/" itemprop="url" rel="index">
                    <span itemprop="name">事件模型</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/事件模型/网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="nginx、swoole高并发原理初探"><a href="#nginx、swoole高并发原理初探" class="headerlink" title="nginx、swoole高并发原理初探"></a>nginx、swoole高并发原理初探</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://segmentfault.com/a/1190000007614502" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007614502</a></p>
</blockquote>
<p><br></p>
<h2 id="一、阅前热身"><a href="#一、阅前热身" class="headerlink" title="一、阅前热身"></a>一、阅前热身</h2><p>为了更加形象的说明同步异步、阻塞非阻塞，我们以小明去买奶茶为例。</p>
<h3 id="1、同步与异步"><a href="#1、同步与异步" class="headerlink" title="1、同步与异步"></a>1、同步与异步</h3><h4 id="①同步与异步的理解"><a href="#①同步与异步的理解" class="headerlink" title="①同步与异步的理解"></a>①同步与异步的理解</h4><blockquote>
<p>同步与异步的重点在消息通知的方式上，也就是<strong>调用结果通知</strong>的方式。</p>
</blockquote>
<ul>
<li><p>同步</p>
<p>当一个同步调用发出去后，调用者要一直等待调用结果的通知后，才能进行后续的执行</p>
</li>
<li><p>异步：</p>
<p>当一个异步调用发出去后，调用者不能立即得到调用结果的返回。</p>
</li>
</ul>
<p>异步调用，要想获得结果，一般有两种方式：</p>
<p>1、<strong>主动轮询</strong>异步调用的结果;</p>
<p>2、被调用方通过<strong><code>callback</code></strong>来通知调用方调用结果。</p>
<h4 id="②生活实例"><a href="#②生活实例" class="headerlink" title="②生活实例"></a>②生活实例</h4><p>同步买奶茶：小明点单交钱，然后等着拿奶茶；</p>
<p>异步买奶茶：小明点单交钱，店员给小明一个小票，等小明奶茶做好了，再来取。</p>
<p>异步买奶茶，小明要想知道奶茶是否做好了，有两种方式：</p>
<p>1、小明主动去问店员，一会就去问一下：“奶茶做好了吗？”…直到奶茶做好。</p>
<p>2、等奶茶做好了，店员喊一声：“小明，奶茶好了！”，然后小明去取奶茶。</p>
<hr>
<h3 id="2、阻塞与非阻塞"><a href="#2、阻塞与非阻塞" class="headerlink" title="2、阻塞与非阻塞"></a>2、阻塞与非阻塞</h3><h4 id="①阻塞与非阻塞的理解"><a href="#①阻塞与非阻塞的理解" class="headerlink" title="①阻塞与非阻塞的理解"></a>①阻塞与非阻塞的理解</h4><blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;阻塞与非阻塞的重点在于进/线程等待消息时候的行为，也就是在<strong>等待消息的时候，当前进/线程是挂起状态，还是非挂起状态</strong>。</p>
</blockquote>
<ul>
<li><p>阻塞</p>
<p>阻塞调用在发出去后，在消息返回之前，当前进/线程会被挂起，直到有消息返回，当前进/线程才会被激活.</p>
</li>
<li><p>非阻塞</p>
<p>非阻塞调用在发出去后，不会阻塞当前进/线程，而会立即返回。</p>
</li>
</ul>
<h4 id="②生活实例-1"><a href="#②生活实例-1" class="headerlink" title="②生活实例"></a>②生活实例</h4><p>阻塞买奶茶：小明点单交钱，干等着拿奶茶，什么事都不做；</p>
<p>非阻塞买奶茶：小明点单交钱，等着拿奶茶，等的过程中，时不时刷刷微博、朋友圈…</p>
<hr>
<h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h3><p>通过上面的分析，我们可以得知：</p>
<blockquote>
<p>同步与异步，重点在于消息通知的方式;阻塞与非阻塞，重点在于等消息时候的行为。</p>
</blockquote>
<p>所以，就有了下面4种组合方式</p>
<ul>
<li>同步阻塞：小明在柜台干等着拿奶茶；</li>
<li>同步非阻塞：小明在柜台边刷微博边等着拿奶茶；</li>
<li>异步阻塞：小明拿着小票啥都不干，一直等着店员通知他拿奶茶；</li>
<li>异步非阻塞：小明拿着小票，刷着微博，等着店员通知他拿奶茶。</li>
</ul>
<hr>
<h2 id="二、Nginx如何处理高并发"><a href="#二、Nginx如何处理高并发" class="headerlink" title="二、Nginx如何处理高并发"></a>二、Nginx如何处理高并发</h2><h3 id="1、Apache面对高并发，为什么很无力？"><a href="#1、Apache面对高并发，为什么很无力？" class="headerlink" title="1、Apache面对高并发，为什么很无力？"></a>1、Apache面对高并发，为什么很无力？</h3><p><code>Apache</code>处理一个请求是<strong>同步阻塞</strong>的模式。</p>
<p><img src="//blog.com/2019/06/23/nginx、swoole高并发原理初探/image_1b2ianfo42ag28ghrgl4u18sa13.png" alt="image_1b2ianfo42ag28ghrgl4u18sa13.png-93.4kB"></p>
<p>每到达一个请求，<code>Apache</code>都会去<code>fork</code>一个子进程去处理这个请求，直到这个请求处理完毕。</p>
<p>面对低并发，这种模式没什么缺点，但是，面对高并发，就是这种模式的软肋了。</p>
<ul>
<li><strong>进程数量决定了并发能力</strong>。1个客户端占用1个进程，那么，进程数量有多少，并发处理能力就有多少，但操作系统可以创建的进程数量是有限的。</li>
<li><strong>多进程就会有进程间的切换问题，而进程间的切换调度势必会造成<code>CPU</code>的额外消耗</strong>。当进程数量达到成千上万的时候，进程间的切换就占了<code>CPU</code>大部分的时间片，而真正进程的执行反而占了`CPU的一小部分，这就得不偿失了。</li>
</ul>
<p>下面，举例说明这2种场景是多进程模式的软肋：</p>
<ul>
<li><strong>及时消息通知程序</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如及时聊天程序，一台服务器可能要维持数十万的连接(典型的<code>C10K</code>问题)，那么就要启动数十万的进程来维持。这显然不可能。</li>
<li><strong>调用外部<code>Http</code>接口时</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设<code>Apache</code>启动100个进程来处理请求，每个请求消耗100ms，那么这100个进程能提供1000qps。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，在我们调用外部<code>Http</code>接口时，比如QQ登录、微博登录，耗时较长，假设一个请求消耗10s，也就是1个进程1s处理0.1个请求，那么100个进程只能达到10qps，这样的处理能力就未免太差了。</p>
<blockquote>
<p>注：什么是C10K问题？<br>网络服务在处理数以万计的客户端连接时，往往出现效率低下甚至完全瘫痪，这被称为C10K问题。（concurrent 10000 connection）</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综上，我们可以看出，<strong><code>Apache</code>是同步阻塞的多进程模式，面对高并发等一些场景，是很苍白的</strong>。</p>
<hr>
<h3 id="2、Nginx何以问鼎高并发？"><a href="#2、Nginx何以问鼎高并发？" class="headerlink" title="2、Nginx何以问鼎高并发？"></a>2、Nginx何以问鼎高并发？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传统的服务器模型就是这样，因为其同步阻塞的多进程模型，无法面对高并发。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，有没有一种方式，可以让我们在一个进程处理所有的并发I/O呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案是有的，这就是<strong>I/O复用技术</strong>。</p>
<h3 id="①I-O复用是神马？"><a href="#①I-O复用是神马？" class="headerlink" title="①I/O复用是神马？"></a>①I/O复用是神马？</h3><h4 id="最初级的I-O复用"><a href="#最初级的I-O复用" class="headerlink" title="最初级的I/O复用"></a>最初级的I/O复用</h4><p><strong>所谓的<code>I/O</code>复用，就是多个<code>I/O</code>可以复用一个进程</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面说的同步阻塞的多进程模型不适合处理高并发，那么，我们再来考虑非阻塞的方式。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;采用非阻塞的模式，当一个连接过来时，我们不阻塞住，这样一个进程可以同时处理多个连接了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如一个进程接受了10000个连接，这个进程每次从头到尾的问一遍这10000个连接：“<strong>有I/O事件没？有的话就交给我处理，没有的话我一会再来问一遍”。</strong>然后进程就一直从头到尾问这10000个连接，如果这1000个连接都没有<code>I/O</code>事件，就会造成<strong>CPU的空转，并且效率也很低</strong>，不好不好。</p>
<h4 id="升级版的I-O复用"><a href="#升级版的I-O复用" class="headerlink" title="升级版的I/O复用"></a>升级版的I/O复用</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面虽然实现了基础版的<code>I/O</code>复用，但是效率太低了。于是伟大的程序猿们日思夜想的去解决这个问题…终于！</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们能不能<strong>引入一个代理，这个代理可以同时观察许多<code>I/O</code>流事件</strong>呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当没有<code>I/O</code>事件的时候，这个进程处于阻塞状态；当有<code>I/O</code>事件的时候，这个代理就去通知进程醒来？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是，早期的程序猿们发明了两个代理—<code>select、poll</code>。</p>
<p><code>select、poll</code>代理的原理是这样的：</p>
<blockquote>
<p>当连接有I/O流事件产生的时候，就会去唤醒进程去处理。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是<strong>进程并不知道是哪个连接产生的I/O流事件</strong>，于是进程就挨个去问：“请问是你有事要处理吗？”……问了99999遍，哦，原来是第100000个进程有事要处理。那么，前面这99999次就白问了，白白<strong>浪费宝贵的CPU时间片了</strong>！痛哉，惜哉…</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注:<code>select</code>与<code>poll</code>原理是一样的，只不过<code>select</code>只能观察1024个连接，<code>poll</code>可以观察无限个连接。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面看了，<code>select</code>、<code>poll</code>因为不知道哪个连接有<code>I/O</code>流事件要处理，性能也挺不好的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，如果发明一个<strong>代理，每次能够知道哪个连接有了<code>I/O</code>流事件</strong>，不就可以避免无意义的空转了吗？</p>
<p>于是，超级无敌、闪闪发光的<code>epoll</code>被伟大的程序员发明出来了。</p>
<p><code>epoll</code>代理的原理是这样的：</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>当连接有I/O流事件产生的时候，epoll就会去告诉进程哪个连接有I/O流事件产生，然后进程就去处理这个进程</strong>。</p>
</blockquote>
<p>如此，多高效！</p>
<h3 id="②基于epoll的Nginx"><a href="#②基于epoll的Nginx" class="headerlink" title="②基于epoll的Nginx"></a>②基于epoll的Nginx</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>有了<code>epoll</code>，理论上1个进程就可以无限数量的连接，而且无需轮询，真正解决了<code>c10k</code>的问题</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Nginx</code>是基于<code>epoll</code>的，<strong>异步非阻塞</strong>的服务器程序。自然，<code>Nginx</code>能够轻松处理百万级的并发连接，也就无可厚非了。</p>
<h2 id="三、swoole如何处理高并发以及异步I-O的实现"><a href="#三、swoole如何处理高并发以及异步I-O的实现" class="headerlink" title="三、swoole如何处理高并发以及异步I/O的实现"></a>三、swoole如何处理高并发以及异步I/O的实现</h2><h3 id="1、swoole介绍"><a href="#1、swoole介绍" class="headerlink" title="1、swoole介绍"></a>1、swoole介绍</h3><p><code>swoole</code>是<code>PHP</code>的一个扩展。<br>简单理解：<code>swoole</code> =  异步<code>I/O</code>+网络通信<br><code>PHPer</code>可以基于<code>swoole</code>去实现过去<code>PHP</code>无法实现的功能。<br>具体请参考<code>swoole</code>官网：<a href="http://www.swoole.com/" target="_blank" rel="noopener">swoole官网</a></p>
<hr>
<h3 id="2、swoole如何处理高并发"><a href="#2、swoole如何处理高并发" class="headerlink" title="2、swoole如何处理高并发"></a>2、swoole如何处理高并发</h3><h3 id="①Reactor模型介绍"><a href="#①Reactor模型介绍" class="headerlink" title="①Reactor模型介绍"></a>①Reactor模型介绍</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IO复用异步非阻塞程序使用经典的<code>Reactor</code>模型，<code>Reactor</code>顾名思义就是反应堆的意思，它<strong>本身不处理任何数据收发</strong>。<strong>只是可以监视一个socket(也可以是管道、eventfd、信号)句柄的事件变化</strong>。</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注:什么是句柄？句柄英文为handler，可以形象的比喻为锅柄、勺柄。也就是资源的唯一标识符、资源的ID。通过这个ID可以操作资源。</p>
</blockquote>
<p><img src="//blog.com/2019/06/23/nginx、swoole高并发原理初探/image_1b2iad9fimm51tc5f4c13tj2009.png" alt="image_1b2iad9fimm51tc5f4c13tj2009.png-63.3kB"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Reactor只是一个事件发生器，实际对socket句柄的操作，如connect/accept、send/recv、close是在callback中完成的。</strong></p>
<h3 id="②swoole的架构"><a href="#②swoole的架构" class="headerlink" title="②swoole的架构"></a>②swoole的架构</h3><p><code>swoole</code>采用 <strong>多线程Reactor+多进程Worker</strong></p>
<p>swoole的架构图如下：</p>
<p><img src="//blog.com/2019/06/23/nginx、swoole高并发原理初探/image_1b2iakmlo6gtba5m6ktfp9esm.png" alt="image_1b2iakmlo6gtba5m6ktfp9esm.png-125.1kB"></p>
<p><strong>swoole的处理连接流程图如下：</strong></p>
<p><img src="//blog.com/2019/06/23/nginx、swoole高并发原理初探/image_1b2ib3qhpkbajn4l2u2go1vc51g.png" alt="image_1b2ib3qhpkbajn4l2u2go1vc51g.png-62.5kB"></p>
<p>当请求到达时,<code>swoole</code>是这样处理的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">请求到达 Main Reactor</span><br><span class="line">        |</span><br><span class="line">        |</span><br><span class="line">Main Reactor根据Reactor的情况，将请求注册给对应的Reactor</span><br><span class="line">(每个Reactor都有epoll。用来监听客户端的变化)</span><br><span class="line">        |</span><br><span class="line">        |</span><br><span class="line">客户端有变化时，交给worker来处理</span><br><span class="line">        |</span><br><span class="line">        |</span><br><span class="line">worker处理完毕，通过进程间通信(比如管道、共享内存、消息队列)发给对应的reactor。</span><br><span class="line">        |</span><br><span class="line">        |</span><br><span class="line">reactor将响应结果发给相应的连接</span><br><span class="line">        |</span><br><span class="line">        |</span><br><span class="line">    请求处理完成</span><br></pre></td></tr></table></figure>
<p>因为<code>reactor</code>基于<code>epoll</code>，所以每个<code>reactor</code>可以处理无数个连接请求。</p>
<p>如此，<code>swoole</code>就轻松的处理了高并发。</p>
<h3 id="3、swoole如何实现异步I-O"><a href="#3、swoole如何实现异步I-O" class="headerlink" title="3、swoole如何实现异步I/O"></a>3、swoole如何实现异步I/O</h3><p>基于上面的<code>Swoole</code>结构图，我们看到<code>swoole</code>的<code>worker</code>进程有2种类型：</p>
<p><strong>一种是 普通的worker进程，一种是 task worker进程。</strong></p>
<p><code>worker</code>进程是用来处理普通的耗时不是太长的请求；</p>
<p><code>task worker</code>进程用来处理耗时较长的请求，比如数据库的<code>I/O</code>操作。</p>
<p>我们以异步<code>Mysql</code>举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">耗时较长的Mysql查询进入worker</span><br><span class="line">            |</span><br><span class="line">            |</span><br><span class="line">worker通过管道将这个请求交给taskworker来处理</span><br><span class="line">            |</span><br><span class="line">            |</span><br><span class="line">worker再去处理其他请求</span><br><span class="line">            |</span><br><span class="line">            |</span><br><span class="line">task worker处理完毕后，处理结果通过管道返回给worker</span><br><span class="line">            |</span><br><span class="line">            |</span><br><span class="line">worker 将结果返回给reactor</span><br><span class="line">            |</span><br><span class="line">            |</span><br><span class="line">reactor将结果返回给请求方</span><br></pre></td></tr></table></figure>
<p>如此，通过<code>worker</code>、<code>task worker</code>结合的方式，我们就实现了异步<code>I/O</code>。</p>
<h2 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a>四、参考文章</h2><p><a href="https://www.zhihu.com/question/22062795" target="_blank" rel="noopener">Nginx 多进程模型是如何实现高并发的？</a><br><a href="http://rango.swoole.com/archives/508" target="_blank" rel="noopener">PHP并发IO编程之路</a><br><a href="https://www.zhihu.com/question/20122137" target="_blank" rel="noopener">epoll 或者 kqueue 的原理是什么？</a><br><a href="https://www.zhihu.com/question/32163005" target="_blank" rel="noopener">IO 多路复用是什么意思？</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/23/MySQL InnoDB 中的 redo undo log/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/23/MySQL InnoDB 中的 redo undo log/" itemprop="url">MySQL InnoDB 中的 redo undo log</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-23T12:12:57+08:00">
                2019-06-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/MySql/" itemprop="url" rel="index">
                    <span itemprop="name">MySql</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/MySql/Innodb/" itemprop="url" rel="index">
                    <span itemprop="name">Innodb</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/MySql/Innodb/MVCC/" itemprop="url" rel="index">
                    <span itemprop="name">MVCC</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/MySql/Innodb/MVCC/UNDO/" itemprop="url" rel="index">
                    <span itemprop="name">UNDO</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/MySql/Innodb/MVCC/UNDO/REDO/" itemprop="url" rel="index">
                    <span itemprop="name">REDO</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MySQL-InnoDB-中的-redo-undo-log"><a href="#MySQL-InnoDB-中的-redo-undo-log" class="headerlink" title="MySQL InnoDB 中的 redo undo log"></a>MySQL InnoDB 中的 redo undo log</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://chenjiayang.me/2019/04/13/mysql-innodb-redo-undo/" target="_blank" rel="noopener">https://chenjiayang.me/2019/04/13/mysql-innodb-redo-undo/</a></p>
</blockquote>
<p><br></p>
<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;讲到 <code>InnoDB</code>、<code>MVCC</code> 等概念时，我们时常听到 <code>redo log</code> 和 <code>undo log</code> 的名字，那么二者的作用是什么呢？其实二者并非事务操作独有，索引更新时也会记录 <code>redo/undo log</code>，甚至记录 <code>undo log</code> 时也会记录 <code>redo log</code>，而本文聚焦于事务方面的 <code>redo/undo log</code>。</p>
<h2 id="什么是-redo-log"><a href="#什么是-redo-log" class="headerlink" title="什么是 redo log"></a>什么是 redo log</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>MySQL</code> 中使用了大量内存 <code>Cache</code> 区域，对数据的修改操作会先直接修改内存中的 <code>Page</code>，但这些页不会立刻同步磁盘，这时内存中的数据已经和磁盘上的不一致了，我们称这种 <code>Page</code>为脏页。试想一下这时候如果数据库宕机了，内存中这部分被修改的数据记录就丢失了，重启后也没办法恢复。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此为了保证数据的安全性，在修改内存中的 <code>Page</code> 之后 <code>InnoDB</code> 会写 <code>redo log</code>，因为 <strong><code>redo log</code> 是顺序写入的</strong>，而众所周知<strong>磁盘的顺序读写的速度远大于随机读写，因此这部分日志写操作对性能影响较小</strong>。然后，<strong><code>InnoDB</code> 会在事务提交前将 <code>redo log</code> 保存到磁盘中</strong>。这里所说的<strong><code>redo log</code> 是物理日志而非逻辑日志，记录的是数据页的物理修改</strong>，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页（恢复数据页，且只能恢复到最后一次提交的位置）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当数据库意外重启时，会根据 <code>redo log</code> 进行数据恢复，如果 <code>redo log</code> 中有事务提交，则进行事务提交修改数据。</p>
<h2 id="什么是-undo-log"><a href="#什么是-undo-log" class="headerlink" title="什么是 undo log"></a>什么是 undo log</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与 <code>redo log</code> 不同，<code>undo log</code> 一般是逻辑日志，根据每行记录进行记录。例如当 <code>DELETE</code>一条记录时，<code>undo log</code> 中会记录一条对应的 <code>INSERT</code> 记录，反之亦然当 <code>UPDTAE</code> 一条记录时，它记录一条对应反向 <code>UPDATE</code> 记录。</p>
<blockquote>
<p>分布式事务 Seata 的 GTS 模式就是这么实现的，只不过这个过程放在了客户端代码里，而且支持的 SQL 类型有要求</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当数据被修改时除了会记录 <code>redo log</code> 还会记录 <code>undo log</code>，<strong>通过 <code>undo log</code> 一方面可以实现事务回滚，另一方面可以根据 <code>undo log</code> 回溯到某个特定的版本的数据，实现 <code>MVCC</code> 的功能</strong>。</p>
<h2 id="为什么要引入-redo-log-？"><a href="#为什么要引入-redo-log-？" class="headerlink" title="为什么要引入 redo log ？"></a>为什么要引入 redo log ？</h2><blockquote>
<p>假设现在只有 undo log 机制。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务提交前为了保证突发宕机不丢更新，肯定要将 <code>undo log</code> 刷到磁盘，但这会造成多次磁盘 <code>IO</code>，但是考虑到日志文件是顺序写入，性能还好。<strong>事务提交后，需要将内存中的脏页立即同步到磁盘的数据文件中，这会造成至少一次磁盘随机 <code>IO</code>，影响性能</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此数据库设计者就思考，如果事务提交后，脏页数据能在内存中缓存一段时间，而不需要立即被同步到磁盘文件，那么就能合并多次随机 <code>IO</code> 来提高性能。但是这样就会丧失事务的<strong>持久性</strong>，因为假如事务已经提交，数据却还在内存中时宕机了，重启后因为只有 <code>undo log</code> 无法恢复被提交的数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此设计者们引入了另外一种机制来实现持久化，即 <code>redo log</code>。在事务提交前，只要将 <code>redo log</code> 持久化即可，不需要将数据持久化。当系统宕机时，虽然数据还没来得及刷回磁盘，但是 <code>redo log</code> 已经持久化了，系统可以根据 <code>redo log</code> 的内容，将所有数据恢复到最新的状态。</p>
<h2 id="只靠-undo-log-行么？"><a href="#只靠-undo-log-行么？" class="headerlink" title="只靠 undo log 行么？"></a>只靠 undo log 行么？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有 <code>undo log</code> 的情况下就必须<strong>保证事务提交前，脏页必须刷回磁盘，否则宕机时这部分数据修改就在内存中丢失了，破坏了持久性，但是如上文提到的，这种办法性能太差，必须改进</strong>。</p>
<h2 id="只靠-redo-log-行么？"><a href="#只靠-redo-log-行么？" class="headerlink" title="只靠 redo log 行么？"></a>只靠 redo log 行么？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有 <code>redo log</code> 的情况下就不能在事务提交前刷脏，我们假设有个大事务更新数据量很大，更新完一部分必须刷一部分脏页回磁盘然后再 <code>load</code> 其他的数据进内存操作，此时如果更新到一半宕机了，那么数据库里存在一部分新数据一部分旧数据，而事务又没有提交，因此应该<strong>回滚，只有 <code>redo log</code> 的情况下无法完成</strong>。</p>
<h2 id="redo-undo-log-的持久化"><a href="#redo-undo-log-的持久化" class="headerlink" title="redo/undo log 的持久化"></a>redo/undo log 的持久化</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>redo log</code> 由两部分组成，一部分是内存中的 <code>redo log buffer</code>，这部分是易失的，重启就没了；二是磁盘上的 <code>redo log file</code>，是持久化的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>InnoDB</code> 通过 <code>force log at commit</code> 技术来实现事务的持久化特性。<strong>为了保证每次 <code>redo log</code> 都能写入磁盘上的日志文件中，每次将内存中的 <code>redo log buffer</code> 内容同步磁盘时都会调用一次 <code>fsync</code></strong>。</p>
<blockquote>
<p>OS 中 write 和 fsync 是不同的操作，我们以为调用了 write 就万事大吉，数据一定到磁盘了，其实不一定，通常情况下 write 只是到了磁盘 IO 缓冲区，何时 fsync 由 OS 控制，这里通过程序强制调用来保证日志一定刷到磁盘</p>
</blockquote>
<p><img src="//blog.com/2019/06/23/MySQL InnoDB 中的 redo undo log/c3beb895ly1g212vf2ljjj20u20reju7.jpg" alt="img"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.jianshu.com/p/57c510f4ec28" target="_blank" rel="noopener">redo/undo log、binlog 的详解及其区别</a></li>
<li><a href="https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html" target="_blank" rel="noopener">详细分析MySQL事务日志(redo log和undo log)</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/23/Epoll的使用详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/23/Epoll的使用详解/" itemprop="url">Epoll的使用详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-23T12:12:57+08:00">
                2019-06-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/" itemprop="url" rel="index">
                    <span itemprop="name">异步与同步</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/" itemprop="url" rel="index">
                    <span itemprop="name">IO</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/" itemprop="url" rel="index">
                    <span itemprop="name">Reactor</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/事件模型/" itemprop="url" rel="index">
                    <span itemprop="name">事件模型</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/事件模型/网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Epoll的使用详解"><a href="#Epoll的使用详解" class="headerlink" title="Epoll的使用详解"></a>Epoll的使用详解</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://www.jianshu.com/p/ee381d365a29" target="_blank" rel="noopener">https://www.jianshu.com/p/ee381d365a29</a></p>
</blockquote>
<p><br></p>
<h2 id="1-Epoll简介"><a href="#1-Epoll简介" class="headerlink" title="1.Epoll简介"></a>1.Epoll简介</h2><p>EPOLL 的API用来执行类似poll()的任务。能够用于检测在多个文件描述符中任何IO可用的情况。Epoll API可以用于边缘触发(edge-triggered)和水平触发(level-triggered), 同时epoll可以检测更多的文件描述符。以下的系统调用函数提供了创建和管理epoll实例：</p>
<ul>
<li>epoll_create() 可以创建一个epoll实例并返回相应的文件描述符(epoll_create1() 扩展了epoll_create() 的功能)。</li>
<li>注册相关的文件描述符使用epoll_ctl()</li>
<li>epoll_wait() 可以用于等待IO事件。如果当前没有可用的事件，这个函数会阻塞调用线程。</li>
</ul>
<p><strong>边缘触发(edge-triggered 简称ET)和水平触发(level-triggered 简称LT)：</strong></p>
<p>epoll的事件派发接口可以运行在两种模式下：边缘触发(edge-triggered)和水平触发(level-triggered)，两种模式的区别请看下面,我们先假设下面的情况：</p>
<ol>
<li>一个代表管道读取的文件描述符已经注册到epoll实例上了。</li>
<li>在管道的写入端写入了2kb的数据。</li>
<li>epoll_wait 返回一个可用的rfd文件描述符。</li>
<li>从管道读取了1kb的数据。</li>
<li>调用epoll_wait 完成。</li>
</ol>
<p>如果rfd被设置了ET，在调用完第五步的epool_wait 后会被挂起，尽管在缓冲区还有可以读取的数据，同时另外一段的管道还在等待发送完毕的反馈。这是因为ET模式下只有文件描述符发生改变的时候，才会派发事件。所以第五步操作，可能会去等待已经存在缓冲区的数据。在上面的例子中，一个事件在第二步被创建，再第三步中被消耗，由于第四步中没有读取完缓冲区，第五步中的epoll_wait可能会一直被阻塞下去。</p>
<p>下面情况下推荐使用ET模式:</p>
<ol>
<li>使用非阻塞的IO。</li>
<li>epoll_wait() 只需要在read或者write返回的时候。</li>
</ol>
<p>相比之下，当我们使用LT的时候（默认）,epoll会比poll更简单更快速，而且我们可以使用在任何一个地方。</p>
<h2 id="2-API介绍"><a href="#2-API介绍" class="headerlink" title="2.API介绍"></a>2.API介绍</h2><p>先简单的看下EPOLL的API</p>
<h3 id="2-1-创建epoll"><a href="#2-1-创建epoll" class="headerlink" title="2.1 创建epoll"></a>2.1 创建epoll</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line"></span><br><span class="line">int epoll_create(int size);</span><br><span class="line">int epoll_create1(int flags);</span><br></pre></td></tr></table></figure>
<p>epoll_create() 可以创建一个epoll实例。在linux 内核版本大于2.6.8 后，这个<strong>size</strong> 参数就被弃用了，但是传入的值必须大于0。</p>
<blockquote>
<p>在 epoll_create () 的最初实现版本时， size参数的作用是创建epoll实例时候告诉内核需要使用多少个文件描述符。内核会使用 size 的大小去申请对应的内存(如果在使用的时候超过了给定的size， 内核会申请更多的空间)。现在，这个size参数不再使用了（内核会动态的申请需要的内存）。但要注意的是，这个size必须要大于0，为了兼容旧版的linux 内核的代码。</p>
</blockquote>
<p>epoll_create() 会返回新的epoll对象的文件描述符。这个文件描述符用于后续的epoll操作。如果不需要使用这个描述符，请使用close关闭。</p>
<p>epoll_create1() 如果<strong>flags</strong>的值是0，epoll_create1()等同于epoll_create()除了过时的size被遗弃了。当然<strong>flasg</strong>可以使用 EPOLL_CLOEXEC，请查看 open() 中的O_CLOEXEC来查看 EPOLL_CLOEXEC有什么用。</p>
<p><strong>返回值:</strong> 如果执行成功，返回一个非负数(实际为文件描述符), 如果执行失败，会返回-1，具体原因请查看error.</p>
<h3 id="2-2-设置epoll事件"><a href="#2-2-设置epoll事件" class="headerlink" title="2.2 设置epoll事件"></a>2.2 设置epoll事件</h3><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line"></span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br></pre></td></tr></table></figure>
<p>这个系统调用能够控制给定的文件描述符<strong>epfd</strong>指向的epoll实例，<strong>op</strong>是添加事件的类型，<strong>fd</strong>是目标文件描述符。</p>
<p>有效的op值有以下几种：</p>
<ul>
<li>EPOLL_CTL_ADD 在<strong>epfd</strong>中注册指定的fd文件描述符并能把<strong>event</strong>和<strong>fd</strong>关联起来。</li>
<li>EPOLL_CTL_MOD 改变<strong>* fd</strong>和<strong>evetn*</strong>之间的联系。</li>
<li>EPOLL_CTL_DEL 从指定的<strong>epfd</strong>中删除<strong>fd</strong>文件描述符。在这种模式中<strong>event</strong>是被忽略的，并且为可以等于NULL。</li>
</ul>
<p><strong>event</strong>这个参数是用于关联制定的<strong>fd</strong>文件描述符的。它的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef union epoll_data &#123;</span><br><span class="line">    void        *ptr;</span><br><span class="line">    int          fd;</span><br><span class="line">    uint32_t     u32;</span><br><span class="line">    uint64_t     u64;</span><br><span class="line">&#125; epoll_data_t;</span><br><span class="line"></span><br><span class="line">struct epoll_event &#123;</span><br><span class="line">    uint32_t     events;      /* Epoll events */</span><br><span class="line">    epoll_data_t data;        /* User data variable */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>events</strong>这个参数是一个字节的掩码构成的。下面是可以用的事件：</p>
<ul>
<li>EPOLLIN - 当关联的文件可以执行 read ()操作时。</li>
<li>EPOLLOUT - 当关联的文件可以执行 write ()操作时。</li>
<li>EPOLLRDHUP - (从 linux 2.6.17 开始)当socket关闭的时候，或者半关闭写段的(当使用边缘触发的时候，这个标识在写一些测试代码去检测关闭的时候特别好用)</li>
<li>EPOLLPRI - 当 read ()能够读取紧急数据的时候。</li>
<li>EPOLLERR - 当关联的文件发生错误的时候，epoll_wait() 总是会等待这个事件，并不是需要必须设置的标识。</li>
<li>EPOLLHUP - 当指定的文件描述符被挂起的时候。epoll_wait() 总是会等待这个事件，并不是需要必须设置的标识。当socket从某一个地方读取数据的时候(管道或者socket),这个事件只是标识出这个已经读取到最后了(EOF)。所有的有效数据已经被读取完毕了，之后任何的读取都会返回0(EOF)。</li>
<li>EPOLLET - 设置指定的文件描述符模式为边缘触发，默认的模式是水平触发。</li>
<li>EPOLLONESHOT - (从 linux 2.6.17 开始)设置指定文件描述符为单次模式。这意味着，在设置后只会有一次从epoll_wait() 中捕获到事件，之后你必须要重新调用 epoll_ctl() 重新设置。</li>
</ul>
<p><strong>返回值：</strong>如果成功，返回0。如果失败，会返回-1， <strong>errno</strong>将会被设置</p>
<p>有以下几种错误：</p>
<ul>
<li>EBADF - <strong>epfd</strong> 或者 <strong>fd</strong> 是无效的文件描述符。</li>
<li>EEXIST - <strong>op</strong>是EPOLL_CTL_ADD，同时 <strong>fd</strong> 在之前，已经被注册到epoll中了。</li>
<li>EINVAL - <strong>epfd</strong>不是一个epoll描述符。或者<strong>fd</strong>和<strong>epfd</strong>相同，或者<strong>op</strong>参数非法。</li>
<li>ENOENT - <strong>op</strong>是EPOLL_CTL_MOD或者EPOLL_CTL_DEL，但是<strong>fd</strong>还没有被注册到epoll上。</li>
<li>ENOMEM - 内存不足。</li>
<li>EPERM - 目标的<strong>fd</strong>不支持epoll。</li>
</ul>
<hr>
<h3 id="2-3-等待epoll事件"><a href="#2-3-等待epoll事件" class="headerlink" title="2.3 等待epoll事件"></a>2.3 等待epoll事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line"></span><br><span class="line">int epoll_wait(int epfd, struct epoll_event *events,</span><br><span class="line">                      int maxevents, int timeout);</span><br><span class="line">                      </span><br><span class="line">int epoll_pwait(int epfd, struct epoll_event *events,</span><br><span class="line">                      int maxevents, int timeout,</span><br><span class="line">                      const sigset_t *sigmask);</span><br></pre></td></tr></table></figure>
<p>epoll_wait 这个系统调用是用来等待<strong>epfd</strong>中的事件。<strong>events</strong>指向调用者可以使用的事件的内存区域。<strong>maxevents</strong>告知内核有多少个events，必须要大于0.</p>
<p><strong>timeout</strong>这个参数是用来制定epoll_wait 会阻塞多少毫秒，会一直阻塞到下面几种情况：</p>
<ol>
<li>一个文件描述符触发了事件。</li>
<li>被一个信号处理函数打断，或者timeout超时。</li>
</ol>
<p>当<strong>timeout</strong>等于-1的时候这个函数会无限期的阻塞下去，当<strong>timeout</strong>等于0的时候，就算没有任何事件，也会立刻返回。</p>
<p>struct epoll_event 如下定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef union epoll_data &#123;</span><br><span class="line">    void    *ptr;</span><br><span class="line">    int      fd;</span><br><span class="line">    uint32_t u32;</span><br><span class="line">    uint64_t u64;</span><br><span class="line">&#125; epoll_data_t;</span><br><span class="line"></span><br><span class="line">struct epoll_event &#123;</span><br><span class="line">    uint32_t     events;    /* Epoll events */</span><br><span class="line">    epoll_data_t data;      /* User data variable */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每次epoll_wait() 返回的时候，会包含用户在epoll_ctl中设置的events。</p>
<p>还有一个系统调用epoll_pwait ()。epoll_pwait()和epoll_wait ()的关系就像select()和 pselect()的关系。和pselect()一样，epoll_pwait()可以让应用程序安全的等待知道某一个文件描述符就绪或者捕捉到信号。</p>
<p>下面的 epoll_pwait () 调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ready = epoll_pwait(epfd, &amp;events, maxevents, timeout, &amp;sigmask);</span><br></pre></td></tr></table></figure>
<p>在内部等同于:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_sigmask(SIG_SETMASK, &amp;sigmask, &amp;origmask);</span><br><span class="line">ready = epoll_wait(epfd, &amp;events, maxevents, timeout);</span><br><span class="line">pthread_sigmask(SIG_SETMASK, &amp;origmask, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>如果 <strong>sigmask</strong>为NULL,  epoll_pwait()等同于epoll_wait()。</p>
<p><strong>返回值：</strong>有多少个IO事件已经准备就绪。如果返回0说明没有IO事件就绪，而是timeout超时。遇到错误的时候，会返回-1，并设置 errno。</p>
<p>有以下几种错误:</p>
<ul>
<li>EBADF - <strong>epfd</strong>是无效的文件描述符</li>
<li>EFAULT - 指针<strong>events</strong>指向的内存没有访问权限</li>
<li>EINTR - 这个调用被信号打断。</li>
<li>EINVAL - <strong>epfd</strong>不是一个epoll的文件描述符，或者<strong>maxevents</strong>小于等于0</li>
</ul>
<h2 id="3-官方demo"><a href="#3-官方demo" class="headerlink" title="3. 官方demo"></a>3. 官方demo</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENTS 10</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>  <span class="title">ev</span>, <span class="title">events</span>[<span class="title">MAX_EVENTS</span>];</span></span><br><span class="line"><span class="keyword">int</span>         listen_sock, conn_sock, nfds, epollfd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Code to set up listening socket, 'listen_sock',</span></span><br><span class="line"><span class="comment"> * (socket(), bind(), listen()) omitted */</span></span><br><span class="line"></span><br><span class="line">epollfd = epoll_create1( <span class="number">0</span> );</span><br><span class="line"><span class="keyword">if</span> ( epollfd == <span class="number">-1</span> )</span><br><span class="line">&#123;</span><br><span class="line">    perror( <span class="string">"epoll_create1"</span> );</span><br><span class="line">    <span class="built_in">exit</span>( EXIT_FAILURE );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ev.events   = EPOLLIN;</span><br><span class="line">ev.data.fd  = listen_sock;</span><br><span class="line"><span class="keyword">if</span> ( epoll_ctl( epollfd, EPOLL_CTL_ADD, listen_sock, &amp;ev ) == <span class="number">-1</span> )</span><br><span class="line">&#123;</span><br><span class="line">    perror( <span class="string">"epoll_ctl: listen_sock"</span> );</span><br><span class="line">    <span class="built_in">exit</span>( EXIT_FAILURE );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">&#123;</span><br><span class="line">    nfds = epoll_wait( epollfd, events, MAX_EVENTS, <span class="number">-1</span> );</span><br><span class="line">    <span class="keyword">if</span> ( nfds == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        perror( <span class="string">"epoll_wait"</span> );</span><br><span class="line">        <span class="built_in">exit</span>( EXIT_FAILURE );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( n = <span class="number">0</span>; n &lt; nfds; ++n )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( events[n].data.fd == listen_sock )</span><br><span class="line">        &#123;</span><br><span class="line">            conn_sock = accept( listen_sock,</span><br><span class="line">                        (struct sockaddr *) &amp;local, &amp;addrlen );</span><br><span class="line">            <span class="keyword">if</span> ( conn_sock == <span class="number">-1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                perror( <span class="string">"accept"</span> );</span><br><span class="line">                <span class="built_in">exit</span>( EXIT_FAILURE );</span><br><span class="line">            &#125;</span><br><span class="line">            setnonblocking( conn_sock );</span><br><span class="line">            ev.events   = EPOLLIN | EPOLLET;</span><br><span class="line">            ev.data.fd  = conn_sock;</span><br><span class="line">            <span class="keyword">if</span> ( epoll_ctl( epollfd, EPOLL_CTL_ADD, conn_sock,</span><br><span class="line">                    &amp;ev ) == <span class="number">-1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                perror( <span class="string">"epoll_ctl: conn_sock"</span> );</span><br><span class="line">                <span class="built_in">exit</span>( EXIT_FAILURE );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            do_use_fd( events[n].data.fd );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-完整可运行的DEMO"><a href="#4-完整可运行的DEMO" class="headerlink" title="4.完整可运行的DEMO"></a>4.完整可运行的DEMO</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_BUF_LEN 256</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置 file describe 为非阻塞模式</span></span><br><span class="line"><span class="comment"> * @param fd 文件描述</span></span><br><span class="line"><span class="comment"> * @return 返回0成功，返回-1失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">make_socket_non_blocking</span> <span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flags, s;</span><br><span class="line">    <span class="comment">// 获取当前flag</span></span><br><span class="line">    flags = fcntl(fd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == flags) &#123;</span><br><span class="line">        perror(<span class="string">"Get fd status"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    flags |= O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置flag</span></span><br><span class="line">    s = fcntl(fd, F_SETFL, flags);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == s) &#123;</span><br><span class="line">        perror(<span class="string">"Set fd status"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// epoll 实例 file describe</span></span><br><span class="line">    <span class="keyword">int</span> epfd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> listenfd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>, <span class="title">event</span>[<span class="title">MAX_EVENT</span>];</span></span><br><span class="line">    <span class="comment">// 绑定的地址</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> local_addr = <span class="string">"192.168.0.45"</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span> = &#123;</span> <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == listenfd) &#123;</span><br><span class="line">        perror(<span class="string">"Open listen socket"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Enable address reuse */</span></span><br><span class="line">    <span class="keyword">int</span> on = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 打开 socket 端口复用, 防止测试的时候出现 Address already in use</span></span><br><span class="line">    result = setsockopt( listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on) );</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == result) &#123;</span><br><span class="line">        perror (<span class="string">"Set socket"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    inet_aton (local_addr, &amp;(server_addr.sin_addr));</span><br><span class="line">    server_addr.sin_port = htons(<span class="number">8080</span>);</span><br><span class="line">    result = bind(listenfd, (<span class="keyword">const</span> struct sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span> (server_addr));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == result) &#123;</span><br><span class="line">        perror(<span class="string">"Bind port"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result = make_socket_non_blocking(listenfd);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == result) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = listen(listenfd, <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == result) &#123;</span><br><span class="line">        perror(<span class="string">"Start listen"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建epoll实例</span></span><br><span class="line">    epfd = epoll_create1(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == epfd) &#123;</span><br><span class="line">        perror(<span class="string">"Create epoll instance"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ev.data.fd = listenfd;</span><br><span class="line">    ev.events = EPOLLIN | EPOLLET <span class="comment">/* 边缘触发选项。 */</span>;</span><br><span class="line">    <span class="comment">// 设置epoll的事件</span></span><br><span class="line">    result = epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &amp;ev);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == result) &#123;</span><br><span class="line">        perror(<span class="string">"Set epoll_ctl"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> wait_count;</span><br><span class="line">        <span class="comment">// 等待事件</span></span><br><span class="line">        wait_count = epoll_wait(epfd, event, MAX_EVENT, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; wait_count; i++) &#123;</span><br><span class="line">            <span class="keyword">uint32_t</span> events = event[i].events;</span><br><span class="line">            <span class="comment">// IP地址缓存</span></span><br><span class="line">            <span class="keyword">char</span> host_buf[NI_MAXHOST];</span><br><span class="line">            <span class="comment">// PORT缓存</span></span><br><span class="line">            <span class="keyword">char</span> port_buf[NI_MAXSERV];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> __result;</span><br><span class="line">            <span class="comment">// 判断epoll是否发生错误</span></span><br><span class="line">            <span class="keyword">if</span> ( events &amp; EPOLLERR || events &amp; EPOLLHUP || (! events &amp; EPOLLIN)) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Epoll has error\n"</span>);</span><br><span class="line">                close (event[i].data.fd);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (listenfd == event[i].data.fd) &#123;</span><br><span class="line">                <span class="comment">// listen的 file describe 事件触发， accpet事件</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> ( ; ; ) &#123; <span class="comment">// 由于采用了边缘触发模式，这里需要使用循环</span></span><br><span class="line">                    struct sockaddr in_addr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                    <span class="keyword">socklen_t</span> in_addr_len = <span class="keyword">sizeof</span> (in_addr);</span><br><span class="line">                    <span class="keyword">int</span> accp_fd = accept(listenfd, &amp;in_addr, &amp;in_addr_len);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">-1</span> == accp_fd) &#123;</span><br><span class="line">                        perror(<span class="string">"Accept"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    __result = getnameinfo(&amp;in_addr, <span class="keyword">sizeof</span> (in_addr),</span><br><span class="line">                                           host_buf, <span class="keyword">sizeof</span> (host_buf) / <span class="keyword">sizeof</span> (host_buf[<span class="number">0</span>]),</span><br><span class="line">                                           port_buf, <span class="keyword">sizeof</span> (port_buf) / <span class="keyword">sizeof</span> (port_buf[<span class="number">0</span>]),</span><br><span class="line">                                           NI_NUMERICHOST | NI_NUMERICSERV);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (! __result) &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">"New connection: host = %s, port = %s\n"</span>, host_buf, port_buf);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    __result = make_socket_non_blocking(accp_fd);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">-1</span> == __result) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    ev.data.fd = accp_fd;</span><br><span class="line">                    ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">                    <span class="comment">// 为新accept的 file describe 设置epoll事件</span></span><br><span class="line">                    __result = epoll_ctl(epfd, EPOLL_CTL_ADD, accp_fd, &amp;ev);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">-1</span> == __result) &#123;</span><br><span class="line">                        perror(<span class="string">"epoll_ctl"</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 其余事件为 file describe 可以读取</span></span><br><span class="line">                <span class="keyword">int</span> done = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 因为采用边缘触发，所以这里需要使用循环。如果不使用循环，程序并不能完全读取到缓存区里面的数据。</span></span><br><span class="line">                <span class="keyword">for</span> ( ; ;) &#123;</span><br><span class="line">                    <span class="keyword">ssize_t</span> result_len = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">char</span> buf[READ_BUF_LEN] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">                    result_len = read(event[i].data.fd, buf, <span class="keyword">sizeof</span> (buf) / <span class="keyword">sizeof</span> (buf[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="number">-1</span> == result_len) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (EAGAIN != errno) &#123;</span><br><span class="line">                            perror (<span class="string">"Read data"</span>);</span><br><span class="line">                            done = <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! result_len) &#123;</span><br><span class="line">                        done = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    write(STDOUT_FILENO, buf, result_len);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"Closed connection\n"</span>);</span><br><span class="line">                    close (event[i].data.fd);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    close (epfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/35/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/35/">35</a><span class="page-number current">36</span><a class="page-number" href="/page/37/">37</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/37/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
