<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/page/81/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/page/81/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/09/微软-API 设计指导/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/微软-API 设计指导/" itemprop="url">微软-API 设计指导</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-09T12:12:57+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/API设计/" itemprop="url" rel="index">
                    <span itemprop="name">API设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="微软-API-设计指导"><a href="#微软-API-设计指导" class="headerlink" title="微软-API 设计指导"></a>微软-API 设计指导</h1><p><br></p>
<p>原文地址：<a href="https://docs.microsoft.com/zh-cn/azure/architecture/best-practices/api-design" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/azure/architecture/best-practices/api-design</a></p>
<p><br></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大多数新式 <code>Web</code>应用程序都会公开<code>API</code>，客户端可以使用这些 <code>API</code>来与该应用程序交互。 设计良好的 <code>Web API</code>应旨在支持：</p>
<ul>
<li><strong>平台独立性</strong>。 不管 <code>API</code> 的内部实现方式如何，任何客户端都应该能够调用该 <code>API</code>。 这就需要使用标准协议并创建一种机制，使客户端和 Web 服务能够就交换数据的格式达成一致。</li>
<li><strong>服务演变</strong>。 <code>Web API</code>应能在不影响客户端应用程序的情况下改进和添加功能。 随着<code>API</code> 的发展，现有客户端应用程序应可继续运行而无需进行任何修改。 所有功能应该是可发现的，使客户端应用程序能够充分利用它。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本指南阐述在设计 <code>Web API</code>时应考虑的问题。</p>
<h2 id="REST-简介"><a href="#REST-简介" class="headerlink" title="REST 简介"></a>REST 简介</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 2000 年，<code>Roy Fielding</code>提议使用表述性状态转移 (<code>REST</code>) 作为设计 <code>Web</code> 服务的体系性方法。 <code>REST</code> 是一种基于超媒体构建分布式系统的架构风格。<code>REST</code> 独立于任何基础协议，并且不一定绑定到<code>HTTP</code>。 但是，最常见的<code>REST</code> 实现使用 <code>HTTP</code> 作为应用程序协议，本指南重点介绍如何设计适用于<code>HTTP</code>的<code>REST API</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于 <code>HTTP</code>的 <code>REST</code>的主要优势在于它使用开放标准，不会绑定 <code>API</code>的实现，也不会将客户端应用程序绑定到任何具体实现。 例如，可以使用 <code>ASP.NET</code> 编写 <code>REST Web</code> 服务，而客户端应用程序能够使用任何语言或工具来发起 <code>HTTP</code>请求和分析 <code>HTTP</code>响应。</p>
<p>下面是使用<code>HTTP</code>设计 <code>RESTful API</code>时的一些主要原则：</p>
<ul>
<li><strong><code>REST API</code>围绕资源设计</strong>，资源是可由客户端访问的任何类型的对象、数据或服务。</li>
</ul>
<ul>
<li><p><strong>每个资源有一个标识符</strong>，即，唯一标识该资源的 <code>URI</code>。 例如，特定客户订单的 URI 可能是：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">https://adventure-works.com/orders/1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>客户端通过交换资源的表示形式来与服务交互。 许多 <code>Web API</code> 使用<code>JSON</code>作为交换格式。 例如，对上面所列的 URI 发出 GET 请求可能返回以下响应正文：</li>
</ul>
  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"orderId"</span>:<span class="number">1</span>,<span class="attr">"orderValue"</span>:<span class="number">99.90</span>,<span class="attr">"productId"</span>:<span class="number">1</span>,<span class="attr">"quantity"</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>REST API</code>使用统一接口，这有助于分离客户端和服务实现。 对于基于 HTTP 构建的<code>REST API</code>，统一接口包括使用标准 <code>HTTP</code> 谓词对资源执行操作。 最常见的操作是 <code>GET、POST、PUT、PATCH 和 DELETE</code>。</li>
</ul>
<ul>
<li><code>REST API</code>使用无状态请求模型。 <code>HTTP</code>请求应是独立的并可按任意顺序发生，因此保留请求之间的瞬时状态信息并不可行。 信息的唯一存储位置就在资源内，并且每个请求应是原子操作。 此约束可让 <code>Web</code>服务获得高度可伸缩性，因为无需保留客户端与特定服务器之间的关联。 任何服务器可以处理来自任何客户端的任何请求。 也就是说，其他因素可能会限制可伸缩性。 例如，许多<code>Web</code> 服务向后端数据存储写入数据，可能导致难以横向扩展。</li>
</ul>
<ul>
<li><p><code>REST API</code> 由表示形式中包含的超媒体链接驱动。 例如，下面显示了某个订单的<code>JSON</code>表示形式。 该表示形式包含一些链接，用于获取或更新与该订单关联的客户。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"orderID"</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="attr">"productID"</span>:<span class="number">2</span>,</span><br><span class="line">    <span class="attr">"quantity"</span>:<span class="number">4</span>,</span><br><span class="line">    <span class="attr">"orderValue"</span>:<span class="number">16.60</span>,</span><br><span class="line">    <span class="attr">"links"</span>: [</span><br><span class="line">        &#123;<span class="attr">"rel"</span>:<span class="string">"product"</span>,<span class="attr">"href"</span>:<span class="string">"https://adventure-works.com/customers/3"</span>, <span class="attr">"action"</span>:<span class="string">"GET"</span> &#125;,</span><br><span class="line">        &#123;<span class="attr">"rel"</span>:<span class="string">"product"</span>,<span class="attr">"href"</span>:<span class="string">"https://adventure-works.com/customers/3"</span>, <span class="attr">"action"</span>:<span class="string">"PUT"</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2008 年，<code>Leonard Richardson</code> 提议对 <code>Web API</code> 使用以下<a href="https://martinfowler.com/articles/richardsonMaturityModel.html" target="_blank" rel="noopener">成熟度模型</a>：</p>
<ul>
<li>级别 0：定义一个 <code>URI</code>，所有操作是对此 <code>URI</code>发出的<code>POST</code> 请求。</li>
<li>级别 1：为各个资源单独创建 <code>URI</code>。</li>
<li>级别 2：使用 <code>HTTP</code>方法来定义对资源执行的操作。</li>
<li>级别 3：使用超媒体（<code>HATEOAS</code>，如下所述）。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据<code>Fielding</code>的定义，级别 3 对应于某个真正的<code>RESTful API</code>。 在实践中，许多发布的<code>Web API</code>大致处于级别 2。</p>
<h2 id="围绕资源组织-API"><a href="#围绕资源组织-API" class="headerlink" title="围绕资源组织 API"></a>围绕资源组织 API</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;侧重于 <code>Web API</code>公开的业务实体。 例如，在电子商务系统中，主实体可能是客户和订单。 可以通过发送包含订单信息的 <code>HTTP POST</code>请求来创建订单。<code>HTTP</code>响应指示下单是否成功。 如果可能，资源 <code>URI</code>应基于名词（资源）而不是动词（对资源执行的操作）。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://adventure-works.com/orders // Good</span><br><span class="line"></span><br><span class="line">https://adventure-works.com/create-order // Avoid</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>资源无需基于单个物理数据项</strong>。 例如，订单资源可以在内部实现为关系数据库中的多个表，但以单个实体的形式提供给客户端。 避免创建反映数据库内部结构的 <code>API</code>。 <code>REST</code> 旨在为实体建模，以及为应用程序可对这些实体执行的操作建模。 不应将内部实现公开给客户端。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实体通常分组成集合（订单、客户）。 <strong>集合是不同于集合中的子项的资源，应具有自身的<code>URI</code></strong>。 例如，以下 URI 可以表示订单集合：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">https://adventure-works.com/orders</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;向集合 <code>URI</code> 发送 <code>HTTP GET</code>请求可检索集合中的子项列表。 集合中的每个子项也有自身的唯一 <code>URI</code>。 对子项的<code>URI</code> 发出 <code>HTTP GET</code>请求会返回该子项的详细信息。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>URI</code> 中采用一致的命名约定。<strong> 一般而言，有效的做法是对引用集合的 <code>URI</code>使用复数名词</strong>。 最好是将集合和项的 <code>URI</code>组织成层次结构。 例如，<code>/customers</code> 是客户集合的路径，<code>/customers/5</code> 是 ID 为 5 的客户的路径。 这种方法有助于使 <code>Web API</code>保持直观。 此外，有许多 <code>Web API</code>框架可以基于参数化<code>URI</code>路径来路由请求，因此，你可以对路径 <code>/customers/{id}</code> 定义路由。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还需要考虑不同类型的资源之间的关系，以及如何公开这些关联。 例如，<code>/customers/5/orders</code> 可以表示客户 5 的所有订单。 我们还可以改变思维方向，使用类似于 <code>/orders/99/customer</code> 的 URI 来表示从订单到客户的关联。 但是，过度扩展此模型可能会变得难以实现。 更好的解决方案是在 <code>HTTP</code> 响应消息的正文中提供指向关联资源的可导航链接。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在更复杂的系统中，我们往往提供 <code>URI</code>（例如 <code>/customers/1/orders/99/products</code>），使客户端能够通过多个关系级别进行导航。 但是，如果资源之间的关系在将来更改，此级别的复杂性可能很难维护并且不够灵活。 相反，请尽量让 URI 相对简单。 应用程序获取对某个资源的引用后，应该可以使用此引用去查找与该资源相关的项目。可将前面的查询替换为 URI <code>/customers/1/orders</code> 以查找客户 1 的所有订单，然后替换为 <code>/orders/99/products</code> 以查找此订单中的产品。</p>
<p> <strong>提示</strong>：避免请求复杂度超过<em>集合/项目/集合</em>的资源 <code>URI</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个因素是所有 <code>Web</code>请求都会增加 <code>Web</code> 服务器的负载。 请求越多，负载就越大。 因此，请尽量避免使用公开大量小型资源的“琐碎”<code>Web API</code>。 此类<code>API</code> 可能需要客户端应用程序发送多个请求才能找到它需要的所有数据。我们建议<strong>将数据非规范化，并将相关信息合并成可通过单个请求检索的较大资源</strong>。 但是，需要权衡客户端获取不需要的数据所产生的开销。 检索大型对象可能增大请求的延迟时间，并产生额外的带宽成本。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;避免在 <code>Web API</code>与底层数据源之间引入依赖关系。 例如，如果数据存储在关系数据库中，则 <code>Web API</code> 不需要将每个表公开为资源集合。 事实上，这可以算作一种粗劣的设计。 请考虑将 <code>Web API</code> 视为数据库的抽象。 如有必要，可在数据库与 <code>Web API</code>之间引入映射层。 这样，对于底层数据库方案所做的更改不会影响客户端应用程序。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，可能无法将 <code>Web API</code>实现的每个操作都映射到特定资源。 可以通过<code>HTTP</code> 请求处理此类非资源场景，这些请求调用某个函数并将结果作为<code>HTTP</code>响应消息返回。 例如，实现简单计算器操作（例如，加法和减法）的 <code>Web API</code> 可以提供公开这些操作作为伪资源的<code>URI</code>，并使用查询字符串来指定所需的参数。 例如，向 <code>URI */add?operand1=99&amp;operand2=1*</code>发出 <code>GET</code>请求会返回正文包含值 100 的响应消息。 但是，请尽量少使用这些形式的 URI。</p>
<h2 id="根据-HTTP-方法定义操作"><a href="#根据-HTTP-方法定义操作" class="headerlink" title="根据 HTTP 方法定义操作"></a>根据 HTTP 方法定义操作</h2><p><code>HTTP</code>协议定义了大量为请求赋于语义的方法。 大多数 <code>RESTful Web API</code>使用的常见 <code>HTTP</code> 方法是：</p>
<ul>
<li><p><strong>GET</strong> 检索位于指定<code>URI</code>处的资源的表示形式。 响应消息的正文包含所请求资源的详细信息。</p>
</li>
<li><p><strong>POST</strong> 在指定的 <code>URI</code> 处创建新资源。 请求消息的正文将提供新资源的详细信息。 请注意，<code>POST</code> 还用于触发不实际创建资源的操作。</p>
</li>
<li><p><strong>PUT</strong> 在指定的 <code>URI</code>处创建或替换资源。 请求消息的正文指定要创建或更新的资源。</p>
</li>
<li><p><strong>PATCH</strong> 对资源执行部分更新。 请求正文包含要应用到资源的一组更改。</p>
</li>
<li><p><strong>DELETE</strong> 删除位于指定<code>URI</code> 处的资源。</p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特定请求的影响应取决于资源是集合还是单个子项。 下表汇总了使用电子商务示例的大多数<code>RESTful</code>实现所采用的常见约定。 请注意，并非所有这些请求都可以实现；这取决于特定方案。</p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>资源</strong></th>
<th style="text-align:left"><strong>POST</strong></th>
<th style="text-align:left"><strong>GET</strong></th>
<th style="text-align:left"><strong>PUT</strong></th>
<th style="text-align:left"><strong>DELETE</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>/customers</code></td>
<td style="text-align:left">创建新客户</td>
<td style="text-align:left">检索所有客户</td>
<td style="text-align:left">批量更新客户</td>
<td style="text-align:left">删除所有客户</td>
</tr>
<tr>
<td style="text-align:left"><code>/customers/1</code></td>
<td style="text-align:left">错误</td>
<td style="text-align:left">检索客户 1 的详细信息</td>
<td style="text-align:left">如果客户 1 存在，则更新其详细信息</td>
<td style="text-align:left">删除客户 1</td>
</tr>
<tr>
<td style="text-align:left"><code>/customers/1/orders</code></td>
<td style="text-align:left">创建客户 1 的新订单</td>
<td style="text-align:left">检索客户 1 的所有订单</td>
<td style="text-align:left">批量更新客户 1 的订单</td>
<td style="text-align:left">删除客户 1 的所有订单</td>
</tr>
</tbody>
</table>
<p><code>POST、PUT</code>和 <code>PATCH</code>之间的差异可能会引起混淆。</p>
<ul>
<li><strong><code>POST</code> 请求创建资源</strong>。 服务器为新资源分配 <code>URI</code>，并将该<code>URI</code> 返回给客户端。 在<code>REST</code> 模型中，我们经常向集合应用 <code>POST</code> 请求。 新资源将添加到集合中。 还可以使用 <code>POST</code>请求将待处理数据提交到现有资源，且不创建任何新资源。</li>
<li><strong><code>PUT</code> 请求创建资源或更新现有资源</strong>。 客户端指定资源的 <code>URI</code>。 请求正文包含资源的完整表示形式。<strong> 如果已存在具有此 <code>URI</code> 的资源，则替换该资源</strong>。 否则创建新资源（如果服务器支持此操作）。<code>PUT</code>请求往往应用到单项资源（例如特定的客户）而不是集合。 服务器可能支持通过<code>PUT</code> 更新，但不支持通过<code>PUT</code>执行创建。 是否支持通过 <code>PUT</code> 执行创建取决于在创建某个资源之前，客户端能否以有意义的方式向该资源分配 <code>URI</code>。 如果不能，则可以使用 <code>POST</code>来创建资源，并使用 <code>PUT</code> 或 <code>PATCH</code>来执行更新。</li>
<li><strong><code>PATCH</code>请求对现有资源执行部分更新</strong>。 客户端指定资源的 <code>URI</code>。 请求正文指定要应用到资源的更改集。 这比使用 <code>PUT</code> 更高效，因为客户端只发送更改，而无需发送资源的整个表示形式。 从技术上讲，如果服务器支持，<code>PATCH</code>也可以创建新资源（通过对一个<code>“null”</code>资源指定一组更新）。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>PUT</code> 请求必须是幂等的</strong>。 <strong>如果客户端多次提交同一个<code>PUT</code>请求，结果应始终相同</strong>（使用相同的值修改相同的资源）。 无法保证<code>POST</code>和 <code>PATCH</code>请求的幂等性。</p>
<h2 id="符合-HTTP-语义"><a href="#符合-HTTP-语义" class="headerlink" title="符合 HTTP 语义"></a>符合 HTTP 语义</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本部分阐述在设计符合<code>HTTP</code> 规范的 <code>API</code>时的一些典型注意事项。 但是，本部分不会一一介绍具体细节或方案。如有疑问，请查阅<code>HTTP</code>规范。</p>
<h3 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如前所述，<strong>客户端和服务器交换资源的表示形式</strong>。 例如，在<code>POST</code>请求中，请求正文包含要创建的资源的表示形式。 在 <code>GET</code> 请求中，响应正文包含已提取的资源的表示形式。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>HTTP</code> 协议中，格式是使用媒体类型（也称为 <code>MIME</code>类型）指定的。 对于非二进制数据，大多数 <code>Web API</code>支持<code>JSON</code>（媒体类型 = <code>application/json</code>），可能还支持 <code>XML</code>（媒体类型 = <code>application/xml</code>）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>请求或响应中的 <code>Content-Type</code>标头指定表示形式的格式</strong>。 下面是包含<code>JSON</code> 数据的<code>POST</code>请求示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">https://adventure-works.com/orders</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json; charset=utf-8</span><br><span class="line"><span class="attribute">Content-Length</span>: 57</span><br><span class="line"></span><br><span class="line">&#123;"Id":1,"Name":"Gizmo","Category":"Widgets","Price":1.99&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果服务器不支持媒体类型，则应返回 <code>HTTP</code>状态代码 415（不支持的媒体类型）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>客户端请求可以包含一个 <code>Accept</code> 标头，该标头包含客户端可以接受的、来自服务器的响应消息中的媒体类型列表</strong>。 例如：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">https://adventure-works.com/orders/2</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Accept</span>: application/json</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果服务器无法匹配所列的任何媒体类型，应返回<code>HTTP</code> 状态代码 406（不可接受）。</p>
<h3 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;成功的 <code>GET</code>方法通常返回<code>HTTP</code>状态代码 200（正常）。 如果找不到资源，该方法应返回 404（未找到）。</p>
<h3 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 <code>POST</code> 方法创建了新资源，则会返回 <code>HTTP</code>状态代码 201（已创建）。 新资源的 <code>URI</code>包含在响应的 <code>Location</code> 标头中。 响应正文包含资源的表示形式。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果该方法执行了一些处理但未创建新资源，则可以返回<code>HTTP</code>状态代码 200，并在响应正文中包含操作结果。或者，如果没有可返回的结果，该方法可以返回<code>HTTP</code> 状态代码 204（无内容）但不返回任何响应正文。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果客户端将无效数据放入请求，服务器应返回<code>HTTP</code>状态代码 400（错误的请求）。 响应正文可以包含有关错误的其他信息，或包含可提供更多详细信息的 <code>URI</code>链接。</p>
<h3 id="PUT-方法"><a href="#PUT-方法" class="headerlink" title="PUT 方法"></a>PUT 方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与 <code>POST</code>方法一样，如果<code>PUT</code>方法创建了新资源，则会返回 <code>HTTP</code> 状态代码 201（已创建）。 如果该方法更新了现有资源，则会返回 200（正常）或 204（无内容）。 在某些情况下，可能无法更新现有资源。 在这种情况下，可考虑返回 HTTP 状态代码 409（冲突）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请考虑实现可批量更新集合中的多个资源的批量 <code>HTTP PUT</code> 操作。 <code>PUT</code>请求应指定集合的<code>URI</code>，而请求正文则应指定要修改的资源的详细信息。 此方法可帮助减少交互成本并提高性能。</p>
<h3 id="PATCH-方法"><a href="#PATCH-方法" class="headerlink" title="PATCH 方法"></a>PATCH 方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端可以使用 <code>PATCH</code> 请求向现有资源发送一组修补文档形式的更新。 服务器将处理该修补文档以执行更新。 修补文档不会描述整个资源，而只描述一组要应用的更改。 <code>PATCH</code> 方法的规范 (<a href="https://tools.ietf.org/html/rfc5789" target="_blank" rel="noopener">RFC 5789</a>) 未定义修补文档的特定格式。 必须从请求中的媒体类型推断格式。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JSON</code>也许是 <code>Web API</code> 的最常用数据格式。 有两种基于 <code>JSON</code>的主要修补格式，分别称作“<code>JSON</code>修补”和“<code>JSON</code> 合并修补”。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JSON</code>合并修补更简单一些。 修补文档的结构与原始 <code>JSON</code>资源相同，但只包含要更改或添加的字段的子集。 此外，可以通过在修补文档中为字段值指定 <code>null</code>，来删除该字段。 （这意味着，如果原始资源包含显式 null 值，则不适合使用合并修补。）</p>
<p>例如，假设原始资源采用以下<code>JSON</code>表示形式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"gizmo"</span>,</span><br><span class="line">    <span class="attr">"category"</span>:<span class="string">"widgets"</span>,</span><br><span class="line">    <span class="attr">"color"</span>:<span class="string">"blue"</span>,</span><br><span class="line">    <span class="attr">"price"</span>:<span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是此资源的可能<code>JSON</code>合并修补代码：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"price"</span>:<span class="number">12</span>,</span><br><span class="line">    <span class="attr">"color"</span>:<span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"size"</span>:<span class="string">"small"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此代码告知服务器要更新 <code>price</code>，删除 <code>color</code>，添加 <code>size</code> — <code>name</code>，不修改 <code>category</code>。 有关 JSON 合并修补的具体详细信息，请参阅 <a href="https://tools.ietf.org/html/rfc7396" target="_blank" rel="noopener">RFC 7396</a>。 <code>JSON</code>合并修补的媒体类型是 <code>application/merge-patch+json</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于修补文档中的 <code>null</code> 具有特殊的含义，如果原始资源包含显式 <code>null</code> 值，则不适合使用合并修补。 此外，修补文档不会指定服务器应用更新的顺序。 此限制是否造成影响具体取决于数据和域。 <a href="https://tools.ietf.org/html/rfc6902" target="_blank" rel="noopener">RFC 6902</a> 中定义的<code>JSON</code>修补更灵活。 它以操作序列的形式指定要应用的更改。 操作包括添加、删除、替换、复制和测试（以验证值）。<code>JSON</code>修补的媒体类型是 <code>application/json-patch+json</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是在处理 <code>PATCH</code> 请求时可能遇到的典型错误状态，以及相应的 <code>HTTP</code>状态代码。</p>
<table>
<thead>
<tr>
<th style="text-align:left">添加状态</th>
<th style="text-align:left">HTTP 状态代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">修补文档格式不受支持。</td>
<td style="text-align:left">415（媒体类型不受支持）</td>
</tr>
<tr>
<td style="text-align:left">修补文档的格式不正确。</td>
<td style="text-align:left">400（错误的请求）</td>
</tr>
<tr>
<td style="text-align:left">修补文档有效，但无法将更改应用到处于当前状态的资源。</td>
<td style="text-align:left">409（冲突）</td>
</tr>
</tbody>
</table>
<h3 id="DELETE-方法"><a href="#DELETE-方法" class="headerlink" title="DELETE 方法"></a>DELETE 方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果删除操作成功，<code>Web</code> 服务器应以 <code>HTTP</code>状态代码 204 做出响应，指示已成功处理该过程，但响应正文不包含其他信息。 如果资源不存在，<code>Web</code> 服务器可以返回 <code>HTTP 404</code>（未找到）。</p>
<h3 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时，<code>POST、PUT、PATCH 或 DELETE</code>操作可能需要经过一段时间的处理才能完成。 如果需要等待该操作完成后才能向客户端发送响应，可能会造成不可接受的延迟。 在这种情况下，请考虑将该操作设置为异步操作。 返回 <code>HTTP</code>状态代码 202（已接受），指示该请求已接受进行处理，但尚未完成。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>应公开一个可返回异步请求状态的终结点，使客户端能够通过轮询状态终结点来监视状态</strong>。 <strong>在 202 响应的 <code>Location</code>标头中包含状态终结点的 <code>URI</code></strong>。 例如：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">202</span> Accepted</span><br><span class="line"><span class="attribute">Location</span>: /api/status/12345</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果客户端向此终结点发送 <code>GET</code> 请求，响应中应包含该请求的当前状态。 （可选）响应中还可以包含预计完成时间，或者用于取消操作的链接。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    "status":"In progress",</span><br><span class="line">    "link": &#123; "rel":"cancel", "method":"delete", "href":"/api/status/12345" &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果异步操作创建了新资源，则该操作完成后，状态终结点应返回状态代码 303（查看其他）。 在 303 响应中，包含一个 <code>Location</code> 标头用于提供新资源的 <code>URI</code>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">303</span> See Other</span><br><span class="line"><span class="attribute">Location</span>: /api/orders/12345</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有关详细信息，请参阅 <a href="https://www.adayinthelifeof.nl/2011/06/02/asynchronous-operations-in-rest/" target="_blank" rel="noopener">REST 中的异步操作</a>。</p>
<h2 id="数据筛选和分页"><a href="#数据筛选和分页" class="headerlink" title="数据筛选和分页"></a>数据筛选和分页</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过单个 <code>URI</code> 公开资源的集合可能会导致应用程序在只需一部分信息时提取大量数据。 例如，假设某个客户端应用程序需要查找成本超过特定值的所有订单。 它可以从 <code>/orders URI</code>检索所有订单，然后在客户端筛选这些订单。显然，此过程的效率非常低下。 它浪费了托管 <code>Web API</code>的服务器的网络带宽和处理能力。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>API</code> 可以允许在<code>URI</code>的查询字符串中传递筛选器，例如 <code>*/orders?minCost=n*</code>。 然后，<code>Web API</code>负责分析和处理查询字符串中的 <code>minCost</code> 参数并在服务器端返回筛选后的结果。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对集合资源执行的 <code>GET</code> 请求可能返回大量的项。 应将<code>Web API</code>设计为限制任何单个请求返回的数据量。 请考虑支持查询字符串指定要检索的最大项数和集合中的起始偏移量。 例如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/orders?limit=25&amp;offset=50</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，请考虑<strong>对返回的项数指定上限，以防拒绝服务攻击</strong>。 若要帮助客户端应用程序，返回分页数据的 <code>GET</code>请求还应包含某种形式的元数据，以指示集合中可用的资源总数。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以<strong>通过提供一个将字段名称用作值的 <code>soft</code> 参数（例如 <code>/orders?sort=ProductID</code>），使用类似的策略对提取的数据排序</strong>。 但是，此方法会对缓存产生负面影响，因为查询字符串参数构成许多缓存实现用作缓存数据的键的资源标识符的一部分。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>如果每个项包含大量数据，可以扩展此方法来限制针对每个项返回的字段</strong>。 例如，可以使用接受以逗号分隔的字段列表的查询字符串参数，例如 <code>/orders?fields=ProductID,Quantity</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>为查询字符串中的所有可选参数提供有意义的默认值</strong>。 例如，如果实现分页，将 <code>limit</code> 参数设为 10，将 <code>offset</code> 参数设为 0；如果实现排序，将排序参数设为资源的键；如果支持投影，将 <code>fields</code> 参数设为资源中的所有字段。</p>
<h2 id="支持大型二进制资源的部分响应"><a href="#支持大型二进制资源的部分响应" class="headerlink" title="支持大型二进制资源的部分响应"></a>支持大型二进制资源的部分响应</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;资源可能包含大型二进制字段，例如文件或图像。 若要解决不可靠和间歇性连接导致的问题并缩短响应时间，请考虑分块检索此类资源。 为此，对于针对大型资源发出的 <code>GET</code> 请求，<code>Web API</code>应支持 <code>Accept-Ranges</code>标头。 此标头指示 <code>GET</code> 操作支持“部分”请求。 客户端应用程序可以提交返回指定为字节范围的资源子集的 <code>GET</code>请求。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，请考虑对这些资源实现 <code>HTTP HEAD</code>请求。 <strong><code>HEAD</code> 请求与 <code>GET</code>请求类似，不过，前者只返回描述资源的 <code>HTTP</code>标头和空消息正文</strong>。 客户端应用程序可以发出 <code>HEAD</code>请求以确定是否要通过使用部分<code>GET</code>请求获取某个资源。 例如：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="string">https://adventure-works.com/products/10?fields=productImage</span> HTTP/1.1</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是响应消息的示例：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"></span><br><span class="line"><span class="attribute">Accept-Ranges</span>: bytes</span><br><span class="line"><span class="attribute">Content-Type</span>: image/jpeg</span><br><span class="line"><span class="attribute">Content-Length</span>: 4580</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Content-Length</code>标头指定资源的总大小，<code>Accept-Ranges</code> 标头指示相应的 <code>GET</code>操作支持部分结果</strong>。 客户端应用程序可以使用此信息以较小的区块检索图像。 第一个请求通过使用 <code>Range</code>标头提取前 2500 个字节：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">https://adventure-works.com/products/10?fields=productImage</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Range</span>: bytes=0-2499</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;响应消息通过返回 <code>HTTP</code>状态代码 206 指示这是部分响应。 <code>Content-Length</code> 标头指定消息正文中返回的实际字节数（不是资源的大小），<code>Content-Range</code>标头指示这是该资源的哪一部分（第 0 到 2499 字节，总共 4580 个字节）:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">206</span> Partial Content</span><br><span class="line"></span><br><span class="line"><span class="attribute">Accept-Ranges</span>: bytes</span><br><span class="line"><span class="attribute">Content-Type</span>: image/jpeg</span><br><span class="line"><span class="attribute">Content-Length</span>: 2500</span><br><span class="line"><span class="attribute">Content-Range</span>: bytes 0-2499/4580</span><br><span class="line"></span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;来自客户端应用程序的后续请求可以检索资源的剩余部分。</p>
<h2 id="使用-HATEOAS-导航到相关资源"><a href="#使用-HATEOAS-导航到相关资源" class="headerlink" title="使用 HATEOAS 导航到相关资源"></a>使用 HATEOAS 导航到相关资源</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>REST</code>背后的主要动机之一是它应能够导航整个资源集，而无需事先了解 <code>URI</code>方案。 每个 <code>HTTP GET</code> 请求应通过响应中包含的超链接返回查找与所请求的对象直接相关的资源所需的信息，还应为它提供描述其中每个资源提供的操作的信息。 此原则称为<code>HATEOAS</code>或作为应用程序状态引擎的超文本。 该系统实际上是有限状态机，每个请求的响应包含从一种状态转为另一种状态所需的信息；任何其他信息都不应是必需的。</p>
<p><strong>备注</strong>：当前没有任何标准或规范定义如何为 <code>HATEOAS</code> 原则建模。 此节中所示的示例说明了一个可能的解决方案。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，若要处理订单与客户之间的关系，可以在订单的表示形式中包含链接，用于指定下单客户可以执行的操作。下面是可能的表示形式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"orderID"</span>:<span class="number">3</span>,</span><br><span class="line">  <span class="attr">"productID"</span>:<span class="number">2</span>,</span><br><span class="line">  <span class="attr">"quantity"</span>:<span class="number">4</span>,</span><br><span class="line">  <span class="attr">"orderValue"</span>:<span class="number">16.60</span>,</span><br><span class="line">  <span class="attr">"links"</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"rel"</span>:<span class="string">"customer"</span>,</span><br><span class="line">      <span class="attr">"href"</span>:<span class="string">"https://adventure-works.com/customers/3"</span>,</span><br><span class="line">      <span class="attr">"action"</span>:<span class="string">"GET"</span>,</span><br><span class="line">      <span class="attr">"types"</span>:[<span class="string">"text/xml"</span>,<span class="string">"application/json"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"rel"</span>:<span class="string">"customer"</span>,</span><br><span class="line">      <span class="attr">"href"</span>:<span class="string">"https://adventure-works.com/customers/3"</span>,</span><br><span class="line">      <span class="attr">"action"</span>:<span class="string">"PUT"</span>,</span><br><span class="line">      <span class="attr">"types"</span>:[<span class="string">"application/x-www-form-urlencoded"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"rel"</span>:<span class="string">"customer"</span>,</span><br><span class="line">      <span class="attr">"href"</span>:<span class="string">"https://adventure-works.com/customers/3"</span>,</span><br><span class="line">      <span class="attr">"action"</span>:<span class="string">"DELETE"</span>,</span><br><span class="line">      <span class="attr">"types"</span>:[]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"rel"</span>:<span class="string">"self"</span>,</span><br><span class="line">      <span class="attr">"href"</span>:<span class="string">"https://adventure-works.com/orders/3"</span>,</span><br><span class="line">      <span class="attr">"action"</span>:<span class="string">"GET"</span>,</span><br><span class="line">      <span class="attr">"types"</span>:[<span class="string">"text/xml"</span>,<span class="string">"application/json"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"rel"</span>:<span class="string">"self"</span>,</span><br><span class="line">      <span class="attr">"href"</span>:<span class="string">"https://adventure-works.com/orders/3"</span>,</span><br><span class="line">      <span class="attr">"action"</span>:<span class="string">"PUT"</span>,</span><br><span class="line">      <span class="attr">"types"</span>:[<span class="string">"application/x-www-form-urlencoded"</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"rel"</span>:<span class="string">"self"</span>,</span><br><span class="line">      <span class="attr">"href"</span>:<span class="string">"https://adventure-works.com/orders/3"</span>,</span><br><span class="line">      <span class="attr">"action"</span>:<span class="string">"DELETE"</span>,</span><br><span class="line">      <span class="attr">"types"</span>:[]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在此示例中，<code>links</code> 数组包含一组链接。 每个链接表示可对相关实体执行的操作。 每个链接的数据包含关系 (“<code>customer</code>“)、URI (<code>https://adventure-works.com/customers/3</code>)、<code>HTTP</code>方法和支持的 <code>MIME</code>类型。 这是客户端应用程序在调用操作时所需的全部信息。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>links</code> 数组还包含有关已检索的资源本身的自引用信息。 这些链接包含关系 <code>self</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;返回的链接集可能会根据资源的状态发生更改。 这就是为何将超文本称作“应用程序状态引擎”的原因。</p>
<h2 id="对-RESTful-Web-API-进行版本控制"><a href="#对-RESTful-Web-API-进行版本控制" class="headerlink" title="对 RESTful Web API 进行版本控制"></a>对 RESTful Web API 进行版本控制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Web API</code> 一直保持静态的可能性很小。 随着业务需求变化，可能会添加新的资源集合，资源之间的关系可能会更改，并且可能会修改资源中的数据结构。 虽然更新<code>Web API</code>以处理新的或不同的需求是一个相对简单的过程，但你必须考虑此类更改将对使用该 <code>Web API</code> 的客户端应用程序造成的影响。 问题在于尽管设计和实现 <code>Web API</code>的开发人员可以完全控制该<code>API</code>，但开发人员对客户端应用程序不具有相同程度的控制，因为这些客户端应用程序可能是由远程运营的第三方组织生成的。 <strong>主要规则是要让现有客户端应用程序能够继续不变地正常运行，同时允许新客户端应用程序利用新功能和新资源</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;版本控制使 <code>Web API</code>可以指定它所公开的功能和资源，并且客户端应用程序可以提交定向到特定版本的功能或资源的请求。 以下各节介绍几种不同的方法，其中每一种方法都有其自己的优势和不足。</p>
<h3 id="无版本控制"><a href="#无版本控制" class="headerlink" title="无版本控制"></a>无版本控制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是最简单的方法，它对于一些内部 <code>API</code>来说可能是可以接受的。 较大的更改可以表示为新资源或新链接。 向现有资源添加内容可能未呈现重大更改，因为不应查看此内容的客户端应用程序将直接忽略它。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，向 URI <code>https://adventure-works.com/customers/3</code> 发出请求应返回包含客户端应用程序所需的 <code>id</code>、<code>name</code> 和 <code>address</code> 字段的单个客户的详细信息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json; charset=utf-8</span><br><span class="line"></span><br><span class="line">&#123;"id":3,"name":"Contoso LLC","address":"1 Microsoft Way Redmond WA 98053"&#125;</span><br></pre></td></tr></table></figure>
<p><strong>备注</strong>：为简单起见，本部分中所示的示例响应不包含 <code>HATEOAS</code>链接。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 <code>DateCreated</code> 字段已添加到客户资源的架构中，则响应将如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json; charset=utf-8</span><br><span class="line"></span><br><span class="line">&#123;"id":3,"name":"Contoso LLC","dateCreated":"2014-09-04T12:11:38.0376089Z","address":"1 Microsoft Way Redmond WA 98053"&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现有的客户端应用程序可能会继续正常工作（如果能够忽略无法识别的字段），而新的客户端应用程序则可以设计为处理该新字段。 但是，如果对资源的架构进行了更根本的更改（如删除或重命名字段）或资源之间的关系发生更改，则这些更改可能构成重大更改，从而阻止现有客户端应用程序正常工作。 在这些情况下应考虑以下方法之一。</p>
<h3 id="URI-版本控制"><a href="#URI-版本控制" class="headerlink" title="URI 版本控制"></a>URI 版本控制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次修改<code>Web API</code>或更改资源的架构时，<strong>向每个资源的<code>URI</code>添加版本号</strong>。 以前存在的 <code>URI</code>应像以前一样继续运行，并返回符合原始架构的资源。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;继续前面的示例，如果将 <code>address</code> 字段重构为包含地址的每个构成部分的子字段（例如 <code>streetAddress</code>、<code>city</code>、<code>state</code> 和 <code>zipCode</code>），则此版本的资源可通过包含版本号的 URI（如 <code>https://adventure-works.com/v2/customers/3</code>）公开：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json; charset=utf-8</span><br><span class="line"></span><br><span class="line">&#123;"id":3,"name":"Contoso LLC","dateCreated":"2014-09-04T12:11:38.0376089Z","address":&#123;"streetAddress":"1 Microsoft Way","city":"Redmond","state":"WA","zipCode":98053&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此版本控制机制非常简单，但依赖于将请求路由到相应终结点的服务器。 但是，随着<code>Web API</code> 经过多次迭代而变得成熟，服务器必须支持多个不同版本，它可能变得难以处理。 此外，从单纯的角度来看，在所有情况下客户端应用程序都要提取相同数据（客户 3），因此<code>URI</code> 实在不应该因版本而有所不同。 此方案也增加了 <code>HATEOAS</code>实现的复杂性，因为所有链接都需要在其 <code>URI</code> 中包括版本号。</p>
<h3 id="查询字符串版本控制"><a href="#查询字符串版本控制" class="headerlink" title="查询字符串版本控制"></a>查询字符串版本控制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不是提供多个 <code>URI</code>，而是可以通过在追加到 <code>HTTP</code> 请求后面的<strong>查询字符串中使用参数来指定资源的版本</strong>，例如 <code>https://adventure-works.com/customers/3?version=2</code>。 如果<code>version</code>参数被较旧的客户端应用程序省略，则应默认为有意义的值（例如 1）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此方法具有语义优势（即，同一资源始终从同一<code>URI</code> 进行检索），但它依赖于代码处理请求以分析查询字符串并发送回相应的 <code>HTTP</code>响应。 此方法也与 <code>URI</code> 版本控制机制一样，增加了实现 <code>HATEOAS</code>的复杂性。</p>
<p><strong>备注</strong>：某些较旧的 <code>Web</code>浏览器和 <code>Web</code>代理不会缓存在<code>URI</code>中包含查询字符串的请求的响应。 这可能会降低<code>web</code> 应用程序，使用 <code>web API</code>并且从运行此类的 <code>web</code>浏览器的性能。</p>
<h3 id="标头版本控制"><a href="#标头版本控制" class="headerlink" title="标头版本控制"></a>标头版本控制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不是追加版本号作为查询字符串参数，而是可以实现指示资源的版本的<strong>自定义标头</strong>。 此方法需要客户端应用程序将相应标头添加到所有请求，虽然如果省略了版本标头，处理客户端请求的代码可以使用默认值（版本 1）。 下面的示例使用了名为<code>Custom-Header</code>的自定义标头。 此标头的值指示 <code>Web API</code> 的版本。</p>
<p>版本 1：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">https://adventure-works.com/customers/3</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Custom-Header</span>: api-version=1</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json; charset=utf-8</span><br><span class="line"></span><br><span class="line">&#123;"id":3,"name":"Contoso LLC","address":"1 Microsoft Way Redmond WA 98053"&#125;</span><br></pre></td></tr></table></figure>
<p>版本 2：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">https://adventure-works.com/customers/3</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Custom-Header</span>: api-version=2</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/json; charset=utf-8</span><br><span class="line"></span><br><span class="line">&#123;"id":3,"name":"Contoso LLC","dateCreated":"2014-09-04T12:11:38.0376089Z","address":&#123;"streetAddress":"1 Microsoft Way","city":"Redmond","state":"WA","zipCode":98053&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，与前面两个方法一样，实现 <code>HATEOAS</code>需要在任何链接中包括相应的自定义标头。</p>
<h3 id="媒体类型版本控制"><a href="#媒体类型版本控制" class="headerlink" title="媒体类型版本控制"></a>媒体类型版本控制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如本指南前面所述，当客户端应用程序向 <code>Web</code> 服务器发送 <code>HTTP GET</code>请求时，它应使用<strong><code>Accept</code>标头规定它可以处理的内容的格式</strong>。 通常，<em>Accept</em> 标头的用途是允许客户端应用程序指定响应的正文应是<code>XML、JSON</code> 还是客户端可以分析的其他某种常见格式。 但是，可以定义包括以下信息的自定义媒体类型：该信息使客户端应用程序可以指示它所需的资源版本。 下面的示例演示了将<code>Accept</code> 标头指定为值 <code>application/vnd.adventure-works.v1+json</code> 的请求。 <code>vnd.adventure-works.v1</code>元素向 Web 服务器指示它应返回资源的版本 1，而 <code>json</code> 元素则指定响应正文的格式应为<code>JSON</code>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">https://adventure-works.com/customers/3</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Accept</span>: application/vnd.adventure-works.v1+json</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;处理请求的代码负责处理 <code>Accept</code> 标头并尽可能采用该值（客户端应用程序可以在<code>Accept</code>标头中指定多种格式，在这种情况下，<code>Web</code> 服务器可以在其中选择最适合的格式用于响应正文）。 <code>Web</code>服务器使用 <code>Content-Type</code> 标头确认响应正文中的数据格式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Content-Type</span>: application/vnd.adventure-works.v1+json; charset=utf-8</span><br><span class="line"></span><br><span class="line">&#123;"id":3,"name":"Contoso LLC","address":"1 Microsoft Way Redmond WA 98053"&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 <code>Accept</code> 标头未指定任何已知的媒体类型，则 <code>Web</code>服务器可以生成 <code>HTTP 406</code>（不可接受）响应消息或返回使用默认媒体类型的消息。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此方法可以说是最纯粹的版本控制机制并自然地适用于<code>HATEOAS</code>，后者可以在资源链接中包含相关数据的 <code>MIME</code>类型。</p>
<p> <strong>备注</strong>：选择版本控制策略时，还应考虑对性能的影响，尤其是在 <code>Web</code> 服务器上缓存时。 <code>URI</code>版本控制和查询字符串版本控制方案都是缓存友好的，因为同一 <code>URI</code>/查询字符串组合每次都指向相同的数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标头版本控制和媒体类型版本控制机制通常需要其他逻辑来检查自定义标头或 <code>Accept</code> 标头中的值。 在大型环境中，使用不同版本的 <code>Web API</code>的多个客户端可能会在服务器端缓存中生成大量重复数据。 如果客户端应用程序通过实现缓存的代理与 <code>Web</code>服务器进行通信，并且该代理在当前未在其缓存中保留所请求数据的副本时，仅将请求转发到 <code>Web</code> 服务器，则此问题可能会变得很严重。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/09/Google API设计指南/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/Google API设计指南/" itemprop="url">Google API设计指南</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-09T12:12:57+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/API设计/" itemprop="url" rel="index">
                    <span itemprop="name">API设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Google-API设计指南"><a href="#Google-API设计指南" class="headerlink" title="Google API设计指南"></a>Google API设计指南</h1><h2 id="面向资源的设计"><a href="#面向资源的设计" class="headerlink" title="面向资源的设计"></a>面向资源的设计</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本设计指南的目标是帮助开发者设计<strong>简单、一致且易用</strong>的网络 <code>API</code>。同时，它还有助于将 <code>RPC API</code>（基于套接字）与 <code>REST API</code>（基于 <code>HTTP</code>）的设计融合起来。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RPC API</code>通常根据接口和方法设计。随着时间的推移，接口和方法越来越多，最终结果可能是形成一个庞大而混乱的<code>API</code>接口，因为开发者必须单独学习每种方法。显然，这既耗时又容易出错。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>引入 <a href="http://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="noopener">REST</a> 架构风格主要是为了与 HTTP/1.1 配合使用，但也有助于解决这个问题。其核心原则是定义可以用少量方法控制的命名资源</strong>。资源和方法被称为 API 的“名词”和“动词”。使用 HTTP 协议时，资源名称自然映射到网址，方法自然映射到 HTTP 的 <code>POST</code>、<code>GET</code>、<code>PUT</code>、<code>PATCH</code> 和 <code>DELETE</code> 方法。这使得开发者可以假定资源拥有相同数量的少量标准方法，他们只需要学习较少的东西并专注于资源及其关系。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;近来，<code>HTTP REST API</code> 在互联网上取得了巨大成功。2010 年，大约 74％ 的公共网络<code>API</code> 是<code>HTTP REST API</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然<code>HTTP REST API</code> 在互联网上非常流行，但它们承载的流量比传统的 <code>RPC API</code>要小。例如，美国高峰时段大约一半的互联网流量是视频内容，显然出于性能考虑，很少有人会使用 <code>REST API</code>来传送此类内容。在数据中心内，许多公司使用基于套接字的 <code>RPC API</code>来承载大多数网络流量，这可能涉及比公共 <code>REST API</code>高几个数量级的数据（以字节为单位）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实际使用中，人们会出于不同目的选择 <code>RPC API</code>和 <code>HTTP REST API</code>，理想情况下，<code>API</code>平台应该为所有类型的<code>API</code> 提供最佳支持。本设计指南可帮助您设计和构建符合此原则的 <code>API</code>。它将面向资源的设计原则应用于通用<code>API</code>设计并定义了许多常见的设计模式，从而提高可用性并降低复杂性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>注意</strong>：本设计指南介绍了如何将 <code>REST</code> 原则应用于 <code>API</code> 设计，与编程语言、操作系统或网络协议无关。这不仅仅是一个创建 <code>REST API</code>的指南。</p>
<h3 id="什么是-REST-API？"><a href="#什么是-REST-API？" class="headerlink" title="什么是 REST API？"></a>什么是 REST API？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>REST API</code>是可单独寻址的“资源”（<code>API</code>中的“名词”）的“集合”。资源通过<a href="https://cloud.google.com/apis/design/resource_names" target="_blank" rel="noopener">资源名称</a>被引用，并通过一组“方法”（也称为“动词”或“操作”）进行控制。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>REST Google API</code> 的“标准方法”（也称为“REST 方法”）包括 <code>List</code>、<code>Get</code>、<code>Create</code>、<code>Update</code> 和 <code>Delete</code>。<code>API</code> 设计者还可以使用“自定义方法”（也称为“自定义动词”或“自定义操作”）来实现无法轻易映射到标准方法的功能（例如数据库事务）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>注意</strong>：自定义动词并不意味着创建自定义 <code>HTTP</code> 动词来支持自定义方法。对基于<code>HTTP</code> 的 <code>API</code> 而言，它们只是映射到最合适的 <code>HTTP</code> 动词。</p>
<h3 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h3><p>设计指南建议在设计面向资源的 <code>API</code> 时采取以下步骤（更多细节将在下面的特定部分中介绍）：</p>
<ul>
<li>确定 <code>API</code>提供的资源类型。</li>
<li>确定资源之间的关系。</li>
<li>根据类型和关系确定资源名称方案。</li>
<li>确定资源架构。</li>
<li>将最小的方法集附加到资源。</li>
</ul>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>面向资源的 API 通常被构建为资源层次结构，其中每个节点是一个“简单资源”或“集合资源”</strong>。为方便起见，它们通常被分别称为资源和集合。</p>
<ul>
<li>一个集合包含<strong>相同类型</strong>的资源列表。例如，一个用户拥有一组联系人。</li>
<li>资源具有一些状态和零个或多个子资源。每个子资源可以是一个简单资源或一个集合资源。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，<code>Gmail API</code> 有一组用户，每个用户都有一组消息、一组线程、一组标签、一个个人资料资源和若干设置资源。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然存储系统和<code>REST API</code>之间存在一些概念上的对应，但具有面向资源<code>API</code>的服务不一定是数据库，并且在解释资源和方法方面具有极大的灵活性。例如，创建日历事件（资源）可以为参与者创建附加事件、向参与者发送电子邮件邀请、预约会议室以及更新视频会议时间安排。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>面向资源的 API 的关键特性是，强调资源（数据模型）甚于资源上执行的方法（功能）</strong>。典型的面向资源的 <code>API</code> 使用少量方法公开大量资源。方法可以是标准方法或自定义方法。在本指南中，标准方法是：<code>List</code>、<code>Get</code>、<code>Create</code>、<code>Update</code>和 <code>Delete</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>如果<code>API</code> 功能能够自然映射到标准方法，则应该在 <code>API</code> 设计中使用该方法</strong>。<strong>如果功能不能自然映射到标准方法，则可以使用“自定义方法”</strong>。<a href="https://cloud.google.com/apis/design/custom_methods" target="_blank" rel="noopener">自定义方法</a>提供与传统 <code>RPC API</code> 相同的设计自由度，可用于实现常见的编程模式，例如数据库事务或数据分析。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下部分介绍了如何将面向资源的 <code>API</code>设计应用于大规模服务的一些实际示例。您可以在 <a href="https://github.com/googleapis/googleapis" target="_blank" rel="noopener">Google API</a> 代码库中找到更多示例。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这些示例中，星号表示列表中的一个特定资源。</p>
<h4 id="Gmail-API"><a href="#Gmail-API" class="headerlink" title="Gmail API"></a>Gmail API</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Gmail API</code> 服务实现了 <code>Gmail API</code> 并公开了大多数<code>Gmail</code>功能。它具有以下资源模型：</p>
<ul>
<li><p>API 服务：<code>gmail.googleapis.com</code></p>
</li>
<li><p>用户集合：<code>users/*</code></p>
<p>每个用户都拥有以下资源。</p>
<ul>
<li>消息集合：<code>users/*/messages/*</code></li>
<li>线程集合：<code>users/*/threads/*</code></li>
<li>标签集合：<code>users/*/labels/*</code></li>
<li>更改历史记录的集合：<code>users/*/history/*</code></li>
<li>表示用户个人资料的资源：<code>users/*/profile</code></li>
<li>表示用户设置的资源：<code>users/*/settings</code></li>
</ul>
</li>
</ul>
<h4 id="Cloud-Pub-Sub-API"><a href="#Cloud-Pub-Sub-API" class="headerlink" title="Cloud Pub/Sub API"></a>Cloud Pub/Sub API</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>pubsub.googleapis.com</code> 服务实现了 <a href="https://cloud.google.com/pubsub" target="_blank" rel="noopener">Cloud Pub/Sub API</a>，它定义了以下资源模型：</p>
<ul>
<li>API 服务：<code>pubsub.googleapis.com</code></li>
<li>主题集合：<code>projects/*/topics/*</code></li>
<li>订阅集合：<code>projects/*/subscriptions/*</code></li>
</ul>
<p><strong>注意</strong>：<code>Pub/Sub API</code> 的其他实现可以选择不同的资源命名方案。</p>
<h4 id="Cloud-Spanner-API"><a href="#Cloud-Spanner-API" class="headerlink" title="Cloud Spanner API"></a>Cloud Spanner API</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>spanner.googleapis.com</code> 服务实现了 <a href="https://cloud.google.com/spanner" target="_blank" rel="noopener">Cloud Spanner API</a>，它定义了以下资源模型：</p>
<ul>
<li>API 服务：<code>spanner.googleapis.com</code></li>
<li>实例集合：<code>projects/*/instances/*</code></li>
<li>实例操作的集合：<code>projects/*/instances/*/operations/*</code></li>
<li>数据库的集合：<code>projects/*/instances/*/databases/*</code></li>
<li>数据库操作的集合：<code>projects/*/instances/*/databases/*/operations/*</code></li>
<li>数据库会话的集合：<code>projects/*/instances/*/databases/*/sessions/*</code></li>
</ul>
<h2 id="资源名称"><a href="#资源名称" class="headerlink" title="资源名称"></a>资源名称</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在面向资源的 <code>API</code>中，“资源”是被命名的实体，“资源名称”是它们的标识符。<strong>每个资源都必须具有自己唯一的资源名称</strong>。<strong>资源名称由资源自身的 ID、任何父资源的 ID 及其 API 服务名称组成</strong>。在下文中，我们将查看资源 ID 以及如何构建资源名称。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>gRPC API</code>应使用无传输协议的 <a href="http://tools.ietf.org/html/rfc3986" target="_blank" rel="noopener">URI</a> 作为资源名称。它们通常遵循 <code>REST</code>网址规则，其行为与网络文件路径非常相似。它们可以轻松映射到 REST 网址：如需了解详情，请参阅<a href="https://cloud.google.com/apis/design/standard_methods" target="_blank" rel="noopener">标准方法</a>部分。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>“集合”是一种特殊的资源，包含相同类型的子资源列表</strong>。例如，目录是文件资源的集合。集合的资源 ID 称为集合 ID。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>资源名称由集合 ID 和资源 ID 构成，按分层方式组织并以正斜杠分隔</strong>。如果资源包含子资源，则子资源的名称由父资源名称后跟子资源的 ID 组成，也以正斜杠分隔。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例 1：存储服务具有一组 <code>buckets</code>，其中每个存储分区都有一组 <code>objects</code>：</p>
<table>
<thead>
<tr>
<th style="text-align:left">API 服务名称</th>
<th style="text-align:left">集合 ID</th>
<th style="text-align:left">资源 ID</th>
<th style="text-align:left">集合 ID</th>
<th style="text-align:left">资源 ID</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">//storage.googleapis.com</td>
<td style="text-align:left">/buckets</td>
<td style="text-align:left">/bucket-id</td>
<td style="text-align:left">/objects</td>
<td style="text-align:left">/object-id</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例 2：电子邮件服务具有一组 <code>users</code>。每个用户都有一个 <code>settings</code> 子资源，而 <code>settings</code> 子资源拥有包括 <code>customFrom</code> 在内的许多其他子资源：</p>
<table>
<thead>
<tr>
<th style="text-align:left">API 服务名称</th>
<th style="text-align:left">集合 ID</th>
<th style="text-align:left">资源 ID</th>
<th style="text-align:left">资源 ID</th>
<th style="text-align:left">资源 ID</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">//mail.googleapis.com</td>
<td style="text-align:left">/users</td>
<td style="text-align:left"><a href="mailto:/name@example.com" target="_blank" rel="noopener">/name@example.com</a></td>
<td style="text-align:left">/settings</td>
<td style="text-align:left">/customFrom</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>API 生产者可以为资源和集合 ID 选择任何可接受的值，只要它们在资源层次结构中是唯一的</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过拆分资源名称（例如 <code>name.split(&quot;/&quot;)[n]</code>），可以获得单个集合 ID 和资源 ID（假设任何段都不包含正斜杠）。</p>
<h3 id="完整资源名称"><a href="#完整资源名称" class="headerlink" title="完整资源名称"></a>完整资源名称</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无传输协议的 <a href="http://tools.ietf.org/html/rfc3986" target="_blank" rel="noopener">URI</a> 由 <a href="http://tools.ietf.org/html/rfc1035" target="_blank" rel="noopener">DNS 兼容的</a> API 服务名称和资源路径组成。资源路径也称为“相对资源名称”。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;//library.googleapis.com/shelves/shelf1/books/book2&quot;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>API</code>服务名称供客户端定位<code>API</code>服务端点；它<strong>可以</strong>是仅限内部服务的虚构 DNS 名称。如果 API 服务名称在上下文中很明显，则通常使用相对资源名称。</p>
<h3 id="相对资源名称"><a href="#相对资源名称" class="headerlink" title="相对资源名称"></a>相对资源名称</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开头没有“/”的 URI 路径 (<a href="http://tools.ietf.org/html/rfc3986#appendix-A" target="_blank" rel="noopener">path-noscheme</a>)。它标识 API 服务中的资源。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;shelves/shelf1/books/book2&quot;</span><br></pre></td></tr></table></figure>
<h3 id="资源-ID"><a href="#资源-ID" class="headerlink" title="资源 ID"></a>资源 ID</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标识其父资源中资源的非空<code>URI</code>段 (<a href="http://tools.ietf.org/html/rfc3986#appendix-A" target="_blank" rel="noopener">segment-nz-nc</a>)，请参见上文的示例。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;资源名称末尾的资源 ID <strong>可以</strong>具有多个 <code>URI 段</code>。例如：</p>
<table>
<thead>
<tr>
<th style="text-align:left">集合 ID</th>
<th style="text-align:left">资源 ID</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">files</td>
<td style="text-align:left">/source/py/parser.py</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;API 服务<strong>应该</strong>尽可能使用网址友好的资源 ID。资源 ID <strong>必须</strong>被清楚地记录，无论它们是由客户端、服务器还是其中一个分配的。例如，文件名通常由客户端分配，而电子邮件消息 ID 通常由服务器分配。</p>
<h3 id="集合-ID"><a href="#集合-ID" class="headerlink" title="集合 ID"></a>集合 ID</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标识其父资源中集合资源的非空 <code>URI</code>段 (<a href="http://tools.ietf.org/html/rfc3986#appendix-A" target="_blank" rel="noopener">segment-nz-nc</a>)，请参见上文的示例。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于集合 ID 通常出现在生成的客户端库中，因此它们<strong>必须</strong>符合以下要求：</p>
<ul>
<li><p><strong>必须</strong>是有效的 <code>C/C++</code> 标识符。</p>
</li>
<li><p><strong>必须</strong>是复数形式的首字母小写驼峰体。如果该词语没有合适的复数形式，例如“evidence（证据）”和“weather（天气）”，则<strong>应该</strong>使用单数形式。</p>
</li>
<li><p><strong>必须</strong>使用简明扼要的英文词语。</p>
</li>
<li><p><strong>应该</strong>避免过于笼统的词语，或对其进行限定后再使用。例如，<code>rowValues</code> 好于<code>values</code></p>
<p><strong>应该</strong>避免在不加以限定的情况下使用以下词语：</p>
<ul>
<li>elements</li>
<li>entries</li>
<li>instances</li>
<li>items</li>
<li>objects</li>
<li>resources</li>
<li>types</li>
<li>values</li>
</ul>
</li>
</ul>
<h3 id="资源名称和网址"><a href="#资源名称和网址" class="headerlink" title="资源名称和网址"></a>资源名称和网址</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然完整的资源名称类似于普通网址，但两者并不相同。<strong>单个资源可以由不同的 API 版本、API 协议或 API 网络端点公开</strong>。完整资源名称未指明此类信息，因此在实际使用中必须将其映射到特定的 API 版本和 API 协议。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要通过 <code>REST API</code>使用完整资源名称，<strong>必须</strong>将其转换为 REST 网址，实现方法为<strong>在服务名称之前添加 HTTPS 传输协议、在资源路径之前添加 API 主要版本以及对资源路径进行网址转义</strong>。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// This is a calendar event resource name.</span><br><span class="line">&quot;//calendar.googleapis.com/users/john smith/events/123&quot;</span><br><span class="line"></span><br><span class="line">// This is the corresponding HTTP URL.</span><br><span class="line">&quot;https://calendar.googleapis.com/v3/users/john%20smith/events/123&quot;</span><br></pre></td></tr></table></figure>
<h3 id="资源名称为字符串"><a href="#资源名称为字符串" class="headerlink" title="资源名称为字符串"></a>资源名称为字符串</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除非存在向后兼容问题，否则 <code>Google API</code><strong>必须</strong>使用纯字符串来表示资源名称。资源名称<strong>应该</strong>像普通文件路径一样处理，并且它们不支持 <code>％</code>编码。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于资源定义，第一个字段<strong>应该</strong>是资源名称的字符串字段，并且<strong>应该</strong>称为 <code>name</code>。</p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意</strong>：以下代码示例使用 <a href="https://github.com/googleapis/googleapis/blob/master/google/api/http.proto" target="_blank" rel="noopener"><em>gRPC 转码</em></a>语法。请点击链接以查看详细信息。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">service LibraryService &#123;</span><br><span class="line">  rpc GetBook(GetBookRequest) returns (Book) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      get: &quot;/v1/&#123;name=shelves/*/books/*&#125;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  rpc CreateBook(CreateBookRequest) returns (Book) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      post: &quot;/v1/&#123;parent=shelves/*&#125;/books&quot;</span><br><span class="line">      body: &quot;book&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Book &#123;</span><br><span class="line">  // Resource name of the book. It must have the format of &quot;shelves/*/books/*&quot;.</span><br><span class="line">  // For example: &quot;shelves/shelf1/books/book2&quot;.</span><br><span class="line">  string name = 1;</span><br><span class="line"></span><br><span class="line">  // ... other properties</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message GetBookRequest &#123;</span><br><span class="line">  // Resource name of a book. For example: &quot;shelves/shelf1/books/book2&quot;.</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message CreateBookRequest &#123;</span><br><span class="line">  // Resource name of the parent resource where to create the book.</span><br><span class="line">  // For example: &quot;shelves/shelf1&quot;.</span><br><span class="line">  string parent = 1;</span><br><span class="line">  // The Book resource to be created. Client must not set the `Book.name` field.</span><br><span class="line">  Book book = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>注意</strong>：为了保证资源名称的一致性，前导正斜杠<strong>不得</strong>被任何网址模板变量捕获。例如，<strong>必须</strong>使用 <code>&quot;/v1/{name=shelves/*/books/*}&quot;</code> 网址模板，而不能使用 <code>&quot;/v1{name=/shelves/*/books/*}&quot;</code>。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="问：为什么不使用资源-ID-来标识资源？"><a href="#问：为什么不使用资源-ID-来标识资源？" class="headerlink" title="问：为什么不使用资源 ID 来标识资源？"></a>问：为什么不使用资源 ID 来标识资源？</h4><p>答：任何大型系统都有很多种资源。在使用资源 ID 来标识资源的时候，我们实际上是使用特定于资源的元组来标识资源，例如 <code>(bucket, object)</code> 或 <code>(user, album, photo)</code>。这会带来几个主要问题：</p>
<ul>
<li>开发者必须了解并记住这些匿名元组。</li>
<li>传递元组通常比传递字符串更难。</li>
<li>集中式基础架构（例如日志记录和访问控制系统）不理解专用元组。</li>
<li>专用元组限制了 API 设计的灵活性，例如提供可重复使用的 API 接口。例如，<a href="https://github.com/googleapis/googleapis/tree/master/google/longrunning" target="_blank" rel="noopener">长时间运行的操作</a>可以与许多其他 API 接口一起使用，因为它们使用灵活的资源名称。</li>
</ul>
<h4 id="问：为什么特殊字段名为-name-而不是-id？"><a href="#问：为什么特殊字段名为-name-而不是-id？" class="headerlink" title="问：为什么特殊字段名为 name 而不是 id？"></a>问：为什么特殊字段名为 <code>name</code> 而不是 <code>id</code>？</h4><p>答：特殊字段以资源“名称”的概念命名。一般来说，我们发现 <code>name</code> 的概念让开发者感到困惑。例如，文件名实际上只是名称还是完整路径？通过预留标准字段 <code>name</code>，开发人员不得不选择更合适的词语，例如 <code>display_name</code>、<code>title</code> 或 <code>full_name</code>。</p>
<h2 id="标准方法"><a href="#标准方法" class="headerlink" title="标准方法"></a>标准方法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本章定义了标准方法的概念，即 <code>List</code>、<code>Get</code>、<code>Create</code>、<code>Update</code> 和 <code>Delete</code>。标准方法可降低复杂性并提高一致性。<a href="https://github.com/googleapis/googleapis" target="_blank" rel="noopener">Google API</a> 代码库中超过 70％ 的 API 方法都是标准方法，这使得它们更易于学习和使用。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下表描述了如何将标准方法映射到 HTTP 方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">标准方法</th>
<th style="text-align:left">HTTP 映射</th>
<th style="text-align:left">HTTP 请求正文</th>
<th style="text-align:left">HTTP 响应正文</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">List</td>
<td style="text-align:left"><code>GET &lt;collection URL&gt;</code></td>
<td style="text-align:left">无</td>
<td style="text-align:left">资源*列表</td>
</tr>
<tr>
<td style="text-align:left">Get</td>
<td style="text-align:left"><code>GET &lt;resource URL&gt;</code></td>
<td style="text-align:left">无</td>
<td style="text-align:left">资源*</td>
</tr>
<tr>
<td style="text-align:left">Create</td>
<td style="text-align:left"><code>POST &lt;collection URL&gt;</code></td>
<td style="text-align:left">资源</td>
<td style="text-align:left">资源*</td>
</tr>
<tr>
<td style="text-align:left">Update</td>
<td style="text-align:left"><code>PUT or PATCH &lt;resource URL&gt;</code></td>
<td style="text-align:left">资源</td>
<td style="text-align:left">资源*</td>
</tr>
<tr>
<td style="text-align:left">Delete</td>
<td style="text-align:left"><code>DELETE &lt;resource URL&gt;</code></td>
<td style="text-align:left">无</td>
<td style="text-align:left"><code>google.protobuf.Empty</code>**</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*如果方法支持响应字段掩码以指定要返回的字段子集，则 <code>List</code>、<code>Get</code>、<code>Create</code> 和 <code>Update</code> 方法返回的资源<strong>可以</strong>包含部分数据。在某些情况下，API 平台对所有方法的字段掩码提供原生支持。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**从不立即移除资源的 <code>Delete</code> 方法（例如更新标志或创建长时间运行的删除操作）返回的响应<strong>应该</strong>包含长时间运行的操作或修改后的资源。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于在单个 <code>API</code>调用的时间跨度内未完成的请求，标准方法还<strong>可以</strong>返回<a href="https://github.com/googleapis/googleapis/blob/master/google/longrunning/operations.proto" target="_blank" rel="noopener">长时间运行的操作</a>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下部分详细描述了每种标准方法。这些示例显示了<code>.proto</code> 文件中定义的方法和 <code>HTTP</code> 映射的特殊注释。您可以在 <a href="https://github.com/googleapis/googleapis" target="_blank" rel="noopener">Google API</a> 代码库中找到许多使用标准方法的示例。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>List</code> 方法将一个集合名称和零个或多个参数作为输入，并返回与输入匹配的资源列表。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>List</code> 通常用于搜索资源。<code>List</code> 适用于来自单个集合的数据，该集合的<strong>大小有限且不进行缓存</strong>。对于更广泛的情况，<strong>应该</strong>使用<a href="https://cloud.google.com/apis/design/custom_methods" target="_blank" rel="noopener">自定义方法</a> <code>Search</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;批量 get（例如，获取多个资源 ID 并为每个 ID 返回对象的方法）<strong>应该</strong>被实现为自定义 <code>BatchGet</code> 方法，而不是 <code>List</code> 方法。但是，如果您有一个已经存在的可提供相同功能的 <code>List</code> 方法，则<strong>可以</strong>出于此目的重复使用 <code>List</code> 方法。如果您使用的是自定义 <code>BatchGet</code> 方法，则<strong>应该</strong>将其映射到 <code>HTTP GET</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;适用的常见模式：<code>分页、结果排序</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;适用的命名规则：<code>过滤字段、结果字段</code>。</p>
<p>HTTP 映射：</p>
<ul>
<li><code>List</code> 方法<strong>必须</strong>使用 HTTP <code>GET</code> 动词。</li>
<li>接收其资源正在列出的集合名称的请求消息字段<strong>应该</strong>映射到网址路径。如果集合名称映射到网址路径，则网址模板的最后一段（<a href="https://cloud.google.com/apis/design/resource_names#CollectionId" target="_blank" rel="noopener">集合 ID</a>）<strong>必须</strong>是字面量。</li>
<li>所有剩余的请求消息字段<strong>应该</strong>映射到网址查询参数。</li>
<li>没有请求正文，API 配置<strong>不得</strong>声明 <code>body</code> 子句。</li>
<li>响应正文<strong>应该</strong>包含资源列表以及可选元数据。</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// Lists books in a shelf.</span><br><span class="line">rpc ListBooks(ListBooksRequest) returns (ListBooksResponse) &#123;</span><br><span class="line">  // List method maps to HTTP GET.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // The `parent` captures the parent resource name, such as &quot;shelves/shelf1&quot;.</span><br><span class="line">    get: &quot;/v1/&#123;parent=shelves/*&#125;/books&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListBooksRequest &#123;</span><br><span class="line">  // The parent resource name, for example, &quot;shelves/shelf1&quot;.</span><br><span class="line">  string parent = 1;</span><br><span class="line"></span><br><span class="line">  // The maximum number of items to return.</span><br><span class="line">  int32 page_size = 2;</span><br><span class="line"></span><br><span class="line">  // The next_page_token value returned from a previous List request, if any.</span><br><span class="line">  string page_token = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListBooksResponse &#123;</span><br><span class="line">  // The field name should match the noun &quot;books&quot; in the method name.  There</span><br><span class="line">  // will be a maximum number of items returned based on the page_size field</span><br><span class="line">  // in the request.</span><br><span class="line">  repeated Book books = 1;</span><br><span class="line"></span><br><span class="line">  // Token to retrieve the next page of results, or empty if there are no</span><br><span class="line">  // more results in the list.</span><br><span class="line">  string next_page_token = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Get</code> 方法需要一个资源名称和零个或多个参数作为输入，并返回指定的资源。</p>
<p>HTTP 映射：</p>
<ul>
<li><code>Get</code> 方法<strong>必须</strong>使用 HTTP <code>GET</code> 动词。</li>
<li>接收资源名称的请求消息字段<strong>应该</strong>映射到网址路径。</li>
<li>所有剩余的请求消息字段<strong>应该</strong>映射到网址查询参数。</li>
<li>没有请求正文，API 配置<strong>不得</strong>声明 <code>body</code> 子句。</li>
<li>返回的资源<strong>应该</strong>映射到整个响应正文。</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Gets a book.</span><br><span class="line">rpc GetBook(GetBookRequest) returns (Book) &#123;</span><br><span class="line">  // Get maps to HTTP GET. Resource name is mapped to the URL. No body.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // Note the URL template variable which captures the multi-segment resource</span><br><span class="line">    // name of the requested book, such as &quot;shelves/shelf1/books/book2&quot;</span><br><span class="line">    get: &quot;/v1/&#123;name=shelves/*/books/*&#125;&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message GetBookRequest &#123;</span><br><span class="line">  // The field will contain name of the resource requested, for example:</span><br><span class="line">  // &quot;shelves/shelf1/books/book2&quot;</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Create</code> 方法需要一个父资源名称、一个资源以及零个或多个参数作为输入。它在指定的父资源下创建新资源，并返回新建的资源。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 API 支持创建资源，则<strong>应该</strong>为每一个可以创建的资源类型设置 <code>Create</code> 方法。</p>
<p>HTTP 映射：</p>
<ul>
<li><code>Create</code> 方法<strong>必须</strong>使用 HTTP <code>POST</code> 动词。</li>
<li>请求消息<strong>应该</strong>具有字段 <code>parent</code>，以指定要在其中创建资源的父资源名称。</li>
<li>包含资源的请求消息字段<strong>必须</strong>映射到请求正文。如果将 <code>google.api.http</code> 注释用于 <code>Create</code> 方法，则<strong>必须</strong>使用 <code>body: &quot;&lt;resource_field&gt;&quot;</code> 表单。</li>
<li>该请求<strong>可以</strong>包含名为 <code>&lt;resource&gt;_id</code> 的字段，以允许调用者选择客户端分配的 ID。该字段<strong>可以</strong>在资源内。</li>
<li>所有剩余的请求消息字段<strong>应该</strong>映射到网址查询参数。</li>
<li>返回的资源<strong>应该</strong>映射到整个 HTTP 响应正文。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 <code>Create</code> 方法支持客户端分配的资源名称并且资源已存在，则请求<strong>应该</strong>失败并显示错误代码 <code>ALREADY_EXISTS</code> 或使用服务器分配的不同的资源名称，并且文档应该清楚地记录创建的资源名称可能与传入的不同。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Create</code> 方法<strong>必须</strong>使用输入资源，以便在资源架构更改时，无需同时更新请求架构和资源架构。对于客户端无法设置的资源字段，<strong>必须</strong>将它们记录为“仅限输出”字段。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// Creates a book in a shelf.</span><br><span class="line">rpc CreateBook(CreateBookRequest) returns (Book) &#123;</span><br><span class="line">  // Create maps to HTTP POST. URL path as the collection name.</span><br><span class="line">  // HTTP request body contains the resource.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // The `parent` captures the parent resource name, such as &quot;shelves/1&quot;.</span><br><span class="line">    post: &quot;/v1/&#123;parent=shelves/*&#125;/books&quot;</span><br><span class="line">    body: &quot;book&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message CreateBookRequest &#123;</span><br><span class="line">  // The parent resource name where the book is to be created.</span><br><span class="line">  string parent = 1;</span><br><span class="line"></span><br><span class="line">  // The book id to use for this book.</span><br><span class="line">  string book_id = 3;</span><br><span class="line"></span><br><span class="line">  // The book resource to create.</span><br><span class="line">  // The field name should match the Noun in the method name.</span><br><span class="line">  Book book = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rpc CreateShelf(CreateShelfRequest) returns (Shelf) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v1/shelves&quot;</span><br><span class="line">    body: &quot;shelf&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message CreateShelfRequest &#123;</span><br><span class="line">  Shelf shelf = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Update</code> 方法需要一条包含一个资源的请求消息和零个或多个参数作为输入。它更新指定的资源及其属性，并返回更新后的资源。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了包含资源<a href="https://cloud.google.com/apis/design/resource_names#Definitions" target="_blank" rel="noopener">名称或父资源</a>的属性之外，<code>Update</code> 方法<strong>应该</strong>可以改变可变资源的属性。<code>Update</code> 方法<strong>不得</strong>包含任何“重命名”或“移动”资源的功能，这些功能<strong>应该</strong>由自定义方法来处理。</p>
<p>HTTP 映射：</p>
<ul>
<li>标准 <code>Update</code> 方法<strong>应该</strong>支持部分资源更新，并将 HTTP 动词 <code>PATCH</code> 与名为 <code>update_mask</code> 的 <code>FieldMask</code> 字段一起使用。 应忽略客户端提供的作为输入的<a href="https://cloud.google.com/apis/design/design_patterns#output_fields" target="_blank" rel="noopener">输出字段</a>。</li>
<li>需要更高级修补语义的 <code>Update</code> 方法（例如附加到重复字段）<strong>应该</strong>由<a href="https://cloud.google.com/apis/design/custom_methods" target="_blank" rel="noopener">自定义方法</a>提供。</li>
<li>如果 <code>Update</code> 方法仅支持完整资源更新，则<strong>必须</strong>使用 HTTP 动词 <code>PUT</code>。但是，强烈建议不要进行完整更新，因为在添加新资源字段时会出现向后兼容性问题。</li>
<li>接收资源名称的消息字段<strong>必须</strong>映射到网址路径。该字段<strong>可以</strong>位于资源消息本身中。</li>
<li>包含资源的请求消息字段<strong>必须</strong>映射到请求正文。</li>
<li>所有剩余的请求消息字段<strong>必须</strong>映射到网址查询参数。</li>
<li>响应消息<strong>必须</strong>是更新的资源本身。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 API 接受客户端分配的资源名称，则服务器<strong>可以</strong>允许客户端指定不存在的资源名称并创建新资源。否则，使用不存在的资源名称的 <code>Update</code> 方法<strong>应该</strong>失败。如果这是唯一的错误条件，则<strong>应该</strong>使用错误代码 <code>NOT_FOUND</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具有支持资源创建的 <code>Update</code> 方法的 API 还<strong>应该</strong>提供 <code>Create</code> 方法。原因是，如果 <code>Update</code> 方法是唯一的方法，则它将不知道如何创建资源。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Updates a book.</span><br><span class="line">rpc UpdateBook(UpdateBookRequest) returns (Book) &#123;</span><br><span class="line">  // Update maps to HTTP PATCH. Resource name is mapped to a URL path.</span><br><span class="line">  // Resource is contained in the HTTP request body.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // Note the URL template variable which captures the resource name of the</span><br><span class="line">    // book to update.</span><br><span class="line">    patch: &quot;/v1/&#123;book.name=shelves/*/books/*&#125;&quot;</span><br><span class="line">    body: &quot;book&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message UpdateBookRequest &#123;</span><br><span class="line">  // The book resource which replaces the resource on the server.</span><br><span class="line">  Book book = 1;</span><br><span class="line"></span><br><span class="line">  // The update mask applies to the resource. For the `FieldMask` definition,</span><br><span class="line">  // see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask</span><br><span class="line">  FieldMask update_mask = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Delete</code> 方法需要一个资源名称和零个或多个参数作为输入，并删除或计划删除指定的资源。<code>Delete</code> 方法<strong>应该</strong>返回 <code>google.protobuf.Empty</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;API <strong>不应该</strong>依赖 <code>Delete</code> 方法返回的任何信息，因为它<strong>不能</strong>重复调用。</p>
<p>HTTP 映射：</p>
<ul>
<li><p><code>Delete</code> 方法<strong>必须</strong>使用 HTTP <code>DELETE</code> 动词。</p>
</li>
<li><p>接收资源名称的请求消息字段<strong>应该</strong>映射到网址路径。</p>
</li>
<li><p>所有剩余的请求消息字段<strong>应该</strong>映射到网址查询参数。</p>
</li>
<li><p>没有请求正文，API 配置<strong>不得</strong>声明 <code>body</code> 子句。</p>
</li>
<li><p>如果 <code>Delete</code> 方法立即移除资源，则<strong>应该</strong>返回空响应。</p>
</li>
<li><p>如果 <code>Delete</code> 方法启动长时间运行的操作，则<strong>应该</strong>返回长时间运行的操作。</p>
</li>
<li><p>如果 <code>Delete</code> 方法仅将资源标记为已删除，则<strong>应该</strong>返回更新后的资源。</p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对 <code>Delete</code> 方法的调用在效果上应该是幂等的，但不需要产生相同的响应。任何数量的 <code>Delete</code> 请求都<strong>应该</strong>导致资源（最终）被删除，但只有第一个请求会产生成功代码。后续请求应生成 <code>google.rpc.Code.NOT_FOUND</code>。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Deletes a book.</span><br><span class="line">rpc DeleteBook(DeleteBookRequest) returns (google.protobuf.Empty) &#123;</span><br><span class="line">  // Delete maps to HTTP DELETE. Resource name maps to the URL path.</span><br><span class="line">  // There is no request body.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // Note the URL template variable capturing the multi-segment name of the</span><br><span class="line">    // book resource to be deleted, such as &quot;shelves/shelf1/books/book2&quot;</span><br><span class="line">    delete: &quot;/v1/&#123;name=shelves/*/books/*&#125;&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message DeleteBookRequest &#123;</span><br><span class="line">  // The resource name of the book to be deleted, for example:</span><br><span class="line">  // &quot;shelves/shelf1/books/book2&quot;</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本章将讨论如何在 API 设计中使用自定义方法。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自定义方法是指 5 个标准方法之外的 API 方法。这些方法<strong>应该</strong>仅用于标准方法不易表达的功能。通常情况下，API 设计者<strong>应该</strong>尽可能优先考虑使用标准方法，而不是自定义方法。标准方法具有大多数开发者熟悉的更简单且定义明确的语义，因此更易于使用且不易出错。另一项优势是 API 平台更加了解和支持标准方法，例如计费、错误处理、日志记录、监控。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自定义方法可以与资源、集合或服务关联。它<strong>可以</strong>接受任意请求和返回任意响应，并且还支持流式请求和响应。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自定义方法名称<strong>必须</strong>遵循方法命名惯例。</p>
<h3 id="HTTP-映射"><a href="#HTTP-映射" class="headerlink" title="HTTP 映射"></a>HTTP 映射</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于自定义方法，它们<strong>应该</strong>使用以下通用 HTTP 映射：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://service.name/v1/some/resource/name:customVerb</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>使用 <code>:</code> 而不是 <code>/</code> 将自定义动词与资源名称分开以便支持任意路径</strong>。例如，恢复删除文件可以映射到 <code>POST /files/a/long/file/name:undelete</code></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选择 HTTP 映射时，<strong>应</strong>遵循以下准则：</p>
<ul>
<li>自定义方法<strong>应该</strong>使用 HTTP <code>POST</code> 动词，因为该动词具有最灵活的语义，但作为替代 get 或 list 的方法（如有可能，<strong>可以</strong>使用 <code>GET</code>）除外。（详情请参阅第三条。）</li>
<li>自定义方法<strong>不应该</strong>使用 HTTP <code>PATCH</code>，但<strong>可以</strong>使用其他 HTTP 动词。在这种情况下，方法<strong>必须</strong>遵循该动词的标准 <a href="https://tools.ietf.org/html/rfc2616#section-9" target="_blank" rel="noopener">HTTP 语义</a>。</li>
<li>请注意，使用 HTTP <code>GET</code> 的自定义方法<strong>必须</strong>具有幂等性并且无负面影响。例如，在资源上实现特殊视图的自定义方法<strong>应该</strong>使用 HTTP <code>GET</code>。</li>
<li>接收与自定义方法关联的资源或集合的资源名称的请求消息字段<strong>应该</strong>映射到网址路径。</li>
<li>网址路径<strong>必须</strong>以包含冒号（后跟自定义动词）的后缀结尾。</li>
<li>如果用于自定义方法的 HTTP 动词允许 HTTP 请求正文（<code>POST</code>、<code>PUT</code>、<code>PATCH</code> 或自定义 HTTP 动词），则此自定义方法的 HTTP 配置<strong>必须</strong>使用 <code>body: &quot;*&quot;</code> 子句，所有其他请求消息字段都<strong>应</strong>映射到 HTTP 请求正文。</li>
<li>如果用于自定义方法的 HTTP 动词不接受 HTTP 请求正文（<code>GET</code>、<code>DELETE</code>），则此方法的 HTTP 配置<strong>不得</strong>使用 <code>body</code> 子句，并且所有其他请求消息字段都<strong>应</strong>映射到网址查询参数。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>警告</strong>：如果一个服务会实现多个 API，API 生产者<strong>必须</strong>仔细创建服务配置，以避免 API 之间的自定义动词发生冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// This is a service level custom method.</span><br><span class="line">rpc Watch(WatchRequest) returns (WatchResponse) &#123;</span><br><span class="line">  // Custom method maps to HTTP POST. All request parameters go into body.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v1:watch&quot;</span><br><span class="line">    body: &quot;*&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This is a collection level custom method.</span><br><span class="line">rpc ClearEvents(ClearEventsRequest) returns (ClearEventsResponse) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v3/events:clear&quot;</span><br><span class="line">    body: &quot;*&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This is a resource level custom method.</span><br><span class="line">rpc CancelEvent(CancelEventRequest) returns (CancelEventResponse) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v3/&#123;name=events/*&#125;:cancel&quot;</span><br><span class="line">    body: &quot;*&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This is a batch get custom method.</span><br><span class="line">rpc BatchGetEvents(BatchGetEventsRequest) returns (BatchGetEventsResponse) &#123;</span><br><span class="line">  // The batch get method maps to HTTP GET verb.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    get: &quot;/v3/events:batchGet&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><p>自定义方法适用于以下场景：</p>
<ul>
<li><strong>重启虚拟机。</strong> 设计备选方案可能是“在重启集合中创建一个重启资源”，这会让人感觉过于复杂，或者“虚拟机具有可变状态，客户端可以将状态从 RUNNING 更新到 RESTARTING”，这会产生可能存在哪些其他状态转换的问题。此外，重启是一个常见概念，可以合理转化为一个自定义方法，从直观上来说符合开发者的预期。</li>
<li><strong>发送邮件。</strong> 创建一个电子邮件消息不一定意味着要发送它（草稿）。与设计备选方案（将消息移动到“发件箱”集合）相比，自定义方法更容易被 API 用户发现，并且可以更直接地对概念进行建模。</li>
<li><strong>提拔员工。</strong> 如果作为标准 <code>update</code> 方法实现，客户端需要复制企业提拔流程管理政策，以确保提拔发生在正确的级别，并属于同一职业阶梯等等。</li>
<li><strong>批处理方法。</strong> 对于对性能要求苛刻的方法，提供自定义批处理方法<strong>可以</strong>有助于减少每个请求的开销。例如，<a href="https://developers.google.com/my-business/reference/rest/v4/accounts.locations/batchGet" target="_blank" rel="noopener">accounts.locations.batchGet</a>。</li>
</ul>
<p>以下是标准方法比自定义方法更适用的示例：</p>
<ul>
<li>使用不同查询参数的查询资源（使用带有标准列表过滤的标准 <code>list</code> 方法）。</li>
<li>简单的资源属性更改（使用带有字段掩码的标准 <code>update</code> 方法）。</li>
<li>关闭一个通知（使用标准 <code>delete</code> 方法）。</li>
</ul>
<h3 id="常用自定义方法"><a href="#常用自定义方法" class="headerlink" title="常用自定义方法"></a>常用自定义方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下是常用或有用的自定义方法名称的精选列表。API 设计者在引入自己的名称之前<strong>应该</strong>考虑使用这些名称，以提高 API 之间的一致性。</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法名称</th>
<th style="text-align:left">自定义动词</th>
<th style="text-align:left">HTTP 动词</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">取消</td>
<td style="text-align:left"><code>:cancel</code></td>
<td style="text-align:left"><code>POST</code></td>
<td style="text-align:left">取消一个未完成的操作（构建、计算等）</td>
</tr>
<tr>
<td style="text-align:left">BatchGet &lt;复数名词&gt;</td>
<td style="text-align:left"><code>:batchGet</code></td>
<td style="text-align:left"><code>GET</code></td>
<td style="text-align:left">批量获取多个资源。（详情请参阅<a href="https://cloud.google.com/apis/design/standard_methods#list" target="_blank" rel="noopener">列表描述</a>）</td>
</tr>
<tr>
<td style="text-align:left">移动</td>
<td style="text-align:left"><code>:move</code></td>
<td style="text-align:left"><code>POST</code></td>
<td style="text-align:left">将资源从一个父级移动到另一个父级。</td>
</tr>
<tr>
<td style="text-align:left">搜索</td>
<td style="text-align:left"><code>:search</code></td>
<td style="text-align:left"><code>GET</code></td>
<td style="text-align:left">List 的替代方法，用于获取不符合 List 语义的数据。</td>
</tr>
<tr>
<td style="text-align:left">恢复删除</td>
<td style="text-align:left"><code>:undelete</code></td>
<td style="text-align:left"><code>POST</code></td>
<td style="text-align:left">恢复之前删除的资源。建议的保留期限为 30 天。</td>
</tr>
</tbody>
</table>
<h2 id="标准字段"><a href="#标准字段" class="headerlink" title="标准字段"></a>标准字段</h2><table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>name</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left"><code>name</code> 字段应包含<a href="https://cloud.google.com/apis/design/resource_names#relative_resource_name" target="_blank" rel="noopener">相对资源名称</a>。</td>
</tr>
<tr>
<td style="text-align:left"><code>parent</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">对于资源定义和 List/Create 请求，<code>parent</code> 字段应包含父级<a href="https://cloud.google.com/apis/design/resource_names#relative_resource_name" target="_blank" rel="noopener">相对资源名称</a>。</td>
</tr>
<tr>
<td style="text-align:left"><code>create_time</code></td>
<td style="text-align:left"><code>Timestamp</code></td>
<td style="text-align:left">创建实体的时间戳。</td>
</tr>
<tr>
<td style="text-align:left"><code>update_time</code></td>
<td style="text-align:left"><code>Timestamp</code></td>
<td style="text-align:left">最后更新实体的时间戳。注意：执行 create/patch/delete 操作时会更新 update_time。</td>
</tr>
<tr>
<td style="text-align:left"><code>delete_time</code></td>
<td style="text-align:left"><code>Timestamp</code></td>
<td style="text-align:left">删除实体的时间戳，仅当它支持保留时才适用。</td>
</tr>
<tr>
<td style="text-align:left"><code>expire_time</code></td>
<td style="text-align:left"><code>Timestamp</code></td>
<td style="text-align:left">实体到期时的到期时间戳。</td>
</tr>
<tr>
<td style="text-align:left"><code>start_time</code></td>
<td style="text-align:left"><code>Timestamp</code></td>
<td style="text-align:left">标记某个时间段开始的时间戳。</td>
</tr>
<tr>
<td style="text-align:left"><code>end_time</code></td>
<td style="text-align:left"><code>Timestamp</code></td>
<td style="text-align:left">标记某个时间段或操作结束的时间戳（无论其成功与否）。</td>
</tr>
<tr>
<td style="text-align:left"><code>read_time</code></td>
<td style="text-align:left"><code>Timestamp</code></td>
<td style="text-align:left">应读取（如果在请求中使用）或已读取（如果在响应中使用）特定实体的时间戳。</td>
</tr>
<tr>
<td style="text-align:left"><code>time_zone</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">时区名称。它应该是 <a href="http://www.iana.org/time-zones" target="_blank" rel="noopener">IANA TZ</a> 名称，例如“America/Los_Angeles”。如需了解详情，请参阅 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones。" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/List_of_tz_database_time_zones。</a></td>
</tr>
<tr>
<td style="text-align:left"><code>region_code</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">位置的 Unicode 国家/地区代码 (CLDR)，例如“US”和“419”。如需了解详情，请访问 <a href="http://www.unicode.org/reports/tr35/#unicode_region_subtag。" target="_blank" rel="noopener">http://www.unicode.org/reports/tr35/#unicode_region_subtag。</a></td>
</tr>
<tr>
<td style="text-align:left"><code>language_code</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">BCP-47 语言代码，例如“en-US”或“sr-Latn”。如需了解详情，请参阅 <a href="http://www.unicode.org/reports/tr35/#Unicode_locale_identifier。" target="_blank" rel="noopener">http://www.unicode.org/reports/tr35/#Unicode_locale_identifier。</a></td>
</tr>
<tr>
<td style="text-align:left"><code>mime_type</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">IANA 发布的 MIME 类型（也称为媒体类型）。如需了解详情，请参阅 <a href="https://www.iana.org/assignments/media-types/media-types.xhtml。" target="_blank" rel="noopener">https://www.iana.org/assignments/media-types/media-types.xhtml。</a></td>
</tr>
<tr>
<td style="text-align:left"><code>display_name</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">实体的显示名称。</td>
</tr>
<tr>
<td style="text-align:left"><code>title</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">实体的官方名称，例如公司名称。它应被视为 <code>display_name</code> 的正式版本。</td>
</tr>
<tr>
<td style="text-align:left"><code>description</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">实体的一个或多个文本描述段落。</td>
</tr>
<tr>
<td style="text-align:left"><code>filter</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">List 方法的标准过滤器参数。</td>
</tr>
<tr>
<td style="text-align:left"><code>query</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">如果应用于搜索方法（即 <a href="https://cloud.google.com/apis/design/custom_methods#common_custom_methods" target="_blank" rel="noopener"><code>:search</code></a>），则与 <code>filter</code> 相同</td>
</tr>
<tr>
<td style="text-align:left"><code>page_token</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">List 请求中的分页令牌。</td>
</tr>
<tr>
<td style="text-align:left"><code>page_size</code></td>
<td style="text-align:left"><code>int32</code></td>
<td style="text-align:left">List 请求中的分页大小。</td>
</tr>
<tr>
<td style="text-align:left"><code>total_size</code></td>
<td style="text-align:left"><code>int32</code></td>
<td style="text-align:left">列表中与分页无关的项目总数。</td>
</tr>
<tr>
<td style="text-align:left"><code>next_page_token</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">List 响应中的下一个分页令牌。它应该用作后续请求的 <code>page_token</code>。空值表示不再有结果。</td>
</tr>
<tr>
<td style="text-align:left"><code>order_by</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">指定 List 请求的结果排序。</td>
</tr>
<tr>
<td style="text-align:left"><code>request_id</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">用于检测重复请求的唯一字符串 ID。</td>
</tr>
<tr>
<td style="text-align:left"><code>resume_token</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">用于恢复流式传输请求的不透明令牌。</td>
</tr>
<tr>
<td style="text-align:left"><code>labels</code></td>
<td style="text-align:left"><code>map&lt;string,string&gt;</code></td>
<td style="text-align:left">表示 Cloud 资源标签。</td>
</tr>
<tr>
<td style="text-align:left"><code>deleted</code></td>
<td style="text-align:left"><code>bool</code></td>
<td style="text-align:left">如果资源允许恢复删除行为，则必须具有 <code>deleted</code> 字段，该字段指示资源已删除。</td>
</tr>
<tr>
<td style="text-align:left"><code>show_deleted</code></td>
<td style="text-align:left"><code>bool</code></td>
<td style="text-align:left">如果资源允许恢复删除行为，相应的 List 方法必须具有 <code>show_deleted</code> 字段，以便客户端可以发现已删除的资源。</td>
</tr>
<tr>
<td style="text-align:left"><code>update_mask</code></td>
<td style="text-align:left"><a href="https://github.com/google/protobuf/blob/master/src/google/protobuf/field_mask.proto" target="_blank" rel="noopener"><code>FieldMask</code></a></td>
<td style="text-align:left">它用于 <code>Update</code> 请求消息，该消息用于对资源执行部分更新。此掩码与资源相关，而不是与请求消息相关。</td>
</tr>
<tr>
<td style="text-align:left"><code>validate_only</code></td>
<td style="text-align:left"><code>bool</code></td>
<td style="text-align:left">如果为 true，则表示仅应验证给定请求，而不执行该请求。</td>
</tr>
</tbody>
</table>
<h2 id="系统参数"><a href="#系统参数" class="headerlink" title="系统参数"></a>系统参数</h2><table>
<thead>
<tr>
<th style="text-align:left">网址查询参数</th>
<th style="text-align:left">HTTP/gRPC 标头</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>access_token</code>, <code>oauth_token</code></td>
<td style="text-align:left">授权</td>
<td style="text-align:left">OAuth 2.0 访问令牌。如需了解详细信息，请参阅 Cloud Platform<a href="https://cloud.google.com/docs/authentication/" target="_blank" rel="noopener"> 身份验证指南</a>。</td>
</tr>
<tr>
<td style="text-align:left"><code>$alt</code>, <code>alt</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">其他响应格式。支持的值为 <code>json</code>（默认）、<code>media</code>、<code>proto</code>（二进制 protobuf）。</td>
</tr>
<tr>
<td style="text-align:left"><code>$.xgafv</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">JSON 错误格式。支持的值为 <code>1</code>、<code>2</code>（默认）。错误格式 <code>1</code> 只应该由旧版客户端使用。</td>
</tr>
<tr>
<td style="text-align:left"><code>$callback</code>, <code>callback</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">JSONP 回调参数。</td>
</tr>
<tr>
<td style="text-align:left"><code>$ct</code></td>
<td style="text-align:left">Content-Type</td>
<td style="text-align:left">HTTP Content-Type 标头覆盖。</td>
</tr>
<tr>
<td style="text-align:left"><code>$fields</code>, <code>fields</code></td>
<td style="text-align:left">X-goog-FieldMask</td>
<td style="text-align:left">用于响应过滤的 FieldMask (google.protobufFieldMask)。如果为空，则返回所有字段。</td>
</tr>
<tr>
<td style="text-align:left"><code>$httpMethod</code></td>
<td style="text-align:left">X-HTTP-Method-Override</td>
<td style="text-align:left">请求的预期 HTTP 方法。部分网络代理不接受所有 HTTP 方法。</td>
</tr>
<tr>
<td style="text-align:left"><code>$key</code>, <code>key</code></td>
<td style="text-align:left">X-Goog-Api-Key</td>
<td style="text-align:left">如需了解 Google API 密钥的详情，请访问 <a href="https://developers.google.com/console/help/#generatingdevkeys。" target="_blank" rel="noopener">https://developers.google.com/console/help/#generatingdevkeys。</a></td>
</tr>
<tr>
<td style="text-align:left"><code>passwd</code>, <code>password</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">预留以防止将密码放入网址中。</td>
</tr>
<tr>
<td style="text-align:left"><code>$prettyPrint</code>, <code>prettyPrint</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">整齐打印 JSON 响应。支持的值为 <code>true</code>、<code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left"><code>$outputDefaults</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">强制输出 JSON 响应的原始默认值。</td>
</tr>
<tr>
<td style="text-align:left"><code>$unique</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">用于停用请求缓存的唯一查询参数。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">X-Goog-Api-Client</td>
<td style="text-align:left">API 客户端标识。该值是以空格分隔的 <code>NAME &quot;/&quot; SEMVER</code> 字符串列表，其中 <code>NAME</code> 只能包含小写字母、数字和“ - ”，并且 <code>SEMVER</code> 应为语义版本字符串。例如：X-Goog-Api-Client: python/3.5.0 grpc-google-pubsub-v1/0.1.0-beta2 linux/2.7.0。</td>
</tr>
<tr>
<td style="text-align:left"><code>$userProject</code></td>
<td style="text-align:left">X-Goog-User-Project</td>
<td style="text-align:left">负责配额计算和结算的调用者指定项目。调用者必须具有项目的 <code>serviceusage.services.use</code> 权限。</td>
</tr>
</tbody>
</table>
<h2 id="命名惯例"><a href="#命名惯例" class="headerlink" title="命名惯例"></a>命名惯例</h2><p>为了能够长时间在众多 API 中为开发者提供一致的体验，API 使用的所有名称都<strong>应该具有以下特点</strong>：</p>
<ul>
<li>简单</li>
<li>直观</li>
<li>一致</li>
</ul>
<p>这包括接口、资源、集合、方法和消息的名称。</p>
<p>由于很多开发者不是以英语为母语，所以这些命名惯例的目标之一是确保大多数开发者可以轻松理解 API。对于方法和资源，我们鼓励使用简单、直观和少量的词汇来命名。</p>
<ul>
<li>API 名称<strong>应该</strong>使用正确的美式英语。例如，使用美式英语的 license、color，而非英式英语的 licence、colour。</li>
<li>为了简化命名，<strong>可以</strong>使用已被广泛接受的简写形式或缩写。例如，API 优于 Application Programming Interface。</li>
<li>尽量使用直观、熟悉的术语。例如，如果描述移除（和销毁）一个资源，则删除优于擦除。</li>
<li>使用相同的名称或术语命名同样的概念，包括跨 API 共享的概念。</li>
<li>避免名称过载。使用不同的名称命名不同的概念。</li>
<li>避免在 API 的上下文以及更大的 Google API 生态系统中使用含糊不清且过于笼统的名称。这些名称可能导致对 API 概念的误解。相反，应选择能准确描述 API 概念的名称。这对定义一阶 API 元素（例如资源）的名称尤其重要。没有要避免使用的名称的明确列表，因为每个名称都必须放在其他名称的上下文中进行评估。实例、信息和服务是过去有问题的名称的示例。所选择的名称应该能清楚地描述 API 概念（例如：什么的实例？）并将其与其他相关概念区分开（例如：“alert”是指规则、信号还是通知？）。</li>
<li>仔细考虑是否使用可能与常用编程语言中的关键字相冲突的名称。您<strong>可以</strong>使用这些名称，但在 API 审核期间可能会触发额外的审查。因此应谨慎使用。</li>
</ul>
<h3 id="产品名称"><a href="#产品名称" class="headerlink" title="产品名称"></a>产品名称</h3><p>产品名称是指 API 的产品营销名称，例如 Google Calendar API。API、界面、文档、服务条款、对帐单以及商业合同等都<strong>必须</strong>使用统一的产品名称。Google API <strong>必须</strong>使用产品团队和营销团队批准的产品名称。</p>
<p>下表显示了所有相关 API 名称及其一致性的示例。如需详细了解各自名称及其命名惯例，请参阅本页面下方的详细信息。</p>
<table>
<thead>
<tr>
<th style="text-align:left">API 名称</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>产品名称</strong></td>
<td style="text-align:left">Google <strong>Calendar</strong> API</td>
</tr>
<tr>
<td style="text-align:left"><strong>服务名称</strong></td>
<td style="text-align:left"><code>calendar.googleapis.com</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>包名称</strong></td>
<td style="text-align:left"><code>google.calendar.v3</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>接口名称</strong></td>
<td style="text-align:left"><code>google.calendar.v3.CalendarService</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>源代码目录</strong></td>
<td style="text-align:left"><code>//google/calendar/v3</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>API 名称</strong></td>
<td style="text-align:left"><code>calendar</code></td>
</tr>
</tbody>
</table>
<h3 id="服务名称"><a href="#服务名称" class="headerlink" title="服务名称"></a>服务名称</h3><p>服务名称<strong>应该</strong>是语法上有效的 DNS 名称（遵循 <a href="http://www.ietf.org/rfc/rfc1035.txt" target="_blank" rel="noopener">RFC 1035</a>），可以解析为一个或多个网络地址。公开的 Google API 的服务名称采用 <code>xxx.googleapis.com</code> 格式。例如，Google Calendar 的服务名称是 <code>calendar.googleapis.com</code>。</p>
<p>如果一个 API 是由多个服务组成，则其名称<strong>应该</strong>更容易被发现。要做到这点，一种方法是使服务名称共享一个通用前缀。例如，<code>build.googleapis.com</code> 和 <code>buildresults.googleapis.com</code> 服务都是 Google Build API 的一部分。</p>
<h3 id="包名称"><a href="#包名称" class="headerlink" title="包名称"></a>包名称</h3><p>API .proto 文件中声明的包名称<strong>应该</strong>与产品和服务名称保持一致。某个版本的 API 的包名称<strong>必须</strong>以此版本结尾。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Google Calendar API</span><br><span class="line">package google.calendar.v3;</span><br></pre></td></tr></table></figure>
<p>与服务无直接关联的抽象 API（例如 Google Watcher API）<strong>应该</strong>使用与产品名称一致的 proto 包名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Google Watcher API</span><br><span class="line">package google.watcher.v1;</span><br></pre></td></tr></table></figure>
<p>API .proto 文件中指定的 Java 包名称<strong>必须</strong>与带有标准 Java 包名称前缀（<code>com.</code>、<code>edu.</code>、<code>net.</code> 等）的 proto 包名称相匹配。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package google.calendar.v3;</span><br><span class="line"></span><br><span class="line">// Specifies Java package name, using the standard prefix &quot;com.&quot;</span><br><span class="line">option java_package = &quot;com.google.calendar.v3&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="集合-ID-1"><a href="#集合-ID-1" class="headerlink" title="集合 ID"></a>集合 ID</h3><p><a href="https://cloud.google.com/apis/design/resource_names#collection_id" target="_blank" rel="noopener">集合 ID</a> <strong>应该</strong>使用复数形式并遵循 <code>lowerCamelCase</code>（小驼峰式命名法）格式，以及美式英语拼写和语义。例如：<code>events</code>、<code>children</code> 或 <code>deletedEvents</code>。</p>
<h3 id="接口名称"><a href="#接口名称" class="headerlink" title="接口名称"></a>接口名称</h3><p>为了避免与<a href="https://cloud.google.com/apis/design/naming_convention#service_names" target="_blank" rel="noopener">服务名称</a>（例如 <code>pubsub.googleapis.com</code>）混淆，术语“接口名称”是指在 .proto 文件中定义 <code>service</code> 时使用的名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Library is the interface name.</span><br><span class="line">service Library &#123;</span><br><span class="line">  rpc ListBooks(...) returns (...);</span><br><span class="line">  rpc ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以将服务名称视为对一组 API 实际实现的引用，而接口名称则是 API 的抽象定义。</p>
<p>接口名称<strong>应该</strong>使用直观的名词，例如 Calendar 或 Blob。该名称<strong>不应该</strong>与编程语言及其运行时库中的成熟概念（例如 File）相冲突。</p>
<p>在极少数情况下，接口名称会与 API 中的其他名称相冲突，此时<strong>应该</strong>使用后缀（例如 <code>Api</code> 或 <code>Service</code>）来消除歧义。</p>
<h3 id="方法名称"><a href="#方法名称" class="headerlink" title="方法名称"></a>方法名称</h3><p>服务<strong>可以</strong>在其 IDL 规范中定义一个或多个与集合和资源上的方法相对应的 RPC 方法。方法名称<strong>应该</strong>采用大驼峰式命名格式、遵循 <code>VerbNoun</code> 的命名惯例，其中 Noun（名词）通常是资源类型。</p>
<table>
<thead>
<tr>
<th style="text-align:left">动词</th>
<th style="text-align:left">名词</th>
<th style="text-align:left">方法名称</th>
<th style="text-align:left">请求消息</th>
<th style="text-align:left">响应消息</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>List</code></td>
<td style="text-align:left"><code>Book</code></td>
<td style="text-align:left"><code>ListBooks</code></td>
<td style="text-align:left"><code>ListBooksRequest</code></td>
<td style="text-align:left"><code>ListBooksResponse</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Get</code></td>
<td style="text-align:left"><code>Book</code></td>
<td style="text-align:left"><code>GetBook</code></td>
<td style="text-align:left"><code>GetBookRequest</code></td>
<td style="text-align:left"><code>Book</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Create</code></td>
<td style="text-align:left"><code>Book</code></td>
<td style="text-align:left"><code>CreateBook</code></td>
<td style="text-align:left"><code>CreateBookRequest</code></td>
<td style="text-align:left"><code>Book</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Update</code></td>
<td style="text-align:left"><code>Book</code></td>
<td style="text-align:left"><code>UpdateBook</code></td>
<td style="text-align:left"><code>UpdateBookRequest</code></td>
<td style="text-align:left"><code>Book</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Rename</code></td>
<td style="text-align:left"><code>Book</code></td>
<td style="text-align:left"><code>RenameBook</code></td>
<td style="text-align:left"><code>RenameBookRequest</code></td>
<td style="text-align:left"><code>RenameBookResponse</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Delete</code></td>
<td style="text-align:left"><code>Book</code></td>
<td style="text-align:left"><code>DeleteBook</code></td>
<td style="text-align:left"><code>DeleteBookRequest</code></td>
<td style="text-align:left"><code>google.protobuf.Empty</code></td>
</tr>
</tbody>
</table>
<p>方法名称的动词部分<strong>应该</strong>使用用于要求或命令的<a href="https://en.wikipedia.org/wiki/Imperative_mood#English" target="_blank" rel="noopener">祈使语气</a>，而不是用于提问的陈述语气。</p>
<p>如果动词提出关于 API 中的子资源的问题（经常使用陈述语气表示），则容易让人混淆。例如，要求 API 创建一本书，这显然是 <code>CreateBook</code>（祈使语气），但是询问 API 关于图书发行商的状态可能会使用陈述语气，例如 <code>IsBookPublisherApproved</code> 或 <code>NeedsPublisherApproval</code>。要在这种情况下保持祈使语气，请使用命令词（例如“check”(<code>CheckBookPublisherApproved</code>) 和“validate”(<code>ValidateBookPublisher</code>)。</p>
<p>方法名称<strong>不应</strong>包含介词（例如“For”、“With”、“At”、“To”）。通常，带有介词的方法名称表示正在使用新方法，应将一个字段添加到现有方法中，或者该方法应使用不同的动词。</p>
<p>例如，如果 <code>CreateBook</code> 消息已存在且您正在考虑添加 <code>CreateBookFromDictation</code>，请考虑使用 <code>TranscribeBook</code> 方法。</p>
<h3 id="消息名称"><a href="#消息名称" class="headerlink" title="消息名称"></a>消息名称</h3><p>消息名称<strong>应该</strong>简洁明了。避免不必要或多余的字词。如果相应的消息中没有形容词，则通常可以省略形容词。例如，如果没有非共享代理设置，则 <code>SharedProxySettings</code> 中的 <code>Shared</code> 是多余的。</p>
<p>消息名称<strong>不应</strong>包含介词（例如“With”、“For”）。通常，带有介词的消息名称可以通过消息上的可选字段来更好地表示。</p>
<h3 id="请求和响应消息"><a href="#请求和响应消息" class="headerlink" title="请求和响应消息"></a>请求和响应消息</h3><p>RPC 方法的请求和响应消息<strong>应该</strong>分别以带有后缀 <code>Request</code> 和 <code>Response</code> 的方法名称命名，除非方法请求或响应类型为以下类型：</p>
<ul>
<li>空消息（使用 <code>google.protobuf.Empty</code>)，</li>
<li>一个资源类型，或</li>
<li>一个表示操作的资源</li>
</ul>
<p>这通常适用于在标准方法 <code>Get</code>、<code>Create</code>、<code>Update</code> 或 <code>Delete</code> 中使用的请求或响应。</p>
<h3 id="枚举名称"><a href="#枚举名称" class="headerlink" title="枚举名称"></a>枚举名称</h3><p>枚举类型<strong>必须</strong>使用 UpperCamelCase 格式的名称。</p>
<p>枚举值<strong>必须</strong>使用 CAPITALIZED_NAMES_WITH_UNDERSCORES 格式。每个枚举值<strong>必须</strong>以分号（而不是逗号）结尾。第一个值<strong>应该</strong>命名为 ENUM_TYPE_UNSPECIFIED，因为在枚举值未明确指定时系统会返回此值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum FooBar &#123;</span><br><span class="line">  // The first value represents the default and must be == 0.</span><br><span class="line">  FOO_BAR_UNSPECIFIED = 0;</span><br><span class="line">  FIRST_VALUE = 1;</span><br><span class="line">  SECOND_VALUE = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="封装容器"><a href="#封装容器" class="headerlink" title="封装容器"></a>封装容器</h3><p>封装 proto2 枚举类型（其中 <code>0</code> 值具有非 <code>UNSPECIFIED</code> 的含义）的消息<strong>应该</strong>以后缀 <code>Value</code> 来命名，并具有名为 <code>value</code>的单个字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum OldEnum &#123;</span><br><span class="line">  VALID = 0;</span><br><span class="line">  OTHER_VALID = 1;</span><br><span class="line">&#125;</span><br><span class="line">message OldEnumValue &#123;</span><br><span class="line">  OldEnum value = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字段名称"><a href="#字段名称" class="headerlink" title="字段名称"></a>字段名称</h3><p>.proto 文件中的字段定义<strong>必须</strong>使用 lower_case_underscore_separated_names 格式。这些名称将映射到每种编程语言的生成代码中的原生命名惯例。</p>
<p>字段名称<strong>不应</strong>包含介词（例如“for”、“during”、“at”），例如：</p>
<ul>
<li><code>reason_for_error</code> 应该改成 <code>error_reason</code></li>
<li><code>cpu_usage_at_time_of_failure</code> 应该改成 <code>failure_time_cpu_usage</code></li>
</ul>
<p>字段名称<strong>不应</strong>使用后置形容词（名词后面的修饰符），例如：</p>
<ul>
<li><code>items_collected</code> 应该改成 <code>collected_items</code></li>
<li><code>objects_imported</code> 应该改成 <code>imported_objects</code></li>
</ul>
<h3 id="重复的字段名称"><a href="#重复的字段名称" class="headerlink" title="重复的字段名称"></a>重复的字段名称</h3><p>API 中的重复字段<strong>必须</strong>使用正确的复数形式。这符合现有 Google API 的命名惯例和外部开发者的共同预期。</p>
<h3 id="时间和时间段"><a href="#时间和时间段" class="headerlink" title="时间和时间段"></a>时间和时间段</h3><p>要表示一个与任何时区或日历无关的时间点，<strong>应该</strong>使用 <code>google.protobuf.Timestamp</code>，并且字段名称<strong>应该</strong>以 <code>time</code>（例如 <code>start_time</code> 和 <code>end_time</code>）结尾。</p>
<p>如果时间指向一个活动，则字段名称<strong>应该</strong>采用 <code>verb_time</code> 的形式，例如 <code>create_time</code> 和 <code>update_time</code>。请勿使用动词的过去时态，例如 <code>created_time</code> 或 <code>last_updated_time</code>。</p>
<p>要表示与任何日历和概念（如“天”或“月”）无关的两个时间点之间的时间跨度，<strong>应该</strong>使用 <code>google.protobuf.Duration</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message FlightRecord &#123;</span><br><span class="line">  google.protobuf.Timestamp takeoff_time = 1;</span><br><span class="line">  google.protobuf.Duration flight_duration = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果由于旧版或兼容性原因（包括系统时间、时长、推迟和延迟），您必须使用整数类型表示与时间相关的字段，那么字段名称<strong>必须</strong>采用以下格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xxx_&#123;time|duration|delay|latency&#125;_&#123;seconds|millis|micros|nanos&#125;</span><br><span class="line">message Email &#123;</span><br><span class="line">  int64 send_time_millis = 1;</span><br><span class="line">  int64 receive_time_millis = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果由于旧版或兼容性原因，不得不使用字符串类型表示时间戳，则字段名称<strong>不应该</strong>包含任何单位后缀。字符串表示形式<strong>应该</strong>使用 RFC 3339 格式，例如“2014-07-30T10:43:17Z”。</p>
<h3 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h3><p>对于与时区和时段无关的日期，<strong>应该</strong>使用 <code>google.type.Date</code>，并且该名称应具有后缀 <code>_date</code>。如果日期必须表示为字符串，则应采用 ISO 8601 日期格式 YYYY-MM-DD，例如 2014-07-30。</p>
<p>对于与时区和日期无关的时间，<strong>应该</strong>使用 <code>google.type.TimeOfDay</code>，并且该名称应具有后缀 <code>_time</code>。如果时间必须表示为字符串，则应采用 ISO 8601 24 小时制格式 HH:MM:SS[FFF]，例如 14:55:01.672。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message StoreOpening &#123;</span><br><span class="line">  google.type.Date opening_date = 1;</span><br><span class="line">  google.type.TimeOfDay opening_time = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数量"><a href="#数量" class="headerlink" title="数量"></a>数量</h3><p>由整数类型表示的数量<strong>必须</strong>包含度量单位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx_&#123;bytes|width_pixels|meters&#125;</span><br></pre></td></tr></table></figure>
<p>如果数量是条目计数，则该字段<strong>应该</strong>具有后缀 <code>_count</code>，例如 <code>node_count</code>。</p>
<h3 id="列表过滤器字段"><a href="#列表过滤器字段" class="headerlink" title="列表过滤器字段"></a>列表过滤器字段</h3><p>如果 API 支持对 <code>List</code> 方法返回的资源进行过滤，则包含过滤器表达式的字段<strong>应该</strong>命名为 <code>filter</code>。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message ListBooksRequest &#123;</span><br><span class="line">  // The parent resource name.</span><br><span class="line">  string parent = 1;</span><br><span class="line"></span><br><span class="line">  // The filter expression.</span><br><span class="line">  string filter = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="列表响应"><a href="#列表响应" class="headerlink" title="列表响应"></a>列表响应</h3><p><code>List</code> 方法的响应消息（包含资源列表）中的字段名称<strong>必须</strong>是资源名称本身的复数形式。例如，<code>CalendarApi.ListEvents()</code> 方法<strong>必须</strong>为返回的资源列表定义一个响应消息 <code>ListEventsResponse</code>，其中包含一个名为 <code>events</code> 的重复字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">service CalendarApi &#123;</span><br><span class="line">  rpc ListEvents(ListEventsRequest) returns (ListEventsResponse) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      get: &quot;/v3/&#123;parent=calendars/*&#125;/events&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListEventsRequest &#123;</span><br><span class="line">  string parent = 1;</span><br><span class="line">  int32 page_size = 2;</span><br><span class="line">  string page_token = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListEventsResponse &#123;</span><br><span class="line">  repeated Event events = 1;</span><br><span class="line">  string next_page_token = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="驼峰式命名法"><a href="#驼峰式命名法" class="headerlink" title="驼峰式命名法"></a>驼峰式命名法</h3><p>除了字段名称和枚举值之外，<code>.proto</code> 文件内的所有定义<strong>必须</strong>使用由 <a href="https://google.github.io/styleguide/javaguide.html#s5.3-camel-case" target="_blank" rel="noopener">Google Java 样式</a>定义的 UpperCamelCase（大驼峰式命名法）格式的名称。</p>
<h3 id="名称缩写"><a href="#名称缩写" class="headerlink" title="名称缩写"></a>名称缩写</h3><p>对于软件开发者熟知的名称缩写，例如 <code>config</code> 和 <code>spec</code>，<strong>应该</strong>在 API 定义中使用这些缩写，而不是完整拼写。这将使源代码易于读写。而在正式文档中，<strong>应该</strong>使用完整的名称。示例：</p>
<ul>
<li>config (configuration)</li>
<li>id (identifier)</li>
<li>spec (specification)</li>
<li>stats (statistics)</li>
</ul>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于一个 API 服务<strong>可以</strong>提供多个 <a href="https://cloud.google.com/apis/design/glossary#api_interface" target="_blank" rel="noopener">API 接口</a>，因此 <a href="https://cloud.google.com/apis/design/glossary#api_version" target="_blank" rel="noopener">API 版本控制</a>策略适用于 API 接口级层，而不是 <a href="https://cloud.google.com/apis/design/glossary#api_service" target="_blank" rel="noopener">API 服务</a>级层。为方便起见，此 API 术语是指以下部分中的 API 接口。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;联网 API <strong>应该</strong>使用<a href="http://semver.org/" target="_blank" rel="noopener">语义版本控制</a>。如果版本号为 <code>MAJOR.MINOR.PATCH</code>，请增加：</p>
<ol>
<li><code>MAJOR</code> 版本（如果进行不兼容的 API 更改），</li>
<li><code>MINOR</code> 版本（如果以向后兼容的方式添加功能），</li>
<li><code>PATCH</code> 版本（如果进行向后兼容的错误修复）。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定主要版本号的规则因 API 的版本而异，具体规则如下：</p>
<ul>
<li>对于 API 的版本 1 (v1)，主要版本号<strong>应该</strong>编码为 proto 包名称的最后一个组件，例如 <code>google.pubsub.v1</code>。在极少数情况下（即包中包含明显稳定且不会发生重大更改的类型和接口），主要版本号<strong>可以</strong>从 proto 包名称中省略，例如 <code>google.protobuf</code> 和 <code>google.longrunning</code>。</li>
<li>对于除 v1 之外的所有 API 版本，主要版本号<strong>必须</strong>编码为 proto 包名称的最后一个组件。例如 <code>google.pubsub.v2</code>。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于正式发布之前的版本（例如 alpha 和 beta 版本），建议为版本号附加后缀。后缀<strong>应该</strong>包含预发布版本名称（例如 alpha、beta）和可选的预发布版本号。</p>
<p>版本升级的示例：</p>
<table>
<thead>
<tr>
<th style="text-align:left">版本</th>
<th style="text-align:left">Proto 包</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">v1alpha</td>
<td style="text-align:left">v1alpha1</td>
<td style="text-align:left">v1 alpha 版本。</td>
</tr>
<tr>
<td style="text-align:left">v1beta1</td>
<td style="text-align:left">v1beta1</td>
<td style="text-align:left">v1 beta 1 版本。</td>
</tr>
<tr>
<td style="text-align:left">v1beta2</td>
<td style="text-align:left">v1beta2</td>
<td style="text-align:left">v1 的第二个 beta 版本。</td>
</tr>
<tr>
<td style="text-align:left">v1test</td>
<td style="text-align:left">v1test</td>
<td style="text-align:left">带有虚拟数据的内部测试版本。</td>
</tr>
<tr>
<td style="text-align:left">v1</td>
<td style="text-align:left">v1</td>
<td style="text-align:left">v1 主要版本，正式版。</td>
</tr>
<tr>
<td style="text-align:left">v1.1beta1</td>
<td style="text-align:left">v1p1beta1</td>
<td style="text-align:left">对 v1 进行细微更改的第一个 beta 版本。</td>
</tr>
<tr>
<td style="text-align:left">v1.1</td>
<td style="text-align:left">v1</td>
<td style="text-align:left">v1.1 版本的次要更新。</td>
</tr>
<tr>
<td style="text-align:left">v2beta1</td>
<td style="text-align:left">v2beta1</td>
<td style="text-align:left">v2 beta 1 版本。</td>
</tr>
<tr>
<td style="text-align:left">v2</td>
<td style="text-align:left">v2</td>
<td style="text-align:left">v2 主要版本，正式版。</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;次要和修补版本号<strong>应该</strong>反映在 API 配置和文档中。这些版本号<strong>不得</strong>在 proto 包名称中进行编码。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>注意</strong>：Google API 平台目前本身不支持次要和修补版本。对于每个主要 API 版本，只有一组文档和客户端库。API 所有者需要通过 API 文档和版本说明进行手动记录。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新的 API 主要版本<strong>不得</strong>依赖于<strong>同一 API</strong> 的先前主要版本。某一个 API <strong>可以</strong>依赖于其他 API，前提是了解这些 API 的依赖项和稳定性风险。稳定的 API 版本<strong>必须</strong>只依赖于其他 API 的最新稳定版本。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一段时间内，同一 API 的不同版本<strong>必须</strong>能够在单个客户端应用中同时工作。这是为了帮助客户端从 API 的旧版本顺利过渡到新版本。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;API 的旧版本只<strong>应该</strong>在其弃用期结束后移除。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由许多 API 共享的常见且稳定的数据类型（如日期和时间）<strong>应该</strong>在单独的 proto 包中定义。如果需要进行重大更改，则<strong>必须</strong>引入新的类型名称或带有新的主要版本的包名称。</p>
<h3 id="向后兼容性"><a href="#向后兼容性" class="headerlink" title="向后兼容性"></a>向后兼容性</h3><p>确定向后兼容的更改可能很困难。</p>
<p>以下列表是一份快速参考，但如果您有任何疑问，请参阅<a href="https://cloud.google.com/apis/design/compatibility" target="_blank" rel="noopener">设计兼容性页面</a>以获取更多详细信息。</p>
<h3 id="向后兼容的（非重大）更改"><a href="#向后兼容的（非重大）更改" class="headerlink" title="向后兼容的（非重大）更改"></a>向后兼容的（非重大）更改</h3><ul>
<li><p>向 API 服务添加 API 接口</p>
</li>
<li><p>向 API 接口添加方法</p>
</li>
<li><p>向方法添加 HTTP 绑定</p>
</li>
<li><p>向请求消息添加字段</p>
</li>
<li><p>向响应消息添加字段</p>
</li>
<li><p>向枚举添加值</p>
</li>
<li><p>添加仅限输出的资源字段</p>
</li>
</ul>
<h3 id="向后不兼容的（重大）更改"><a href="#向后不兼容的（重大）更改" class="headerlink" title="向后不兼容的（重大）更改"></a>向后不兼容的（重大）更改</h3><ul>
<li>移除或重命名服务、接口、字段、方法或枚举值</li>
<li>更改 HTTP 绑定</li>
<li>更改字段的类型</li>
<li>更改 proto 字段编号</li>
<li>更改资源名称格式</li>
<li>更改现有请求的可见行为</li>
<li>更改 HTTP 定义中的网址格式</li>
<li>向资源消息添加读取/写入字段</li>
</ul>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本页面详细介绍了<a href="https://cloud.google.com/apis/design/versioning" target="_blank" rel="noopener">版本控制</a>部分提供的重大更改和非重大更改的列表。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;何为重大（不兼容）更改，这个问题的答案并不完全明确。此处的指导说明<strong>应</strong>被视为每个可能更改的指示性列表而非完整列表。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此处列出的规则仅涉及客户端兼容性。API 提供方应该了解自己在部署方面的要求，包括实现详细信息的更改。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总体目标是将服务更新到新的次要版本或应用补丁时客户端不应该受影响。尚在研究的影响类型包括：</p>
<ul>
<li>源兼容性：针对 1.0 编写的代码无法针对 1.1 进行编译</li>
<li>二进制兼容性：针对 1.0 编译的代码无法针对 1.1 客户端库来链接/运行。（详细情况取决于客户端平台；这个问题在不同情况下有所不同。）</li>
<li>线路兼容性：针对 1.0 构建的应用程序无法与 1.1 服务器通信</li>
<li>语义兼容性：一切都在运行，但产生了意想不到的或出乎意料的结果</li>
<li></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从另一个角度说：旧客户端应该能与使用同一主要版本号的较新服务器结合使用，当其要更新到新的次要版本时（例如利用新功能），应该可以轻松做到。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了从基于协议的理论方面来考虑，由于存在涉及生成代码和手写代码的客户端库，因此存在实际考虑因素。测试您正在研究的更改时，应尽可能通过生成新版本的客户端库来测试，并确保其测试仍能通过。</p>
<p>下面的讨论内容将原型消息分为三类：</p>
<ul>
<li>请求消息（例如 <code>GetBookRequest</code>）</li>
<li>响应消息（例如 <code>ListBooksResponse</code>）</li>
<li>资源消息（例如 <code>Book</code>，包括其他资源消息中使用的任何消息）</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些类别的消息具有不同的规则，因为请求消息仅从客户端发送到服务器，响应消息仅从服务器发送到客户端，但资源消息通常可以双向传输。特别是，可以更新的资源需要从读取/修改/写入周期方面来考虑。</p>
<h3 id="向后兼容的（非重大）更改-1"><a href="#向后兼容的（非重大）更改-1" class="headerlink" title="向后兼容的（非重大）更改"></a>向后兼容的（非重大）更改</h3><h4 id="向-API-服务定义添加-API-接口"><a href="#向-API-服务定义添加-API-接口" class="headerlink" title="向 API 服务定义添加 API 接口"></a>向 API 服务定义添加 API 接口</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从协议的角度来看，这始终比较安全。唯一需要注意的是，客户端库可能已经使用了手写代码中的新 API 接口名称。如果您的新接口与现有接口完全正交，则不太可能实现；如果它是现有接口的简化版本，则更有可能导致冲突。</p>
<h4 id="向-API-接口添加方法"><a href="#向-API-接口添加方法" class="headerlink" title="向 API 接口添加方法"></a>向 API 接口添加方法</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除非您添加的方法与客户端库中已生成的方法发生冲突，否则这应该没问题。</p>
<p>（可能造成重大后果的例子：如果您有 <code>GetFoo</code> 方法，C# 代码生成器已经创建了 <code>GetFoo</code> 和 <code>GetFooAsync</code> 方法。因此，从客户端库的角度来看，在 API 接口中添加 <code>GetFooAsync</code> 方法将是一个重大更改。）</p>
<h4 id="向方法添加-HTTP-绑定"><a href="#向方法添加-HTTP-绑定" class="headerlink" title="向方法添加 HTTP 绑定"></a>向方法添加 HTTP 绑定</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设绑定没有引入任何歧义，让服务器响应之前拒绝的网址就是安全的。将现有操作应用于新资源名称模式时，<strong>可以</strong>执行此操作。</p>
<h4 id="向请求消息添加字段"><a href="#向请求消息添加字段" class="headerlink" title="向请求消息添加字段"></a>向请求消息添加字段</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;添加请求字段可以是非重大更改，前提是未指定该字段的客户端将在新版本中采用与旧版本相同的处理方式。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能错误地执行此操作的最明显示例是使用分页：如果 API 的 v1.0 不包含集合的分页，则无法在 v1.1 中添加它，除非将默认的 <code>page_size</code> 视为无限（这通常是一个坏主意）。否则，希望通过单个请求获得完整结果的 v1.0 客户端可能只收到部分结果，而且不会意识到该集合包含更多资源。</p>
<h4 id="向响应消息添加字段"><a href="#向响应消息添加字段" class="headerlink" title="向响应消息添加字段"></a>向响应消息添加字段</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并非资源（例如 <code>ListBooksResponse</code>）的响应消息可在不影响客户端的情况下进行扩展，前提是这样不会改变其他响应字段的行为。之前在响应中填充的任何字段都应继续使用相同的语义填充，即使这会引入冗余也如此。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，在 1.0 版中的查询响应可能包含 <code>contained_duplicates</code> 的布尔字段，这表示某些结果由于复制而省略。在 1.1 版中，我们可能会在 <code>duplicate_count</code> 字段提供更详细的信息。尽管它在 1.1 版本中是多余的，但仍<strong>必须</strong>填充 <code>contained_duplicates</code> 字段。</p>
<h4 id="向枚举添加值"><a href="#向枚举添加值" class="headerlink" title="向枚举添加值"></a>向枚举添加值</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只能在请求消息中使用的枚举可以自由扩展以包含新元素。例如，使用<a href="https://cloud.google.com/apis/design/design_patterns#resource_view" target="_blank" rel="noopener">资源视图</a>模式可在新的次要版本中添加新视图。客户永远不需要接收这个枚举，因此他们不必知道他们不关心的值。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于资源消息和响应消息，默认假设客户端应该处理他们不知道的枚举值。但是，API 提供方应该知道编写应用来正确处理新的枚举元素可能很困难。API 所有者<strong>应该</strong>在遇到未知枚举值时记录预期的客户端行为。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;借助 Proto3，客户端可以接收它们不知道的值并重新序列化保持相同值的消息，这样才不会影响读取/修改/写入周期。使用 JSON 格式可在值“名称”未知的情况下发送数值，但服务器通常不知道客户端是否真的知道特定值。因此，JSON 客户端可能知道它们已收到以前未知的值，但它们只会看到名称或数字 - 他们不会同时知道这两者。在读取/修改/写入循环中将相同的值返回到服务器，此时不应修改该字段，因为服务器应该理解这两种形式。</p>
<h4 id="添加仅限输出的资源字段"><a href="#添加仅限输出的资源字段" class="headerlink" title="添加仅限输出的资源字段"></a>添加仅限输出的资源字段</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>可以</strong>添加只能由服务器提供的资源实体中的字段。服务器<strong>可以</strong>验证请求中任何客户端提供的值是否有效，但<strong>不能</strong>在该值省略时失败。</p>
<h3 id="向后不兼容的（重大）的更改"><a href="#向后不兼容的（重大）的更改" class="headerlink" title="向后不兼容的（重大）的更改"></a>向后不兼容的（重大）的更改</h3><h4 id="移除或重命名服务、字段、方法或枚举值"><a href="#移除或重命名服务、字段、方法或枚举值" class="headerlink" title="移除或重命名服务、字段、方法或枚举值"></a>移除或重命名服务、字段、方法或枚举值</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从根本上看，如果客户端代码可能引用某些内容，对其执行移除或重命名操作就是重大更改，<strong>必须</strong>通过新的主要版本进行。引用旧名称的代码，对于有些语言（例如 C＃和 Java）会导致编译失败，对于其他语言则可能导致执行失败或数据丢失。传输格式兼容性与此无关。</p>
<h4 id="更改-HTTP-绑定"><a href="#更改-HTTP-绑定" class="headerlink" title="更改 HTTP 绑定"></a>更改 HTTP 绑定</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此处的“更改”实际上是“删除和添加”。例如，如果您确定确实要支持 <code>PATCH</code>，但您发布的版本支持 <code>PUT</code>，或者您使用了错误的自定义动词名称，则<strong>可以</strong>添加新绑定，但<strong>不能</strong>因为相同原因而删除旧绑定，因为移除服务方法是一个重大更改。</p>
<h4 id="更改字段的类型"><a href="#更改字段的类型" class="headerlink" title="更改字段的类型"></a>更改字段的类型</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使新类型与传输格式兼容，这也可能更改客户端库生成的代码，因此<strong>必须</strong>通过新的主要版本进行。对于已编译的静态类型语言，这很容易引入编译时错误。</p>
<h4 id="更改资源名称格式"><a href="#更改资源名称格式" class="headerlink" title="更改资源名称格式"></a>更改资源名称格式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;资源<strong>不得</strong>更改其名称 - 这意味着不能更改集合名称。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与大多数重大更改不同，这也会影响主要版本：如果客户端可以使用 v2.0 访问在 v1.0 中创建的资源（反之亦然），则应在两个版本中使用相同的资源名称。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;较容易忽略的是，由于以下原因，有效资源名称集<strong>也不应</strong>更改：</p>
<ul>
<li>如果它的限制变得更严格，之前成功的请求现在将失败。</li>
<li>如果它没有之前记录的限制严格，基于先前文档做出假设的客户端可能无法正常工作。客户很可能采用对允许的字符集和名称长度敏感的方式，将资源名称存储在其他位置。或者，客户很可能执行自己的资源名称验证以遵循文档说明。（例如，在开始支持更长的 EC2 资源 ID 之前，<a href="https://aws.amazon.com/blogs/aws/theyre-here-longer-ec2-resource-ids-now-available/" target="_blank" rel="noopener">亚马逊为客户提供了大量警告并且有一个迁移期</a>。）</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，此类更改可能仅在原型文档中可见。因此，在审核 CL 是否损坏时，仅查看非评论更改并不够。</p>
<h4 id="更改现有请求的可见行为"><a href="#更改现有请求的可见行为" class="headerlink" title="更改现有请求的可见行为"></a>更改现有请求的可见行为</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户通常依赖 API 行为和语义，<strong>即使此类行为没有得到明确支持或记录</strong>。因此，在大多数情况下，更改 API 数据的行为或语义造成的影响将被视为使用者的责任。如果行为未以加密方式隐藏，则<strong>应</strong>假设用户已发现并将依赖此行为。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于这个原因（即使数据很无趣），对分页令牌加密也是一个好主意，可以防止用户创建自己的令牌，以及在令牌行为发生更改时影响令牌。</p>
<h4 id="更改-HTTP-定义中的网址格式"><a href="#更改-HTTP-定义中的网址格式" class="headerlink" title="更改 HTTP 定义中的网址格式"></a>更改 HTTP 定义中的网址格式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了上面列出的资源名称更改之外，此处需要考虑两种更改：</p>
<ul>
<li>自定义方法名称：虽然并非资源名称的一部分，但自定义方法名称是 REST 客户端发布到的网址的一部分。更改自定义方法名称不应该影响 gRPC 客户端，但公共 API 必须假定它们具有 REST 客户端。</li>
<li>资源参数名称：从 <code>v1/shelves/{shelf}/books/{book}</code> 更改为 <code>v1/shelves/{shelf_id}/books/{book_id}</code> 不会影响已替代的资源名称，但可能会影响代码生成。</li>
</ul>
<h4 id="向资源消息添加读取-写入字段"><a href="#向资源消息添加读取-写入字段" class="headerlink" title="向资源消息添加读取/写入字段"></a>向资源消息添加读取/写入字段</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端通常会执行读取/修改/写入操作。大多数客户端不会为它们不知道的字段提供值，特别是 proto3，它不支持此操作。您可以指定消息类型（而不是原始类型）的任何缺失字段都表示更新未应用于这些字段，但这使得从实体中显式移除此类字段值变得更加困难。原始类型（包括 <code>string</code> 和 <code>bytes</code>）根本无法采用这种方式处理，因为在 proto3 中，将 <code>int32</code> 字段明确指定为 0 与完全不指定没有区别。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果使用字段掩码执行所有更新，这就不是问题，因为客户端不会隐式覆盖它不知道的字段。但是，这个 API 决策并不寻常：大多数 API 都支持“整个资源”更新。</p>
<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本章简要介绍了<code>Google API</code>错误模型并为开发人员提供了正确生成和处理错误的通用指南。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Google API</code> 使用简单的协议无关错误模型，以便我们在不同的 <code>API</code>、<code>API</code> 协议（如 <code>gRPC 或 HTTP</code>）和错误上下文（例如异步、批处理或工作流错误）中能够有一致的体验。</p>
<h3 id="错误模型"><a href="#错误模型" class="headerlink" title="错误模型"></a>错误模型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;错误模型由 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto" target="_blank" rel="noopener"><code>google.rpc.Status</code></a> 在逻辑上定义，该实例将在 <code>API</code>错误发生时返回给客户端。以下代码段显示了错误模型的总体设计：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package google.rpc;</span><br><span class="line"></span><br><span class="line">message Status &#123;</span><br><span class="line">  // A simple error code that can be easily handled by the client. The</span><br><span class="line">  // actual error code is defined by `google.rpc.Code`.</span><br><span class="line">  int32 code = 1;</span><br><span class="line"></span><br><span class="line">  // A developer-facing human-readable error message in English. It should</span><br><span class="line">  // both explain the error and offer an actionable resolution to it.</span><br><span class="line">  string message = 2;</span><br><span class="line"></span><br><span class="line">  // Additional error information that the client code can use to handle</span><br><span class="line">  // the error, such as retry delay or a help link.</span><br><span class="line">  repeated google.protobuf.Any details = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于大多数 <code>Google API</code> 采用面向资源的 <code>API</code> 设计，因此错误处理遵循相同的设计原则，使用一小组标准错误配合大量资源。例如，服务器没有定义不同类型的“找不到”错误，而是使用一个标准 <code>google.rpc.Code.NOT_FOUND</code> 错误代码并告诉客户端找不到哪个特定资源。状态空间变小降低了文档的复杂性，在客户端库中提供了更好的惯用映射，并降低了客户端的逻辑复杂性，同时不限制是否包含可操作信息。</p>
<h3 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Google API</code> <strong>必须</strong>使用 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto" target="_blank" rel="noopener"><code>google.rpc.Code</code></a> 定义的规范错误代码。单个 API <strong>应</strong>避免定义其他错误代码，因为开发人员不太可能编写用于处理大量错误代码的逻辑。作为参考，每个 API 调用平均处理 3 个错误代码意味着大多数应用的逻辑只是用于错误处理，这对开发人员而言并非好体验。</p>
<h3 id="错误消息"><a href="#错误消息" class="headerlink" title="错误消息"></a>错误消息</h3><p>错误消息应该可以帮助用户轻松快捷地<strong>理解和解决</strong> API 错误。通常，在编写错误消息时请考虑以下准则：</p>
<ul>
<li>不要假设用户是您 API 的专家用户。用户可能是客户端开发人员、操作人员、IT 人员或应用的最终用户。</li>
<li>不要假设用户了解有关服务实现的任何信息，或者熟悉错误的上下文（例如日志分析）。</li>
<li>如果可能，应构建错误消息，以便技术用户（但不一定是 API 开发人员）可以响应错误并改正。</li>
<li>确保错误消息内容简洁。如果需要，请提供一个链接，便于有疑问的读者提问、提供反馈或详细了解错误消息中不方便说明的信息。此外，可使用详细信息字段来提供更多信息。</li>
</ul>
<h3 id="错误详情"><a href="#错误详情" class="headerlink" title="错误详情"></a>错误详情</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Google API</code>为错误详细信息定义了一组标准错误负载，您可在 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto" target="_blank" rel="noopener">google/rpc/error_details.proto</a> 中找到这些错误负载。它们涵盖了对于<code>API</code>错误的最常见需求，例如配额失败和无效参数。与错误代码一样，错误详细信息应尽可能使用这些标准负载。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有在可以帮助应用代码处理错误的情况下，才应引入其他错误详细信息类型。如果错误信息只能由人工处理，则应根据错误消息内容，让开发人员手动处理，而不是引入新的错误详细信息类型。</p>
<p>以下是一些 <code>error_details</code> 负载示例：</p>
<ul>
<li><code>RetryInfo</code>：描述客户端何时可以重试失败的请求，这些内容可能在以下方法中返回：<code>Code.UNAVAILABLE</code> 或 <code>Code.ABORTED</code></li>
<li><code>QuotaFailure</code>：描述配额检查失败的方式，这些内容可能在以下方法中返回：<code>Code.RESOURCE_EXHAUSTED</code></li>
<li><code>BadRequest</code>：描述客户端请求中的违规行为，这些内容可能在以下方法中返回：<code>Code.INVALID_ARGUMENT</code></li>
</ul>
<h3 id="HTTP-映射-1"><a href="#HTTP-映射-1" class="headerlink" title="HTTP 映射"></a>HTTP 映射</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然 <code>proto3</code> 消息具有原生<code>JSON</code>编码，但<code>Google</code> 的 <code>API</code>平台对 <code>Google JSON REST API</code> 使用了不同的错误架构，以实现向后兼容性。</p>
<p>架构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// The error schema for Google REST APIs. NOTE: this schema is not used for</span><br><span class="line">// other wire protocols.</span><br><span class="line">message Error &#123;</span><br><span class="line">  // This message has the same semantics as `google.rpc.Status`. It has an extra</span><br><span class="line">  // field `status` for backward compatibility with Google API Client Library.</span><br><span class="line">  message Status &#123;</span><br><span class="line">    // This corresponds to `google.rpc.Status.code`.</span><br><span class="line">    int32 code = 1;</span><br><span class="line">    // This corresponds to `google.rpc.Status.message`.</span><br><span class="line">    string message = 2;</span><br><span class="line">    // This is the enum version for `google.rpc.Status.code`.</span><br><span class="line">    google.rpc.Code status = 4;</span><br><span class="line">    // This corresponds to `google.rpc.Status.details`.</span><br><span class="line">    repeated google.protobuf.Any details = 5;</span><br><span class="line">  &#125;</span><br><span class="line">  // The actual error payload. The nested message structure is for backward</span><br><span class="line">  // compatibility with Google API client libraries. It also makes the error</span><br><span class="line">  // more readable to developers.</span><br><span class="line">  Status error = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"error"</span>: &#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">401</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"Request had invalid credentials."</span>,</span><br><span class="line">    <span class="attr">"status"</span>: <span class="string">"UNAUTHENTICATED"</span>,</span><br><span class="line">    <span class="attr">"details"</span>: [&#123;</span><br><span class="line">      <span class="attr">"@type"</span>: <span class="string">"type.googleapis.com/google.rpc.RetryInfo"</span>,</span><br><span class="line">      ...</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RPC-映射"><a href="#RPC-映射" class="headerlink" title="RPC 映射"></a>RPC 映射</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不同的 <code>RPC</code>协议采用不同方式映射错误模型。对于 <a href="http://grpc.io/" target="_blank" rel="noopener">gRPC</a>，生成的代码和每种支持语言的运行时库为错误模型提供原生支持。您可在 gRPC 的 API 文档中找到更多信息（例如，可参阅 gRPC Java 的 <a href="https://github.com/grpc/grpc-java/blob/master/core/src/main/java/io/grpc/Status.java" target="_blank" rel="noopener"><code>io.grpc.Status</code></a>）。</p>
<h3 id="客户端库映射"><a href="#客户端库映射" class="headerlink" title="客户端库映射"></a>客户端库映射</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Google</code>客户端库可能会根据语言选择采用不同方式表达错误，以与既定习语保持一致。例如，<a href="https://github.com/GoogleCloudPlatform/google-cloud-go" target="_blank" rel="noopener">google-cloud-go</a> 库将返回一个错误，该错误会实现与 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto" target="_blank" rel="noopener"><code>google.rpc.Status</code></a> 相同的接口，而 <a href="https://github.com/googleapis/google-cloud-java" target="_blank" rel="noopener">google-cloud-java</a> 将引发异常。</p>
<h3 id="错误本地化"><a href="#错误本地化" class="headerlink" title="错误本地化"></a>错误本地化</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto" target="_blank" rel="noopener"><code>google.rpc.Status</code></a> 中的 <code>message</code> 字段面向开发人员，<strong>必须</strong>使用英语。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要面向用户的错误消息，请使用 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto" target="_blank" rel="noopener"><code>google.rpc.LocalizedMessage</code></a> 作为您的详细信息字段。如果 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto" target="_blank" rel="noopener"><code>google.rpc.LocalizedMessage</code></a> 中的消息字段可以进行本地化，请确保 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto" target="_blank" rel="noopener"><code>google.rpc.Status</code></a> 中的消息字段使用英文。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认情况下，API 服务应使用经过身份验证的用户的语言区域设置或 HTTP <code>Accept-Language</code> 标头来确定本地化的语言。</p>
<h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的表格包含在 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto" target="_blank" rel="noopener"><code>google.rpc.Code</code></a> 中定义的所有 gRPC 错误代码及其原因的简短描述。要处理错误，您可以检查返回状态代码的说明并相应地修改您的调用。</p>
<table>
<thead>
<tr>
<th style="text-align:left">HTTP</th>
<th style="text-align:left">RPC</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">200</td>
<td style="text-align:left"><code>OK</code></td>
<td style="text-align:left">无错误。</td>
</tr>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left"><code>INVALID_ARGUMENT</code></td>
<td style="text-align:left">客户端指定了无效参数。如需了解详情，请查看错误消息和错误详细信息。</td>
</tr>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left"><code>FAILED_PRECONDITION</code></td>
<td style="text-align:left">请求无法在当前系统状态下执行，例如删除非空目录。</td>
</tr>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left"><code>OUT_OF_RANGE</code></td>
<td style="text-align:left">客户端指定了无效范围。</td>
</tr>
<tr>
<td style="text-align:left">401</td>
<td style="text-align:left"><code>UNAUTHENTICATED</code></td>
<td style="text-align:left">由于 OAuth 令牌丢失、无效或过期，请求未通过身份验证。</td>
</tr>
<tr>
<td style="text-align:left">403</td>
<td style="text-align:left"><code>PERMISSION_DENIED</code></td>
<td style="text-align:left">客户端权限不足。可能的原因包括 OAuth 令牌的覆盖范围不正确、客户端没有权限或者尚未为客户端项目启用 API。</td>
</tr>
<tr>
<td style="text-align:left">404</td>
<td style="text-align:left"><code>NOT_FOUND</code></td>
<td style="text-align:left">找不到指定的资源，或者请求由于未公开的原因（例如白名单）而被拒绝。</td>
</tr>
<tr>
<td style="text-align:left">409</td>
<td style="text-align:left"><code>ABORTED</code></td>
<td style="text-align:left">并发冲突，例如读取/修改/写入冲突。</td>
</tr>
<tr>
<td style="text-align:left">409</td>
<td style="text-align:left"><code>ALREADY_EXISTS</code></td>
<td style="text-align:left">客户端尝试创建的资源已存在。</td>
</tr>
<tr>
<td style="text-align:left">429</td>
<td style="text-align:left"><code>RESOURCE_EXHAUSTED</code></td>
<td style="text-align:left">资源配额不足或达到速率限制。如需了解详情，客户端应该查找 google.rpc.QuotaFailure 错误详细信息。</td>
</tr>
<tr>
<td style="text-align:left">499</td>
<td style="text-align:left"><code>CANCELLED</code></td>
<td style="text-align:left">请求被客户端取消。</td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left"><code>DATA_LOSS</code></td>
<td style="text-align:left">出现不可恢复的数据丢失或数据损坏。客户端应该向用户报告错误。</td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left"><code>UNKNOWN</code></td>
<td style="text-align:left">出现未知的服务器错误。通常是服务器错误。</td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left"><code>INTERNAL</code></td>
<td style="text-align:left">出现内部服务器错误。通常是服务器错误。</td>
</tr>
<tr>
<td style="text-align:left">501</td>
<td style="text-align:left"><code>NOT_IMPLEMENTED</code></td>
<td style="text-align:left">API 方法未通过服务器实现。</td>
</tr>
<tr>
<td style="text-align:left">503</td>
<td style="text-align:left"><code>UNAVAILABLE</code></td>
<td style="text-align:left">服务不可用。通常是服务器已关闭。</td>
</tr>
<tr>
<td style="text-align:left">504</td>
<td style="text-align:left"><code>DEADLINE_EXCEEDED</code></td>
<td style="text-align:left">超出请求时限。仅当调用者设置的时限比方法的默认时限短（即请求的时限不足以让服务器处理请求）并且请求未在时限范围内完成时，才会发生这种情况。</td>
</tr>
</tbody>
</table>
<h3 id="错误重试"><a href="#错误重试" class="headerlink" title="错误重试"></a>错误重试</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端<strong>应</strong>使用指数退避算法重试 500 和 503 错误。除非另有说明，否则最小延迟应为 1 秒。对于 429 错误，客户端可能会以最少 30 秒的延迟重试。对于所有其他错误，重试可能不适用 - 首先确保您的请求具有幂等性，并查看错误消息以获取指导。</p>
<h3 id="错误传播"><a href="#错误传播" class="headerlink" title="错误传播"></a>错误传播</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您的 API 服务依赖于其他服务，则不应盲目地将这些服务的错误传播到您的客户端。在翻译错误时，我们建议执行以下操作：</p>
<ul>
<li>隐藏实现详细信息和机密信息。</li>
<li>调整负责该错误的一方。例如，从另一个服务接收 <code>INVALID_ARGUMENT</code> 错误的服务器应该将 <code>INTERNAL</code> 传播给它自己的调用者。</li>
</ul>
<h3 id="生成错误"><a href="#生成错误" class="headerlink" title="生成错误"></a>生成错误</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您是服务器开发人员，则应该生成包含足够信息的错误，以帮助客户端开发人员理解并解决问题。同时，您必须重视用户数据的安全性和隐私性，避免在错误消息和错误详细信息中披露敏感信息，因为错误通常会被记录下来并且可能被其他人访问。例如，诸如“客户端 IP 地址不在白名单 <code>128.0.0.0/8</code>上”之类的错误消息会披露服务器端政策的相关信息，这些信息可能是用户无法访问的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要生成正确的错误，首先需要熟悉 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto" target="_blank" rel="noopener"><code>google.rpc.Code</code></a>，然后才能为每个错误条件选择最合适的错误代码。服务器应用可以并行检查多个错误条件，并返回第一个错误条件。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下表列出了每个错误代码和恰当的错误消息示例。</p>
<table>
<thead>
<tr>
<th style="text-align:left">HTTP</th>
<th style="text-align:left">RPC</th>
<th style="text-align:left">错误消息示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left"><code>INVALID_ARGUMENT</code></td>
<td style="text-align:left">请求字段 x.y.z 是 xxx，预期为 [yyy, zzz] 内的一个。</td>
</tr>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left"><code>FAILED_PRECONDITION</code></td>
<td style="text-align:left">资源 xxx 是非空目录，因此无法删除。</td>
</tr>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left"><code>OUT_OF_RANGE</code></td>
<td style="text-align:left">参数“age”超出范围 [0,125]。</td>
</tr>
<tr>
<td style="text-align:left">401</td>
<td style="text-align:left"><code>UNAUTHENTICATED</code></td>
<td style="text-align:left">身份验证凭据无效。</td>
</tr>
<tr>
<td style="text-align:left">403</td>
<td style="text-align:left"><code>PERMISSION_DENIED</code></td>
<td style="text-align:left">使用权限“xxx”处理文件“yyy”被拒绝。</td>
</tr>
<tr>
<td style="text-align:left">404</td>
<td style="text-align:left"><code>NOT_FOUND</code></td>
<td style="text-align:left">找不到资源“xxx”。</td>
</tr>
<tr>
<td style="text-align:left">409</td>
<td style="text-align:left"><code>ABORTED</code></td>
<td style="text-align:left">无法锁定资源“xxx”。</td>
</tr>
<tr>
<td style="text-align:left">409</td>
<td style="text-align:left"><code>ALREADY_EXISTS</code></td>
<td style="text-align:left">资源“xxx”已经存在。</td>
</tr>
<tr>
<td style="text-align:left">429</td>
<td style="text-align:left"><code>RESOURCE_EXHAUSTED</code></td>
<td style="text-align:left">超出配额限制“xxx”。</td>
</tr>
<tr>
<td style="text-align:left">499</td>
<td style="text-align:left"><code>CANCELLED</code></td>
<td style="text-align:left">请求被客户端取消。</td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left"><code>DATA_LOSS</code></td>
<td style="text-align:left">请参阅注释。</td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left"><code>UNKNOWN</code></td>
<td style="text-align:left">请参阅注释。</td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left"><code>INTERNAL</code></td>
<td style="text-align:left">请参阅注释。</td>
</tr>
<tr>
<td style="text-align:left">501</td>
<td style="text-align:left"><code>NOT_IMPLEMENTED</code></td>
<td style="text-align:left">方法“xxx”未实现。</td>
</tr>
<tr>
<td style="text-align:left">503</td>
<td style="text-align:left"><code>UNAVAILABLE</code></td>
<td style="text-align:left">请参阅注释。</td>
</tr>
<tr>
<td style="text-align:left">504</td>
<td style="text-align:left"><code>DEADLINE_EXCEEDED</code></td>
<td style="text-align:left">请参阅注释。</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：由于客户端无法修复服务器错误，因此生成其他错误详细信息没有任何用处。为避免在错误条件下泄露敏感信息，建议不要生成任何错误消息，而仅生成 <code>google.rpc.DebugInfo</code> 错误详细信息。<code>DebugInfo</code> 专为服务器端的日志记录而设计，<strong>不得</strong>发送到客户端。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>google.rpc</code> 软件包定义了一组标准错误负载，它们优先于自定义错误负载。下表列出了每个错误代码及其匹配的标准错误负载（如果适用）。</p>
<table>
<thead>
<tr>
<th style="text-align:left">HTTP</th>
<th style="text-align:left">RPC</th>
<th style="text-align:left">建议的错误详细信息</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left"><code>INVALID_ARGUMENT</code></td>
<td style="text-align:left"><code>google.rpc.BadRequest</code></td>
</tr>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left"><code>FAILED_PRECONDITION</code></td>
<td style="text-align:left"><code>google.rpc.PreconditionFailure</code></td>
</tr>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left"><code>OUT_OF_RANGE</code></td>
<td style="text-align:left"><code>google.rpc.BadRequest</code></td>
</tr>
<tr>
<td style="text-align:left">401</td>
<td style="text-align:left"><code>UNAUTHENTICATED</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">403</td>
<td style="text-align:left"><code>PERMISSION_DENIED</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">404</td>
<td style="text-align:left"><code>NOT_FOUND</code></td>
<td style="text-align:left"><code>google.rpc.ResourceInfo</code></td>
</tr>
<tr>
<td style="text-align:left">409</td>
<td style="text-align:left"><code>ABORTED</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">409</td>
<td style="text-align:left"><code>ALREADY_EXISTS</code></td>
<td style="text-align:left"><code>google.rpc.ResourceInfo</code></td>
</tr>
<tr>
<td style="text-align:left">429</td>
<td style="text-align:left"><code>RESOURCE_EXHAUSTED</code></td>
<td style="text-align:left"><code>google.rpc.QuotaFailure</code></td>
</tr>
<tr>
<td style="text-align:left">499</td>
<td style="text-align:left"><code>CANCELLED</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left"><code>DATA_LOSS</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left"><code>UNKNOWN</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left"><code>INTERNAL</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">501</td>
<td style="text-align:left"><code>NOT_IMPLEMENTED</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">503</td>
<td style="text-align:left"><code>UNAVAILABLE</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">504</td>
<td style="text-align:left"><code>DEADLINE_EXCEEDED</code></td>
</tr>
</tbody>
</table>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>API 服务通常使用 <code>.proto</code> 文件来定义 API 接口，并使用 <code>.yaml</code> 文件来配置 API 服务。每个 API 服务<strong>必须</strong>在 API 代码库中有一个 API 目录，其中包含定义文件和构建脚本。</p>
<p>每个 API 目录<strong>应该</strong>具有以下标准布局：</p>
<ul>
<li>API 目录<ul>
<li>代码库必要条件<ul>
<li><code>BUILD</code>：构建文件。</li>
<li><code>METADATA</code>：构建元数据文件。</li>
<li><code>OWNERS</code>：API 目录所有者。</li>
</ul>
</li>
<li>配置文件<ul>
<li><code>{service}.yaml</code>：基准服务配置文件，<code>google.api.Service</code> proto 消息的 YAML 表示法。</li>
<li><code>prod.yaml</code>：生产环境增量服务配置文件。</li>
<li><code>staging.yaml</code>：模拟环境增量服务配置文件。</li>
<li><code>test.yaml</code>：测试环境增量服务配置文件。</li>
<li><code>local.yaml</code>：本地环境增量服务配置文件。</li>
</ul>
</li>
<li>文档文件<ul>
<li><code>README.md</code>：主要 readme 文件。它应包含一般生产概览和技术说明等。</li>
<li><code>doc/*</code>：技术文档文件。它们应采用 Markdown 格式。</li>
</ul>
</li>
<li>接口定义<ul>
<li><code>v[0-9]*/*</code>：每个这样的目录都包含 API 的主要版本，主要是 proto 文件和构建脚本。</li>
<li><code>{subapi}/v[0-9]*/*</code>：每个 <code>{subapi}</code> 目录包含子 API 的接口定义。每个子 API 可以有自己的独立主要版本。</li>
<li><code>type/*</code>：proto 文件，包含在不同 API 之间、同一 API 的不同版本之间或 API 与服务实现之间共享的类型。<code>type/*</code> 下的类型定义一旦发布就不<strong>应该</strong>有重大更改。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>gRPC API <strong>应</strong>使用 <a href="https://cloud.google.com/apis/design/proto3" target="_blank" rel="noopener">proto3</a> IDL 在 <code>.proto</code> 文件中定义。</p>
<p>文件结构<strong>必须</strong>将更高级别和更重要的定义置于较低级别和较不重要的项目之前。在每个 proto 文件中，适用的部分<strong>应</strong>按以下顺序排列：</p>
<ul>
<li>版权和许可声明（如果需要）。</li>
<li>采用该顺序的 Proto <code>syntax</code>、<code>package</code>、<code>import</code> 和 <code>option</code> 语句。</li>
<li>API 概览文档，为读取器准备文件的其余部分。</li>
<li>按重要性降序排列的 API proto <code>service</code> 定义。</li>
<li>与相应方法采用相同顺序的 RPC 请求和响应 <code>message</code> 定义。每个请求消息<strong>必须</strong>在其相应的响应消息之前（如果有）。</li>
<li>资源 <code>message</code> 定义。父资源<strong>必须</strong>在其子资源之前定义。</li>
</ul>
<p>如果单个 proto 文件包含整个 API 接口，<strong>应</strong>在 API 之后命名：</p>
<table>
<thead>
<tr>
<th style="text-align:left">API</th>
<th style="text-align:left">Proto</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>Library</code></td>
<td style="text-align:left"><code>library.proto</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Calendar</code></td>
<td style="text-align:left"><code>calendar.proto</code></td>
</tr>
</tbody>
</table>
<p>大 .proto 文件可能会拆分为多个文件。应根据需要将服务、资源消息和请求/响应消息移到单独的文件中。</p>
<p>我们建议每个服务及其相应的请求和响应使用一个文件。考虑将此文件命名为 <code>&lt;enclosed service name&gt;.proto</code>。对于仅包含资源的 proto 文件，请考虑将此文件简单命名为 <code>resources.proto</code>。</p>
<h3 id="Proto-文件名"><a href="#Proto-文件名" class="headerlink" title="Proto 文件名"></a>Proto 文件名</h3><p>Proto 文件名<strong>应</strong>使用 lower_case_underscore_separated_names，并且<strong>必须</strong>使用扩展名 <code>.proto</code>。例如：<code>service_controller.proto</code>。</p>
<h3 id="Proto-选项"><a href="#Proto-选项" class="headerlink" title="Proto 选项"></a>Proto 选项</h3><p>为了在不同 API 中生成一致的客户端库，API 开发人员<strong>必须</strong>在其 <code>.proto</code> 文件中使用一致的 proto 选项。符合本指南的 API 定义<strong>必须</strong>使用以下文件级 proto 选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">// The package name should start with the company name and end with</span><br><span class="line">// the major version.</span><br><span class="line">package google.abc.xyz.v1;</span><br><span class="line"></span><br><span class="line">// This option specifies the namespace to be used in C# code. This defaults</span><br><span class="line">// to the PascalCased version of the proto package, which is fine if the</span><br><span class="line">// package name consists of single-word segments.</span><br><span class="line">// For example, a package name of &quot;google.shopping.pets.v1&quot; would use a C#</span><br><span class="line">// namespace of &quot;Google.Shopping.Pets.V1&quot;.</span><br><span class="line">// However, if any segment of a package name consists of multiple words,</span><br><span class="line">// this option needs to be specified to avoid only the first word being</span><br><span class="line">// capitalized. For example, a Google Pet Store API might have a package name of</span><br><span class="line">// &quot;google.shopping.petstore.v1&quot;, which would mean a C# namespace of</span><br><span class="line">// &quot;Google.Shopping.Petstore.V1&quot;. Instead, the option should be used to</span><br><span class="line">// capitalize it properly as &quot;Google.Shopping.PetStore.V1&quot;.</span><br><span class="line">//</span><br><span class="line">// For more detail on C#/.NET capitalization rules, see the [Framework Design</span><br><span class="line">// Guidelines](https://msdn.microsoft.com/en-us/library/ms229043).</span><br><span class="line">//</span><br><span class="line">// One corner-case of capitalization: while acronyms are generally</span><br><span class="line">// PascalCased (e.g. Http), two-letter acronyms are normally all in capitals,</span><br><span class="line">// e.g. `IOStream` and `OSVersion`, not `IoStream` and `OsVersion`. However,</span><br><span class="line">// in APIs this should be used carefully, as protoc doesn&apos;t know which words</span><br><span class="line">// are abbreviations and which aren&apos;t: it would introduce inconsistency to have</span><br><span class="line">// a namespace of (say) `OSLogin` but then a class called `OsDetails` generated</span><br><span class="line">// from a message of the same name. Unless you can be certain that the acronym</span><br><span class="line">// won&apos;t crop up in a message or field name, it&apos;s safest to stick to regular</span><br><span class="line">// PascalCase.</span><br><span class="line">//</span><br><span class="line">// For pre-releases, the Alpha/Beta should also be capitalized, so &quot;V1Beta1&quot;</span><br><span class="line">// rather than &quot;V1beta1&quot; for example.</span><br><span class="line">option csharp_namespace = &quot;Google.Abc.Xyz.V1&quot;;</span><br><span class="line"></span><br><span class="line">// This option lets the proto compiler generate Java code inside the package</span><br><span class="line">// name (see below) instead of inside an outer class. It creates a simpler</span><br><span class="line">// developer experience by reducing one-level of name nesting and be</span><br><span class="line">// consistent with most programming languages that don&apos;t support outer classes.</span><br><span class="line">option java_multiple_files = true;</span><br><span class="line"></span><br><span class="line">// The Java outer classname should be the filename in UpperCamelCase. This</span><br><span class="line">// class is only used to hold proto descriptor, so developers don&apos;t need to</span><br><span class="line">// work with it directly.</span><br><span class="line">option java_outer_classname = &quot;XyzProto&quot;;</span><br><span class="line"></span><br><span class="line">// The Java package name must be proto package name with proper prefix.</span><br><span class="line">option java_package = &quot;com.google.abc.xyz.v1&quot;;</span><br><span class="line"></span><br><span class="line">// A reasonable prefix for the Objective-C symbols generated from the package.</span><br><span class="line">// It should at a minimum be 3 characters long, all uppercase, and convention</span><br><span class="line">// is to use an abbreviation of the package name. Something short, but</span><br><span class="line">// hopefully unique enough to not conflict with things that may come along in</span><br><span class="line">// the future. &apos;GPB&apos; is reserved for the protocol buffer implementation itself.</span><br><span class="line">option objc_class_prefix = &quot;GABCX&quot;;</span><br><span class="line"></span><br><span class="line">// This option specifies the namespace to be used in PHP code. This defaults</span><br><span class="line">// to the PascalCased version of the proto package, which is fine if the</span><br><span class="line">// package name consists of single-word segments.</span><br><span class="line">// For example, a package name of &quot;google.shopping.pets.v1&quot; would use a PHP</span><br><span class="line">// namespace of &quot;Google\\Shopping\\Pets\\V1&quot;.</span><br><span class="line">// However, if any segment of a package name consists of multiple words,</span><br><span class="line">// this option needs to be specified to avoid only the first word being</span><br><span class="line">// capitalized. For example, a Google Pet Store API might have a package name of</span><br><span class="line">// &quot;google.shopping.petstore.v1&quot;, which would mean a PHP namespace of</span><br><span class="line">// &quot;Google\\Shopping\\Petstore\\V1&quot;. Instead, the option should be used to</span><br><span class="line">// capitalize it properly as &quot;Google\\Shopping\\PetStore\\V1&quot;.</span><br><span class="line">//</span><br><span class="line">// For pre-releases, the Alpha/Beta should not be capitalized, so &quot;V1beta1&quot;</span><br><span class="line">// rather than &quot;V1Beta1&quot; for example. Note that this is different from the</span><br><span class="line">// capitalization used in the csharp_namespace option for pre-releases.</span><br><span class="line">option php_namespace = &quot;Google\\Abc\\Xyz\\V1&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><h4 id="联网-API"><a href="#联网-API" class="headerlink" title="联网 API"></a>联网 API</h4><ul>
<li>跨计算机网络运行的应用编程接口。它们使用包括 HTTP 在内的各种网络协议进行通信，并且由不同的组织生成，通常供大于求。</li>
</ul>
<h4 id="Google-API"><a href="#Google-API" class="headerlink" title="Google API"></a>Google API</h4><ul>
<li>Google 服务公开的联网 API。其中大多数都托管在 <code>googleapis.com</code> 域名上。不包括其他类型的 API，例如客户端库和 SDK。</li>
</ul>
<h4 id="API-接口"><a href="#API-接口" class="headerlink" title="API 接口"></a>API 接口</h4><ul>
<li>一个 Protocol Buffers 服务定义。它通常映射到大多数编程语言中的某一个接口。API 接口可以由任意数量的 API 服务实现。</li>
</ul>
<h4 id="API-版本"><a href="#API-版本" class="headerlink" title="API 版本"></a>API 版本</h4><ul>
<li>一个 API 接口或一组 API 接口（如果一起定义）的版本。API 版本通常由字符串（例如“v1”）表示，并显示在 API 请求和 Protocol Buffers 包名称中。</li>
</ul>
<h4 id="API-方法"><a href="#API-方法" class="headerlink" title="API 方法"></a>API 方法</h4><ul>
<li>API 接口中的单个操作。它在 Protocol Buffers 中由 <code>rpc</code> 定义表示，并且通常映射到大多数编程语言的 API 接口中的一个函数。</li>
</ul>
<h4 id="API-请求"><a href="#API-请求" class="headerlink" title="API 请求"></a>API 请求</h4><ul>
<li>API 方法的单个调用。它通常用作计费、日志记录、监控和速率限制的单位。</li>
</ul>
<h4 id="API-服务"><a href="#API-服务" class="headerlink" title="API 服务"></a>API 服务</h4><ul>
<li>在一个或多个网络端点上公开的一个或多个 API 接口的部署实现。API 服务由其与 <a href="https://www.ietf.org/rfc/rfc1035.txt" target="_blank" rel="noopener">RFC 1035 DNS</a> 兼容的服务名称（例如 <code>calendar.googleapis.com</code>）标识。</li>
</ul>
<h4 id="API-端点"><a href="#API-端点" class="headerlink" title="API 端点"></a>API 端点</h4><ul>
<li>是指 API 服务用于响应实际 API 请求的网络地址，如 <code>pubsub.googleapis.com</code> 和 <code>content-pubsub.googleapis.com</code>。</li>
</ul>
<h4 id="API-产品"><a href="#API-产品" class="headerlink" title="API 产品"></a>API 产品</h4><ul>
<li>API 服务及相关组件（如服务条款、文档、客户端库和服务支持）将作为一个产品统一呈现给客户。例如 Google Calendar API。注意：人们有时将 API 产品简称为 API。</li>
</ul>
<h4 id="API-服务定义"><a href="#API-服务定义" class="headerlink" title="API 服务定义"></a>API 服务定义</h4><ul>
<li>用于定义 API 服务的 API 接口定义（.proto 文件）和 API 服务配置（.yaml 文件）的组合。Google API 服务定义的架构为 <a href="https://github.com/googleapis/googleapis/blob/master/google/api/service.proto" target="_blank" rel="noopener"><code>google.api.Service</code></a>。</li>
</ul>
<h4 id="API-使用者"><a href="#API-使用者" class="headerlink" title="API 使用者"></a>API 使用者</h4><ul>
<li>使用 API 服务的实体。对于 Google API，使用者通常是拥有客户端应用或服务器资源的 Google 项目。</li>
</ul>
<h4 id="API-生产者"><a href="#API-生产者" class="headerlink" title="API 生产者"></a>API 生产者</h4><ul>
<li>生产 API 服务的实体。对于 Google API，生产者通常是拥有 API 服务的 Google 项目。</li>
</ul>
<h4 id="API-后端"><a href="#API-后端" class="headerlink" title="API 后端"></a>API 后端</h4><ul>
<li>实现 API 服务业务逻辑的一组服务器及相关基础架构。单个 API 后端服务器通常称为 API 服务器。</li>
</ul>
<h4 id="API-前端"><a href="#API-前端" class="headerlink" title="API 前端"></a>API 前端</h4><ul>
<li><p>跨 API 服务提供通用功能（例如负载平衡和身份验证）的一组服务器及相关基础架构。单个 API 前端服务器通常称为 API 代理。</p>
<p>注意：API 前端和 API 后端运行时可以彼此相邻，也可以离得很远。在某些情况下，它们可以编译为单个应用二进制文件，并在单个进程中运行。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/09/13 个设计 REST API 的最佳实践/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/13 个设计 REST API 的最佳实践/" itemprop="url">13 个设计 REST API 的最佳实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-09T12:12:57+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/API设计/" itemprop="url" rel="index">
                    <span itemprop="name">API设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="13-个设计-REST-API-的最佳实践"><a href="#13-个设计-REST-API-的最佳实践" class="headerlink" title="13 个设计 REST API 的最佳实践"></a>13 个设计 REST API 的最佳实践</h1><h2 id="1-了解应用于-REST-之上的-HTTP-知识"><a href="#1-了解应用于-REST-之上的-HTTP-知识" class="headerlink" title="1. 了解应用于 REST 之上的 HTTP 知识"></a>1. 了解应用于 REST 之上的 HTTP 知识</h2><p>如果你想要构建设计优良的 <strong>REST API</strong>，了解一些关于 <strong>HTTP 协议</strong>的基础知识是很有帮助的，毕竟磨刀不误砍材工。</p>
<p>在 MDN 上有很多质量不错的<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview" target="_blank" rel="noopener">文档</a>介绍 HTTP。但是，就 <strong>REST API 设计</strong>本身而言，所涉及到的 HTTP 知识要点大概包含以下几条：</p>
<ul>
<li>HTTP 中包含<strong>动词</strong>（或方法）： <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>PATCH</code> 还有 <code>DELETE</code> 是最常用的。</li>
<li>REST 是<strong>面向资源</strong>的，一个资源被一个 <strong>URI</strong> 所标识，比如 <code>/articles/</code>。</li>
<li><strong>端点（endpoint）</strong>，一般指动词与 URI 的组合，比如 <code>GET: /articles/</code>。</li>
<li>一个端点可以被解释为对某种资源进行的某个动作。比如， <code>POST: /articles</code> 可能代表“创建一个新的 article”。</li>
<li>在业务领域，我们常常可以将<strong>动词</strong>和 <strong>CRUD</strong>（增删查改）关联起来：<code>GET</code> 代表查，<code>POST</code>代表增，<code>PUT</code> 和 <code>PATCH</code> 代表改（注: PUT 通常代表整体更新，而 PATCH 代表局部更新），而 <code>DELETE</code> 代表删。</li>
</ul>
<p>当然了，你可以将 HTTP 协议中所提供的任何东西应用于 REST API 的设计之中，但以上这些是比较基础的，因此时刻将它们记在脑海中是很有必要的。</p>
<h2 id="2-不要返回纯文本"><a href="#2-不要返回纯文本" class="headerlink" title="2. 不要返回纯文本"></a>2. 不要返回纯文本</h2><p>虽然返回 JSON 数据格式的数据不是 REST 架构规范强制限定的，但大多 REST API 都遵循这条准则。</p>
<p>但是，仅仅返回 JSON 数据格式的数据还是不够的，你还需要指定返回 body 的头部，比如 <code>Content-Type</code>，它的值必须指定为 <code>application/json</code>。这一点对于程序化客户端尤为重要（比如通过 python 的 <code>requests</code> 模块来与 api 进行交互）—— 这些程序是否对返回数据进行正确解码取决于这个头部。</p>
<p>注：通常而言，对于浏览器来说，这似乎不是问题，因为浏览器一般都自带内容嗅探机制，但为了保持一致性，还是在响应中设置这个头部比较妥当。</p>
<h2 id="3-避免在-URI-中使用动词"><a href="#3-避免在-URI-中使用动词" class="headerlink" title="3. 避免在 URI 中使用动词"></a>3. 避免在 URI 中使用动词</h2><p>如果你理解了第 1 条最佳实践所传达的意思，那么你现在就会明白<strong>不要</strong>将动词放入 REST API 的 URI 中。这是因为 HTTP 的动词已经足以描述执行于资源的业务逻辑操作了。</p>
<p>举个例子，当你想要提供一个针对某个 article 提供 banner 图片并返回的接口时，可能会实现如下格式的接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET: /articles/:slug/generateBanner/</span><br></pre></td></tr></table></figure>
<p>这里 GET 已经说明了这个接口是在做<strong>读</strong>的操作，因此，可以简化为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET: /articles/:slug/banner/</span><br></pre></td></tr></table></figure>
<p>类似的，如果这个端口是要创建一个 article:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 不要这么做</span><br><span class="line">POST: /articles/createNewArticle/</span><br><span class="line"></span><br><span class="line">// 这才是最佳实践</span><br><span class="line">POST: /articles/</span><br></pre></td></tr></table></figure>
<p>尝试用 HTTP 的动词来描述所涉及的业务逻辑操作。</p>
<h2 id="4-使用复数的名词来描述资源"><a href="#4-使用复数的名词来描述资源" class="headerlink" title="4. 使用复数的名词来描述资源"></a>4. 使用复数的名词来描述资源</h2><p>一些时候，使用资源的复数形式还是单数形式确实存在一定的困扰，比如使用 <code>/article/:id/</code> 更好还是使用 <code>/articles/:id/</code> 更好呢？</p>
<p>这里我推荐使用后者。为什么呢？因为复数形式可以满足所有类型端点的需求。</p>
<p>单数形式的 <code>GET /article/2/</code> 看起来还是不错的，但是如果是 <code>GET /article/</code> 呢？你能够仅通过字面信息来区分这个接口是返回某个 article 还是多个呢？</p>
<p>因此，为了避免有单数命名造成的歧义性，并尽可能的保持一致性，使用复数形式，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET: /articles/2/</span><br><span class="line">POST: /articles/</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="5-在响应中返回错误详情"><a href="#5-在响应中返回错误详情" class="headerlink" title="5. 在响应中返回错误详情"></a>5. 在响应中返回错误详情</h2><p>当 API 服务器处理错误时，如果能够在返回的 JSON body 中包含错误信息，对于接口调用者来说，会一定程度上帮助他们完成调试。比如对于常见的提交表单，当遇到如下错误信息时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;error&quot;: &quot;Invalid payoad.&quot;,</span><br><span class="line">    &quot;detail&quot;: &#123;</span><br><span class="line">        &quot;surname&quot;: &quot;This field is required.&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口调用者很快就是明白发生错误的原因。</p>
<h2 id="6-小心-status-code"><a href="#6-小心-status-code" class="headerlink" title="6. 小心 status code"></a>6. 小心 status code</h2><p>这一点可能是最重要、最重要、最重要的一点，可能也是这篇文章中，唯一你需要记住的那一点。</p>
<p>你可能知道，HTTP 中你可以返回带有 200 状态码的错误响应，但这是十分糟糕的。不要这么做，你应当返回与返回错误类型相一致的<strong>具有一定含义的状态码</strong>。</p>
<p>聪明的读者可能会说，我按照第 5 点最佳实践来提供足够详细的信息，难道不行吗？当然可以，不过让我讲一个故事：</p>
<p>我曾经使用过一个 API，对于它返回的所有响应的状态码均是 <code>200 OK</code>，同时通过响应数据中的 <code>status</code> 字段来表示当前的请求是否成功，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;success&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，虽然状态码是 <code>200 OK</code>，但我却不能绝对确定请求是否成功，事实上，当错误发生时，这个 API 会按如下代码片段返回响应：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;status&quot;: &quot;failure&quot;,</span><br><span class="line">    &quot;data&quot;: &#123;</span><br><span class="line">        &quot;error&quot;: &quot;Expected at least two items in list.&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>头部还是 <code>text/html</code>，因为它同时返回了一些 HTML 片段。</p>
<p>正因为这样，我不得不在检查响应状态码正确的同时，还需校验这个具有特殊含义的 <code>status</code> 字段的值，才可以放心的处理响应返回的 <code>data</code>。</p>
<p>这种设计的一个真正坏处在于，它打破了接口与调用者之间的“信任”，因为你可能会担心这个接口对你撒谎（注：言外之意就是，由于特设的字段可能会改变，因此增加了不可靠性）。</p>
<p>所以，使用正确的状态码，同时仅在响应的 body 中返回错误信息，并设置正确的头部，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 400 Bad Request</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;error&quot;: &quot;Expected at least two items in list.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-保持-status-code-的一致性"><a href="#7-保持-status-code-的一致性" class="headerlink" title="7. 保持 status code 的一致性"></a>7. 保持 status code 的一致性</h2><p>当你掌握了正确使用状态码之后，就应该努力使它们具有一致性。</p>
<p>比如，如果一个 POST 类型的端点返回 <code>201 Created</code>，那么所有的 POST 端点都应返回同样的状态码。这样做的好处在于，调用者无需在意端点返回的状态码取决于某种特殊条件，也就形成了一致性。如果有特殊情况，请在文档中显著地说明它们。</p>
<p>下面是我推荐的与动词相对应的状态码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET: 200 OK</span><br><span class="line">POST: 201 Created</span><br><span class="line">PUT: 200 OK</span><br><span class="line">PATCH: 200 OK</span><br><span class="line">DELETE: 204 No Content</span><br></pre></td></tr></table></figure>
<h2 id="8-不要嵌套资源"><a href="#8-不要嵌套资源" class="headerlink" title="8. 不要嵌套资源"></a>8. 不要嵌套资源</h2><p>使用 REST API 获取资源数据，通常情况下会直接获取多个或者单个，但当我们需要获取<strong>相关联</strong>的资源时，该怎么做呢？</p>
<p>比如说，我们期望获取作者为某个 author 的 article 列表 —— 假设 authro 的 <code>id=12</code>。这里提供两种方案：</p>
<p>第一种方案通过在 URI 中，将嵌套的资源放在所关联的资源后边来进行描述，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET: /authors/12/articles/</span><br></pre></td></tr></table></figure>
<p>一些人推荐这种方案的理由是，这种形式的 URI 一定程度上描述了 author 与 article 之间的一对多关系。但与此同时，结合第 4 点最佳实践，我们就不太能够分清当前端点返回的数据到底是 author 类型还是 article 类型。</p>
<p>这里有一篇<a href="https://www.python.org/dev/peps/pep-0020/#id3" target="_blank" rel="noopener">文章</a>，详细阐述了扁平化形式优于嵌套形式，因此一定有更好的方法，这就是下面的第二种方案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET: /articles/?author_id=12</span><br></pre></td></tr></table></figure>
<p>直接将筛选 article 的逻辑抽离为 querystring 即可，这样的 URI 相比之前，更加清晰地描述了“获取所有 author(id=12) 的 article”的意思。</p>
<h2 id="9-优雅地处理尾部斜杠"><a href="#9-优雅地处理尾部斜杠" class="headerlink" title="9. 优雅地处理尾部斜杠"></a>9. 优雅地处理尾部斜杠</h2><p>一个好的 URI 中是否应当包含尾部斜杠，并不具有探讨价值，选择一种更倾向的风格并保持一致性即可，同时当客户端误用尾部斜杠时，提供重定向响应。</p>
<p>我再来讲我自己的一个故事。某天，我在将某个 API 端点集成到项目中，但是我总是收到 <code>500 Internal Error</code> 的错误，我调用的端点差不多看起来这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST: /entities</span><br></pre></td></tr></table></figure>
<p>调试一段时间之后，我几乎崩溃了，因为我根本不知道我哪里做错了，直到我发现服务器之所以报 500 的错误，是因为我粗心丢掉了尾部斜杠（注：这种经历人人都会遇到，我在 SF 上遇过无数次类似的问题），当我把 URI 改成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST: /entities/</span><br></pre></td></tr></table></figure>
<p>之后，一切正常运转。</p>
<p>当然，大多数的 web 框架都针对 URL 是否包含尾部斜杠，进行了优雅地处理并提供定制选项，如果可以的话，找到它并开启这项功能。</p>
<h2 id="10-使用-querystring-来完成筛选和分页功能"><a href="#10-使用-querystring-来完成筛选和分页功能" class="headerlink" title="10. 使用 querystring 来完成筛选和分页功能"></a>10. 使用 querystring 来完成筛选和分页功能</h2><p>大部分情况下，一个简单的端点没有办法满足负责业务场景。</p>
<p>你的用户可能想要获取满足一定条件下的某些数据集合 ，同时为了保证性能，仅仅获取这个集合下的一个子集。换言之，这通常叫作<strong>筛选</strong>功能和<strong>分页</strong>功能：</p>
<ul>
<li>筛选：用户可以提供额外的属性来控制返回的数据集合</li>
<li>分页：获取数据集合的子集，最简单的分页是基于分页个数的分页，它由 <code>page</code> 和 <code>page_size</code> 来决定</li>
</ul>
<p>那么问题来了，我们如何将这两项功能与 RESTful API 结合在一起呢？</p>
<p>答案当然是通过 <strong>querystring</strong>。对于分页，很显然使用这种方式再合适不过了，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET: /articles/?page=1&amp;page_size=10</span><br></pre></td></tr></table></figure>
<p>但对于筛选，你可能会犯第 8 点最佳实践中所指出的问题，比如获取处于 published 状态的 article 列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET: /articles/published/</span><br></pre></td></tr></table></figure>
<p>除了之前提出的问题外，这里还涉及一个设计上的问题，就是 <strong>published</strong> 本身不是资源，它仅仅是资源的特征，类似这种特征字段，应该将它们放到 querystring 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET: /articles/?published=true&amp;page=2&amp;page_size=20</span><br></pre></td></tr></table></figure>
<p>更加优雅、清晰，不是吗？</p>
<h2 id="11-分清-401-和-403"><a href="#11-分清-401-和-403" class="headerlink" title="11. 分清 401 和 403"></a>11. 分清 401 和 403</h2><p>当我们遇到 API 中关于安全的错误提示时，很容易混淆这两个不同类型的错误，<strong>认证</strong>和<strong>授权</strong>（比如权限相关）—— 老实讲，我自己也经常搞混。</p>
<p>这里是我自己总结的备忘录，它阐述了我如何在实际情况下，区分它们：</p>
<ul>
<li>用户是否未提供身份验证凭据？认证是否还有效？这种类型的错误一般是未认证（<code>401 Unauthorized</code>）。</li>
<li>用户经过了正常的身份验证，但没有访问资源所需的权限？这种一般是未授权（<code>403 Forbidden</code>）</li>
</ul>
<h2 id="12-巧用-202-Accepted"><a href="#12-巧用-202-Accepted" class="headerlink" title="12. 巧用 202 Accepted"></a>12. 巧用 202 Accepted</h2><p>我发现 <code>202 Accepted</code> 在某些场合是 <code>201 Created</code> 的一个非常便捷的替代方案，这个状态码的含义是：</p>
<blockquote>
<p>服务器已经接受了你的请求，但是到目前为止还未创建新的资源，但一切仍处于正常状态。</p>
</blockquote>
<p>我分享两种特别适合使用 <code>202 Accepted</code> 状态码的业务场景：</p>
<ul>
<li>如果资源是经过位于将来一系列处理流程之后才创建的，比如当某项作业完成时</li>
<li>如果资源已经存在，但这是理想状态，因此不应该被识别为一个错误时</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/09/深度解密Go语言之关于 interface 的10个问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/深度解密Go语言之关于 interface 的10个问题/" itemprop="url">深度解密Go语言之关于 interface 的10个问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-09T12:12:57+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="深度解密Go语言之关于-interface-的10个问题"><a href="#深度解密Go语言之关于-interface-的10个问题" class="headerlink" title="深度解密Go语言之关于 interface 的10个问题"></a>深度解密Go语言之关于 interface 的10个问题</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://www.cnblogs.com/qcrao-2018/p/10766091.html" target="_blank" rel="noopener">https://www.cnblogs.com/qcrao-2018/p/10766091.html</a></p>
</blockquote>
<h1 id="1-Go-语言与鸭子类型的关系"><a href="#1-Go-语言与鸭子类型的关系" class="headerlink" title="1. Go 语言与鸭子类型的关系"></a>1. Go 语言与鸭子类型的关系</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先直接来看维基百科里的定义：</p>
<blockquote>
<p>If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;翻译过来就是：如果某个东西长得像鸭子，像鸭子一样游泳，像鸭子一样嘎嘎叫，那它就可以被看成是一只鸭子。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Duck Typing</code>，鸭子类型，是动态编程语言的一种对象推断策略，它更关注对象能如何被使用，而不是对象的类型本身。<code>Go</code> 语言作为一门静态语言，它通过通过接口的方式完美支持鸭子类型。</p>
<p>例如，在动态语言 python 中，定义一个这样的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def hello_world(coder):</span><br><span class="line">    coder.say_hello()</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当调用此函数的时候，可以传入任意类型，只要它实现了 <code>say_hello()</code> 函数就可以。如果没有实现，运行过程中会出现错误。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而<strong>在静态语言如<code>Java, C++</code> 中，必须要显示地声明实现了某个接口，之后，才能用在任何需要这个接口的地方</strong>。如果你在程序中调用 <code>hello_world</code> 函数，却传入了一个根本就没有实现 <code>say_hello()</code> 的类型，那在编译阶段就不会通过。这也是静态语言比动态语言更安全的原因。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;动态语言和静态语言的差别在此就有所体现。<strong>静态语言在编译期间就能发现类型不匹配的错误，不像动态语言，必须要运行到那一行代码才会报错</strong>。插一句，这也是我不喜欢用 <code>python</code> 的一个原因。当然，<strong>静态语言要求程序员在编码阶段就要按照规定来编写程序，为每个变量规定数据类型，这在某种程度上，加大了工作量，也加长了代码量</strong>。动态语言则没有这些要求，可以让人更专注在业务上，代码也更短，写起来更快，这一点，写 <code>python</code> 的同学比较清楚。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Go</code>语言作为一门现代静态语言，是有后发优势的。它引入了动态语言的便利，同时又会进行静态语言的类型检查，写起来是非常<code>Happy</code> 的。<strong><code>Go</code> 采用了折中的做法：不要求类型显示地声明实现了某个接口，只要实现了相关的方法即可，编译器就能检测到</strong>。</p>
<p>来看个例子：</p>
<p>先定义一个接口，和使用此接口作为参数的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type IGreeting interface &#123;</span><br><span class="line">    sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sayHello(i IGreeting) &#123;</span><br><span class="line">    i.sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来定义两个结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Go struct &#123;&#125;</span><br><span class="line">func (g Go) sayHello() &#123;</span><br><span class="line">    fmt.Println(&quot;Hi, I am GO!&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type PHP struct &#123;&#125;</span><br><span class="line">func (p PHP) sayHello() &#123;</span><br><span class="line">    fmt.Println(&quot;Hi, I am PHP!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，在 <code>main</code> 函数里调用 <code>sayHello()</code>函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    golang := Go&#123;&#125;</span><br><span class="line">    php := PHP&#123;&#125;</span><br><span class="line"></span><br><span class="line">    sayHello(golang)</span><br><span class="line">    sayHello(php)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hi, I am GO!</span><br><span class="line">Hi, I am PHP!</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>main</code>函数中，调用调用 <code>sayHello()</code> 函数时，传入了 <code>golang, php</code> 对象，它们并没有显式地声明实现了 <code>IGreeting</code> 类型，只是实现了接口所规定的 <code>sayHello()</code>函数。实际上，编译器在调用 <code>sayHello()</code> 函数时，会隐式地将 <code>golang, php</code> 对象转换成 <code>IGreeting</code> 类型，这也是静态语言的类型检查功能。</p>
<p>顺带再提一下动态语言的特点：</p>
<blockquote>
<p>变量绑定的类型是不确定的，在运行期间才能确定<br>函数和方法可以接收任何类型的参数，且调用时不检查参数类型<br>不需要实现接口</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结一下，鸭子类型是一种动态语言的风格，在这种风格中，<strong>一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由它”当前方法和属性的集合”决定</strong>。<code>Go</code> 作为一种静态语言，<strong>通过接口实现了 <code>鸭子类型</code>，实际上是 <code>Go</code> 的编译器在其中作了隐匿的转换工作</strong>。</p>
<h1 id="2-值接收者和指针接收者的区别"><a href="#2-值接收者和指针接收者的区别" class="headerlink" title="2. 值接收者和指针接收者的区别"></a>2. 值接收者和指针接收者的区别</h1><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方法能给用户自定义的类型添加新的行为。它<strong>和函数的区别在于方法有一个接收者，给一个函数添加一个接收者，那么它就变成了方法</strong>。接收者可以是<code>值接收者</code>，也可以是<code>指针接收者</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在调用方法的时候，值类型既可以调用<code>值接收者</code>的方法，也可以调用<code>指针接收者</code>的方法；指针类型既可以调用<code>指针接收者</code>的方法，也可以调用<code>值接收者</code>的方法。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是说，不管方法的接收者是什么类型，该类型的值和指针都可以调用，不必严格符合接收者的类型。</p>
<p>来看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">    age int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p Person) howOld() int &#123;</span><br><span class="line">    return p.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Person) growUp() &#123;</span><br><span class="line">    p.age += 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    // qcrao 是值类型</span><br><span class="line">    qcrao := Person&#123;age: 18&#125;</span><br><span class="line"></span><br><span class="line">    // 值类型 调用接收者也是值类型的方法</span><br><span class="line">    fmt.Println(qcrao.howOld())</span><br><span class="line"></span><br><span class="line">    // 值类型 调用接收者是指针类型的方法</span><br><span class="line">    qcrao.growUp()</span><br><span class="line">    fmt.Println(qcrao.howOld())</span><br><span class="line"></span><br><span class="line">    // ----------------------</span><br><span class="line"></span><br><span class="line">    // stefno 是指针类型</span><br><span class="line">    stefno := &amp;Person&#123;age: 100&#125;</span><br><span class="line"></span><br><span class="line">    // 指针类型 调用接收者是值类型的方法</span><br><span class="line">    fmt.Println(stefno.howOld())</span><br><span class="line"></span><br><span class="line">    // 指针类型 调用接收者也是指针类型的方法</span><br><span class="line">    stefno.growUp()</span><br><span class="line">    fmt.Println(stefno.howOld())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上例子的输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">18</span><br><span class="line">19</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调用了 <code>growUp</code> 函数后，不管调用者是值类型还是指针类型，它的 <code>Age</code> 值都改变了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，当类型和方法的接收者类型不同时，其实是编译器在背后做了一些工作，用一个表格来呈现：</p>
<table>
<thead>
<tr>
<th>-</th>
<th>值接收者</th>
<th>指针接收者</th>
</tr>
</thead>
<tbody>
<tr>
<td>值类型调用者</td>
<td>方法会使用调用者的一个副本，类似于“传值”</td>
<td>使用值的引用来调用方法，上例中，<code>qcrao.growUp()</code> 实际上是 <code>(&amp;qcrao).growUp()</code></td>
</tr>
<tr>
<td>指针类型调用者</td>
<td>指针被解引用为值，上例中，<code>stefno.howOld()</code> 实际上是 <code>(*stefno).howOld()</code></td>
<td>实际上也是“传值”，方法里的操作会影响到调用者，类似于指针传参，拷贝了一份指针</td>
</tr>
</tbody>
</table>
<h2 id="值接收者和指针接收者"><a href="#值接收者和指针接收者" class="headerlink" title="值接收者和指针接收者"></a>值接收者和指针接收者</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面说过，不管接收者类型是值类型还是指针类型，都可以通过值类型或指针类型调用，这里面实际上通过语法糖起作用的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先说结论：<strong>实现了接收者是值类型的方法，相当于自动实现了接收者是指针类型的方法</strong>；而<strong>实现了接收者是指针类型的方法，【不会自动生成对应接收者是值类型的方法】</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;来看一个例子，就会完全明白：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type coder interface &#123;</span><br><span class="line">    code()</span><br><span class="line">    debug()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Gopher struct &#123;</span><br><span class="line">    language string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p Gopher) code() &#123;</span><br><span class="line">    fmt.Printf(&quot;I am coding %s language\n&quot;, p.language)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Gopher) debug() &#123;</span><br><span class="line">    fmt.Printf(&quot;I am debuging %s language\n&quot;, p.language)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var c coder = &amp;Gopher&#123;&quot;Go&quot;&#125;</span><br><span class="line">    c.code()</span><br><span class="line">    c.debug()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述代码里定义了一个接口 <code>coder</code>，接口定义了两个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code()</span><br><span class="line">debug()</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着定义了一个结构体 <code>Gopher</code>，它实现了两个方法，一个值接收者，一个指针接收者。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，我们在 <code>main</code> 函数里通过接口类型的变量调用了定义的两个函数。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行一下，结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I am coding Go language</span><br><span class="line">I am debuging Go language</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是如果我们把 <code>main</code> 函数的第一条语句换一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var c coder = Gopher&#123;&quot;Go&quot;&#125;</span><br><span class="line">    c.code()</span><br><span class="line">    c.debug()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行一下，报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./main.go:23:6: cannot use Gopher literal (type Gopher) as type coder in assignment:</span><br><span class="line">    Gopher does not implement coder (debug method has pointer receiver)</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看出这两处代码的差别了吗？第一次是将 <code>&amp;Gopher</code> 赋给了 <code>coder</code>；第二次则是将 <code>Gopher</code> 赋给了 <code>coder</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二次报错是说，<code>Gopher</code> 没有实现 <code>coder</code>。很明显了吧，因为 <code>Gopher</code> 类型并没有实现 <code>debug</code> 方法；表面上看， <code>*Gopher</code> 类型也没有实现 <code>code</code> 方法，但是因为 <code>Gopher</code> 类型实现了 <code>code</code> 方法，所以让 <code>*Gopher</code> 类型自动拥有了 <code>code</code> 方法。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，上面的说法有一个简单的解释：<strong>接收者是指针类型的方法，很可能在方法中会对接收者的属性进行更改操作，从而影响接收者</strong>；而对于<strong>接收者是值类型的方法，在方法中不会对接收者本身产生影响</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，当实现了一个接收者是值类型的方法，就可以自动生成一个接收者是对应指针类型的方法，因为两者都不会影响接收者。但是，<strong>当实现了一个接收者是指针类型的方法，如果此时自动生成一个接收者是值类型的方法，原本期望对接收者的改变（通过指针实现），现在无法实现，因为值类型会产生一个拷贝，不会真正影响调用者</strong>。</p>
<p>最后，只要记住下面这点就可以了：</p>
<blockquote>
<p><strong>如果实现了接收者是值类型的方法，会隐含地也实现了接收者是指针类型的方法</strong>，反之，结论不成立。</p>
</blockquote>
<h2 id="两者分别在何时使用"><a href="#两者分别在何时使用" class="headerlink" title="两者分别在何时使用"></a>两者分别在何时使用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用者</strong>；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身</strong>；</p>
<p>使用指针作为方法的接收者的理由：</p>
<ul>
<li>方法能够修改接收者指向的值。</li>
<li><strong>避免在每次调用方法时复制该值</strong>，在值的类型为大型结构体时，这样做会更加高效。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的<code>本质</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果类型具备“原始的本质”，也就是说它的成员都是由 <code>Go</code> 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;像内置的引用类型，如 <code>slice，map，interface，channel</code>，这些类型比较特殊，声明他们的时候，实际上是创建了一个 <code>header</code>， 对于他们也是直接定义值接收者类型的方法。这样，调用函数时，是直接 <code>copy</code>了这些类型的 <code>header</code>，而 <code>header</code> 本身就是为复制设计的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>如果类型具备非原始的本质，不能被安全地复制，这种类型总是应该被共享，那就定义指针接收者的方法</strong>。比如 <code>go</code> 源码里的文件结构体（<code>struct File</code>）就不应该被复制，应该只有一份<code>实体</code>。这一段说的比较绕，大家可以去看《Go 语言实战》5.3 那一节。</p>
<h1 id="3-iface-和-eface-的区别是什么"><a href="#3-iface-和-eface-的区别是什么" class="headerlink" title="3. iface 和 eface 的区别是什么"></a>3. iface 和 eface 的区别是什么</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>iface</code> 和 <code>eface</code> 都是 Go 中描述接口的底层结构体，区别在于 <code>iface</code> 描述的接口包含方法，而 <code>eface</code> 则是不包含任何方法的空接口：<code>interface{}</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从源码层面看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type iface struct &#123;</span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type itab struct &#123;</span><br><span class="line">    inter  *interfacetype</span><br><span class="line">    _type  *_type</span><br><span class="line">    link   *itab</span><br><span class="line">    hash   uint32 // copy of _type.hash. Used for type switches.</span><br><span class="line">    bad    bool   // type does not implement interface</span><br><span class="line">    inhash bool   // has this itab been added to hash?</span><br><span class="line">    unused [2]byte</span><br><span class="line">    fun    [1]uintptr // variable sized</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>iface</code> 内部维护两个指针，<code>tab</code> 指向一个 <code>itab</code> 实体， 它表示接口的类型以及赋给这个接口的实体类型。<code>data</code> 则指向接口具体的值，一般而言是一个指向堆内存的指针。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再来仔细看一下 <code>itab</code> 结构体：<code>_type</code> 字段描述了实体的类型，包括内存对齐方式，大小等；<code>inter</code> 字段则描述了接口的类型。<code>fun</code> 字段放置和接口方法对应的具体数据类型的方法地址，实现接口调用方法的动态分派，一般在每次给接口赋值发生转换时会更新此表，或者直接拿缓存的 itab。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里只会列出实体类型和接口相关的方法，实体类型的其他方法并不会出现在这里。如果你学过 C++ 的话，这里可以类比虚函数的概念。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，你可能会觉得奇怪，为什么 <code>fun</code> 数组的大小为 1，要是接口定义了多个方法可怎么办？实际上，这里存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储。从汇编角度来看，通过增加地址就能获取到这些函数指针，没什么影响。顺便提一句，这些方法是按照函数名称的字典序进行排列的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再看一下 <code>interfacetype</code> 类型，它描述的是接口的类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type interfacetype struct &#123;</span><br><span class="line">    typ     _type</span><br><span class="line">    pkgpath name</span><br><span class="line">    mhdr    []imethod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，它包装了 <code>_type</code> 类型，<code>_type</code> 实际上是描述 Go 语言中各种数据类型的结构体。我们注意到，这里还包含一个 <code>mhdr</code> 字段，表示接口所定义的函数列表， <code>pkgpath</code> 记录定义了接口的包名。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里通过一张图来看下 <code>iface</code> 结构体的全貌：</p>
<p><img src="//blog.com/2019/05/09/深度解密Go语言之关于 interface 的10个问题/56564826-82527600-65e1-11e9-956d-d98a212bc863.png" alt="iface 结构体全景"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接着来看一下 <code>eface</code> 的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type eface struct &#123;</span><br><span class="line">    _type *_type</span><br><span class="line">    data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相比 <code>iface</code>，<code>eface</code> 就比较简单了。只维护了一个 <code>_type</code> 字段，表示空接口所承载的具体的实体类型。<code>data</code> 描述了具体的值。</p>
<p><img src="//blog.com/2019/05/09/深度解密Go语言之关于 interface 的10个问题/56565105-318f4d00-65e2-11e9-96bd-4b2e192791dc.png" alt="eface 结构体全景"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们来看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    x := 200</span><br><span class="line">    var any interface&#123;&#125; = x</span><br><span class="line">    fmt.Println(any)</span><br><span class="line"></span><br><span class="line">    g := Gopher&#123;&quot;Go&quot;&#125;</span><br><span class="line">    var c coder = g</span><br><span class="line">    fmt.Println(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type coder interface &#123;</span><br><span class="line">    code()</span><br><span class="line">    debug()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Gopher struct &#123;</span><br><span class="line">    language string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p Gopher) code() &#123;</span><br><span class="line">    fmt.Printf(&quot;I am coding %s language\n&quot;, p.language)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p Gopher) debug() &#123;</span><br><span class="line">    fmt.Printf(&quot;I am debuging %s language\n&quot;, p.language)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行命令，打印出汇编语言：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S ./src/main.go</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，main 函数里调用了两个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func convT2E64(t *_type, elem unsafe.Pointer) (e eface)</span><br><span class="line">func convT2I(tab *itab, elem unsafe.Pointer) (i iface)</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面两个函数的参数和 <code>iface</code> 及 <code>eface</code> 结构体的字段是可以联系起来的：两个函数都是将参数<code>组装</code>一下，形成最终的接口。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作为补充，我们最后再来看下 <code>_type</code> 结构体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type _type struct &#123;</span><br><span class="line">    // 类型大小</span><br><span class="line">    size       uintptr</span><br><span class="line">    ptrdata    uintptr</span><br><span class="line">    // 类型的 hash 值</span><br><span class="line">    hash       uint32</span><br><span class="line">    // 类型的 flag，和反射相关</span><br><span class="line">    tflag      tflag</span><br><span class="line">    // 内存对齐相关</span><br><span class="line">    align      uint8</span><br><span class="line">    fieldalign uint8</span><br><span class="line">    // 类型的编号，有bool, slice, struct 等等等等</span><br><span class="line">    kind       uint8</span><br><span class="line">    alg        *typeAlg</span><br><span class="line">    // gc 相关</span><br><span class="line">    gcdata    *byte</span><br><span class="line">    str       nameOff</span><br><span class="line">    ptrToThis typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Go 语言各种数据类型都是在 <code>_type</code> 字段的基础上，增加一些额外的字段来进行管理的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">type arraytype struct &#123;</span><br><span class="line">    typ   _type</span><br><span class="line">    elem  *_type</span><br><span class="line">    slice *_type</span><br><span class="line">    len   uintptr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type chantype struct &#123;</span><br><span class="line">    typ  _type</span><br><span class="line">    elem *_type</span><br><span class="line">    dir  uintptr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type slicetype struct &#123;</span><br><span class="line">    typ  _type</span><br><span class="line">    elem *_type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type structtype struct &#123;</span><br><span class="line">    typ     _type</span><br><span class="line">    pkgPath name</span><br><span class="line">    fields  []structfield</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些数据类型的结构体定义，是反射实现的基础。</p>
<h1 id="4-接口的动态类型和动态值"><a href="#4-接口的动态类型和动态值" class="headerlink" title="4. 接口的动态类型和动态值"></a>4. 接口的动态类型和动态值</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从源码里可以看到：<code>iface</code>包含两个字段：<code>tab</code> 是接口表指针，指向类型信息；<code>data</code> 是数据指针，则指向具体的数据。它们分别被称为<code>动态类型</code>和<code>动态值</code>。而接口值包括<code>动态类型</code>和<code>动态值</code>。</p>
<h3 id="【引申1】接口类型和-nil-作比较"><a href="#【引申1】接口类型和-nil-作比较" class="headerlink" title="【引申1】接口类型和 nil 作比较"></a>【引申1】接口类型和 <code>nil</code> 作比较</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>接口值的零值是指<code>动态类型</code>和<code>动态值</code>都为 <code>nil</code></strong>。<strong>当仅且当这两部分的值都为 <code>nil</code> 的情况下，这个接口值就才会被认为 <code>接口值 == nil</code></strong>。</p>
<p>来看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Coder interface &#123;</span><br><span class="line">    code()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Gopher struct &#123;</span><br><span class="line">    name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (g Gopher) code() &#123;</span><br><span class="line">    fmt.Printf(&quot;%s is coding\n&quot;, g.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var c Coder</span><br><span class="line">    fmt.Println(c == nil)</span><br><span class="line">    fmt.Printf(&quot;c: %T, %v\n&quot;, c, c)</span><br><span class="line"></span><br><span class="line">    var g *Gopher</span><br><span class="line">    fmt.Println(g == nil)</span><br><span class="line"></span><br><span class="line">    c = g</span><br><span class="line">    fmt.Println(c == nil)</span><br><span class="line">    fmt.Printf(&quot;c: %T, %v\n&quot;, c, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">c: &lt;nil&gt;, &lt;nil&gt;</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">c: *main.Gopher, &lt;nil&gt;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一开始，<code>c</code> 的 动态类型和动态值都为 <code>nil</code>，<code>g</code> 也为 <code>nil</code>，当把 <code>g</code> 赋值给 <code>c</code> 后，<code>c</code> 的动态类型变成了 <code>*main.Gopher</code>，仅管 <code>c</code> 的动态值仍为 <code>nil</code>，但是当 <code>c</code> 和 <code>nil</code> 作比较的时候，结果就是 <code>false</code> 了。</p>
<p>【引申2】<br>来看一个例子，看一下它的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type MyError struct &#123;&#125;</span><br><span class="line"></span><br><span class="line">func (i MyError) Error() string &#123;</span><br><span class="line">    return &quot;MyError&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    err := Process()</span><br><span class="line">    fmt.Println(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(err == nil)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Process() error &#123;</span><br><span class="line">    var err *MyError = nil</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;nil&gt;</span><br><span class="line">false</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里先定义了一个 <code>MyError</code> 结构体，实现了 <code>Error</code> 函数，也就实现了 <code>error</code> 接口。<code>Process</code> 函数返回了一个 <code>error</code> 接口，这块隐含了类型转换。所以，虽然它的值是 <code>nil</code>，其实它的类型是 <code>*MyError</code>，最后和 <code>nil</code> 比较的时候，结果为 <code>false</code>。</p>
<h3 id="【引申3】如何打印出接口的动态类型和值？"><a href="#【引申3】如何打印出接口的动态类型和值？" class="headerlink" title="【引申3】如何打印出接口的动态类型和值？"></a>【引申3】如何打印出接口的动态类型和值？</h3><p>直接看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;unsafe&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type iface struct &#123;</span><br><span class="line">    itab, data uintptr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var a interface&#123;&#125; = nil</span><br><span class="line"></span><br><span class="line">    var b interface&#123;&#125; = (*int)(nil)</span><br><span class="line"></span><br><span class="line">    x := 5</span><br><span class="line">    var c interface&#123;&#125; = (*int)(&amp;x)</span><br><span class="line">    </span><br><span class="line">    ia := *(*iface)(unsafe.Pointer(&amp;a))</span><br><span class="line">    ib := *(*iface)(unsafe.Pointer(&amp;b))</span><br><span class="line">    ic := *(*iface)(unsafe.Pointer(&amp;c))</span><br><span class="line"></span><br><span class="line">    fmt.Println(ia, ib, ic)</span><br><span class="line"></span><br><span class="line">    fmt.Println(*(*int)(unsafe.Pointer(ic.data)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码里直接定义了一个 <code>iface</code> 结构体，用两个指针来描述 <code>itab</code> 和 <code>data</code>，之后将 a, b, c 在内存中的内容强制解释成我们自定义的 <code>iface</code>。最后就可以打印出动态类型和动态值的地址。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;0 0&#125; &#123;17426912 0&#125; &#123;17426912 842350714568&#125;</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a 的动态类型和动态值的地址均为 0，也就是 nil；b 的动态类型和 c 的动态类型一致，都是 <code>*int</code>；最后，c 的动态值为 5。</p>
<h1 id="5-编译器自动检测类型是否实现接口"><a href="#5-编译器自动检测类型是否实现接口" class="headerlink" title="5. 编译器自动检测类型是否实现接口"></a>5. 编译器自动检测类型是否实现接口</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经常看到一些开源库里会有一些类似下面这种奇怪的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var _ io.Writer = (*myWriter)(nil)</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时候会有点懵，不知道作者想要干什么，实际上这就是此问题的答案。编译器会由此检查 <code>*myWriter</code> 类型是否实现了 <code>io.Writer</code> 接口。</p>
<p>来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;io&quot;</span><br><span class="line"></span><br><span class="line">type myWriter struct &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*func (w myWriter) Write(p []byte) (n int, err error) &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;*/</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    // 检查 *myWriter 类型是否实现了 io.Writer 接口</span><br><span class="line">    var _ io.Writer = (*myWriter)(nil)</span><br><span class="line"></span><br><span class="line">    // 检查 myWriter 类型是否实现了 io.Writer 接口</span><br><span class="line">    var _ io.Writer = myWriter&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注释掉为<code>myWriter</code> 定义的 <code>Write</code>函数后，运行程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">src/main.go:14:6: cannot use (*myWriter)(nil) (type *myWriter) as type io.Writer in assignment:</span><br><span class="line">    *myWriter does not implement io.Writer (missing Write method)</span><br><span class="line">src/main.go:15:6: cannot use myWriter literal (type myWriter) as type io.Writer in assignment:</span><br><span class="line">    myWriter does not implement io.Writer (missing Write method)</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;报错信息：<code>*myWriter/myWriter</code>未实现<code>io.Writer</code> 接口，也就是未实现 <code>Write</code>方法。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解除注释后，运行程序不报错。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，上述赋值语句会发生隐式地类型转换，在转换的过程中，编译器会检测等号右边的类型是否实现了等号左边接口所规定的函数。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总结一下，可通过在代码中添加类似如下的代码，用来检测类型是否实现了接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var _ io.Writer = (*myWriter)(nil)</span><br><span class="line">var _ io.Writer = myWriter&#123;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-接口的构造过程是怎样的"><a href="#6-接口的构造过程是怎样的" class="headerlink" title="6. 接口的构造过程是怎样的"></a>6. 接口的构造过程是怎样的</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经看过了 <code>iface</code> 和 <code>eface</code> 的源码，知道 <code>iface</code> 最重要的是 <code>itab</code> 和 <code>_type</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了研究清楚接口是如何构造的，接下来我会拿起汇编的武器，还原背后的真相。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;来看一个示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Person interface &#123;</span><br><span class="line">    growUp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">    age int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p Student) growUp() &#123;</span><br><span class="line">    p.age += 1</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var qcrao = Person(Student&#123;age: 18&#125;)</span><br><span class="line"></span><br><span class="line">    fmt.Println(qcrao)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S main.go</span><br></pre></td></tr></table></figure>
<p>得到 main 函数的汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">0x0000 00000 (./src/main.go:30) TEXT    &quot;&quot;.main(SB), $80-0</span><br><span class="line">0x0000 00000 (./src/main.go:30) MOVQ    (TLS), CX</span><br><span class="line">0x0009 00009 (./src/main.go:30) CMPQ    SP, 16(CX)</span><br><span class="line">0x000d 00013 (./src/main.go:30) JLS     157</span><br><span class="line">0x0013 00019 (./src/main.go:30) SUBQ    $80, SP</span><br><span class="line">0x0017 00023 (./src/main.go:30) MOVQ    BP, 72(SP)</span><br><span class="line">0x001c 00028 (./src/main.go:30) LEAQ    72(SP), BP</span><br><span class="line">0x0021 00033 (./src/main.go:30) FUNCDATA$0, gclocals·69c1753bd5f81501d95132d08af04464(SB)</span><br><span class="line">0x0021 00033 (./src/main.go:30) FUNCDATA$1, gclocals·e226d4ae4a7cad8835311c6a4683c14f(SB)</span><br><span class="line">0x0021 00033 (./src/main.go:31) MOVQ    $18, &quot;&quot;..autotmp_1+48(SP)</span><br><span class="line">0x002a 00042 (./src/main.go:31) LEAQ    go.itab.&quot;&quot;.Student,&quot;&quot;.Person(SB), AX</span><br><span class="line">0x0031 00049 (./src/main.go:31) MOVQ    AX, (SP)</span><br><span class="line">0x0035 00053 (./src/main.go:31) LEAQ    &quot;&quot;..autotmp_1+48(SP), AX</span><br><span class="line">0x003a 00058 (./src/main.go:31) MOVQ    AX, 8(SP)</span><br><span class="line">0x003f 00063 (./src/main.go:31) PCDATA  $0, $0</span><br><span class="line">0x003f 00063 (./src/main.go:31) CALL    runtime.convT2I64(SB)</span><br><span class="line">0x0044 00068 (./src/main.go:31) MOVQ    24(SP), AX</span><br><span class="line">0x0049 00073 (./src/main.go:31) MOVQ    16(SP), CX</span><br><span class="line">0x004e 00078 (./src/main.go:33) TESTQ   CX, CX</span><br><span class="line">0x0051 00081 (./src/main.go:33) JEQ     87</span><br><span class="line">0x0053 00083 (./src/main.go:33) MOVQ    8(CX), CX</span><br><span class="line">0x0057 00087 (./src/main.go:33) MOVQ    $0, &quot;&quot;..autotmp_2+56(SP)</span><br><span class="line">0x0060 00096 (./src/main.go:33) MOVQ    $0, &quot;&quot;..autotmp_2+64(SP)</span><br><span class="line">0x0069 00105 (./src/main.go:33) MOVQ    CX, &quot;&quot;..autotmp_2+56(SP)</span><br><span class="line">0x006e 00110 (./src/main.go:33) MOVQ    AX, &quot;&quot;..autotmp_2+64(SP)</span><br><span class="line">0x0073 00115 (./src/main.go:33) LEAQ    &quot;&quot;..autotmp_2+56(SP), AX</span><br><span class="line">0x0078 00120 (./src/main.go:33) MOVQ    AX, (SP)</span><br><span class="line">0x007c 00124 (./src/main.go:33) MOVQ    $1, 8(SP)</span><br><span class="line">0x0085 00133 (./src/main.go:33) MOVQ    $1, 16(SP)</span><br><span class="line">0x008e 00142 (./src/main.go:33) PCDATA  $0, $1</span><br><span class="line">0x008e 00142 (./src/main.go:33) CALL    fmt.Println(SB)</span><br><span class="line">0x0093 00147 (./src/main.go:34) MOVQ    72(SP), BP</span><br><span class="line">0x0098 00152 (./src/main.go:34) ADDQ    $80, SP</span><br><span class="line">0x009c 00156 (./src/main.go:34) RET</span><br><span class="line">0x009d 00157 (./src/main.go:34) NOP</span><br><span class="line">0x009d 00157 (./src/main.go:30) PCDATA  $0, $-1</span><br><span class="line">0x009d 00157 (./src/main.go:30) CALL    runtime.morestack_noctxt(SB)</span><br><span class="line">0x00a2 00162 (./src/main.go:30) JMP     0</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们从第 10 行开始看，如果不理解前面几行汇编代码的话，可以回去看看公众号前面两篇文章，这里我就省略了。</p>
<table>
<thead>
<tr>
<th>汇编行数</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>10-14</td>
<td>构造调用 <code>runtime.convT2I64(SB)</code> 的参数</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们来看下这个函数的参数形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func convT2I64(tab *itab, elem unsafe.Pointer) (i iface) &#123;</span><br><span class="line">    // ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>convT2I64</code> 会构造出一个 <code>inteface</code>，也就是我们的 <code>Person</code> 接口。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个参数的位置是 <code>(SP)</code>，这里被赋上了 <code>go.itab.&quot;&quot;.Student,&quot;&quot;.Person(SB)</code> 的地址。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们从生成的汇编找到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go.itab.&quot;&quot;.Student,&quot;&quot;.Person SNOPTRDATA dupok size=40</span><br><span class="line">        0x0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  </span><br><span class="line">        0x0010 00 00 00 00 00 00 00 00 da 9f 20 d4              </span><br><span class="line">        rel 0+8 t=1 type.&quot;&quot;.Person+0</span><br><span class="line">        rel 8+8 t=1 type.&quot;&quot;.Student+0</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>size=40</code> 大小为40字节，回顾一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type itab struct &#123;</span><br><span class="line">    inter  *interfacetype // 8字节</span><br><span class="line">    _type  *_type // 8字节</span><br><span class="line">    link   *itab // 8字节</span><br><span class="line">    hash   uint32 // 4字节</span><br><span class="line">    bad    bool   // 1字节</span><br><span class="line">    inhash bool   // 1字节</span><br><span class="line">    unused [2]byte // 2字节</span><br><span class="line">    fun    [1]uintptr // variable sized // 8字节</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把每个字段的大小相加，<code>itab</code> 结构体的大小就是 40 字节。上面那一串数字实际上是 <code>itab</code> 序列化后的内容，注意到大部分数字是 0，从 24 字节开始的 4 个字节 <code>da 9f 20 d4</code> 实际上是 <code>itab</code> 的 <code>hash</code> 值，这在判断两个类型是否相同的时候会用到。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面两行是链接指令，简单说就是将所有源文件综合起来，给每个符号赋予一个全局的位置值。这里的意思也比较明确：前8个字节最终存储的是 <code>type.&quot;&quot;.Person</code> 的地址，对应 <code>itab</code> 里的 <code>inter</code> 字段，表示接口类型；8-16 字节最终存储的是 <code>type.&quot;&quot;.Student</code> 的地址，对应 <code>itab</code> 里 <code>_type</code> 字段，表示具体类型。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个参数就比较简单了，它就是数字 <code>18</code> 的地址，这也是初始化 <code>Student</code> 结构体的时候会用到。</p>
<table>
<thead>
<tr>
<th>汇编行数</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>15</td>
<td>调用 <code>runtime.convT2I64(SB)</code></td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体看下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func convT2I64(tab *itab, elem unsafe.Pointer) (i iface) &#123;</span><br><span class="line">    t := tab._type</span><br><span class="line">    </span><br><span class="line">    //...</span><br><span class="line">    </span><br><span class="line">    var x unsafe.Pointer</span><br><span class="line">    if *(*uint64)(elem) == 0 &#123;</span><br><span class="line">        x = unsafe.Pointer(&amp;zeroVal[0])</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        x = mallocgc(8, t, false)</span><br><span class="line">        *(*uint64)(x) = *(*uint64)(elem)</span><br><span class="line">    &#125;</span><br><span class="line">    i.tab = tab</span><br><span class="line">    i.data = x</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这块代码比较简单，把 <code>tab</code> 赋给了 <code>iface</code> 的 <code>tab</code> 字段；<code>data</code> 部分则是在堆上申请了一块内存，然后将 <code>elem</code> 指向的 <code>18</code> 拷贝过去。这样 <code>iface</code> 就组装好了。</p>
<table>
<thead>
<tr>
<th>汇编行数</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>17</td>
<td>把 <code>i.tab</code> 赋给 <code>CX</code></td>
</tr>
<tr>
<td>18</td>
<td>把 <code>i.data</code> 赋给 <code>AX</code></td>
</tr>
<tr>
<td>19-21</td>
<td>检测 <code>i.tab</code> 是否是 nil，如果不是的话，把 CX 移动 8 个字节，也就是把 <code>itab</code> 的 <code>_type</code> 字段赋给了 CX，这也是接口的实体类型，最终要作为 <code>fmt.Println</code> 函数的参数</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后面，就是调用 <code>fmt.Println</code> 函数及之前的参数准备工作了，不再赘述。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，我们就把一个 <code>interface</code> 的构造过程说完了。</p>
<p>【引申1】<br>如何打印出接口类型的 <code>Hash</code> 值？</p>
<p>这里参考曹大神翻译的一篇文章，参考资料里会写上。具体做法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type iface struct &#123;</span><br><span class="line">    tab  *itab</span><br><span class="line">    data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line">type itab struct &#123;</span><br><span class="line">    inter uintptr</span><br><span class="line">    _type uintptr</span><br><span class="line">    link uintptr</span><br><span class="line">    hash  uint32</span><br><span class="line">    _     [4]byte</span><br><span class="line">    fun   [1]uintptr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var qcrao = Person(Student&#123;age: 18&#125;)</span><br><span class="line"></span><br><span class="line">    iface := (*iface)(unsafe.Pointer(&amp;qcrao))</span><br><span class="line">    fmt.Printf(&quot;iface.tab.hash = %#x\n&quot;, iface.tab.hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定义了一个<code>山寨版</code>的 <code>iface</code> 和 <code>itab</code>，说它<code>山寨</code>是因为 <code>itab</code> 里的一些关键数据结构都不具体展开了，比如 <code>_type</code>，对比一下正宗的定义就可以发现，但是<code>山寨版</code>依然能工作，因为 <code>_type</code> 就是一个指针而已嘛。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>main</code> 函数里，先构造出一个接口对象 <code>qcrao</code>，然后强制类型转换，最后读取出 <code>hash</code> 值，非常妙！你也可以自己动手试一下。</p>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iface.tab.hash = 0xd4209fda</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得一提的是，构造接口 <code>qcrao</code> 的时候，即使我把 <code>age</code> 写成其他值，得到的 <code>hash</code> 值依然不变的，这应该是可以预料的，<code>hash</code> 值只和他的字段、方法相关。</p>
<h1 id="7-类型转换和断言的区别"><a href="#7-类型转换和断言的区别" class="headerlink" title="7. 类型转换和断言的区别"></a>7. 类型转换和断言的区别</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道，<strong>Go 语言中不允许隐式类型转换，也就是说 <code>=</code> 两边，不允许出现类型不相同的变量</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>类型转换</code>、<code>类型断言</code>本质都是把一个类型转换成另外一个类型。不同之处在于，类型断言是对接口变量进行的操作。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>对于<code>类型转换</code>而言，转换前后的两个类型要相互兼容才行。类型转换的语法为：</p>
<blockquote>
<p>&lt;结果类型&gt; := &lt;目标类型&gt; ( &lt;表达式&gt; )</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var i int = 9</span><br><span class="line"></span><br><span class="line">    var f float64</span><br><span class="line">    f = float64(i)</span><br><span class="line">    fmt.Printf(&quot;%T, %v\n&quot;, f, f)</span><br><span class="line"></span><br><span class="line">    f = 10.8</span><br><span class="line">    a := int(f)</span><br><span class="line">    fmt.Printf(&quot;%T, %v\n&quot;, a, a)</span><br><span class="line"></span><br><span class="line">    // s := []int(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面的代码里，我定义了一个 <code>int</code> 型和 <code>float64</code> 型的变量，尝试在它们之前相互转换，结果是成功的：<code>int</code> 型和 <code>float64</code> 是相互兼容的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我把最后一行代码的注释去掉，编译器会报告类型不兼容的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cannot convert i (type int) to type []int</span><br></pre></td></tr></table></figure>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面说过，因为<strong>空接口 <code>interface{}</code> 没有定义任何函数，因此 Go 中所有类型都实现了空接口</strong>。当一个函数的形参是 <code>interface{}</code>，那么在函数中，需要对形参进行断言，从而得到它的真实类型。</p>
<p>断言的语法为：</p>
<blockquote>
<p>&lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;.( 目标类型 ) // 安全类型断言<br>&lt;目标类型的值&gt; := &lt;表达式&gt;.( 目标类型 )　　//非安全类型断言</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类型转换和类型断言有些相似，不同之处，在于<strong>类型断言是对接口进行的操作</strong>。</p>
<p>还是来看一个简短的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">    Age int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var i interface&#123;&#125; = new(Student)</span><br><span class="line">    s := i.(Student)</span><br><span class="line">    </span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: interface conversion: interface &#123;&#125; is *main.Student, not main.Student</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直接 <code>panic</code> 了，这是因为 <code>i</code> 是 <code>*Student</code> 类型，并非 <code>Student</code> 类型，断言失败。这里直接发生了 <code>panic</code>，线上代码可能并不适合这样做，可以采用“安全断言”的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    var i interface&#123;&#125; = new(Student)</span><br><span class="line">    s, ok := i.(Student)</span><br><span class="line">    if ok &#123;</span><br><span class="line">        fmt.Println(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，即使断言失败也不会 <code>panic</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;断言其实还有另一种形式，就是用<strong>在利用 <code>switch</code> 语句判断接口的类型。每一个 <code>case</code> 会被顺序地考虑</strong>。当命中一个 <code>case</code> 时，就会执行 <code>case</code> 中的语句，因此 <code>case</code> 语句的顺序是很重要的，因为很有可能会有多个 <code>case</code> 匹配的情况。</p>
<p>代码示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    //var i interface&#123;&#125; = new(Student)</span><br><span class="line">    //var i interface&#123;&#125; = (*Student)(nil)</span><br><span class="line">    var i interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(&quot;%p %v\n&quot;, &amp;i, i)</span><br><span class="line"></span><br><span class="line">    judge(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func judge(v interface&#123;&#125;) &#123;</span><br><span class="line">    fmt.Printf(&quot;%p %v\n&quot;, &amp;v, v)</span><br><span class="line"></span><br><span class="line">    switch v := v.(type) &#123;</span><br><span class="line">    case nil:</span><br><span class="line">        fmt.Printf(&quot;%p %v\n&quot;, &amp;v, v)</span><br><span class="line">        fmt.Printf(&quot;nil type[%T] %v\n&quot;, v, v)</span><br><span class="line"></span><br><span class="line">    case Student:</span><br><span class="line">        fmt.Printf(&quot;%p %v\n&quot;, &amp;v, v)</span><br><span class="line">        fmt.Printf(&quot;Student type[%T] %v\n&quot;, v, v)</span><br><span class="line"></span><br><span class="line">    case *Student:</span><br><span class="line">        fmt.Printf(&quot;%p %v\n&quot;, &amp;v, v)</span><br><span class="line">        fmt.Printf(&quot;*Student type[%T] %v\n&quot;, v, v)</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        fmt.Printf(&quot;%p %v\n&quot;, &amp;v, v)</span><br><span class="line">        fmt.Printf(&quot;unknow\n&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">    Age int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>main</code> 函数里有三行不同的声明，每次运行一行，注释另外两行，得到三组运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// --- var i interface&#123;&#125; = new(Student)</span><br><span class="line">0xc4200701b0 [Name: ], [Age: 0]</span><br><span class="line">0xc4200701d0 [Name: ], [Age: 0]</span><br><span class="line">0xc420080020 [Name: ], [Age: 0]</span><br><span class="line">*Student type[*main.Student] [Name: ], [Age: 0]</span><br><span class="line"></span><br><span class="line">// --- var i interface&#123;&#125; = (*Student)(nil)</span><br><span class="line">0xc42000e1d0 &lt;nil&gt;</span><br><span class="line">0xc42000e1f0 &lt;nil&gt;</span><br><span class="line">0xc42000c030 &lt;nil&gt;</span><br><span class="line">*Student type[*main.Student] &lt;nil&gt;</span><br><span class="line"></span><br><span class="line">// --- var i interface&#123;&#125;</span><br><span class="line">0xc42000e1d0 &lt;nil&gt;</span><br><span class="line">0xc42000e1e0 &lt;nil&gt;</span><br><span class="line">0xc42000e1f0 &lt;nil&gt;</span><br><span class="line">nil type[&lt;nil&gt;] &lt;nil&gt;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于第一行语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var i interface&#123;&#125; = new(Student)</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>i</code> 是一个 <code>*Student</code> 类型，匹配上第三个 case，从打印的三个地址来看，这三处的变量实际上都是不一样的。在 <code>main</code> 函数里有一个局部变量 <code>i</code>；调用函数时，实际上是复制了一份参数，因此函数里又有一个变量 <code>v</code>，它是 <code>i</code> 的拷贝；断言之后，又生成了一份新的拷贝。所以最终打印的三个变量的地址都不一样。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于第二行语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var i interface&#123;&#125; = (*Student)(nil)</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>这里想说明的其实是 <code>i</code> 在这里动态类型是 <code>(*Student)</code>, 数据为 <code>nil</code>，它的类型并不是 <code>nil</code>，它与 <code>nil</code> 作比较的时候，得到的结果也是 <code>false</code></strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一行语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var i interface&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这回 <code>i</code> 才是 <code>nil</code> 类型。</p>
<h3 id="【引申1】-打印结构体变量-1"><a href="#【引申1】-打印结构体变量-1" class="headerlink" title="【引申1】 打印结构体变量 1"></a>【引申1】 打印结构体变量 1</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>fmt.Println</code> 函数的参数是 <code>interface</code>。对于内置类型，函数内部会用穷举法，得出它的真实类型，然后转换为字符串打印</strong>。<strong>而对于自定义类型，首先确定该类型是否实现了 <code>String()</code> 方法，如果实现了，则直接打印输出 <code>String()</code> 方法的结果</strong>；<strong>否则，会通过反射来遍历对象的成员进行打印</strong>。</p>
<p>再来看一个简短的例子，比较简单，不要紧张：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">    Name string</span><br><span class="line">    Age int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var s = Student&#123;</span><br><span class="line">        Name: &quot;qcrao&quot;,</span><br><span class="line">        Age: 18,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为 <code>Student</code> 结构体没有实现 <code>String()</code> 方法，所以 <code>fmt.Println</code> 会利用反射挨个打印成员变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;qcrao 18&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;增加一个 <code>String()</code> 方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (s Student) String() string &#123;</span><br><span class="line">    return fmt.Sprintf(&quot;[Name: %s], [Age: %d]&quot;, s.Name, s.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Name: qcrao], [Age: 18]</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照我们自定义的方法来打印了。</p>
<h3 id="【引申2】打印结构体变量-2"><a href="#【引申2】打印结构体变量-2" class="headerlink" title="【引申2】打印结构体变量 2"></a>【引申2】打印结构体变量 2</h3><p>针对上面的例子，如果改一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (s *Student) String() string &#123;</span><br><span class="line">    return fmt.Sprintf(&quot;[Name: %s], [Age: %d]&quot;, s.Name, s.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意看两个函数的接受者类型不同，现在 <code>Student</code> 结构体只有一个接受者类型为 <code>指针类型</code> 的 <code>String()</code> 函数，打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;qcrao 18&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么？</p>
<blockquote>
<p><strong>类型 <code>*T</code> 只有接受者是 <code>*T</code> 的方法；而类型 <code>T</code> 拥有接受者是 <code>T</code> 和 <code>*T</code> 的方法</strong>。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以， <code>Student</code> 结构体定义了接受者类型是值类型的 <code>String()</code> 方法时，通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(s)</span><br><span class="line">fmt.Println(&amp;s)</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;均可以按照自定义的格式来打印。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 <code>Student</code> 结构体定义了接受者类型是指针类型的 <code>String()</code> 方法时，只有通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(&amp;s)</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;才能按照自定义的格式打印。</p>
<h1 id="8-接口转换的原理"><a href="#8-接口转换的原理" class="headerlink" title="8. 接口转换的原理"></a>8. 接口转换的原理</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过前面提到的 <code>iface</code> 的源码可以看到，实际上它包含接口的类型 <code>interfacetype</code> 和 实体类型的类型 <code>_type</code>，这两者都是 <code>iface</code> 的字段 <code>itab</code> 的成员。也就是说生成一个 <code>itab</code> 同时需要接口的类型和实体的类型。</p>
<blockquote>
<p><interface 类型，="" 实体类型=""> -&gt;itable</interface></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>当判定一种类型是否满足某个接口时，<code>Go</code> 使用类型的方法集和接口所需要的方法集进行匹配，如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如某类型有 <code>m</code> 个方法，某接口有 <code>n</code> 个方法，则很容易知道这种判定的时间复杂度为 <code>O(mn)</code>，Go 会对方法集的函数按照函数名的字典序进行排序，所以实际的时间复杂度为 <code>O(m+n)</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们来探索将一个接口转换给另外一个接口背后的原理，当然，能转换的原因必然是类型兼容。</p>
<p>直接来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">type coder interface &#123;</span><br><span class="line">    code()</span><br><span class="line">    run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type runner interface &#123;</span><br><span class="line">    run()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Gopher struct &#123;</span><br><span class="line">    language string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (g Gopher) code() &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (g Gopher) run() &#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    var c coder = Gopher&#123;&#125;</span><br><span class="line"></span><br><span class="line">    var r runner</span><br><span class="line">    r = c</span><br><span class="line">    fmt.Println(c, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单解释下上述代码：定义了两个 <code>interface</code>: <code>coder</code> 和 <code>runner</code>。定义了一个实体类型 <code>Gopher</code>，类型 <code>Gopher</code> 实现了两个方法，分别是 <code>run()</code> 和 <code>code()</code>。main 函数里定义了一个接口变量 <code>c</code>，绑定了一个 <code>Gopher</code> 对象，之后将 <code>c</code> 赋值给另外一个接口变量 <code>r</code> 。赋值成功的原因是 <code>c</code> 中包含 <code>run()</code> 方法。这样，两个接口变量完成了转换。</p>
<p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -S ./src/main.go</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;得到 main 函数的汇编命令，可以看到： <code>r = c</code> 这一行语句实际上是调用了 <code>runtime.convI2I(SB)</code>，也就是 <code>convI2I</code> 函数，从函数名来看，就是将一个 <code>interface</code> 转换成另外一个 <code>interface</code>，看下它的源代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func convI2I(inter *interfacetype, i iface) (r iface) &#123;</span><br><span class="line">    tab := i.tab</span><br><span class="line">    if tab == nil &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    if tab.inter == inter &#123;</span><br><span class="line">        r.tab = tab</span><br><span class="line">        r.data = i.data</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    r.tab = getitab(inter, tab._type, false)</span><br><span class="line">    r.data = i.data</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码比较简单，函数参数 <code>inter</code> 表示接口类型，<code>i</code> 表示绑定了实体类型的接口，<code>r</code> 则表示接口转换了之后的新的 <code>iface</code>。通过前面的分析，我们又知道， <code>iface</code> 是由 <code>tab</code> 和 <code>data</code> 两个字段组成。所以，实际上 <code>convI2I</code> 函数真正要做的事，找到新 <code>interface</code> 的 <code>tab</code> 和 <code>data</code>，就大功告成了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还知道，<code>tab</code> 是由接口类型 <code>interfacetype</code> 和 实体类型 <code>_type</code>。所以最关键的语句是 <code>r.tab = getitab(inter, tab._type, false)</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，重点来看下 <code>getitab</code> 函数的源码，只看关键的地方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">func getitab(inter *interfacetype, typ *_type, canfail bool) *itab &#123;</span><br><span class="line">    // ……</span><br><span class="line"></span><br><span class="line">    // 根据 inter, typ 计算出 hash 值</span><br><span class="line">    h := itabhash(inter, typ)</span><br><span class="line"></span><br><span class="line">    // look twice - once without lock, once with.</span><br><span class="line">    // common case will be no lock contention.</span><br><span class="line">    var m *itab</span><br><span class="line">    var locked int</span><br><span class="line">    for locked = 0; locked &lt; 2; locked++ &#123;</span><br><span class="line">        if locked != 0 &#123;</span><br><span class="line">            lock(&amp;ifaceLock)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 遍历哈希表的一个 slot</span><br><span class="line">        for m = (*itab)(atomic.Loadp(unsafe.Pointer(&amp;hash[h]))); m != nil; m = m.link &#123;</span><br><span class="line"></span><br><span class="line">            // 如果在 hash 表中已经找到了 itab（inter 和 typ 指针都相同）</span><br><span class="line">            if m.inter == inter &amp;&amp; m._type == typ &#123;</span><br><span class="line">                // ……</span><br><span class="line">                </span><br><span class="line">                if locked != 0 &#123;</span><br><span class="line">                    unlock(&amp;ifaceLock)</span><br><span class="line">                &#125;</span><br><span class="line">                return m</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 在 hash 表中没有找到 itab，那么新生成一个 itab</span><br><span class="line">    m = (*itab)(persistentalloc(unsafe.Sizeof(itab&#123;&#125;)+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, &amp;memstats.other_sys))</span><br><span class="line">    m.inter = inter</span><br><span class="line">    m._type = typ</span><br><span class="line">    </span><br><span class="line">    // 添加到全局的 hash 表中</span><br><span class="line">    additab(m, true, canfail)</span><br><span class="line">    unlock(&amp;ifaceLock)</span><br><span class="line">    if m.bad &#123;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    return m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单总结一下：getitab 函数会根据 <code>interfacetype</code> 和 <code>_type</code> 去全局的 itab 哈希表中查找，如果能找到，则直接返回；否则，会根据给定的 <code>interfacetype</code> 和 <code>_type</code> 新生成一个 <code>itab</code>，并插入到 itab 哈希表，这样下一次就可以直接拿到 <code>itab</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里查找了两次，并且第二次上锁了，这是因为如果第一次没找到，在第二次仍然没有找到相应的 <code>itab</code> 的情况下，需要新生成一个，并且写入哈希表，因此需要加锁。这样，其他协程在查找相同的 <code>itab</code> 并且也没有找到时，第二次查找时，会被挂住，之后，就会查到第一个协程写入哈希表的 <code>itab</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再来看一下 <code>additab</code> 函数的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">// 检查 _type 是否符合 interface_type 并且创建对应的 itab 结构体 将其放到 hash 表中</span><br><span class="line">func additab(m *itab, locked, canfail bool) &#123;</span><br><span class="line">    inter := m.inter</span><br><span class="line">    typ := m._type</span><br><span class="line">    x := typ.uncommon()</span><br><span class="line"></span><br><span class="line">    // both inter and typ have method sorted by name,</span><br><span class="line">    // and interface names are unique,</span><br><span class="line">    // so can iterate over both in lock step;</span><br><span class="line">    // the loop is O(ni+nt) not O(ni*nt).</span><br><span class="line">    // </span><br><span class="line">    // inter 和 typ 的方法都按方法名称进行了排序</span><br><span class="line">    // 并且方法名都是唯一的。所以循环的次数是固定的</span><br><span class="line">    // 只用循环 O(ni+nt)，而非 O(ni*nt)</span><br><span class="line">    ni := len(inter.mhdr)</span><br><span class="line">    nt := int(x.mcount)</span><br><span class="line">    xmhdr := (*[1 &lt;&lt; 16]method)(add(unsafe.Pointer(x), uintptr(x.moff)))[:nt:nt]</span><br><span class="line">    j := 0</span><br><span class="line">    for k := 0; k &lt; ni; k++ &#123;</span><br><span class="line">        i := &amp;inter.mhdr[k]</span><br><span class="line">        itype := inter.typ.typeOff(i.ityp)</span><br><span class="line">        name := inter.typ.nameOff(i.name)</span><br><span class="line">        iname := name.name()</span><br><span class="line">        ipkg := name.pkgPath()</span><br><span class="line">        if ipkg == &quot;&quot; &#123;</span><br><span class="line">            ipkg = inter.pkgpath.name()</span><br><span class="line">        &#125;</span><br><span class="line">        for ; j &lt; nt; j++ &#123;</span><br><span class="line">            t := &amp;xmhdr[j]</span><br><span class="line">            tname := typ.nameOff(t.name)</span><br><span class="line">            // 检查方法名字是否一致</span><br><span class="line">            if typ.typeOff(t.mtyp) == itype &amp;&amp; tname.name() == iname &#123;</span><br><span class="line">                pkgPath := tname.pkgPath()</span><br><span class="line">                if pkgPath == &quot;&quot; &#123;</span><br><span class="line">                    pkgPath = typ.nameOff(x.pkgpath).name()</span><br><span class="line">                &#125;</span><br><span class="line">                if tname.isExported() || pkgPath == ipkg &#123;</span><br><span class="line">                    if m != nil &#123;</span><br><span class="line">                        // 获取函数地址，并加入到itab.fun数组中</span><br><span class="line">                        ifn := typ.textOff(t.ifn)</span><br><span class="line">                        *(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[0]), uintptr(k)*sys.PtrSize)) = ifn</span><br><span class="line">                    &#125;</span><br><span class="line">                    goto nextimethod</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // ……</span><br><span class="line">        </span><br><span class="line">        m.bad = true</span><br><span class="line">        break</span><br><span class="line">    nextimethod:</span><br><span class="line">    &#125;</span><br><span class="line">    if !locked &#123;</span><br><span class="line">        throw(&quot;invalid itab locking&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 计算 hash 值</span><br><span class="line">    h := itabhash(inter, typ)</span><br><span class="line">    // 加到Hash Slot链表中</span><br><span class="line">    m.link = hash[h]</span><br><span class="line">    m.inhash = true</span><br><span class="line">    atomicstorep(unsafe.Pointer(&amp;hash[h]), unsafe.Pointer(m))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>additab</code> 会检查 <code>itab</code> 持有的 <code>interfacetype</code> 和 <code>_type</code> 是否符合，就是看 <code>_type</code> 是否完全实现了 <code>interfacetype</code> 的方法，也就是看两者的方法列表重叠的部分就是 <code>interfacetype</code> 所持有的方法列表。注意到其中有一个双层循环，乍一看，循环次数是 <code>ni * nt</code>，但由于两者的函数列表都按照函数名称进行了排序，因此最终只执行了 <code>ni + nt</code> 次，代码里通过一个小技巧来实现：第二层循环并没有从 0 开始计数，而是从上一次遍历到的位置开始。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;求 hash 值的函数比较简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func itabhash(inter *interfacetype, typ *_type) uint32 &#123;</span><br><span class="line">    h := inter.typ.hash</span><br><span class="line">    h += 17 * typ.hash</span><br><span class="line">    return h % hashSize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>hashSize</code> 的值是 1009。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更一般的，当把实体类型赋值给接口的时候，会调用 <code>conv</code> 系列函数，例如空接口调用 <code>convT2E</code> 系列、非空接口调用 <code>convT2I</code> 系列。这些函数比较相似：</p>
<blockquote>
<ol>
<li>具体类型转空接口时，_type 字段直接复制源类型的 _type；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。</li>
<li>具体类型转非空接口时，入参 tab 是编译器在编译阶段预先生成好的，新接口 tab 字段直接指向入参 tab 指向的 itab；调用 mallocgc 获得一块新内存，把值复制进去，data 再指向这块新内存。</li>
<li>而对于接口转接口，itab 调用 getitab 函数获取。只用生成一次，之后直接从 hash 表中获取。</li>
</ol>
</blockquote>
<h1 id="9-如何用-interface-实现多态"><a href="#9-如何用-interface-实现多态" class="headerlink" title="9. 如何用 interface 实现多态"></a>9. 如何用 interface 实现多态</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Go</code> 语言并没有设计诸如虚函数、纯虚函数、继承、多重继承等概念，但它通过接口却非常优雅地支持了面向对象的特性。</p>
<p>多态是一种运行期的行为，它有以下几个特点：</p>
<blockquote>
<ol>
<li>一种类型具有多种类型的能力</li>
<li>允许不同的对象对同一消息做出灵活的反应</li>
<li>以一种通用的方式对待个使用的对象</li>
<li>非动态语言必须通过继承和接口的方式来实现</li>
</ol>
</blockquote>
<p>看一个实现了多态的代码例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    qcrao := Student&#123;age: 18&#125;</span><br><span class="line">    whatJob(&amp;qcrao)</span><br><span class="line"></span><br><span class="line">    growUp(&amp;qcrao)</span><br><span class="line">    fmt.Println(qcrao)</span><br><span class="line"></span><br><span class="line">    stefno := Programmer&#123;age: 100&#125;</span><br><span class="line">    whatJob(stefno)</span><br><span class="line"></span><br><span class="line">    growUp(stefno)</span><br><span class="line">    fmt.Println(stefno)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func whatJob(p Person) &#123;</span><br><span class="line">    p.job()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func growUp(p Person) &#123;</span><br><span class="line">    p.growUp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Person interface &#123;</span><br><span class="line">    job()</span><br><span class="line">    growUp()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">    age int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p Student) job() &#123;</span><br><span class="line">    fmt.Println(&quot;I am a student.&quot;)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *Student) growUp() &#123;</span><br><span class="line">    p.age += 1</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Programmer struct &#123;</span><br><span class="line">    age int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p Programmer) job() &#123;</span><br><span class="line">    fmt.Println(&quot;I am a programmer.&quot;)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p Programmer) growUp() &#123;</span><br><span class="line">    // 程序员老得太快 ^_^</span><br><span class="line">    p.age += 10</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码里先定义了 1 个 <code>Person</code> 接口，包含两个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">job()</span><br><span class="line">growUp()</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，又定义了 2 个结构体，<code>Student</code> 和 <code>Programmer</code>，同时，类型 <code>*Student</code>、<code>Programmer</code> 实现了 <code>Person</code> 接口定义的两个函数。注意，<code>*Student</code> 类型实现了接口， <code>Student</code> 类型却没有。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后，我又定义了函数参数是 <code>Person</code> 接口的两个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func whatJob(p Person)</span><br><span class="line">func growUp(p Person)</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>main</code> 函数里先生成 <code>Student</code> 和 <code>Programmer</code> 的对象，再将它们分别传入到函数 <code>whatJob</code> 和 <code>growUp</code>。函数中，直接调用接口函数，<strong>实际执行的时候是看最终传入的实体类型是什么，调用的是实体类型实现的函数</strong>。于是，不同对象针对同一消息就有多种表现，<code>多态</code>就实现了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更深入一点来说的话，在函数 <code>whatJob()</code> 或者 <code>growUp()</code> 内部，接口 <code>person</code> 绑定了实体类型 <code>*Student</code> 或者 <code>Programmer</code>。根据前面分析的 <code>iface</code> 源码，这里会直接调用 <code>fun</code> 里保存的函数，类似于： <code>s.tab-&gt;fun[0]</code>，而因为 <code>fun</code> 数组里保存的是实体类型实现的函数，所以当函数传入不同的实体类型时，调用的实际上是不同的函数实现，从而实现多态。</p>
<p>运行一下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I am a student.</span><br><span class="line">&#123;19&#125;</span><br><span class="line">I am a programmer.</span><br><span class="line">&#123;100&#125;</span><br></pre></td></tr></table></figure>
<h1 id="10-Go-接口与-C-接口有何异同"><a href="#10-Go-接口与-C-接口有何异同" class="headerlink" title="10. Go 接口与 C++ 接口有何异同"></a>10. Go 接口与 C++ 接口有何异同</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>接口定义了一种规范，描述了类的行为和功能，而不做具体实现</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++ 的接口是使用抽象类来实现的，如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Shape</span><br><span class="line">&#123;</span><br><span class="line">   public:</span><br><span class="line">      // 纯虚函数</span><br><span class="line">      virtual double getArea() = 0;</span><br><span class="line">   private:</span><br><span class="line">      string name;      // 名称</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设计抽象类的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;派生类需要明确地声明它继承自基类，并且需要实现基类中所有的纯虚函数。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++ 定义接口的方式称为“侵入式”，而 Go 采用的是 “非侵入式”，不需要显式声明，只需要实现接口定义的函数，编译器自动会识别。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++ 和 Go 在定义接口方式上的不同，也导致了底层实现上的不同。C++ 通过虚函数表来实现基类调用派生类的函数；而 Go 通过 <code>itab</code> 中的 <code>fun</code> 字段来实现接口变量调用实体类型的函数。C++ 中的虚函数表是在编译期生成的；而 Go 的 <code>itab</code> 中的 <code>fun</code> 字段是在运行期间动态生成的。原因在于，Go 中实体类型可能会无意中实现 N 多接口，很多接口并不是本来需要的，所以不能为类型实现的所有接口都生成一个 <code>itab</code>， 这也是“非侵入式”带来的影响；这在 C++ 中是不存在的，因为派生需要显示声明它继承自哪个基类。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/09/如何设计一个良好的接口/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/如何设计一个良好的接口/" itemprop="url">如何设计一个良好的接口</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-09T12:12:57+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/API设计/" itemprop="url" rel="index">
                    <span itemprop="name">API设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="如何设计一个良好的接口"><a href="#如何设计一个良好的接口" class="headerlink" title="如何设计一个良好的接口"></a>如何设计一个良好的接口</h1><p>​      在设计接口时，有很多因素要考虑，如接口的业务定位，接口的安全性，接口的可扩展性、接口的稳定性、接口的跨域性、接口的协议规则、接口的路径规则、接口单一原则、</p>
<h2 id="一-规范性建议"><a href="#一-规范性建议" class="headerlink" title="一 规范性建议"></a>一 规范性建议</h2><hr>
<h3 id="1-职责原则"><a href="#1-职责原则" class="headerlink" title="1.职责原则"></a><strong>1.职责原则</strong></h3><p>在设计接口时，必须明确接口的职责，即接口类型，接口应解决什么业务问题等</p>
<h3 id="2-单一性原则"><a href="#2-单一性原则" class="headerlink" title="2.单一性原则"></a><strong>2.单一性原则</strong></h3><p>在明确接口职责的条件下，尽量做到接口单一，即一个接口只做一件事，而非两件以上。很多非资深接口设计者，在设计接口时，</p>
<p>总认为接口所做的事越多，越牛叉，这是非常严重的错误认识。</p>
<h3 id="3-协议规范"><a href="#3-协议规范" class="headerlink" title="3.协议规范"></a><strong>3.协议规范</strong></h3><p>在设计接口时，应明确接口协议，是采用HTTP协议,HTTPS协议还是FTP协议，要根据具体情况来定。</p>
<p>(1)FTP协议(File Transfer Protocol，简称FTP)，是一套标准的文件传输协议，用于传输文件，如.txt，.csv等，一般文件传输，采用FTP协议</p>
<p>(2)HTTP协议，适用一般对安全性要求比较低或没要求的业务情景</p>
<p>(3)HTTPS=HTTP+SSL,适用于对安全性要求较高的业务情景</p>
<h3 id="4-路径规则"><a href="#4-路径规则" class="headerlink" title="4.路径规则"></a><strong>4.路径规则</strong></h3><p>由于api获取的是一种资源，所以网址中尽量为名词，而非动词</p>
<p> /api/v1.0/Pruduct/2019</p>
<p>/api/v1.0/Users/2019</p>
<h3 id="5-http请求方式"><a href="#5-http请求方式" class="headerlink" title="5.http请求方式"></a><strong>5.http请求方式</strong></h3><p>接口基本访问协议：get(获取)，post(新增)，put(修改)和delete(删除)</p>
<p>get     /users：列出所有用户</p>
<p>get    /users/id：根据id获取用户</p>
<p>post   /user：新增用户</p>
<p>put      /user/id：根据用户id更新用户</p>
<p>delete   /user/id：根据用户id删除用户</p>
<h3 id="6-域名"><a href="#6-域名" class="headerlink" title="6.域名"></a><strong>6.域名</strong></h3><p>一般地，域名分为主域名和专有域名，主域名适合api长期不变或变化较少的业务，专有域名是解决具体的专有业务的</p>
<p>以百度举例：</p>
<p>(1)主域名:<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p>
<p>(2)产品服务类</p>
<p> 百度文库：<a href="https://wenku.baidu.com/" target="_blank" rel="noopener">https://wenku.baidu.com/</a></p>
<p> 百度知道：<a href="https://zhidao.baidu.com/" target="_blank" rel="noopener">https://zhidao.baidu.com/</a></p>
<p> 百度资讯： <a href="https://zhidao.baidu.com/" target="_blank" rel="noopener">https://zhidao.baidu.com/</a></p>
<p>(3)市场活动类</p>
<p>百度公益：<a href="http://gongyi.baidu.com[" target="_blank" rel="noopener">http://gongyi.baidu.com[</a></p>
<p>](<a href="http://gongyi.baidu.com/" target="_blank" rel="noopener">http://gongyi.baidu.com/</a>)</p>
<p>百度logo：<a href="http://logo.baidu.com/" target="_blank" rel="noopener">http://logo.baidu.com/</a></p>
<p>百度世界：<a href="https://baiduworld.baidu.com" target="_blank" rel="noopener">https://baiduworld.baidu.com</a></p>
<h3 id="7-跨域考虑"><a href="#7-跨域考虑" class="headerlink" title="7.跨域考虑"></a><strong>7.跨域考虑</strong></h3><p>在明确域名的情况下，一定要考虑接口是否跨域，以及跨域应采用的技术手段等</p>
<h3 id="8-api版本"><a href="#8-api版本" class="headerlink" title="8.api版本"></a><strong>8.api版本</strong></h3><p>对于接口的url，应加版本号<a href="http://api.demo.com/v{d}/，如" target="_blank" rel="noopener">http://api.demo.com/v{d}/，如</a> ，其中d表示版本号,如v1.0,v2.0</p>
<p>例子：获取产品号为2019,版本号为v1.0的版本号的产品信息</p>
<p><code>/api/v1.0/Pruducts/2019</code></p>
<h3 id="9-适度过滤信息"><a href="#9-适度过滤信息" class="headerlink" title="9.适度过滤信息"></a><strong>9.适度过滤信息</strong></h3><p>当记录数比较多时(如 <code>SELECT * FROM TBName</code>)，因适当添加一些条件对数据进行过滤，如TOP,分页,分组，排序和WHERE条件等</p>
<p>下面是一些常见的参数。</p>
<p>?limit=100：返回100条数据</p>
<p>?offset=101：从第101条数据开始返回</p>
<p>?page=10：指第10页</p>
<p>per_page=100：每页100条数据</p>
<p>?sortby=name：排序字段</p>
<p>?order=desc：降序</p>
<p>？group=groupName:分组</p>
<p>?producy_type=1：筛选条件</p>
<h3 id="10-返回数据格式"><a href="#10-返回数据格式" class="headerlink" title="10.返回数据格式"></a><strong>10.返回数据格式</strong></h3><p>返回数据格式，一般包括三个字段：</p>
<p>(1)失败情况(状态码、错误码和错误描述)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">“status”:0,//状态码 0-表示失败，1-表示成功</span><br><span class="line"></span><br><span class="line">“error_code”:”2003”,//错误码，一般在设计时定义</span><br><span class="line"></span><br><span class="line">“error_des”:”身份验证失败”//错误描述，一般在设计时定义</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)成功情况(标识id,数据对象,状态码)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">     ”sid“:”sh20190111”,//token id</span><br><span class="line"></span><br><span class="line">     ”users“:&#123;</span><br><span class="line"></span><br><span class="line">                   ”id“:”al201901111341”,//用户id</span><br><span class="line"></span><br><span class="line">                  “name”:”Alan_beijing”,//用户名</span><br><span class="line"></span><br><span class="line">                   “addr”:”用户地址”</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">     “status”:1//状态码 0-表示失败，1-表示成功</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-安全性原则"><a href="#11-安全性原则" class="headerlink" title="11.安全性原则"></a><strong>11.安全性原则</strong></h3><p>接口暴露的考虑，接口并发量的考虑，接口防攻击的考虑，接口跨域的考虑等</p>
<h3 id="12-可扩展性原则"><a href="#12-可扩展性原则" class="headerlink" title="12.可扩展性原则"></a><strong>12.可扩展性原则</strong></h3><p>在设计接口时，充分考虑接口的可扩展性。</p>
<h3 id="13-定义api界限"><a href="#13-定义api界限" class="headerlink" title="13.定义api界限"></a><strong>13.定义api界限</strong></h3><p>任何api，从权限上，可归结为匿名api和非匿名api，前者不需要验证，后者需要验证</p>
<h3 id="14-定义api返回码"><a href="#14-定义api返回码" class="headerlink" title="14.定义api返回码"></a><strong>14.定义api返回码</strong></h3><p>在api设计时，要定好api返回码，如</p>
<p>1–授权过期</p>
<p>404–未找到资源</p>
<p>500–内部服务器错误</p>
<p>600–账号被锁</p>
<h2 id="二-反规范性建议"><a href="#二-反规范性建议" class="headerlink" title="二 反规范性建议"></a>二 反规范性建议</h2><hr>
<p>​      存在这样一种业务场景：某个接口需要返回多个api接口组合的结果 ，在类似的业务场景下，所设计的接口，具有一定的反规范性。</p>
<h3 id="1-Request"><a href="#1-Request" class="headerlink" title="1.Request"></a><strong>1.Request</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data:[</span><br><span class="line">    &#123;url:&apos;api1&apos;,type:&apos;get&apos;,data:&#123;...&#125;&#125;,</span><br><span class="line">    &#123;url:&apos;api2&apos;,type:&apos;get&apos;,data:&#123;...&#125;&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h3 id="2-Responce"><a href="#2-Responce" class="headerlink" title="2.Responce"></a><strong>2.Responce</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    status:0,</span><br><span class="line">    msg:&apos;&apos;,</span><br><span class="line">    data:[</span><br><span class="line">        &#123;status:1,msg:&apos;&apos;,data:[]&#125;,</span><br><span class="line">        &#123;status:1,msg:&apos;&apos;,data:&#123;&#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三-实例"><a href="#三-实例" class="headerlink" title="三  实例"></a>三  实例</h2><hr>
<p>​      假设存在这样一个一个业务：一个ERP系统，需要提供两个接口，一个是用户访问接口(需要验证)，另一个是用户注册接口(不需要验证)。</p>
<p>​    根据本篇文章一，二部分的建议，我们来设计满足该业务需求的接口</p>
<p><strong>（一）定义统一参数</strong></p>
<p>1.定义统一输入参数</p>
<p><img src="//blog.com/2019/05/09/如何设计一个良好的接口/1066923-20190114150329936-1759634466.png" alt="img"></p>
<p>2.定义统一输出参数</p>
<p><img src="//blog.com/2019/05/09/如何设计一个良好的接口/1066923-20190114150132848-1498730965.png" alt="img"></p>
<p>3.定义统一错误码</p>
<p><img src="//blog.com/2019/05/09/如何设计一个良好的接口/1066923-20190114151059575-138067158.png" alt="img"></p>
<p><strong>（二）定义接口授权类别</strong></p>
<p>如下为定义接口授权类别</p>
<p><img src="//blog.com/2019/05/09/如何设计一个良好的接口/1066923-20190114153258908-632263285.png" alt="img"></p>
<p><strong>（三）用户接口</strong></p>
<p>1.用户注册</p>
<p><img src="//blog.com/2019/05/09/如何设计一个良好的接口/1066923-20190114151735626-1842219688.png" alt="img"></p>
<p>2.Request</p>
<p><img src="//blog.com/2019/05/09/如何设计一个良好的接口/1066923-20190114152044823-18703836.png" alt="img"></p>
<p>3.Responce</p>
<p><img src="//blog.com/2019/05/09/如何设计一个良好的接口/1066923-20190114152428270-617695622.png" alt="img"></p>
<p>4.code示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Request:</span><br><span class="line">&#123;</span><br><span class="line">    &quot;mobile&quot;:13636595499,</span><br><span class="line">    &quot;verify_code&quot;:&quot;987654&quot;,</span><br><span class="line">    &quot;pwd&quot;:&quot;123456&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Responce:</span><br><span class="line">(1)error</span><br><span class="line">&#123;</span><br><span class="line">   &quot;status&quot;:0,</span><br><span class="line">   &quot;error_code&quot;:1001，</span><br><span class="line">   &quot;error_desc&quot;:&quot;手机验证码已失效&quot;</span><br><span class="line">&#125;</span><br><span class="line">(2)succed</span><br><span class="line">&#123;</span><br><span class="line">   &quot;sid&quot;:&quot;sh201901141529&quot;,</span><br><span class="line">   &quot;uid&quot;:1,</span><br><span class="line">   &quot;status&quot;:1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>（四）用户登录</strong></p>
<p>1.登录接口概述</p>
<p> <img src="//blog.com/2019/05/09/如何设计一个良好的接口/1066923-20190114153541285-1632029604.png" alt="img"></p>
<p>2.Request</p>
<p><img src="//blog.com/2019/05/09/如何设计一个良好的接口/1066923-20190114153927051-9088316.png" alt="img"></p>
<p>3.Responce</p>
<p><img src="//blog.com/2019/05/09/如何设计一个良好的接口/1066923-20190114155642109-1359715878.png" alt="img"></p>
<p>4.Code</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Responce:</span><br><span class="line">1.error</span><br><span class="line">&#123;</span><br><span class="line">   &quot;status&quot;:0,</span><br><span class="line">   &quot;error_code&quot;:1002,</span><br><span class="line">   &quot;error_desc&quot;:&quot;密码错误&quot;</span><br><span class="line">&#125;</span><br><span class="line">2.succeed</span><br><span class="line">&#123;</span><br><span class="line">   &quot;sid&quot;:&quot;sh201901141529&quot;,</span><br><span class="line">   &quot;user&quot;:&#123;</span><br><span class="line">         &quot;id&quot;:1,</span><br><span class="line">     &quot;username&quot;:&quot;&quot;,</span><br><span class="line">      age:0,</span><br><span class="line">      gender:0</span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;status&quot;:1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/80/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/80/">80</a><span class="page-number current">81</span><a class="page-number" href="/page/82/">82</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/82/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
