<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/page/105/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/page/105/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/04/04/如何优化Golang中重复的错误处理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/04/如何优化Golang中重复的错误处理/" itemprop="url">如何优化Golang中重复的错误处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-04T12:12:57+08:00">
                2019-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="如何优化Golang中重复的错误处理"><a href="#如何优化Golang中重复的错误处理" class="headerlink" title="如何优化Golang中重复的错误处理"></a>如何优化Golang中重复的错误处理</h1><blockquote>
<p>原文地址：<a href="https://huoding.com/2019/04/11/728" target="_blank" rel="noopener">https://huoding.com/2019/04/11/728</a></p>
</blockquote>
<p>Golang 错误处理最让人头疼的问题就是代码里充斥着「if err != nil」，它们破坏了代码的可读性，本文收集了几个例子，让大家明白如何优化此类问题。</p>
<p>让我们看看 <a href="https://blog.golang.org/errors-are-values" target="_blank" rel="noopener">Errors are values</a> 中提到的一个 io.Writer 例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_, err = fd.Write(p0[a:b])</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br><span class="line">_, err = fd.Write(p1[c:d])</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br><span class="line">_, err = fd.Write(p2[e:f])</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码乍一看无法直观的看出其本来的意图是什么，改进版：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">type errWriter struct &#123;</span><br><span class="line">	w   io.Writer</span><br><span class="line">	err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ew *errWriter) write(buf []byte) &#123;</span><br><span class="line">	if ew.err != nil &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	_, ew.err = ew.w.Write(buf)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ew := &amp;errWriter&#123;w: fd&#125;</span><br><span class="line">ew.write(p0[a:b])</span><br><span class="line">ew.write(p1[c:d])</span><br><span class="line">ew.write(p2[e:f])</span><br><span class="line">if ew.err != nil &#123;</span><br><span class="line">    return ew.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过自定义类型 errWriter 来封装 io.Writer，并且封装了 error，新类型有一个 write 方法，不过其方法签名并没有返回 error，而是在方法内部判断一旦有问题就立刻返回，有了这些准备工作，我们就可以<strong>把原本穿插在业务逻辑中间的错误判断提出来放到最后来统一调用</strong>，从而在视觉上保证让人可以直观的看出代码本来的意图是什么。</p>
<p>让我们再看看 <a href="https://dave.cheney.net/2019/01/27/eliminate-error-handling-by-eliminating-errors" target="_blank" rel="noopener">Eliminate error handling by eliminating errors</a> 中提到的另一个 io.Writer 例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">type Header struct &#123;</span><br><span class="line">	Key, Value string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Status struct &#123;</span><br><span class="line">	Code   int</span><br><span class="line">	Reason string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func WriteResponse(w io.Writer, st Status, headers []Header, body io.Reader) error &#123;</span><br><span class="line">	_, err := fmt.Fprintf(w, &quot;HTTP/1.1 %d %s\r\n&quot;, st.Code, st.Reason)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for _, h := range headers &#123;</span><br><span class="line">		_, err := fmt.Fprintf(w, &quot;%s: %s\r\n&quot;, h.Key, h.Value)</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if _, err := fmt.Fprint(w, &quot;\r\n&quot;); err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_, err = io.Copy(w, body)</span><br><span class="line">	return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一感觉既然错误是 fmt.Fprint 和 io.Copy 返回的，是不是我们要重新封装一下它们？实际上真正的源头是它们的参数 io.Writer，因为直接调用 io.Writer 的 Writer 方法的话，方法签名中有返回值 error，所以每一步 fmt.Fprint 和 io.Copy 操作都不得不进行重复的错误处理，看上去是坏味道，改进版：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">type errWriter struct &#123;</span><br><span class="line">	io.Writer</span><br><span class="line">	err error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *errWriter) Write(buf []byte) (int, error) &#123;</span><br><span class="line">	if e.err != nil &#123;</span><br><span class="line">		return 0, e.err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var n int</span><br><span class="line">	n, e.err = e.Writer.Write(buf)</span><br><span class="line">	return n, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func WriteResponse(w io.Writer, st Status, headers []Header, body io.Reader) error &#123;</span><br><span class="line">	ew := &amp;errWriter&#123;Writer: w&#125;</span><br><span class="line">	fmt.Fprintf(ew, &quot;HTTP/1.1 %d %s\r\n&quot;, st.Code, st.Reason)</span><br><span class="line"></span><br><span class="line">	for _, h := range headers &#123;</span><br><span class="line">		fmt.Fprintf(ew, &quot;%s: %s\r\n&quot;, h.Key, h.Value)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Fprint(ew, &quot;\r\n&quot;)</span><br><span class="line">	io.Copy(ew, body)</span><br><span class="line"></span><br><span class="line">	return ew.err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过自定义类型 errWriter 来封装 io.Writer，并且封装了 error，同时重写了 Writer 方法，虽然方法签名中仍然有返回值 error，但是我们单独保存了一份 error，并且在方法内部判断一旦有问题就立刻返回，有了这些准备工作，新版的 WriteResponse 不再有重复的错误判断，只需要在最后检查一下 error 即可。</p>
<p>类似的做法在 Golang 标准库中屡见不鲜，让我们继续看看 <a href="https://dave.cheney.net/2019/01/27/eliminate-error-handling-by-eliminating-errors" target="_blank" rel="noopener">Eliminate error handling by eliminating errors</a> 中提到的一个关于 bufio.Reader 和 bufio.Scanner 的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">func CountLines(r io.Reader) (int, error) &#123;</span><br><span class="line">	var (</span><br><span class="line">		br    = bufio.NewReader(r)</span><br><span class="line">		lines int</span><br><span class="line">		err   error</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	for &#123;</span><br><span class="line">		_, err = br.ReadString(&apos;\n&apos;)</span><br><span class="line">		lines++</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if err != io.EOF &#123;</span><br><span class="line">		return 0, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return lines, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们构造一个 bufio.Reader，然后在一个循环中调用 ReadString 方法，如果读到文件结尾，那么 ReadString 会返回一个错误（io.EOF），为了判断此类情况，我们不得不在每次循环时判断「if err != nil」，看上去这是坏味道，改进版：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func CountLines(r io.Reader) (int, error) &#123;</span><br><span class="line">	sc := bufio.NewScanner(r)</span><br><span class="line">	lines := 0</span><br><span class="line"></span><br><span class="line">	for sc.Scan() &#123;</span><br><span class="line">		lines++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return lines, sc.Err()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，和 bufio.Reader 相比，bufio.Scanner 是一个更高阶的类型，换句话简单点来说的话，相当于是 bufio.Scanner 抽象了 bufio.Reader，通过把低阶的 bufio.Reader 换成高阶的 bufio.Scanner，循环中不再需要判断「if err != nil」，因为 Scan 方法签名不再返回 error，而是返回 bool，当在循环里读到了文件结尾的时候，循环直接结束，如此一来，我们就可以统一在最后调用 Err 方法来判断成功还是失败，看看 Scanner 的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">type Scanner struct &#123;</span><br><span class="line">	r            io.Reader // The reader provided by the client.</span><br><span class="line">	split        SplitFunc // The function to split the tokens.</span><br><span class="line">	maxTokenSize int       // Maximum size of a token; modified by tests.</span><br><span class="line">	token        []byte    // Last token returned by split.</span><br><span class="line">	buf          []byte    // Buffer used as argument to split.</span><br><span class="line">	start        int       // First non-processed byte in buf.</span><br><span class="line">	end          int       // End of data in buf.</span><br><span class="line">	err          error     // Sticky error.</span><br><span class="line">	empties      int       // Count of successive empty tokens.</span><br><span class="line">	scanCalled   bool      // Scan has been called; buffer is in use.</span><br><span class="line">	done         bool      // Scan has finished.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见 Scanner 封装了 io.Reader，并且封装了 error，和我们之前讨论的做法一致。有一点说明一下，实际上查看 Scan 源代码的话，你会发现它不是通过 err 来判断是否结束的，而是通过 done 来判断是否结束，这是因为 Scan 只有遇到文件结束的错误才退出，其它错误会继续执行，当然，这只是具体的细节问题，不影响我们的结论。</p>
<p>通过对以上几个例子的分析，我们可以得出优化重复错误处理的大概套路：<strong>通过创建新的类型来封装原本干脏活累活的旧类型，同时在新类型中封装 error，新旧类型的方法签名可以保持兼容，也可以不兼容，这个不是关键的，视客观情况而定，至于具体的逻辑实现，先判断有没有 error，如果有就直接退出，如果没有就继续执行，并且在执行过程中保存可能出现的 error 以便后面操作使用，最后通过统一调用新类型的 error 来完成错误处理</strong>。提醒一下，此方案的缺点是<strong>要到最后才能知道有没有错误</strong>，好在如此的控制粒度在多数时候并无大碍。</p>
<blockquote>
<p>调用方不方便提前返回，依旧会完成所有的计算（以及其它 I/O），到最后才发现文件根本写不进去，白算了。</p>
<p>对于一个原子性的操作，这种方案是不可行的，因为这个方案存在部分成功、部分失败的可能</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/04/04/异步网络模型/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/04/异步网络模型/" itemprop="url">异步网络模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-04T12:12:57+08:00">
                2019-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/" itemprop="url" rel="index">
                    <span itemprop="name">异步与同步</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/" itemprop="url" rel="index">
                    <span itemprop="name">IO</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/" itemprop="url" rel="index">
                    <span itemprop="name">Reactor</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/事件模型/" itemprop="url" rel="index">
                    <span itemprop="name">事件模型</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/事件模型/网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="异步网络模型"><a href="#异步网络模型" class="headerlink" title="异步网络模型"></a>异步网络模型</h1><p>异步网络模型在服务开发中应用非常广泛，相关资料和开源库也非常多。项目中，使用现成的轮子提高了开发效率，除了能使用轮子，还是有必要了解一下轮子的内部构造。</p>
<p>这篇文章从最基础的5种I/O模型切入，到I/O事件处理模型，再到并发模式，最后以Swoole开源库来做具体分析，逐步深入。文中提到的模型都是一些通用的模型，在《linux高性能服务器编程》中也都有涉及。文章不涉及模型的实现细节，最重要的是去理解各个模型的工作模式以及其优缺点。</p>
<p>文中涉及接口调用的部分，都是指Linux系统的接口调用。 共分为5部分：</p>
<p><strong>I/O模型</strong></p>
<p>从基础的系统调用方法出发，给大家从头回顾一下最基本的I/O模型，虽然简单，但是不可或缺的基础；</p>
<p><strong>事件处理模型</strong></p>
<p>这部分在同步I/O、异步I/O的基础上分别介绍Reactor模型以及Proactor模型，着重两种模型的构成以及事件处理流程。Reactor模型是我们常见的；不同平台对异步I/O系统接口的支持力度不同，这部分还介绍了一种使用同步I/O来模拟Proactor模型的方法。</p>
<p><strong>并发模式</strong></p>
<p>就是多线程、多进程的编程的模式。介绍了两种较为高效的并发模型，半同步／半异步(包括其演变模式)、Follower／Leader模式。</p>
<p><strong>Swoole异步网络模型分析</strong></p>
<p>这部分是结合已介绍的事件处理模型、并发模式对Swoole的异步模型进行分析； 从分析的过程来看，看似复杂的网络模型，可以拆分为简单的模型单元，只不过我们需要权衡利弊，选取合适业务需求的模型单元进行组合。 我们团队基于Swoole 1.8.5版本，做了很多修改，部分模块做了重构，计划在17年6月底将修改后版本开源出去，敬请期待。</p>
<p><strong>改善性能的方法</strong></p>
<p>最后一部分是在引入话题，介绍的是几种常用的方法。性能优化是没有终点的，希望大家能贡献一些想法和具体方法。</p>
<h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h2><p>POSIX 规范中定义了同步I/O 和异步I/O的术语，<br><strong>同步I/O</strong> : 需要进程去真正的去操作I/O；</p>
<p><strong>异步I/O</strong>：内核在I/O操作完成后再通知应用进程操作结果。</p>
<p>在《UNIX网络编程》中介绍了5中I/O模型：阻塞I/O、非阻塞I/O、I/O复用、SIGIO 、异步I/O；本节对这5种I/O模型进行说明和对比。</p>
<h3 id="I-O阻塞"><a href="#I-O阻塞" class="headerlink" title="I/O阻塞"></a>I/O阻塞</h3><p>通常把阻塞的文件描述符（file descriptor，fd）称之为阻塞I/O。默认条件下，创建的socket fd是阻塞的，针对阻塞I/O调用系统接口，可能因为等待的事件没有到达而被系统挂起，直到等待的事件触发调用接口才返回，例如，tcp socket的connect调用会阻塞至第三次握手成功（不考虑socket 出错或系统中断），如图1所示。另外socket 的系统API ，如，accept、send、recv等都可能被阻塞。</p>
<p><img src="//blog.com/2019/04/04/异步网络模型/connect_bloackxx-1.png" alt="img"></p>
<p>另外补充一点，网络编程中，通常把可能永远阻塞的系统API调用 称为慢系统调用，典型的如 accept、recv、select等。慢系统调用在阻塞期间可能被信号中断而返回错误，相应的errno 被设置为EINTR，我们需要处理这种错误，解决办法有：</p>
<p><strong>1. 重启系统调用</strong></p>
<p>直接上示例代码吧，以accept为例，被中断后重启accept 。有个例外，若connect 系统调用在阻塞时被中断，是不能直接重启的（与内核socket 的状态有关)，有兴趣的同学可以深入研究一下connect 的内核实现。使用I/O复用等待连接完成，能避免connect不能重启的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> client_fd = <span class="number">-1</span>;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span>  </span><br><span class="line"><span class="keyword">socklen_t</span> child_addrlen;  </span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">call_accept:  </span><br><span class="line">    client_fd = accept(server_fd,<span class="literal">NULL</span>,<span class="literal">NULL</span>)；</span><br><span class="line">    <span class="keyword">if</span> (client_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (EINTR == errno) &#123;</span><br><span class="line">          <span class="keyword">goto</span> call_accept;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          sw_sysError(<span class="string">"accept fail"</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 信号处理</strong></p>
<p>利用信号处理，可以选择忽略信号，或者在安装信号时设置SA_RESTART属性。设置属性SA_RESTART，信号处理函数返回后，被安装信号中断的系统调用将自动恢复，示例代码如下。需要知道的是，设置SA_RESTART属性方法并不完全适用，对某些系统调用可能无效，这里只是提供一种解决问题的思路，示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> client_fd = <span class="number">-1</span>;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">action</span>,<span class="title">old_action</span>;</span></span><br><span class="line"></span><br><span class="line">action.sa_handler = sig_handler;  </span><br><span class="line">sigemptyset(&amp;action.sa_mask);  </span><br><span class="line">action.sa_flags = <span class="number">0</span>;  </span><br><span class="line">action.sa_flags |= SA_RESTART;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 若信号已经被忽略，则不设置</span></span><br><span class="line">sigaction(SIGALRM, <span class="literal">NULL</span>, &amp;old_action)；  </span><br><span class="line"><span class="keyword">if</span> (old_action.sa_handler != SIG_IGN) &#123;  </span><br><span class="line">    sigaction(SIGALRM, &amp;action, <span class="literal">NULL</span>)；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;  </span><br><span class="line">    client_fd = accept(server_fd,<span class="literal">NULL</span>,<span class="literal">NULL</span>)；</span><br><span class="line">    <span class="keyword">if</span> (client_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        sw_sysError(<span class="string">"accept fail"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="I-O非阻塞"><a href="#I-O非阻塞" class="headerlink" title="I/O非阻塞"></a>I/O非阻塞</h3><p>把非阻塞的文件描述符称为非阻塞I/O。可以通过设置SOCK_NONBLOCK标记创建非阻塞的socket fd，或者使用fcntl将fd设置为非阻塞。</p>
<p>对非阻塞fd调用系统接口时，不需要等待事件发生而立即返回，事件没有发生，接口返回-1，此时需要通过errno的值来区分是否出错，有过网络编程的经验的应该都了解这点。不同的接口，立即返回时的errno值不尽相同，如，recv、send、accept errno通常被设置为EAGIN 或者EWOULDBLOCK，connect 则为EINPRO- GRESS 。</p>
<p>以recv操作非阻塞套接字为例，如图2所示。</p>
<p><img src="//blog.com/2019/04/04/异步网络模型/recv_noblock-1.png" alt="img"></p>
<p>当我们需要读取，在有数据可读的事件触发时，再调用recv，避免应用层不断去轮询检查是否可读，提高程序的处理效率。通常非阻塞I/O与I/O事件处理机制结合使用。</p>
<h3 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I/O复用"></a>I/O复用</h3><p>最常用的I/O事件通知机制就是I/O复用(I/O multiplexing)。Linux 环境中使用select/poll/epoll 实现I/O复用，I/O复用接口本身是阻塞的，在应用程序中通过I/O复用接口向内核注册fd所关注的事件，当关注事件触发时，通过I/O复用接口的返回值通知到应用程序，如图3所示,以recv为例。I/O复用接口可以同时监听多个I/O事件以提高事件处理效率。</p>
<p><img src="//blog.com/2019/04/04/异步网络模型/io---1.png" alt="img"></p>
<p>关于select/poll/epoll的对比，可以参考[]，epoll使用比较多，但是在并发的模式下，需要关注惊群的影响。</p>
<h3 id="SIGIO"><a href="#SIGIO" class="headerlink" title="SIGIO"></a>SIGIO</h3><p>除了I/O复用方式通知I/O事件，还可以通过SIGIO信号来通知I/O事件，如图4所示。两者不同的是，在等待数据达到期间，I/O复用是会阻塞应用程序，而SIGIO方式是不会阻塞应用程序的。</p>
<p><img src="//blog.com/2019/04/04/异步网络模型/------1.png" alt="img"></p>
<h3 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h3><p>POSIX规范定义了一组异步操作I/O的接口，不用关心fd 是阻塞还是非阻塞，异步I/O是由内核接管应用层对fd的I/O操作。异步I/O向应用层通知I/O操作完成的事件，这与前面介绍的I/O 复用模型、SIGIO模型通知事件就绪的方式明显不同。以aio_read 实现异步读取IO数据为例，如图5所示，在等待I/O操作完成期间，不会阻塞应用程序。</p>
<p><img src="//blog.com/2019/04/04/异步网络模型/--io-1.png" alt="img"></p>
<h3 id="I-O模型对比"><a href="#I-O模型对比" class="headerlink" title="I/O模型对比"></a>I/O模型对比</h3><p>前面介绍的5中I/O中，I/O 阻塞、I/O非阻塞、I/O复用、SIGIO 都会在不同程度上阻塞应用程序，而只有异步I/O模型在整个操作期间都不会阻塞应用程序。</p>
<p>如图6所示，列出了5种I/O模型的比较</p>
<p><img src="//blog.com/2019/04/04/异步网络模型/-------1--1.png" alt="img"></p>
<h2 id="事件处理模型"><a href="#事件处理模型" class="headerlink" title="事件处理模型"></a>事件处理模型</h2><p>网络设计模式中，如何处理各种I/O事件是其非常重要的一部分，Reactor 和Proactor两种事件处理模型应运而生。上章节提到将I/O分为同步I/O 和 异步I/O，可以使用同步I/O实现Reactor模型，使用异步I/O实现Proactor模型。</p>
<p>本章节将介绍Reactor和Proactor两种模型，最后将介绍一种使用同步I/O模拟Proactor事件处理模型。</p>
<h3 id="Reactor事件处理模型"><a href="#Reactor事件处理模型" class="headerlink" title="Reactor事件处理模型"></a><strong>Reactor事件处理模型</strong></h3><p>Reactor模型是同步I/O事件处理的一种常见模型，关于Reactor模型结构的资料非常多，一个典型的Reactor模型类图结构如图7所示，</p>
<p><img src="//blog.com/2019/04/04/异步网络模型/import5.png" alt="img"></p>
<p><strong>Reactor的核心思想</strong>：将关注的I/O事件注册到多路复用器上，一旦有I/O事件触发，将事件分发到事件处理器中，执行就绪I/O事件对应的处理函数中。模型中有三个重要的组件：</p>
<ul>
<li><strong>多路复用器</strong>：由操作系统提供接口，Linux提供的I/O复用接口有select、poll、epoll；</li>
<li><strong>事件分离器</strong>：将多路复用器返回的就绪事件分发到事件处理器中；</li>
<li><strong>事件处理器</strong>：处理就绪事件处理函数。</li>
</ul>
<p>图7所示，Reactor 类结构中包含有如下角色。</p>
<ul>
<li><strong>Handle</strong>：标示文件描述符；</li>
<li><strong>Event Demultiplexer</strong>：执行多路事件分解操作，对操作系统内核实现I/O复用接口的封装；用于阻塞等待发生在句柄集合上的一个或多个事件（如select/poll/epoll）；</li>
<li><strong>Event Handler</strong>：事件处理接口；</li>
<li><strong>Event Handler A(B)</strong>：实现应用程序所提供的特定事件处理逻辑；</li>
<li><strong>Reactor</strong>：反应器，定义一个接口，实现以下功能：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a) 供应用程序注册和删除关注的事件句柄；</span><br><span class="line">b) 运行事件处理循环；</span><br><span class="line">c) 等待的就绪事件触发，分发事件到之前注册的回调函数上处理.</span><br></pre></td></tr></table></figure>
<p>接下来介绍Reactor的工作流程，如图8所示，为Reactor模型工作的简化流程。</p>
<p><img src="//blog.com/2019/04/04/异步网络模型/-------4-.png" alt="img"></p>
<ol>
<li>注册I/O就绪事件处理器；</li>
<li>事件分离器等待I/O就绪事件；</li>
<li>I/O事件触发，激活事件分离器，分离器调度对应的事件处理器；</li>
<li>事件处理器完成I/O操作，处理数据.</li>
</ol>
<p>网络设计中，Reactor使用非常广，在开源社区有很许多非常成熟的、跨平台的、Reactor模型的网络库，比较典型如libevent。</p>
<h3 id="Proactor事件处理模型"><a href="#Proactor事件处理模型" class="headerlink" title="Proactor事件处理模型"></a>Proactor事件处理模型</h3><p>与Reactor不同的是，Proactor使用异步I/O系统接口将I/O操作托管给操作系统，Proactor模型中分发处理异步I/O完成事件，并调用相应的事件处理接口来处理业务逻辑。Proactor类结构如图9所示。</p>
<p><img src="//blog.com/2019/04/04/异步网络模型/import8.png" alt="img"></p>
<p>图9所示，Proactor类结构中包含有如下角色：</p>
<ul>
<li><strong>Handle</strong>： 用来标识socket连接或是打开文件；</li>
<li><strong>Async Operation Processor</strong>：异步操作处理器；负责执行异步操作，一般由操作系统内核实现；</li>
<li><strong>Async Operation</strong>：异步操作；</li>
<li><strong>Completion Event Queue</strong>：完成事件队列；异步操作完成的结果放到队列中等待后续使用；</li>
<li><strong>Proactor</strong>：主动器；为应用程序进程提供事件循环；从完成事件队列中取出异步操作的结果，分发调用相应的后续处理逻辑；</li>
<li><strong>Completion Handler</strong>：完成事件接口；一般是由回调函数组成的接口；</li>
<li><strong>Completion Handler A(B)</strong>：完成事件处理逻辑；实现接口定义特定的应用处理逻辑。</li>
</ul>
<p>Proactor模型的简化的工作流程,如图10所示。</p>
<p><img src="//blog.com/2019/04/04/异步网络模型/-------3-.png" alt="img"></p>
<ol>
<li>发起I/O异步操作，注册I/O完成事件处理器;</li>
<li>事件分离器等待I/O操作完成事件；</li>
<li>内核并行执行实际的I/O操作，并将结果数据存入用户自定义缓 冲区；</li>
<li>内核完成I/O操作，通知事件分离器，事件分离器调度对应的事件处理器；</li>
<li>事件处理器处理用户自定义缓冲区中的数据。</li>
</ol>
<p>Proactor利用异步I/O并行能力，可给应用程序带来更高的效率，但是同时也增加了编程的复杂度。windows对异步I/O提供了非常好的支持，常用Proactor的模型实现服务器；而Linux对异步I/O操作(aio接口)的支持并不是特别理想，而且不能直接处理accept，因此Linux平台上还是以Reactor模型为主。</p>
<p>Boost asio采用的是Proactor模型，但是Linux上，采用I/O复用的方式来模拟Proactor，另启用线程来完成读写操作和调度。</p>
<h3 id="同步I-O模拟Proactor"><a href="#同步I-O模拟Proactor" class="headerlink" title="同步I/O模拟Proactor"></a>同步I/O模拟Proactor</h3><p>下面一种使用同步I/O模拟Proactor的方案，原理是：</p>
<p><strong>主线程执行数据读写操作，读写操作完成后，主线程向工作线程通知I/O操作“完成事件”；</strong></p>
<p>工作流程如图 11所示。</p>
<p><img src="//blog.com/2019/04/04/异步网络模型/11.png" alt="img"></p>
<p>简单的描述一下图11 的执行流程：</p>
<ol>
<li>主线程往系统I/O复用中注册文件描述符fd上的读就绪事件；</li>
<li>主线程调用调用系统I/O复用接口等待文件描述符fd上有数据可读；</li>
<li>当fd上有数据可读时，通知主线程。主线程循环读取fd上的数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后向I/O复用中注册fd上的写就绪事件。主线程进入事件等待循环，等待fd可写。</li>
</ol>
<h2 id="并发模式"><a href="#并发模式" class="headerlink" title="并发模式"></a>并发模式</h2><p>在I/O密集型的程序，采用并发方式可以提高CPU的使用率，可采用多进程和多线程两种方式实现并发。当前有高效的两种并发模式，半同步/半异步模式、Follower/Leader模式。</p>
<h3 id="半同步-半异步模式"><a href="#半同步-半异步模式" class="headerlink" title="半同步/半异步模式"></a>半同步/半异步模式</h3><p>首先区分一个概念，并发模式中的“同步”、“异步”与 I/O模型中的“同步”、“异步”是两个不同的概念：</p>
<p><strong>并发模式中</strong>，“同步”指程序按照代码顺序执行，“异步”指程序依赖事件驱动，如图12 所示并发模式的“同步”执行和“异步”执行的读操作；</p>
<p><strong>I/O模型中</strong>，“同步”、“异步”用来区分I/O操作的方式，是主动通过I/O操作拿到结果，还是由内核异步的返回操作结果。</p>
<p><img src="//blog.com/2019/04/04/异步网络模型/12.png" alt="img"></p>
<p><img src="//blog.com/2019/04/04/异步网络模型/d4293cab-d80d-4396-9790-425c1e414cc5.png" alt="img"></p>
<p>本节从最简单的半同步/半异步模式的工作流程出发，并结合事件处理模型介绍两种演变的模式。</p>
<h4 id="半同步-半异步工作流程"><a href="#半同步-半异步工作流程" class="headerlink" title="半同步/半异步工作流程"></a><strong>半同步/半异步工作流程</strong></h4><p>半同步/半异步模式的工作流程如图13 所示。</p>
<p><img src="//blog.com/2019/04/04/异步网络模型/13-1.png" alt="img"></p>
<p>其中异步线程处理I/O事件，同步线程处理请求对象，简单的来说：</p>
<ol>
<li>异步线程监听到事件后，将其封装为请求对象插入到请求队列中；</li>
<li>请求队列有新的请求对象，通知同步线程获取请求对象；</li>
<li>同步线程处理请求对象，实现业务逻辑。</li>
</ol>
<h4 id="半同步-半反应堆模式"><a href="#半同步-半反应堆模式" class="headerlink" title="半同步/半反应堆模式"></a>半同步/半反应堆模式</h4><p>考虑将两种事件处理模型，即Reactor和Proactor，与几种I/O模型结合在一起，那么半同步/半异步模式就演变为半同步／半反应堆模式。先看看使用Reactor的方式，如图14 所示。</p>
<p><img src="//blog.com/2019/04/04/异步网络模型/15.png" alt="img"></p>
<p>其工作流程为：</p>
<ol>
<li>异步线程监听所有fd上的I/O事件，若监听socket接可读，接受新的连接；并监听该连接上的读写事件；</li>
<li>若连接socket上有读写事件发生，异步线程将该连接socket插入请求队列中；</li>
<li>同步线程被唤醒，并接管连接socket，从socket上读取请求和发送应答；</li>
</ol>
<p>若将Reactor替换为Proactor，那么其工作流程为：</p>
<ol>
<li>异步线程完成I/O操作，并I/O操作的结果封装为任务对象，插入请求队列中；</li>
<li>请求队列通知同步线程处理任务；</li>
<li>同步线程执行任务处理逻辑。</li>
</ol>
<h4 id="一种高效的演变模式"><a href="#一种高效的演变模式" class="headerlink" title="一种高效的演变模式"></a>一种高效的演变模式</h4><p>半同步／半反应堆模式有明显的缺点：</p>
<ol>
<li>异步线程和同步线程共享队列，需要保护，存在资源竞争；</li>
<li>工作线程同一时间只能处理一个任务，任务处理量很大或者任务处理存在一定的阻塞时，任务队列将会堆积，任务的时效性也等不到保证；不能简单地考虑增加工作线程来处理该问题，线程数达到一定的程度，工作线程的切换也将白白消耗大量的CPU资源。</li>
</ol>
<p>下面介绍一种改进的方式，如图15 所示，每个工作线程都有自己的事件循环，能同时独立处理多个用户连接。</p>
<p><img src="//blog.com/2019/04/04/异步网络模型/16.png" alt="img"></p>
<p>其工作流程为：</p>
<ol>
<li>主线程实现连接监听，只处理网络I/O连接事件；</li>
<li>新的连接socket分发至工作线程中，这个socket上的I/O事件都由该工作线程处理，工作线程都可以处理多个socket 的I/O事件；</li>
<li>工作线程独立维护自己的事件循环，监听不同连接socket的I/O事件。</li>
</ol>
<h3 id="Follower-Leader-模式"><a href="#Follower-Leader-模式" class="headerlink" title="Follower/Leader 模式"></a>Follower/Leader 模式</h3><p>Follower/Leader是多个工作线程轮流进行事件监听、事件分发、处理事件的模式。</p>
<p>在Follower/Leader模式工作的任何一个时间点，只有一个工作线程处理成为Leader ，负责I/O事件监听，而其他线程都是Follower，并等待成为Leader。</p>
<p>Follower/Leader模式的工作流概述如下：</p>
<ol>
<li>当前Leader Thread1监听到就绪事件后，从Follower 线程集中推选出 Thread 2成为新的Leader；</li>
<li>新的Leader Thread2 继续事件I/O监听；</li>
<li>Thread1继续处理I/O就绪事件，执行完后加入到Follower 线程集中，等待成为Leader。</li>
</ol>
<p>从上描述，Leader/Follower模式的工作线程存在三种状态，工作线程同一时间只能处于一种状态，这三种状态为：</p>
<ul>
<li>Leader：线程处于领导者状态，负责监听I/O事件；</li>
<li>Processing：线程处理就绪I/O事件；</li>
<li>Follower：等待成为新的领导者或者可能被当前Leader指定处理就绪事件。</li>
</ul>
<p>Leader监听到I/O就绪事件后，有两种处理方式:</p>
<ol>
<li>推选出新的Leader后，并转移到Processing处理该I/O就绪事件；</li>
<li>指定其他Follower 线程处理该I/O就绪事件，此时保持Leader状态不变；</li>
</ol>
<p>如图16所示为上面描述的三种状态的转移关系。</p>
<p><img src="//blog.com/2019/04/04/异步网络模型/17.png" alt="img"></p>
<p>如图16所示，处于Processing状态的线程处理完I/O事件后，若当前不存在Leader，就自动提升为Leader，否则转变Follower。</p>
<p>从以上描述中可知，Follower/Leader模式中不需要在线程间传递数据，线程间也不存在共享资源。但很明显Follower/Leader 仅支持一个事件处理源集，无法做到图15所示的每个工作线程独立监听I/O事件。</p>
<h2 id="Swoole-网络模型分析"><a href="#Swoole-网络模型分析" class="headerlink" title="Swoole 网络模型分析"></a>Swoole 网络模型分析</h2><p>Swoole为PHP提供I/O扩展功能，支持异步I/O、同步I/O、并发通信，并且为PHP多进程模式提供了并发数据结构和IPC通信机制；Swoole 既可以充当网络I/O服务器，也支持I/O客户端，较大程度为用户简化了网络I/O、多进程／多线程并发编程的工作。</p>
<p>Swoole作为server时，支持3种运行模式，分别是多进程模式、多线程模式、多进程＋多线程模式；多进程＋多线程模式是其中最为复杂的方式，其他两种方式可以认为是其特例。</p>
<p>本节结合之前介绍几种事件处理模型、并发模式来分析Swoole server的多进程＋多线程模型，如图17。<img src="//blog.com/2019/04/04/异步网络模型/2.png" alt="img"></p>
<p>图17所示，整体上可以分为Master Process、Manger Process、Work Process Pool三部分。这三部分的主要功能：</p>
<ol>
<li><strong>Master Process：</strong>监听服务端口，接收用户连接，收发连接数据，依靠reactor模型驱动；</li>
<li><strong>Manager Process：</strong>Master Process的子进程，负责fork WorkProcess，并监控Work Process的运行状态；</li>
<li><strong>Work Process Pool：</strong>工作进程池，与PHP业务层交互，将客户端数据或者事件（如连接关闭）回调给业务层，并将业务层的响应数据或者操作（如主动关闭连接）交给Master Process处理；工作进程依靠reactor模型驱动。</li>
</ol>
<p>Manager Process 监控Work Process进程，本节不做进一步讲解，主要关注Master和Work。</p>
<h4 id="Master-Process"><a href="#Master-Process" class="headerlink" title="Master Process"></a><strong>Master Process</strong></h4><p>Master Process 内部包括主线程(Main Thread)和工作线程池(Work Thread Pool),这两部分主要功能分别是：</p>
<p><strong>主线程:</strong> 监听服务端口，接收网络连接，将成功建立的连接分发到线程池中；依赖reactor模型驱动；</p>
<p><strong>工作线程池:</strong> 独立管理连接，收发网络数据；依赖Reactor事件处理驱动。</p>
<p>顾一下前面介绍的半同步/半异步并发模式，很明显，主进程的工作方式就是图15所示的方式。</p>
<h4 id="Work-Process"><a href="#Work-Process" class="headerlink" title="Work Process"></a>Work Process</h4><p>如上所描述，Work Process是Master Process和PHP层之间的媒介：</p>
<ol>
<li>Work Process接收来自Master Process的数据，包括网络数据和连接事件，回调至PHP业务层；</li>
<li>将来自PHP层的数据和连接控制信息发送给Master Process进程，Master Process来处理。</li>
</ol>
<p>Work Process同样是依赖Reactor事件模型驱动，其工作方式一个典型的Reactor模式。</p>
<p>Work Process作为Master Process和PHP层之间的媒介，将数据收发操作和数据处理分离开来，即使PHP层因消息处理将Work进程阻塞一段时间，也不会对其他连接有影响。</p>
<p>从整体层面来看，Master Process实现对连接socket上数据的I/O操作，这个过程对于Work Process是异步的，结合图11 所描述的同步I/O模拟Proactor模式，两种方式如出一辙，只不过这里使用的是多进程。</p>
<h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a><strong>进程间通信</strong></h4><p>Work Process是Master Process和PHP层之间的媒介，那么需要看看Work Process 与Master Process之间的通信方式，并在Swoole server 的多进程＋多线程模型进程中，整个过程还是有些复杂，下面说明一下该流程，如图18所示。<br><img src="//blog.com/2019/04/04/异步网络模型/-------12--2.png" alt="img"></p>
<p>具体流程为：</p>
<ol>
<li>Master 进程主线程接收客户端连接，连接建立成功后，分发至工作线程，工作线程通过Unix Socket通知Work进程连接信息；</li>
<li>Work 进程将连接信息回调至PHP业务层；</li>
<li>Maser 进程中的工作线程接收客户端请求消息，并通过Unix Socket方式发送到Work进程；</li>
<li>Work 进程将请求消息回调至PHP业务层；</li>
<li>PHP业务层构造回复消息，通过Work进程发送，Work进程将回复消息拷贝至共享内存中，并通过Unix Socket通知发送至Master进程的工作线程有数据需要发送；</li>
<li>工作线程从共享内存中取出需发送的数据，并发送至客户端；</li>
<li>客户端断开连接，工作线程将连接断开的事件通过UnixSocket发送至Work进程；</li>
<li>Work进程将连接断开事件回调至PHP业务层.</li>
</ol>
<p>需要注意在步骤5中，Work进程通知Master进程有数据需要发送，不是将数据直接发送给Master进程，而是将数据地址(在共享内存中)发送给Master进程。</p>
<h2 id="改善性能的方法"><a href="#改善性能的方法" class="headerlink" title="改善性能的方法"></a>改善性能的方法</h2><p>性能对于服务器而言是非常敏感和重要的，当前，硬件的发展虽然不是服务器性能的瓶颈，作为软件开发人员还是应该考虑在软件层面来上改善服务性能。好的网络模块，除了稳定性，还有非常多的细节、技巧处理来提升服务性能，感兴趣的同学可以深入了解Ngnix源码的细节，以及陈硕的《Linux多线程服务器编程》。</p>
<h3 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h3><p>如果应用程序不关心数据的内容，就没有必要将数据拷贝到应用缓冲区，可以借助内核接口直接将数据拷贝到内核缓冲区处理，如在提供文件下载服务时，不需要将文件内容先读到应用缓冲区，在调用send接口发送出去，可以直接使用sendfile （零拷贝）接口直接发送出去。</p>
<p>应用程序的工作模块之间也应该避免数据拷贝，如：</p>
<ol>
<li>当两个工作进程之间需要传递数据，可以考虑使用共享内存的方式实现数据共享；</li>
<li>在流媒体的应用中，对帧数据的非必要拷贝会对程序性能的影响，特备是在嵌入式环境中影响非常明显。通常采用的办法是，给每帧数据分配内存（下面统称为buffer），当需要使用该buffer时，会增加该buffer的引用计数，buffer的引用计数为0时才会释放对应的内存。这种方式适合在进程内数据无拷贝传递，并且不会给释放buffer带来困扰。</li>
</ol>
<h3 id="资源池"><a href="#资源池" class="headerlink" title="资源池"></a>资源池</h3><p>在服务运行期间，需要使用系统调用为用户分配资源，通常系统资源的分配都是比较耗时的，如动态创建进程／线程。可以考虑在服务启动时预先分配资源，即创建资源池，当需要资源，从资源池中获取即可，若资源池不够用时，再动态的分配，使用完成后交还到资源池中。这实际上是用空间换取时间，在服务运行期间可以节省非必要的资源创建过程。需要注意的是，使用资源池还需要根据业务和硬件环境对资源池的大小进行限制。</p>
<p>资源池是一个抽象的概念，常见的包括进程池、线程池、 内存池、连接池；这些资源池的相关资料非常多，这里就不一一介绍了。</p>
<h3 id="锁-上下文切换"><a href="#锁-上下文切换" class="headerlink" title="锁/上下文切换"></a>锁/上下文切换</h3><p>1.<strong>关于锁</strong><br>对共享资源的操作是并发程序中经常被提起的一个话题，都知道在业务逻辑上无法保证同步操作共享资源时，需要对共享资源加锁保护，但是锁不仅不能处理任何业务逻辑，而且还存在一定的系统开销。并且对锁的不恰当使用，可能成为服务期性能的瓶颈。</p>
<p>针对锁的使用有如下建议：</p>
<ol>
<li>如果能够在设计层面避免共享资源竞争，就可以避免锁，如图15描述的模式;</li>
<li>若无法避免对共享资源的竞争，优先考虑使用无锁队列的方式实现共享资源；</li>
<li>使用锁时，优先考虑使用读写锁；此外，锁的范围也要考虑，尽量较少锁的颗粒度，避免其他线程无谓的等待。</li>
</ol>
<p>2.<strong>上下文切换</strong><br>并发程序需要考虑上下文切换的问题，内核调度线程(进程)执行是存在系统开销的，若线程(进程)调度占用CPU的时间比重过大，那处理业务逻辑占用的CPU时间就会不足。在项目中，线程(进程)数量越多，上下文切换会很频繁，因此是不建议为每个用户连接创建一个线程，如图15所示的并发模式，一个线程可同时处理多个用户连接，是比较合理的解决方案。</p>
<p>多核的机器上，并发程序的不同线程可以运行在不同的CPU上，只要线程数量不大于CPU数目，上下文切换不会有什么问题，在实际的并发网络模块中，线程(进程)的个数也是根据CPU数目来确定的。在多核机器上，可以设置CPU亲和性，将进程／线程与CPU绑定，提高CPU cache的命中率，建好内存访问损耗。</p>
<h3 id="有限状态机器"><a href="#有限状态机器" class="headerlink" title="有限状态机器"></a>有限状态机器</h3><p>有限状态机是一种高效的逻辑处理方式，在网络协议处理中应用非常广泛，最典型的是内核协议栈中TCP状态转移。有限状态机中每种类型对应执行逻辑单元的状态，对逻辑事务的处理非常有效。 有限状态机包括两种，一种是每个状态都是相互独立的，状态间不存在转移；另一种就是状态间存在转移。有限状态机比较容易理解，下面给出两种有限状态机的示例代码。</p>
<p><strong>不存在状态转移</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _tag_state_enum&#123;  </span><br><span class="line">    A_STATE,</span><br><span class="line">    B_STATE,</span><br><span class="line">    C_STATE,</span><br><span class="line">    D_STATE</span><br><span class="line">&#125;state_enum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">STATE_MACHINE_HANDLER</span><span class="params">(state_enum cur_state)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cur_state)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> A_STATE:</span><br><span class="line">         process_A_STATE();</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> B_STATE:</span><br><span class="line">         process_B_STATE();</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> C_STATE:</span><br><span class="line">         process_C_STATE();</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>存在状态转移</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TRANS_STATE_MACHINE_HANDLER</span><span class="params">(state_enum cur_state)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C_STATE != cur_state) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (cur_state) &#123;</span><br><span class="line">        <span class="keyword">case</span> A_STATE:</span><br><span class="line">            process_A_STATE();</span><br><span class="line">            cur_state = B_STATE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> B_STATE:</span><br><span class="line">            process_B_STATE();</span><br><span class="line">            cur_state = C_STATE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> C_STATE:</span><br><span class="line">            process_C_STATE();</span><br><span class="line">            cur_state = D_STATE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h3><p>经常会面临一些业务定时超时的需求，用例子来说明吧。</p>
<p><strong>功能需求</strong>：服务器需要维护来自大量客户端的TCP连接（假设单机服务器需要支持的最大TCP连接数在10W级别），如果某连接上60s内没有数据到达，就认为相应的客户端下线。</p>
<p>先介绍一下两种容易想到的解决方案,</p>
<p><strong>方案a</strong> <strong>轮询扫描</strong></p>
<p>处理过程为：</p>
<ol>
<li>维护一个map&lt;client_id, last_update_time &gt; 记录客户端最近一次的请求时间；</li>
<li>当client_id对应连接有数据到达时，更新last_update_time；</li>
<li>启动一个定时器，轮询扫描map 中client_id 对应的last_update_time，若超过 60s，则认为对应的客户端下线。</li>
</ol>
<p>轮询扫描，只启动一个定时器，但轮询效率低，特别是服务器维护的连接数很大时，部分连接超时事件得不到及时处理。</p>
<p><strong>方案b</strong> <strong>多定时器触发</strong></p>
<p>处理过程为：</p>
<ol>
<li>维护一个map&lt;client_id, last_update_time &gt; 记录客户端最近一次的请求时间；</li>
<li>当某client_id 对应连接有数据到达时，更新last_update_time，同时为client_id启用一个定时器，60s后触发;</li>
<li>当client_id对应的定时器触发后，查看map中client_id对应的last_update_time是否超过60s，若超时则认为对应客户端下线。</li>
</ol>
<p>多定时器触发，每次请求都要启动一个定时器，可以想象，消息请求非常频繁是，定时器的数量将会很庞大，消耗大量的系统资源。</p>
<p><strong>方案c 时间轮方案</strong></p>
<p>下面介绍一下利用时间轮的方式实现的一种高效、能批量的处理方案，先说一下需要的数据结构：</p>
<ol>
<li>创建0~60的数据，构成环形队列time_wheel，current_index维护环形队列的当前游标，如图19所示；</li>
<li>数组元素是slot 结构，slot是一个set&lt;client_id&gt;，构成任务集；</li>
<li>维护一个map&lt;client_id,index&gt;，记录client_id 落在哪个slot上。</li>
</ol>
<p><img src="//blog.com/2019/04/04/异步网络模型/1.png" alt="img"></p>
<p>执行过程为：</p>
<ol>
<li>启用一个定时器，运行间隔1s，更新current_index，指向环形队列下一个元素，0-&gt;1-&gt;2-&gt;3…-&gt;58-&gt;59-&gt;60…0；</li>
<li>连接上数据到达时，从map中获取client_id所在的slot，在slot的set中删除该client_id；</li>
<li>将client_id加入到current_index - 1锁标记的slot中；</li>
<li>更新map中client_id 为current_id-1 。</li>
</ol>
<p><strong>与a、b两种方案相比，方案c具有如下优势</strong>：</p>
<ol>
<li>只需要一个定时器，运行间隔1s，CPU消耗非常少；</li>
<li>current_index 所标记的slot中的set不为空时，set中的所有client_id对应的客户端均认为下线，即批量超时。</li>
</ol>
<p>上面描述的时间轮处理方式会存在1s以内的误差，若考虑实时性，可以提高定时器的运行间隔，另外该方案可以根据实际业务需求扩展到应用中。我们对Swoole的修改中，包括对定时器进行了重构，其中超时定时器采用的就是如上所描述的时间轮方案，并且精度可控。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/04/04/服务器网络编程之线程模型/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/04/服务器网络编程之线程模型/" itemprop="url">服务器网络编程之线程模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-04T12:12:57+08:00">
                2019-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/" itemprop="url" rel="index">
                    <span itemprop="name">异步与同步</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/" itemprop="url" rel="index">
                    <span itemprop="name">IO</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/" itemprop="url" rel="index">
                    <span itemprop="name">Reactor</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/事件模型/" itemprop="url" rel="index">
                    <span itemprop="name">事件模型</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/事件模型/网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="服务器网络编程之线程模型"><a href="#服务器网络编程之线程模型" class="headerlink" title="服务器网络编程之线程模型"></a>服务器网络编程之线程模型</h1><blockquote>
<p>Reactor 模式首先是事件驱动的，有一个或多个并发输入源，有一个Service Handler，有多个Request Handlers；这个Service Handler会同步的将输入的请求（Event）多路复用的分发给相应的Request Handler。如果用图表示的如下： </p>
<p><img src="//blog.com/2019/04/04/服务器网络编程之线程模型/169ed823caf32d30.png" alt="img"></p>
</blockquote>
<p>  不知道读者有没有发现 Reactor 模式跟 IO 模型中的 IO 多路复用模型非常相似 ，在学习网络编程过程中也被这两个概念迷惑了很久。其实在设计模式层面 IO 多路复用也是采用 Reactor 模式的。IO 多路复用模型可以看成是 Reactor 模式在 IO 模型上的应用，而今天我们要讲的是 Reactor 模式在进程/线程模型上的应用。</p>
<p>  在我的看来，进程/线程模型可以分为非 Reactor 模式和 Reactor 模式两种（当然还有 Proactor 模式，这种本文先不讲，因为使用的比较少，而且我也还没搞懂这种模式）。非 Reactor 模式和 Reactor 模式的两种进程/线程模型下具体又分很多种，后面会一一列举。非 Reactor 模式的进程/线程模型是传统的模型，现在已经很少见，放在这里主要是让读者做个了解同时与 Reactor 模式的进程/线程模式做个对比。</p>
<h3 id="非-Reactor-模式的进程-线程模型"><a href="#非-Reactor-模式的进程-线程模型" class="headerlink" title="非 Reactor 模式的进程/线程模型"></a>非 Reactor 模式的进程/线程模型</h3><p>  传统模型不使用 IO 多路使用，所以问题比较多。初学者建议看下这部分，如果你觉得被迷糊了或者不感兴趣可以跳过该部分，直接看 Reactor 模式的部分即可。但该部分的第 1、2 点需要了解下。</p>
<h4 id="1、单进程单线程"><a href="#1、单进程单线程" class="headerlink" title="1、单进程单线程"></a>1、单进程单线程</h4><p><img src="//blog.com/2019/04/04/服务器网络编程之线程模型/169e8b282b1937ba.png" alt="img"></p>
<p>   描述：这种模型所有的逻辑都在在一个进程中，包括建立连接-&gt;Read 连接上的数据-&gt;业务处理-&gt;Write 回一些数据然后一直循环下去。该模型一次只能处理一个连接，这个在真正的应用中是没有的。初学者在模仿《Unix网络编程卷 I》例子编写网络程序时应该会使用这种模型，当然例子中一般会在 Write 后面多个 Close 连接的动作，以免在处理下一个连接的时候造成前一个句柄泄露。 </p>
<p>  优点：代码简单，无需去了解进程、线程的概念，适合学习网络编程的初学者。在不了解进程/线程模型情况下的默认模型。</p>
<p>  缺点：没有任何实用价值。</p>
<h4 id="2、单进程多线程"><a href="#2、单进程多线程" class="headerlink" title="2、单进程多线程"></a>2、单进程多线程</h4><p><img src="//blog.com/2019/04/04/服务器网络编程之线程模型/169e8b0804b1a47c.png" alt="img"></p>
<p>   描述：进程只做建立连接的动作，每接收一个连接就创建一个线程，在此连接上的读-&gt;业务处理-&gt;写-&gt;关闭连接都在线程中去做，可以采用线程池的方式减少线程的创建和销毁。这种线程模型有一定的应用场景，Tomcat 三种线程模型之 BIO 用的就是这种进程/线程模型。初学者在学习完单进程单线程模型后对线程有所了解即可开始学习该种模型，可以实现一个简单的聊天室程序。</p>
<p>  优点：可以同时与多个 Client 建立连接，接收连接和处理连接业务分开。</p>
<p>  缺点：每个连接占用一个线程，当连接上没有数据的时候造成线程资源浪费，可以建立的连接数比较有限。</p>
<h4 id="3、多进程单线程"><a href="#3、多进程单线程" class="headerlink" title="3、多进程单线程"></a>3、多进程单线程</h4><p><img src="//blog.com/2019/04/04/服务器网络编程之线程模型/169e8a0c89aa6902.png" alt="img"></p>
<p>  描述：</p>
<p>  (1) 主进程启动时创建监听套接字并监听，然后 fork 出 N 个子进程。</p>
<p>  (2) 由于父子进程的继承性，子进程同时也在端口监听，然后在父进程中关闭监听。</p>
<p>  (3) 父进程负责子进程的创建、销毁、资源回收等，子进程负责连接的建立-&gt;Read-&gt;业务处理-&gt;Write 等。</p>
<p>  由于所有进程都在同一个端口监听，该模型会出现一个比较知名的现象—惊群现象：当有一个连接来临时，所有子进程都会被唤醒，但是最后能与 Client 建立连接的只有一个，造成资源浪费（系通调度也是消耗 CPU 的）。不过 linux 2.6 版本以后已经在内核消除了惊群，当有连接来临只会唤醒一个等待在 accept() 上的进程。即使内核没修复，在应用层也可以用锁的方式防止惊群。</p>
<p>  缺点：这种模型是单进程单线程的进化版本，然而并没有什么卵用。且增加了开发的难度。所以不列出它的优点，介绍这种模型主要是引出惊群的概念，在后面的 Reactor 模型中的多进程情况下也会出现类似的情况。</p>
<h3 id="Reactor-模式的进程-线程模型"><a href="#Reactor-模式的进程-线程模型" class="headerlink" title="Reactor 模式的进程/线程模型"></a>Reactor 模式的进程/线程模型</h3><p>  该模式一般是 Reactor 模型 + IO 多路复用，下面的任何一种模型都具有一定的实用场景。</p>
<h4 id="1、单进程单线程-1"><a href="#1、单进程单线程-1" class="headerlink" title="1、单进程单线程"></a>1、单进程单线程</h4><p><img src="//blog.com/2019/04/04/服务器网络编程之线程模型/169e8a24e92c1553.png" alt="img"></p>
<p>  描述：只有一个进程，监听套接字和连接套接字上的事件都由 Select 来处理，</p>
<p>  (1) 如果有建立连接的请求过来，Acceptor 负责接受并与之建立连接，同时将连接套接字加入 Select 进行监听；</p>
<p>  (2) 如果某个连接上有读事件则进行 Read-&gt;业务处理-&gt;Write 等操作；</p>
<p>  (3) 如此循环反复。</p>
<p>  优点：编程简单，对于业务处理不复杂的后台，基本能满足服务器端网络编程。老东家的服务器端程序全是这种模式，主要原因有如下</p>
<p>  (1) 如果一台机器性能不行，那就向集群中新增一台。</p>
<p>  (2) 业务处理并不复杂。</p>
<p>  (3) 扩展成多进程的话，如果不是多核意义不大。</p>
<p>  (4) 如果采用单进程多线程，C++ 处理线程不像 Java 简单，还要考虑并发的问题，收益比不大。</p>
<p>  缺点：会有阻塞，在进行业务处理的时候不能进行其他操作：如建立连接，读取其他套接字上的数据等。</p>
<h4 id="2、单进程多线程-1"><a href="#2、单进程多线程-1" class="headerlink" title="2、单进程多线程"></a>2、单进程多线程</h4><p><img src="//blog.com/2019/04/04/服务器网络编程之线程模型/169e8a2e67bd5207.png" alt="img"></p>
<p>   描述：与单进程单线程类似，不同的是该模型将业务处理放在线程中，进程就不会阻塞在业务处理上。</p>
<p>  优点：比较完美的进程/线程模型，在 Java 实现中复杂度也不高。很多网络库都是基于此，比如 Netty 。</p>
<p>  缺点：待补充。</p>
<h4 id="3、多进程单线程："><a href="#3、多进程单线程：" class="headerlink" title="3、多进程单线程："></a>3、多进程单线程：</h4><p><img src="//blog.com/2019/04/04/服务器网络编程之线程模型/169e8a34fffe2cb6.png" alt="img"></p>
<p>   描述：与非 Reactor 模式中的多进程单线程相似，只是本模式在子进程中使用了 IO 多路复用，实用性以下就上来了。大名鼎鼎的 nginx 就采用这种进程/线程模型</p>
<p>  优点：编程相对简单，充分利用多核。能满足高并发，不然 nginx 也不可能采用这种模式。</p>
<p>  缺点：子进程还是会阻塞在业务处理上。</p>
<h4 id="4、多进程多线程"><a href="#4、多进程多线程" class="headerlink" title="4、多进程多线程"></a>4、多进程多线程</h4><p>  描述：这里不再画出图形，就是在在子进程上将业务处理交给多线程处理，参考单进程多线程里的线程池那里。</p>
<p>  优点：充分利用多核同时子进程不会阻塞在业务处理上</p>
<p>  缺点：编程复杂。</p>
<h4 id="5、主从进程-多线程："><a href="#5、主从进程-多线程：" class="headerlink" title="5、主从进程 +多线程："></a>5、主从进程 +多线程：</h4><p><img src="//blog.com/2019/04/04/服务器网络编程之线程模型/169e8a4060a78f5d.png" alt="img"></p>
<p>   描述：前面几种 Reactor 模式的进程/线程模型中，连接的建立和连接的读写都是在同一进程中。本模型中将连接的建立和连接读写放在不同的进程中。</p>
<p>  (1) 主进程在监听套接字上 Select 阻塞，一旦有请求过来则与之建立连接，并将连接套接字传递给从进程。</p>
<p>  (2) 从进程在连接套接字上 Select 阻塞，一旦连接上有数据过来则进行 Read，并将业务处理通过线程来处理。如果有必要还会向连接 Write 数据。</p>
<p>  优点：连接的建立和连接的读写分开在不同进程中，处理效率会更高。该模型比单进程多线程模式还更优一点，且也可以利用多核。</p>
<p>  缺点：编程复杂。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/04/01/Cookie 禁用了，Session 还能用吗？/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/01/Cookie 禁用了，Session 还能用吗？/" itemprop="url">Cookie 禁用了，Session 还能用吗？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-01T12:12:57+08:00">
                2019-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/cookie/" itemprop="url" rel="index">
                    <span itemprop="name">cookie</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/cookie/session/" itemprop="url" rel="index">
                    <span itemprop="name">session</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/cookie/session/会话/" itemprop="url" rel="index">
                    <span itemprop="name">会话</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Cookie-禁用了，Session-还能用吗？"><a href="#Cookie-禁用了，Session-还能用吗？" class="headerlink" title="Cookie 禁用了，Session 还能用吗？"></a>Cookie 禁用了，Session 还能用吗？</h1><blockquote>
<p>原文地址：<a href="https://learnku.com/articles/25858" target="_blank" rel="noopener">https://learnku.com/articles/25858</a></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在默认的JSP、PHP配置中，SessionID是需要存储在Cookie中的，默认Cookie名为：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PHPSESSIONID</span><br><span class="line"></span><br><span class="line">JSESSIONID</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;以下以PHP为例：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">你第一次访问网站时，</span><br><span class="line"></span><br><span class="line">服务端脚本中开启了Sessionsession_start();，</span><br><span class="line"></span><br><span class="line">服务器会生成一个不重复的 SESSIONID 的文件session_id();，比如在/<span class="keyword">var</span>/lib/php/session目录</span><br><span class="line"></span><br><span class="line">并将返回(Response)如下的HTTP头 Set-Cookie:PHPSESSIONID=xxxxxxx</span><br><span class="line"></span><br><span class="line">客户端接收到Set-Cookie的头，将PHPSESSIONID写入cookie</span><br><span class="line"></span><br><span class="line">当你第二次访问页面时，所有Cookie会附带的请求头(Request)发送给服务器端</span><br><span class="line"></span><br><span class="line">服务器识别PHPSESSIONID这个cookie，然后去session目录查找对应session文件，</span><br><span class="line"></span><br><span class="line">找到这个session文件后，检查是否过期，如果没有过期，去读取Session文件中的配置；如果已经过期，清空其中的配置</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果客户端禁用了Cookie，那PHPSESSIONID都无法写入客户端，Session还能用？</p>
<p>答案显而易见：不能</p>
<p><strong>并且服务端因为没有得到PHPSESSIONID的cookie，会不停的生成session_id文件</strong></p>
<h2 id="取巧传递session-id"><a href="#取巧传递session-id" class="headerlink" title="取巧传递session_id"></a>取巧传递session_id</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;但是这难不倒服务端程序，聪明的程序员想到，如果一个Cookie都没接收到，基本上可以预判客户端禁用了Cookie，那将session_id附带在每个网址后面(包括POST)，<br>比如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET http:<span class="comment">//www.xx.com/index.php?session_id=xxxxx</span></span><br><span class="line">POST http:<span class="comment">//www.xx.com/post.php?session_id=xxxxx</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;然后在每个页面的开头使用session_id($_GET[‘session_id’])，来强制指定当前session_id</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这样，答案就变成了：能</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">聪明的你肯定想到，那将这个网站发送给别人，那么他将会以你的身份登录并做所有的事情</span><br><span class="line">（目前很多订阅公众号就将openid附带在网址后面，这是同样的漏洞）。</span><br><span class="line"></span><br><span class="line">其实不仅仅如此，cookie也可以被盗用，比如XSS注入，通过XSS漏洞获取大量的Cookie，也就是控制了大量的用户，腾讯有专门的XSS漏洞扫描机制，因为大量的QQ盗用，发广告就是因为XSS漏洞</span><br><span class="line"></span><br><span class="line">所以Laravel等框架中，内部实现了Session的所有逻辑，并将PHPSESSIONID设置为httponly并加密，这样，前端JS就无法读取和修改这些敏感信息，降低了被盗用的风险。</span><br></pre></td></tr></table></figure>
<h2 id="Cookie在现代"><a href="#Cookie在现代" class="headerlink" title="Cookie在现代"></a>Cookie在现代</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;禁用Cookie是 IE6 那个年代的事情，现在的网站都非常的依赖Cookie，禁用Cookie会造成大量的麻烦。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在Flash还流行的年代，Flash在提交数据会经常出现用户无法找到的情况，其实是因为Flash在IE下是独立的程序，无法得到IE下的Cookie。</span><br><span class="line">所以在Flash的flash_var中，一般都会指定当前的session_id，让Flash提交数据的时候，将这个session_id附带着提交过去</span><br><span class="line">Chrome中使用 Flash沙箱 已经解决了cookie的问题，但是为了兼容IE，比如swfupload等flash程序都要求开发者附带一个session_id</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/04/01/你一定是用了假的 Linux cron/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/01/你一定是用了假的 Linux cron/" itemprop="url">你一定是用了假的 Linux cron</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-01T12:12:57+08:00">
                2019-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/cron/" itemprop="url" rel="index">
                    <span itemprop="name">cron</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/cron/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/cron/Linux/定时任务/" itemprop="url" rel="index">
                    <span itemprop="name">定时任务</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="你一定是用了假的-Linux-cron"><a href="#你一定是用了假的-Linux-cron" class="headerlink" title="你一定是用了假的 Linux cron"></a>你一定是用了假的 Linux cron</h1><blockquote>
<p>原文地址：<a href="https://learnku.com/articles/25177" target="_blank" rel="noopener">https://learnku.com/articles/25177</a></p>
</blockquote>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>好多系统中会用到邮件系统，我们假设有一个 PHP 脚本用来发送邮件。使用 Linux cron 每分钟执行一次</p>
<blockquote>
<p>我们暂时不引入队列系统，其实使用队列处理此方式更优。</p>
</blockquote>
<p>我们得到下面的基本配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * php /home/app/email.php</span><br></pre></td></tr></table></figure>
<h2 id="问题分析和解决"><a href="#问题分析和解决" class="headerlink" title="问题分析和解决"></a>问题分析和解决</h2><h3 id="如果这个邮件服务出现异常，进程僵死怎么办？"><a href="#如果这个邮件服务出现异常，进程僵死怎么办？" class="headerlink" title="如果这个邮件服务出现异常，进程僵死怎么办？"></a>如果这个邮件服务出现异常，进程僵死怎么办？</h3><p>假设由于未知因素， <code>email.php</code> 脚本一直执行，没有退出。极端的情况，进入一个 while 死循环。</p>
<p><em>这下倒好，原来说好的一分钟执行一次，现在一直死这边了，后面的脚本也不能跑了</em></p>
<hr>
<p>解决办法：</p>
<p>使用 timeout，假设我们设定每个脚本最多执行时间位 200秒，超过 200秒 就自动死掉。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * timeout 200 php /home/app/email.php</span><br></pre></td></tr></table></figure>
<h3 id="如果这个脚本执行时间超过-60秒，下一分钟又会执行-php-email-php，如果避免重复执行？"><a href="#如果这个脚本执行时间超过-60秒，下一分钟又会执行-php-email-php，如果避免重复执行？" class="headerlink" title="如果这个脚本执行时间超过 60秒，下一分钟又会执行 php email.php，如果避免重复执行？"></a>如果这个脚本执行时间超过 60秒，下一分钟又会执行 <code>php email.php</code>，如果避免重复执行？</h3><p>这样会出现，有两个进程同时在执行 <code>php email.php</code>，那会不会出现同一个任务被执行了两次？</p>
<hr>
<p>解决办法：</p>
<p>使用 flock 进行互斥控制</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">用法：</span><br><span class="line"> flock [选项] &lt;文件|目录&gt; &lt;命令&gt; [&lt;参数&gt;...]</span><br><span class="line"> flock [选项] &lt;文件|目录&gt; -c &lt;命令&gt;</span><br><span class="line"> flock [选项] &lt;文件描述符号码&gt;</span><br><span class="line"></span><br><span class="line">通过 shell 脚本管理文件锁。</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"> -s, --shared             获取共享锁</span><br><span class="line"> -x, --exclusive          获取排他锁(默认)</span><br><span class="line"> -u, --unlock             移除锁</span><br><span class="line"> -n, --nonblock           失败而非等待</span><br><span class="line"> -w, --timeout &lt;秒&gt;       等待限定的时间</span><br><span class="line"> -E, --conflict-exit-code &lt;数字&gt;     冲突或超时后的退出代码</span><br><span class="line"> -o, --close              运行命令前关闭文件描述符</span><br><span class="line"> -c, --<span class="built_in">command</span> &lt;命令&gt;      通过 shell 运行单个命令字符串</span><br><span class="line"> -F, --no-fork            执行命令时不 fork</span><br><span class="line">     --verbose            增加详尽程度</span><br><span class="line"></span><br><span class="line"> -h, --<span class="built_in">help</span>               display this <span class="built_in">help</span></span><br><span class="line"> -V, --version            display version</span><br></pre></td></tr></table></figure>
<p>我们用到其中的排他设置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * flock -xn /tmp/test.lock -c <span class="string">"timeout 200 php /home/app/email.php"</span></span><br></pre></td></tr></table></figure>
<h3 id="记录好日志"><a href="#记录好日志" class="headerlink" title="记录好日志"></a>记录好日志</h3><p>定时任务可能要记录日志呀，不然后期怎么排查</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * flock -xn /tmp/test.lock -c <span class="string">"timeout 200 php /home/app/email.php &gt;&gt; /home/log/test.log 2&gt;&amp;1"</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * flock -xn /tmp/test.lock -c <span class="string">"timeout 200 php /home/app/email.php &gt;&gt; /home/log/test.log 2&gt;&amp;1"</span></span><br></pre></td></tr></table></figure>
<h3 id="番外篇-频率提升"><a href="#番外篇-频率提升" class="headerlink" title="番外篇 频率提升"></a>番外篇 频率提升</h3><p>我觉得一分钟一次频率太低，想 10s 执行一次怎么办？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* * * * * php /home/app/email.php &gt;&gt; /home/<span class="built_in">log</span>/test.log 2&gt;&amp;1</span><br><span class="line">* * * * * ( sleep 10 ; php /home/app/email.php &gt;&gt; /home/<span class="built_in">log</span>/test.log 2&gt;&amp;1 )</span><br><span class="line">* * * * * ( sleep 20 ; php /home/app/email.php &gt;&gt; /home/<span class="built_in">log</span>/test.log 2&gt;&amp;1 )</span><br><span class="line">* * * * * ( sleep 30 ; php /home/app/email.php &gt;&gt; /home/<span class="built_in">log</span>/test.log 2&gt;&amp;1 )</span><br><span class="line">* * * * * ( sleep 40 ; php /home/app/email.php &gt;&gt; /home/<span class="built_in">log</span>/test.log 2&gt;&amp;1 )</span><br><span class="line">* * * * * ( sleep 50 ; php /home/app/email.php &gt;&gt; /home/<span class="built_in">log</span>/test.log 2&gt;&amp;1 )</span><br></pre></td></tr></table></figure>
<h3 id="番外篇-flock-测试"><a href="#番外篇-flock-测试" class="headerlink" title="番外篇 flock 测试"></a>番外篇 flock 测试</h3><p>准备一个 php 脚本 <code>/home/rovast/Code/flock/test.php</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$i = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span> ($i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">echo</span> --$i . \PHP_EOL;</span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flock -xn /tmp/mytest.lock -c <span class="string">"timeout 30 php /home/rovast/Code/flock/test.php"</span></span><br></pre></td></tr></table></figure>
<p>我们看到终端不停输出数值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">9999</span><br><span class="line">9998</span><br><span class="line">9997</span><br><span class="line">9996</span><br><span class="line">9995</span><br><span class="line">9994</span><br><span class="line">9993</span><br><span class="line">9992</span><br><span class="line">9991</span><br><span class="line">9990</span><br></pre></td></tr></table></figure>
<p>我们再打开另外一个终端，执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flock -xn /tmp/mytest.lock -c <span class="string">"timeout 30 php /home/rovast/Code/flock/test.php"</span></span><br></pre></td></tr></table></figure>
<p>我们发现：</p>
<ol>
<li>第二次执行的没有输出（因为 flock 互斥）</li>
<li>第一个执行的，30秒后自动关闭进程（因为 timeout 30）</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/104/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/104/">104</a><span class="page-number current">105</span><a class="page-number" href="/page/106/">106</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/106/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
