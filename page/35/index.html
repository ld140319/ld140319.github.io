<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/page/35/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/page/35/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/26/从Servlet、Dubbo、Mybatis聊聊责任链究竟怎么用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/26/从Servlet、Dubbo、Mybatis聊聊责任链究竟怎么用/" itemprop="url">从Servlet、Dubbo、Mybatis聊聊责任链究竟怎么用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-26T12:12:57+08:00">
                2019-06-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/代码规范与技巧/" itemprop="url" rel="index">
                    <span itemprop="name">代码规范与技巧</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/代码规范与技巧/代码技巧/" itemprop="url" rel="index">
                    <span itemprop="name">代码技巧</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/代码规范与技巧/代码技巧/责任链模式/" itemprop="url" rel="index">
                    <span itemprop="name">责任链模式</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/代码规范与技巧/代码技巧/责任链模式/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="从Servlet、Dubbo、Mybatis聊聊责任链究竟怎么用"><a href="#从Servlet、Dubbo、Mybatis聊聊责任链究竟怎么用" class="headerlink" title="从Servlet、Dubbo、Mybatis聊聊责任链究竟怎么用"></a>从Servlet、Dubbo、Mybatis聊聊责任链究竟怎么用</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://www.cnblogs.com/lizo/p/7503862.html" target="_blank" rel="noopener">https://www.cnblogs.com/lizo/p/7503862.html</a></p>
</blockquote>
<p><br></p>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;责任链模式的定义：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系， 将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。这里就不再过多的介绍什么是责任链模式，主要来说说<code>java</code>中如何编写。主要从下面3个框架中的代码中介绍。</p>
<ul>
<li><p><code>servlet</code>中的<code>filter</code></p>
</li>
<li><p><code>dubbo</code>中的<code>filter</code></p>
</li>
<li><p><code>mybatis</code>中的<code>plugin</code> 这3个框架在实现责任链方式不尽相同。</p>
</li>
</ul>
<h2 id="servlet中的Filter"><a href="#servlet中的Filter" class="headerlink" title="servlet中的Filter"></a>servlet中的Filter</h2><p><code>servlet</code>中分别定义了一个 <code>Filter</code>和<code>FilterChain</code>的接口，核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationFilterChain</span> <span class="keyword">implements</span> <span class="title">FilterChain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">//当前执行filter的offset</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n; <span class="comment">//当前filter的数量</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationFilterConfig[] filters;  <span class="comment">//filter配置类，通过getFilter()方法获取Filter</span></span><br><span class="line">    <span class="keyword">private</span> Servlet servlet</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; n) &#123;</span><br><span class="line">            ApplicationFilterConfig filterConfig = filters[pos++];</span><br><span class="line">            Filter filter = filterConfig.getFilter();</span><br><span class="line">            filter.doFilter(request, response, <span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// filter都处理完毕后，执行servlet</span></span><br><span class="line">            servlet.service(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码还算简单，结构也比较清晰，定义一个<code>Chain</code>，里面包含了<code>Filter</code>列表和<code>servlet</code>，达到在调用真正<code>servlet</code>之前进行各种<code>filter</code>逻辑。</p>
<p><img src="//blog.com/2019/06/26/从Servlet、Dubbo、Mybatis聊聊责任链究竟怎么用/1.webp" alt="输入图片说明"></p>
<h2 id="Dubbo中的Filter"><a href="#Dubbo中的Filter" class="headerlink" title="Dubbo中的Filter"></a>Dubbo中的Filter</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Dubbo</code>在创建<code>Filter</code>的时候是另外一个方法，通过把<code>Filter</code>封装成<code>Invoker</code>的匿名类，通过链表这样的数据结构来完成责任链，核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">buildInvokerChain</span><span class="params">(<span class="keyword">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>&#123;</span><br><span class="line">    Invoker&lt;T&gt; last = invoker;</span><br><span class="line">    <span class="comment">//只获取满足条件的Filter</span></span><br><span class="line">    List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);</span><br><span class="line">    <span class="keyword">if</span> (filters.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = filters.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">            <span class="keyword">final</span> Filter filter = filters.get(i);</span><br><span class="line">            <span class="keyword">final</span> Invoker&lt;T&gt; next = last;</span><br><span class="line">            last = <span class="keyword">new</span> Invoker&lt;T&gt;() &#123;</span><br><span class="line">                ...</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> filter.invoke(next, invocation);</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Dubbo</code>的责任链就没有类似<code>FilterChain</code>这样的类把<code>Filter</code>和调用<code>Invoker</code>结合起来，而是通过创建一个链表，调用的时候我们只知道第一个节点，每个节点包含了下一个调用的节点信息。 这里的虽然<code>Invoker</code>封装<code>Filter</code>没有显示的指定<code>next</code>，但是通过<code>java</code>匿名类和<code>final</code>的机制达到同样的效果。<br><img src="//blog.com/2019/06/26/从Servlet、Dubbo、Mybatis聊聊责任链究竟怎么用/2.webp" alt="输入图片说明"></p>
<h2 id="Mybatis中的Plugin"><a href="#Mybatis中的Plugin" class="headerlink" title="Mybatis中的Plugin"></a>Mybatis中的Plugin</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Mybatis</code>可以配置各种<code>Plugin</code>，无论是官方提供的还是自己定义的，<code>Plugin</code>和<code>Filter</code>类似，就在执行<code>Sql</code>语句的时候做一些操作。<code>Mybatis</code>的责任链则是通过动态代理的方式，使用<code>Plugin</code>代理实际的<code>Executor</code>类。（这里实际还使用了组合模式，因为<code>Plugin</code>可以嵌套代理），核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">private</span> Interceptor interceptor;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;      </span><br><span class="line">        <span class="keyword">if</span> (满足代理条件) &#123;</span><br><span class="line">            <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对传入的对象进行代理，可能是实际的Executor类，也可能是Plugin代理类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; type = target.getClass();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">        <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">                    type.getClassLoader(),</span><br><span class="line">                    interfaces,</span><br><span class="line">                    <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　简单的示意图如下：</p>
<p><img src="//blog.com/2019/06/26/从Servlet、Dubbo、Mybatis聊聊责任链究竟怎么用/3.webp" alt="输入图片说明"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里简单介绍了<code>Servlet</code>、<code>Dubbo</code>、<code>Mybatis</code>对责任链模式的不同实现手段，其中<code>Servlet</code>是相对比较清晰，又易于实现的方式，而<code>Dubbo</code>和<code>Mybatis</code>则适合在原有代码基础上，增加责任链模式代码改动量最小的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/24/58集团的账号体系打通/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/24/58集团的账号体系打通/" itemprop="url">58集团的账号体系打通</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-24T12:12:57+08:00">
                2019-06-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/账号体系/" itemprop="url" rel="index">
                    <span itemprop="name">账号体系</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/账号体系/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/账号体系/架构/业务设计/" itemprop="url" rel="index">
                    <span itemprop="name">业务设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="58集团的账号体系打通"><a href="#58集团的账号体系打通" class="headerlink" title="58集团的账号体系打通"></a>58集团的账号体系打通</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s/fpntu4I9rfZpV1L9lp9JMA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/fpntu4I9rfZpV1L9lp9JMA</a></p>
</blockquote>
<p><br></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;近些年，58集团快速发展，先后合并和收购了赶集网、中华英才、安居客等多家公司。为了共建58集团生态，优化资源配置，集团各个子公司的产品和业务进行了全面整合。账号是所有产品和业务必须具备的基础配置，所以产品和业务整合的重要一步便是账号打通。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;集团各个子公司的原有业务都是建立在各自独立的账号体系上，并且都拥有较为庞大的用户基数。如何较低成本的实现账号打通，满足业务线的需求，是账号技术团队需要解决的问题。</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>总结各业务线的账号打通需求主要有以下几点：</p>
<p>a) <strong>联合登录的需求</strong>：A站用户登录了，B站对应用户也是登录状态，反之亦然。</p>
<p>b) <strong>资源互通的需求</strong>：A站的业务系统可以查询和使用B站对应用户的业务数据或资源，反之亦然。</p>
<h2 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了实现业务方的需求，比较可行的方案就是账号体系合并或是账号关联。</p>
<h3 id="一、账号体系合并"><a href="#一、账号体系合并" class="headerlink" title="一、账号体系合并"></a>一、账号体系合并</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓<strong>账号体系合并，就是将多套独立的账号体系的账号数据合并到一起，将登录、注册等账号系统功能也统一成一套，这样只剩一套账号体系，打通问题也就不存在了</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个比较彻底的方案，<strong>基本过程就是将一方的账号数据导入另一方的账号数据库中，对同一个人的两个账号进行合并，废弃掉被导入方的登录系统，统一使用一套，多域名联合登录需求可以通过经典的<code>CAS</code>单点登录方案实现</strong>。</p>
<p><img src="//blog.com/2019/06/24/58集团的账号体系打通/2VY3NksPSaE0oMuicLVxPTAtXZQWefDlC4R6Ip8vIkmITf2yicCnNMOS2aTwGZ60CE6tI1oxR0fZ4XKHnOoWdWpA.png" alt="img"></p>
<p><strong>图1  账号体系合并</strong></p>
<p>这个方案看起很美好，但实施起来却有非常多的困难：</p>
<h4 id="可能存在的问题"><a href="#可能存在的问题" class="headerlink" title="可能存在的问题"></a>可能存在的问题</h4><h5 id="两个独立账号体系间的有冲突的账号数据很难合并"><a href="#两个独立账号体系间的有冲突的账号数据很难合并" class="headerlink" title="两个独立账号体系间的有冲突的账号数据很难合并"></a>两个独立账号体系间的有冲突的账号数据很难合并</h5><p>比如：</p>
<p>1) <strong>用户名相同的用户并不能保证就是同一个人，所以很难合并</strong>。</p>
<p>2) <strong>绑定手机或绑定邮箱相同的用户，理论上可以认为是同一个人，但如果有交叉不一致的情况就很难处理</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：在58账号体系中有用户A的手机号是M1，邮箱是E1；但在赶集账号体系中手机号M1对应的赶集用户是B, 而邮箱E1对应的赶集用户是C，这种情况下就很难合并，必须产品设计上做取舍，比如以手机号为主，舍弃邮箱冲突的用户。</p>
<p><img src="//blog.com/2019/06/24/58集团的账号体系打通/2VY3NksPSaE0oMuicLVxPTAtXZQWefDlCxcP84xRia3EgSLicvMx3DQ8PWjjcDkCPicvMWOKjc7hQjNlGB9T9gkGrA.png" alt="img"></p>
<p><strong>图2  账号数据冲突</strong></p>
<p>3) <strong>如果双方都支持第三方登录，就还可能有第三方绑定和手机、邮箱绑定不一致的情况</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，大部分第三方的开放平台（如微信、QQ），在将同一账号授权给不同的接入方时<code>OPENID</code>并不相同，所以我们仅通过双方获得的<code>OPENID</code>无法知道是不是同一个第三方账号，也就更无法知道是不是同一个人，所以第三方绑定的数据很难合并。</p>
<h5 id="合并之后，被导入方的业务系统需要做调整"><a href="#合并之后，被导入方的业务系统需要做调整" class="headerlink" title="合并之后，被导入方的业务系统需要做调整"></a>合并之后，被导入方的业务系统需要做调整</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于合并之后，被导入方原有用户ID己经无效，所以业务系统关联的用户ID就需要做转换，如果业务方众多，这会是一个较为困难的过程。还有一种折中的方案，就是<strong>存储下新旧用户ID的对应关系，由账号系统提供的鉴权功能，自动做ID转换，做到对业务方透明，业务方仍然依赖原用户ID开发</strong>。</p>
<p><img src="//blog.com/2019/06/24/58集团的账号体系打通/2VY3NksPSaE0oMuicLVxPTAtXZQWefDlC7uIA7JA7dcpTZJIjkN4ImMN5pKTxDKn2T4ZPF4H0X7AibWZCUlFlWPw.png" alt="img"></p>
<p><strong>图3  鉴权时新旧UID映射</strong></p>
<h5 id="用户投诉"><a href="#用户投诉" class="headerlink" title="用户投诉"></a>用户投诉</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，如果账号导入合并的过程对用户是透明无感知的，也可能会带来一些问题。比如各个子公司的品牌对外还是独立的，虽然我们知道是一家，但用户不一定知道。<strong>在未经用户同意的情况下将账号合并在一起，可能会引起投诉</strong>；当用户登录了A网站，到了B网站就自动登录了，可能会觉得很奇怪；当用户注册了A网站，去B网站注册账号，发现手机号已经注册了，会不会怀疑自己的资料被泄露了？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综上所述，账号体系合并，并不是一个容易实施的方案，并且需要产品设计上做一些取舍。但由于此方案可以较为彻底的解决账号打通的问题，我们在进行一些较小的独立账号体系合并时，如果冲突问题不是很严重，会首推这个方案。</p>
<h3 id="二、-账号关联打通"><a href="#二、-账号关联打通" class="headerlink" title="二、 账号关联打通"></a>二、 账号关联打通</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一种常用的打通方案就是账号关联，即<strong>各个账号体系间还是彼此独立的，只是将双方的账号关联起来，并在账号关联的基础上实现联合登录、资源互通</strong>等需求。</p>
<p>这种方案的好处有三个：</p>
<p>第一，<strong>首次关联的过程可以让用户参与，由用户去决定哪两个账号关联在一起，这样就不会有冲突的问题也可以减少投诉，关联在一起的两个账号也不要求手机号或邮箱是相同的</strong>。</p>
<p>第二，<strong>双方的业务系统不需要改造，只需要双方的账号系统进行改造即可</strong>。</p>
<p>第三，<strong>资源互通的需求可以由业务方去实现，账号系统只需提供关联关系的查询以及必要的鉴权功能</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两个独立的账号体系间实现账号关联及联合登录，最为常用的方案就是基于开放平台，我们所常见的通过微信或QQ来登录其它的网站就是这样的方案，通过接入第三方系统的开放平台授权功能，可以实现在第三方系统账号登录后，自己网站对应的账号也是登录态。方案细节见下图。</p>
<p><img src="//blog.com/2019/06/24/58集团的账号体系打通/2VY3NksPSaE0oMuicLVxPTAtXZQWefDlC8qDYvDKS0XxHNTMGkJgBMBxg1b2OlDqFNucRLvjvNNUFLibNofCmhLw.png" alt="img"></p>
<p><strong>图4 基于开放平台的联合登录方案</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此方案的难点就是，在公网环境下，如何在两个独立的账号系统间安全的传递登录用户信息。开放平台<code>OAUTH2.0</code>协议的临时授权码流程正好可以解决此类问题。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面说的这种联合登录方式是单向的，如果想实现双向联合登录，即在我们的账号登录后，对应的微信或QQ也是登录态，可行的方案也很简单，那就是让微信或QQ的登录系统也同时接入我们的开放平台，接入细节亦如之前，但相信最困难的一点就是如何说服微信或QQ了(^_^)。还好我们不需要去做和微信、QQ的双向联合登录，此方案在集团内部的多个账号体系间实施，就容易多了。</p>
<p><img src="//blog.com/2019/06/24/58集团的账号体系打通/2VY3NksPSaE0oMuicLVxPTAtXZQWefDlCWXzUsZNzMicQzjrtjrKI0XOzBEn9eNW3bib30ylQicmbLWmLyjeB3PlTw.png" alt="img"></p>
<p><strong>图5  基于开放平台的双向联合登录方案示意</strong></p>
<p>实现双向联合登录有几个关键点需要重点说一下：</p>
<p>1) 为了更优的用户的体验，我们希望联合登录的过程，<strong>尽量做到用户无感知</strong>。在联合登录流程中，有两个环节可能会触发用户感知，<strong>一是第三方账号尚未登录时会触发登录，二是开放平台的授权页面</strong>，详见图4。其中第一种情况是不可避免的，但<strong>第二种情况，开放平台的授权页面我们可以设计为隐式授权方式，就不需要用户再确认一次。通常情况下隐式授权</strong>，只能获得<code>openID</code>,<code>accessToken</code>等基本信息，无法获得用户的敏感信息（如头像、昵称、手机号之类），但是对于联合登录的需求己经足够了。</p>
<p>2) 在A站用户登录后，如果希望B站对应用户也马上登录，可以在A站用户登录成功后，自动触发一次B站的基于A站开放平台的联合登录流程。反之亦然。</p>
<p><img src="//blog.com/2019/06/24/58集团的账号体系打通/2VY3NksPSaE0oMuicLVxPTAtXZQWefDlCzKuzCOjiaxWjVqrkvRzlC0F1nCV3SxNxWXeMOSBDRQFbMOiaVwWqelrg.png" alt="img"></p>
<p><strong>图6  A站先登录再自动登录B站</strong></p>
<p>3) <strong>第三方联合登录需要保存自己的<code>userID</code>和对方<code>openID</code>的对应关系</strong>，在双向联合登录时如果双方账号体系都存储这份账号关联数据，就可能出现不一致的情况。一种解决方案是将账号关联数据存储在一处，由双方去维护；还有一种方案就是双方各自存储一份账号关联数据，并做双向同步，如果双方的机房不在一处，为了保证性能，可以使用这种方案。</p>
<p><img src="//blog.com/2019/06/24/58集团的账号体系打通/2VY3NksPSaE0oMuicLVxPTAtXZQWefDlC3MqhmQWH2J0x5KvcMIoHNtCptRTTwPgxMZUjUD9KriaK35ib0BOu60pw.png" alt="img"></p>
<p><strong>图7  账号关联数据双向同步</strong></p>
<p>4) <strong>在此方案中如果一方的业务系统需要在服务器端访问对方对应账号的业务数据和资源，为了保证安全性，可基于开放平台的鉴权功能</strong>。</p>
<p><img src="//blog.com/2019/06/24/58集团的账号体系打通/2VY3NksPSaE0oMuicLVxPTAtXZQWefDlC5F4KJc78SwrTYawITPtiaEej9iaflUf2Qr2ibKlx8e5kZhfm0MKOoO2TQ.png" alt="img"></p>
<p><strong>图8  服务端访问对方数据</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综上所述，本方案充分利用了己经非常成熟的开放平台系统，以较低的成本实现了账号的关联打通，实现了双向联合登录和资源共享。但这个方案也同时带来了以下两个问题：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一，<strong>账号安全问题</strong>，双方的登录体系还是相互独立的，在实现了联合登录后，会造成只要有一方的账号被盗，另一方相关联的账号也会被盗。在很多情况下，双方登录系统的安全能力是不统一的，这就很符合木桶理论，整体的安全能力取决于安全能力最差的系统。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二，<strong>系统冗余问题</strong>，账号体系是一个较为复杂的系统，但功能上各方基本上差不多，在集团内部多个团队同时维护多套类似的系统，会造成资源上的浪费。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为此，我们设计了一套云账号平台的方案，来解决这两个问题。</p>
<h3 id="三、云账号平台"><a href="#三、云账号平台" class="headerlink" title="三、云账号平台"></a>三、云账号平台</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;云账号平台是指将账号体系的基础能力包括账号安全能力都统一到一套平台上，原先各个独立账号体系的账号数据都托管到这个平台上，账号数据间仍保持逻辑上的独立性。</p>
<p><img src="//blog.com/2019/06/24/58集团的账号体系打通/2VY3NksPSaE0oMuicLVxPTAtXZQWefDlC2hmLRb8oOnXTNAerSrZNHjXMGJN0npicK1lCBgzsUSHSWInklUHGYgw.png" alt="img"></p>
<p><strong>图9  云账号平台功能架构</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;云账号的方案，很好地解决了账号安全和冗余建设的问题，未来基于云账号平台的新账号能力也可以快速的应用到各个托管的账号体系上。此外由于所有账号数据和账号功能都在一个平台上，基于云账号平台再去实现账号合并或者账号关联就会容易很多，方案也可以简单很多，可以大幅降低账号打通的成本。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文分享了58集团在账号体系打通方面所做的一些实践，重点阐述了其中的一些痛点和难点问题以及我们的解决方案。账号打通是很多快速发展，并不断壮大的互联网公司可能面临的共性问题，也希望能有更多朋友一起来探讨更优的解决方案。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/23/IO网络模型的应用-基于线程实现&基于事件驱动实现/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/23/IO网络模型的应用-基于线程实现&基于事件驱动实现/" itemprop="url">IO网络模型的应用-基于线程实现&基于事件驱动实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-23T12:12:57+08:00">
                2019-06-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/" itemprop="url" rel="index">
                    <span itemprop="name">异步与同步</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/" itemprop="url" rel="index">
                    <span itemprop="name">IO</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/" itemprop="url" rel="index">
                    <span itemprop="name">Reactor</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/事件模型/" itemprop="url" rel="index">
                    <span itemprop="name">事件模型</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/事件模型/网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="IO网络模型的应用-基于线程实现-amp-基于事件驱动实现"><a href="#IO网络模型的应用-基于线程实现-amp-基于事件驱动实现" class="headerlink" title="IO网络模型的应用-基于线程实现&amp;基于事件驱动实现"></a>IO网络模型的应用-基于线程实现&amp;基于事件驱动实现</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s/F5hbjnPraPS2BvOmmhdaNQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/F5hbjnPraPS2BvOmmhdaNQ</a></p>
</blockquote>
<p><br></p>
<p><strong>IO模型两个体系结构介绍</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网络<code>IO</code>有很多种实现方式，主要的有两个体系结构，分别是：基于进程、线程实现的设计，与基于事件驱动的设计。</p>
<h2 id="一、基于进程、线程实现的设计"><a href="#一、基于进程、线程实现的设计" class="headerlink" title="一、基于进程、线程实现的设计"></a>一、基于进程、线程实现的设计</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于线程实现遵循的思想是一个线程来处理一个连接（<code>One-Connection-Per-Thread</code>）。适用于：使用了非线程安全库而又要避免线程竞争的站点。</p>
<h3 id="1-iterative服务器"><a href="#1-iterative服务器" class="headerlink" title="1. iterative服务器"></a>1. iterative服务器</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是最原始的网络思路，<strong>程序只有一个主进程</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>主进程是一个死循环，不断的accept端口。当有连接创建后，就开始执行业务逻辑</strong>。<strong>处理完成后，关闭<code>socket</code>，循环这一过程</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方案也不适合长连接，但是很适合<code>daytime</code>这种<code>write-only</code>服务。<strong><code>iterative</code>服务器一次只能处理一个调用，这样服务没有办法同时为多个客户端服务</strong>。</p>
<p><img src="//blog.com/2019/06/23/IO网络模型的应用-基于线程实现&基于事件驱动实现/2VY3NksPSaEF138gbSkbuIBExESwJk2Jgqa4LIiac7Jfjr8ymicIe5fHAtGYFeAPrL1yh2ycYM5oNvqJzyCcXTtg.png" alt="img"></p>
<h3 id="2-预派生子进程，主进程调用accept"><a href="#2-预派生子进程，主进程调用accept" class="headerlink" title="2. 预派生子进程，主进程调用accept"></a>2. 预派生子进程，主进程调用accept</h3><p><img src="//blog.com/2019/06/23/IO网络模型的应用-基于线程实现&基于事件驱动实现/2VY3NksPSaEF138gbSkbuIBExESwJk2J0Ue6GZ7x0277rsgwTwlly5mlDPO1PISyXIicJjCUA9zia5jJOnFokFlg.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了可以同时服务多个客户端，产生了称之为<code>process-per-connection</code>的方式。<strong>当创建连接后，<code>fork</code>一个子进程用来处理这个请求直到客户端断开连接。同时主进程则立即再次<code>accept</code>监听新的请求</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这使得服务器能同时为多个客户端服务。每个子进程服务于一个客户端的长连接，处理多个任务。<strong>客户端数目的唯一限制是操作系统对用户能拥有多少子进程的限制</strong>。该方案<strong>适合并发连接数不大且一个连接上有很多有顺序的任务，同时计算响应时间的工作量远大于<code>fork( )</code>的开销的情况</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本方案中，如果使用子线程代替子进程的方案叫<code>thread-per-connection</code>。在 <code>Java 1.4</code>引入<code>NIO</code>之前，<code>Java</code>网络服务程序多采用<code>thread-per-connection</code>。线程方案中伸缩性受到操作系统线程数的限制，操作系统的<code>scheduler</code>一两百个还行，几千个的话是个不小的负担。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注：<strong>当主进程<code>accept</code>连接并<code>fork</code>子进程处理连接上的任务时，主进程<code>close</code>不会关闭连接。只有当主进程与子进程都<code>close</code>后，才会关闭连接</strong>。</p>
<h3 id="3-预派生子进程-每个子进程调用accept"><a href="#3-预派生子进程-每个子进程调用accept" class="headerlink" title="3. 预派生子进程,每个子进程调用accept"></a>3. 预派生子进程,每个子进程调用accept</h3><p><img src="//blog.com/2019/06/23/IO网络模型的应用-基于线程实现&基于事件驱动实现/2VY3NksPSaEF138gbSkbuIBExESwJk2J2JkJxiaBlTzbYogG4pForYiaqwuYGl6gMY8J1EmL4o72H9WDBKMgettQ.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果请求以短连接为主，频繁的<code>fork</code>，开销过多。此时就可预先派生进程，多个子进程处理请求，以减少运行过程中<code>for</code>k的开销。</p>
<p><strong>优点：</strong></p>
<ul>
<li>初始化时创建多个进程处理客户端连接，减少运行过程中<code>fork</code>的开销。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>预创建进程数目&gt;客户端数目：造成进程资源浪费，增加进程切换开销；</li>
<li>预创建进程数目&lt;客户端数目：新到的客户端将得不到服务，内核仍会完成三步握手，造成服务器在响应时间上的恶化；</li>
<li><strong>惊群现象</strong>：服务进程在程序启动阶段派生N个子进程，各个子进程阻塞在对同一个<code>listenfd</code>的<code>accept</code>调用上，<strong>当第一个客户端连接到达时，所有阻塞的子进程都将被唤醒，其中只有最先运行的子进程将获得客户端连接</strong>。“惊群现象”造成性能受损；</li>
</ul>
<h3 id="4-预派生子进程-锁保护accept"><a href="#4-预派生子进程-锁保护accept" class="headerlink" title="4. 预派生子进程,锁保护accept"></a>4. 预派生子进程,锁保护accept</h3><p><img src="//blog.com/2019/06/23/IO网络模型的应用-基于线程实现&基于事件驱动实现/2VY3NksPSaHbSHoRJVB1bG9qibWQpQpAZXtAibRchjELpRzLZuDxJPYoiaKHPMVUKk9AQh37AjkibjmksI4FRQAvRw.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图所示，<strong>让应用程序在调用<code>accept</code>前后安置某种形式的锁，这样在任意时刻只有一个子进程阻塞在accept调用中，不会产生多个进程同时调用系统<code>accept</code>，减少频繁的用户态与系统态的切换</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>nginx</code>以在<code>1.11.3</code>在“惊群现象”问题采用同样的方法解决。<strong><code>nginx</code>多进程的锁在底层默认是通过CPU自旋锁来实现</strong>。<strong>如果操作系统不支持自旋锁，就采用文件锁</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>linux 4.5</code>支持了<code>EPOLLEXCLUSIVE</code>，<code>nginx-1.11.3</code>也支持<code>EPOLLEXCLUSIVE</code>，不在自己在<code>accept</code>上实现锁了，交由系统底层实现。</p>
<h3 id="5-预先派生子进程-父进程accept"><a href="#5-预先派生子进程-父进程accept" class="headerlink" title="5. 预先派生子进程,父进程accept"></a>5. 预先派生子进程,父进程accept</h3><p><img src="//blog.com/2019/06/23/IO网络模型的应用-基于线程实现&基于事件驱动实现/2VY3NksPSaEF138gbSkbuIBExESwJk2Jt55qG4gmfxYGgxuqnxib7JzXKvD3MAX8mZBYXlic71ue1ghrXLAIZBog.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>惊群现象”另一个方案：预先创建子进程，父进程负责<code>accept</code>监听端口，然后把连接上接收的数据通过套接字传递给子进程，以解决所有子进程的<code>accept</code>调用上锁问题</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>W.Richard Stevens</code>通过实验指出：父进程通过<strong>字节流管道</strong>传递到各个子进程，并且各个子进程通过字节流写回管道，比使用上锁的方式要更费时。增加了数据传输拷贝开销。实现上也更复杂，不推荐使用。</p>
<h3 id="基于进程或线程实现的设计瓶颈"><a href="#基于进程或线程实现的设计瓶颈" class="headerlink" title="基于进程或线程实现的设计瓶颈"></a>基于进程或线程实现的设计瓶颈</h3><p><strong>线程：</strong>是共享地址空间，从而可以高效地共享数据。</p>
<p><strong>进程：</strong>一台机器上的多个进程能高效地共享代码段（操作系统可以映射为同样的物理内存），但不能共享数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此线程模型要比对应的进程模型要快。但线程运行在同一地址空间，<strong>一个线程的崩溃将导致整个进程的崩溃，另外无法实现热升级</strong>，<code>nginx</code>就是采用进程模型，支持<code>reload\upgrade</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>进程与线程都受到操作系统线程数的限制</strong>。操作系统的<code>scheduler</code>一两百个进程还行，1千以内的线程还行，但是系统<code>scheduler</code>变得无法承受负担。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>连接与线程之间存在对应关系，一个连接从开始到关闭一直会占用一个线程</strong>，如果使用<code>Keep-Alive</code>这样减少连接的创建成本的方式，势必会导致大量的工作线程在空闲状态下等待。另外，数百甚至数千并发连接所创建的线程会浪费存储器中的大量堆栈空间。</p>
<h2 id="二、基于事件驱动的设计"><a href="#二、基于事件驱动的设计" class="headerlink" title="二、基于事件驱动的设计"></a>二、基于事件驱动的设计</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>基于事件驱动设计遵循的思想是将线程与连接分离开，线程只是用来处理特定的回调或业务逻辑</strong>。</p>
<h3 id="1-Reactor"><a href="#1-Reactor" class="headerlink" title="1. Reactor"></a>1. Reactor</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Reactor</code>设计模式是基于事件驱动的一种实现方式，采用基于事件驱动的设计，<strong>当有事件触发时，才会调用处理器进行数据处理</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主进程<code>acceptor</code>监听端口，一次获取多个连接，顺序处理每个连接的业务逻辑。虽然一次可以处理多个请求，但实现上还是一个线程完成所有任务。不适合多核<code>CPU</code>。</p>
<p><img src="//blog.com/2019/06/23/IO网络模型的应用-基于线程实现&基于事件驱动实现/2VY3NksPSaEF138gbSkbuIBExESwJk2JgoIPG81ibtt4KuIJkXtM7c8knuQBL4PDbR4icsmYO3Zoc7GsjTDtM0iaA.png" alt=""></p>
<h3 id="2-Reactor-Thread-per-task"><a href="#2-Reactor-Thread-per-task" class="headerlink" title="2. Reactor+Thread-per-task"></a>2. Reactor+Thread-per-task</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>Reactor</code>的基础上，<code>acceptor</code>读取到多个连接的多个任务后，为每个任务创建一个线程去处理，然后在处理完成时消毁线程。充分利用<code>cpu</code>，但增加了运行时动态创建线程的开销。另外<strong>多线程执行顺序不确定，会导致一个连接的多个请求，在多个线程同时处理：新来的还在执行中，后到的请求已经被执行完了</strong>。</p>
<p><img src="//blog.com/2019/06/23/IO网络模型的应用-基于线程实现&基于事件驱动实现/2VY3NksPSaEF138gbSkbuIBExESwJk2JhSk9icHrm5515sOib8hfmCW6H9DsfDU1JxHictKgjbPJ8icOHriayHGugew.png" alt="img"></p>
<h3 id="3-Reactor-Threadpoll"><a href="#3-Reactor-Threadpoll" class="headerlink" title="3. Reactor+Threadpoll"></a>3. Reactor+Threadpoll</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为减少创建线程的开销，程序在启动时，预先创建线程池。<code>Reactor</code>使用<code>acceptor</code>接到请求事件后，读取请求数据，然后再将数据通过<code>threadPool</code>分配处理。<strong>利用线程池高效的处理<code>CPU</code>密集型的业务逻辑</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但<strong>如果服务是高<code>IO</code>型，只有一个线程负责读取没有办法充分利用多核</strong>。</p>
<p><img src="//blog.com/2019/06/23/IO网络模型的应用-基于线程实现&基于事件驱动实现/2VY3NksPSaEF138gbSkbuIBExESwJk2JFtw6M5lWAvkiboyxBBOKibkEktTdyeDPVXwx4NoeC5fZuSUgKv3yZiarA.png" alt="img"></p>
<h3 id="4-Multiple-Reactors"><a href="#4-Multiple-Reactors" class="headerlink" title="4. Multiple Reactors"></a>4. Multiple Reactors</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主线程负责<code>acceptor</code>监听端口，获取到多个连接后，将他们分配到多个<code>subReactor</code>。<code>subReactor</code>负责数据的读取&amp;处理，提高的了<code>IO</code>的吞吐量。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>subReactor</code>的数据一般是固定的，为CPU核数或CPU核数的2倍。程序可以充多利用多核，当<code>IO</code>的并发升高后，依赖多核能力，总体处理能力不会下降。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>一个连接的业务逻辑一直在一个线程中处理，可以保证数据的处理是有序的</strong>。<strong>但是由于<code>subReactor</code>处理是一个线程，如一个业务逻辑耗费大量<code>CPU</code>时间时，业务处理能力就开始下降</strong>。</p>
<p><img src="//blog.com/2019/06/23/IO网络模型的应用-基于线程实现&基于事件驱动实现/2VY3NksPSaEF138gbSkbuIBExESwJk2J0yEqW0uaWIOLg44WCugDFm51AfvGnxBDldsFDcO9fPb38ibugu4ZF3w.png" alt="img"></p>
<h3 id="5-Multiple-Reactors-Threadpoll"><a href="#5-Multiple-Reactors-Threadpoll" class="headerlink" title="5. Multiple Reactors+Threadpoll"></a>5. Multiple Reactors+Threadpoll</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了兼顾<code>IO</code>密集型与<code>CPU</code>密集弄的问题。使用<strong>多个<code>subReactor</code>+ 处理线程池</strong>的方式。</p>
<p><img src="//blog.com/2019/06/23/IO网络模型的应用-基于线程实现&基于事件驱动实现/2VY3NksPSaEF138gbSkbuIBExESwJk2JT6oaHfOvA1RTibJY5Cuu8zdFCqwj9I56gKJXLvcwHynZOjUPXXfwt2Q.png" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们使用的<code>nginx、apache、tomcat、netty、muduo、javaNIO</code>之类的软件，他们都是使用上面设计思想中一种或几种的组合。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在应用的时候，需要按我们的具体需要场景来使用，比如：是长连接任务多还是短连接多、一个连接上任务的有序性要求、事务性、<code>IO</code>密集型、<code>CPU</code>密集型等来选定服务实现方式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/23/PHP并发IO编程之路/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/23/PHP并发IO编程之路/" itemprop="url">PHP并发IO编程之路</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-23T12:12:57+08:00">
                2019-06-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/" itemprop="url" rel="index">
                    <span itemprop="name">异步与同步</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/" itemprop="url" rel="index">
                    <span itemprop="name">IO</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/" itemprop="url" rel="index">
                    <span itemprop="name">Reactor</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/事件模型/" itemprop="url" rel="index">
                    <span itemprop="name">事件模型</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/事件模型/网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="PHP并发IO编程之路"><a href="#PHP并发IO编程之路" class="headerlink" title="PHP并发IO编程之路"></a>PHP并发IO编程之路</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="http://rango.swoole.com/archives/508" target="_blank" rel="noopener">http://rango.swoole.com/archives/508</a></p>
</blockquote>
<p><br></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并发<code>IO</code> 问题一直是服务器端编程中的技术难题，从最早的同步阻塞直接 <code>Fork</code> 进程，到 <code>Worker</code>进程池/线程池，到现在的异步<code>IO</code>、协程。<code>PHP</code>程序员因为有强大的 <code>LAMP</code>框架，对这类底层方面的知识知之甚少，本文目的就是详细介绍<code>PHP</code>进行并发 <code>IO</code> 编程的各种尝试，最后再介绍 <code>Swoole</code> 的使用，深入浅出全面解析并发<code>IO</code> 问题。</p>
<h2 id="多进程-多线程同步阻塞"><a href="#多进程-多线程同步阻塞" class="headerlink" title="多进程/多线程同步阻塞"></a>多进程/多线程同步阻塞</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最早的服务器端程序都是通过多进程、多线程来解决并发<code>IO</code>的问题。进程模型出现的最早，从 <code>Unix</code> 系统诞生就开始有了进程的概念。最早的服务器端程序一般都是 <code>Accept</code> 一个客户端连接就创建一个进程，然后子进程进入循环同步阻塞地与客户端连接进行交互，收发处理数据。</p>
<p><img src="//blog.com/2019/06/23/PHP并发IO编程之路/4.png" alt="4"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;多线程模式出现要晚一些，<strong>线程与进程相比更轻量，而且线程之间是共享内存堆栈的，所以不同的线程之间交互非常容易实现</strong>。比如聊天室这样的程序，客户端连接之间可以交互，比聊天室中的玩家可以任意的其他人发消息。用多线程模式实现非常简单，线程中可以直接向某一个客户端连接发送数据。而<strong>多进程模式就要用到管道、消息队列、共享内存，统称进程间通信（IPC）复杂的技术才能实现</strong>。</p>
<p>代码实例：</p>
<p><img src="//blog.com/2019/06/23/PHP并发IO编程之路/1.png" alt="实例1"></p>
<p>多进程/线程模型的流程是</p>
<ol>
<li>创建一个 <code>socket</code>，绑定服务器端口（<code>bind</code>），监听端口（<code>listen</code>），在<code>PHP</code>中用<code>stream_socket_server</code>一个函数就能完成上面3个步骤，当然也可以使用更底层的<code>sockets</code>扩展分别实现。</li>
<li>进入<code>while</code>循环，阻塞在<code>accept</code>操作上，等待客户端连接进入。此时程序会进入睡眠状态，直到有新的客户端发起<code>connect</code>到服务器，操作系统会唤醒此进程。<code>accept</code>函数返回客户端连接的<code>socket</code></li>
<li>主进程在多进程模型下通过<code>fork（php: pcntl_fork）</code>创建子进程，多线程模型下使用<code>pthread_create（php: new Thread）</code>创建子线程。下文如无特殊声明将使用进程同时表示进程/线程。</li>
<li>子进程创建成功后进入<code>while</code>循环，<strong>阻塞在<code>recv（php: fread）</code>调用上，等待客户端向服务器发送数据</strong>。收到数据后服务器程序进行处理然后使用<code>send（php: fwrite）</code>向客户端发送响应。长连接的服务会持续与客户端交互，而短连接服务一般收到响应就会close。</li>
<li>当客户端连接关闭时，子进程退出并销毁所有资源。主进程会回收掉此子进程。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模式最大的问题是，<strong>进程/线程创建和销毁的开销很大</strong>。所以上面的模式没办法应用于非常繁忙的服务器程序。对应的改进版解决了此问题，这就是经典的 <strong>Leader-Follower</strong> 模型。</p>
<p>代码实例：</p>
<p><img src="//blog.com/2019/06/23/PHP并发IO编程之路/2.png" alt="2"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它的特点是<strong>程序启动后就会创建N个进程</strong>。每个子进程进入 <code>Accept</code>，等待新的连接进入。当客户端连接到服务器时，其中一个子进程会被唤醒，开始处理客户端请求，并且不再接受新的<code>TCP</code>连接。当此连接关闭时，子进程会释放，重新进入 <code>Accept</code>，参与处理新的连接。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个模型的优势是<strong>完全可以复用进程，没有额外消耗，性能非常好</strong>。很多常见的服务器程序都是基于此模型的，比如 <code>Apache</code> 、<code>PHP-FPM</code>。</p>
<p>多进程模型也有一些缺点：</p>
<ol>
<li><p><strong>这种模型严重依赖进程的数量解决并发问题</strong>，一个客户端连接就需要占用一个进程，工作进程的数量有多少，并发处理能力就有多少。操作系统可以创建的进程数量是有限的。</p>
</li>
<li><p><strong>启动大量进程会带来额外的进程调度消耗</strong>。数百个进程时可能进程上下文切换调度消耗占CPU不到1%可以忽略不计，如果启动数千甚至数万个进程，消耗就会直线上升。调度消耗可能占到 CPU 的百分之几十甚至 100%。</p>
</li>
<li><p><strong>有一些场景多进程模型无法解决</strong></p>
<ol>
<li><p>比如即时聊天程序（IM），一台服务器要同时维持上万甚至几十万上百万的连接（经典的<code>C10K</code>问题），多进程模型就力不从心了。</p>
</li>
<li><p>通常Web服务器启动100个进程，如果一个请求消耗100ms，100个进程可以提供1000qps，这样的处理能力还是不错的。但是如果请求内要调用外网Http接口，像QQ、微博登录，耗时会很长，一个请求需要10s。那一个进程1秒只能处理0.1个请求，100个进程只能达到10qps，这样的处理能力就太差了。</p>
</li>
</ol>
</li>
</ol>
<p>有没有一种技术可以在一个进程内处理所有并发<code>IO</code>呢？答案是有，这就是<strong>IO复用技术</strong>。</p>
<h2 id="IO复用-事件循环-异步非阻塞"><a href="#IO复用-事件循环-异步非阻塞" class="headerlink" title="IO复用/事件循环/异步非阻塞"></a>IO复用/事件循环/异步非阻塞</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实<code>IO</code>复用的历史和多进程一样长，<code>Linux</code>很早就提供了 <code>select</code>系统调用，可以在一个进程内维持1024个连接。后来又加入了<code>poll</code>系统调用，<code>poll</code>做了一些改进，解决了 1024 限制的问题，可以维持任意数量的连接。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但<code>select/poll</code>还有一个问题就是，它<strong>需要循环检测连接是否有事件</strong>。这样问题就来了，如果服务器有100万个连接，在某一时间只有一个连接向服务器发送了数据，<code>select/poll</code>需要做循环100万次，其中只有1次是命中的，剩下的99万9999次都是无效的，白白<strong>浪费了CPU资源</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;直到<code>Linux 2.6</code>内核提供了新的<code>epoll</code>系统调用，可以维持无限数量的连接，而且无需轮询，这才真正解决了 <code>C10K</code>问题。现在各种高并发异步<code>IO</code>的服务器程序都是基于epoll实现的，比如<code>Nginx</code>、<code>Node.js</code>、<code>Erlang</code>、<code>Golang</code>。像<code>Node.js</code> 这样单进程单线程的程序，都可以维持超过1百万<code>TCP</code>连接，全部归功于<code>epoll</code>技术。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>IO</code>复用异步非阻塞程序使用经典的<strong>Reactor</strong>模型，<code>Reactor</code>顾名思义就是反应堆的意思，它<strong>本身不处理任何数据收发</strong>。<strong>只是可以监视一个<code>socket</code>句柄的事件变化</strong>。</p>
<p><img src="//blog.com/2019/06/23/PHP并发IO编程之路/5.png" alt="5"></p>
<p><code>Reactor</code>有4个核心的操作：</p>
<ol>
<li><code>add</code>添加<code>socket</code>监听到<code>reactor</code>，可以是<code>listen socket</code>也可以使客户端<code>socket</code>，也可以是管道、<code>eventfd</code>、信号等</li>
</ol>
<ol start="2">
<li><p><code>set</code>修改事件监听，可以设置监听的类型，如可读、可写。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可读很好理解，对于<code>listen socket</code>就是有新客户端连接到来了需要<code>accept</code>。对于客户端连接就是收到数据，需要<code>recv</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可写事件比较难理解一些。一个<code>SOCKET</code>是有缓存区的，如果要向客户端连接发送2M的数据，一次性是发不出去的，操作系统默认<code>TCP</code>缓存区只有256K。一次性只能发256K，缓存区满了之后<code>send</code>就会返回<code>EAGAIN</code>错误。这时候就要监听可写事件，在纯异步的编程中，必须去监听可写才能保证<code>send</code>操作是完全非阻塞的。</p>
</li>
</ol>
<ol start="3">
<li><code>del</code>从<code>reactor</code>中移除，不再监听事件</li>
</ol>
<ol start="4">
<li><code>callback</code>就是事件发生后对应的处理逻辑，一般在<code>add/set</code>时制定。<code>C</code>语言用函数指针实现，<code>JS</code>可以用匿名函数，<code>PHP</code>可以用匿名函数、对象方法数组、字符串函数名。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Reactor</code>只是一个事件发生器，实际对<code>socket</code>句柄的操作，如<code>connect/accept</code>、<code>send/recv</code>、<code>close</code>是在<code>callback</code>中完成的</strong>。具体编码可参考下面的伪代码：</p>
<p><img src="//blog.com/2019/06/23/PHP并发IO编程之路/6.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Reactor</code>模型还可以与多进程、多线程结合起来用，既实现异步非阻塞<code>IO</code>，又利用到多核。目前流行的异步服务器程序都是这样的方式：如</p>
<ul>
<li><code>Nginx</code>：多进程<code>Reactor</code></li>
<li><code>Nginx+Lua</code>：多进程<code>Reactor</code>+协程</li>
<li><code>Golang</code>：单线程<code>Reactor</code>+多线程协程</li>
<li><code>Swoole</code>：多线程<code>Reactor</code>+多进程<code>Worker</code></li>
</ul>
<h2 id="协程是什么"><a href="#协程是什么" class="headerlink" title="协程是什么"></a>协程是什么</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;协程从底层技术角度看实际上还是异步<code>IO Reactor</code>模型，应用层自行实现了任务调度，借助<code>Reactor</code>切换各个当前执行的用户态线程，但用户代码中完全感知不到<code>Reactor</code>的存在。</p>
<h2 id="PHP并发IO编程实践"><a href="#PHP并发IO编程实践" class="headerlink" title="PHP并发IO编程实践"></a>PHP并发IO编程实践</h2><h3 id="PHP相关扩展"><a href="#PHP相关扩展" class="headerlink" title="PHP相关扩展"></a>PHP相关扩展</h3><ul>
<li><code>Stream</code>：<code>PHP</code>内核提供的<code>socket</code>封装</li>
<li><code>Sockets</code>：对底层<code>Socket API</code>的封装</li>
<li><code>Libevent</code>：对<code>libevent</code>库的封装</li>
<li><code>Event</code>：基于<code>Libevent</code>更高级的封装，提供了面向对象接口、定时器、信号处理的支持</li>
<li><code>Pcntl/Posix</code>：多进程、信号、进程管理的支持</li>
<li><code>Pthread</code>：多线程、线程管理、锁的支持</li>
<li><code>PHP</code>还有共享内存、信号量、消息队列的相关扩展</li>
<li><code>PECL</code>：<code>PHP</code>的扩展库，包括系统底层、数据分析、算法、驱动、科学计算、图形等都有。如果<code>PHP</code>标准库中没有找到，可以在<code>PECL</code>寻找想要的功能。</li>
</ul>
<h3 id="PHP语言的优劣势"><a href="#PHP语言的优劣势" class="headerlink" title="PHP语言的优劣势"></a>PHP语言的优劣势</h3><p><img src="//blog.com/2019/06/23/PHP并发IO编程之路/3.png" alt="3"></p>
<p><strong>PHP的优点：</strong></p>
<ol>
<li>第一个是简单，<code>PHP</code>比其他任何的语言都要简单</li>
<li><code>PHP</code>的功能非常强大，因为<code>PHP</code>官方的标准库和扩展库里提供了做服务器编程能用到的99%的东西。<code>PHP</code>的<code>PECL</code>扩展库里你想要的任何的功能。</li>
<li>另外<code>PHP</code>有超过20年的历史，生态圈是非常大的，在<code>Github</code>可以找到很多代码。</li>
</ol>
<p><strong>PHP的缺点：</strong></p>
<ol>
<li><strong>性能比较差</strong>，因为毕竟是动态脚本，<strong>不适合做密集运算</strong>，如果同样的 PHP 程序使用 C/C++ 来写，PHP 版本要比它差一百倍。</li>
<li><strong>函数命名规范差</strong>，这一点大家都是了解的，PHP更讲究实用性，没有一些规范。一些函数的命名是很混乱的，所以每次你必须去翻PHP的手册。</li>
<li><strong>提供的数据结构和函数的接口粒度比较粗</strong>。PHP只有一个Array数据结构，底层基于HashTable。PHP的Array集合了Map，Set，Vector，Queue，Stack，Heap等数据结构的功能。另外PHP有一个SPL提供了其他数据结构的类封装。</li>
</ol>
<p>所以PHP</p>
<ol>
<li>PHP更<strong>适合偏实际应用层面的程序，业务开发、快速实现的利器</strong></li>
<li>PHP<strong>不适合开发底层软件</strong></li>
<li>使用C/C++、JAVA、Golang等静态编译语言作为PHP的补充，动静结合</li>
<li>借助IDE工具实现自动补全、语法提示  </li>
</ol>
<h2 id="PHP的Swoole扩展"><a href="#PHP的Swoole扩展" class="headerlink" title="PHP的Swoole扩展"></a>PHP的Swoole扩展</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于上面的扩展使用纯<code>PHP</code>就可以完全实现异步网络服务器和客户端程序。但是想实现一个类似于多<code>IO</code>线程，还是有很多繁琐的编程工作要做，包括如何来管理连接，如何来保证数据的收发原子性，网络协议的处理。另外<code>PHP</code>代码在协议处理部分性能是比较差的，所以我启动了一个新的开源项目<code>Swoole</code>，使用<code>C</code>语言和<code>PHP</code>结合来完成了这项工作。灵活多变的业务模块使用<code>PHP</code>开发效率高，基础的底层和协议处理部分用<code>C</code>语言实现，保证了高性能。它以扩展的方式加载到了<code>PHP</code>中，提供了一个完整的网络通信的框架，然后<code>PHP</code>的代码去写一些业务。它的模型是基于<strong>多线程<code>Reactor</code>+多进程<code>Worker</code></strong>，既支持全异步，也支持半异步半同步。</p>
<h3 id="Swoole的一些特点："><a href="#Swoole的一些特点：" class="headerlink" title="Swoole的一些特点："></a>Swoole的一些特点：</h3><ul>
<li><code>Accept</code>线程，解决<code>Accept</code>性能瓶颈和惊群问题</li>
<li>多<code>IO</code>线程，可以更好地利用多核</li>
<li>提供了全异步和半同步半异步2种模式</li>
<li>处理高并发<code>IO</code>的部分用异步模式</li>
<li>复杂的业务逻辑部分用同步模式</li>
<li>底层支持了遍历所有连接、互发数据、自动合并拆分数据包、数据发送原子性。</li>
</ul>
<h3 id="Swoole的进程-线程模型："><a href="#Swoole的进程-线程模型：" class="headerlink" title="Swoole的进程/线程模型："></a>Swoole的进程/线程模型：</h3><p><img src="//blog.com/2019/06/23/PHP并发IO编程之路/7.png" alt="img"></p>
<h3 id="Swoole程序的执行流程："><a href="#Swoole程序的执行流程：" class="headerlink" title="Swoole程序的执行流程："></a>Swoole程序的执行流程：</h3><p><img src="//blog.com/2019/06/23/PHP并发IO编程之路/8.png" alt="img"></p>
<h2 id="使用PHP-Swoole扩展实现异步通信编程"><a href="#使用PHP-Swoole扩展实现异步通信编程" class="headerlink" title="使用PHP+Swoole扩展实现异步通信编程"></a>使用PHP+Swoole扩展实现异步通信编程</h2><p>实例代码在<a href="https://github.com/swoole/swoole-src" target="_blank" rel="noopener">https://github.com/swoole/swoole-src</a> 主页查看。</p>
<h3 id="TCP服务器与客户端"><a href="#TCP服务器与客户端" class="headerlink" title="TCP服务器与客户端"></a>TCP服务器与客户端</h3><p><strong>异步TCP服务器：</strong></p>
<p><img src="//blog.com/2019/06/23/PHP并发IO编程之路/9.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里<code>new swoole_server</code>对象，然后参数传入监听的<code>HOST</code>和<code>PORT</code>，然后设置了3个回调函数，分别是<code>onConnect</code>有新的连接进入、<code>onReceive</code>收到了某一个客户端的数据、<code>onClose</code>某个客户端关闭了连接。最后调用<code>start</code>启动服务器程序。<code>swoole</code>底层会根据当前机器有多少<code>CPU</code>核数，启动对应数量的<code>Reactor</code>线程和<code>Worker</code>进程。</p>
<p><strong>异步客户端：</strong></p>
<p><img src="//blog.com/2019/06/23/PHP并发IO编程之路/10.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端的使用方法和服务器类似只是回调事件有4个，<code>onConnect</code>成功连接到服务器，这时可以去发送数据到服务器。<code>onError</code>连接服务器失败。<code>onReceive</code>服务器向客户端连接发送了数据。<code>onClose</code>连接关闭。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置完事件回调后，发起<code>connect</code>到服务器，参数是服务器的<code>IP</code>,<code>PORT</code>和超时时间。</p>
<p><strong>同步客户端：</strong></p>
<p><img src="//blog.com/2019/06/23/PHP并发IO编程之路/11.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同步客户端不需要设置任何事件回调，它没有<code>Reactor</code>监听，是阻塞串行的。等待<code>IO</code>完成才会进入下一步。</p>
<p><strong>异步任务：</strong></p>
<p><img src="//blog.com/2019/06/23/PHP并发IO编程之路/12.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;异步任务功能用于在一个纯异步的<code>Server</code>程序中去执行一个耗时的或者阻塞的函数。底层实现使用进程池，任务完成后会触发<code>onFinish</code>，程序中可以得到任务处理的结果。比如一个IM需要广播，如果直接在异步代码中广播可能会影响其他事件的处理。另外文件读写也可以使用异步任务实现，因为文件句柄没办法像<code>socket</code>一样使用<code>Reactor</code>监听。因为文件句柄总是可读的，直接读取文件可能会使服务器程序阻塞，使用异步任务是非常好的选择。</p>
<p><strong>异步毫秒定时器</strong></p>
<p><img src="//blog.com/2019/06/23/PHP并发IO编程之路/13.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这2个接口实现了类似<code>JS</code>的<code>setInterval</code>、<code>setTimeout</code>函数功能，可以设置在n毫秒间隔实现一个函数或 n毫秒后执行一个函数。</p>
<h3 id="异步MySQL客户端"><a href="#异步MySQL客户端" class="headerlink" title="异步MySQL客户端"></a>异步MySQL客户端</h3><p><img src="//blog.com/2019/06/23/PHP并发IO编程之路/14.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>swoole</code>还提供一个内置连接池的<code>MySQL</code>异步客户端，可以设定最大使用<code>MySQL</code>连接数。并发<code>SQL</code>请求可以复用这些连接，而不是重复创建，这样可以保护<code>MySQL</code>避免连接资源被耗尽。</p>
<h3 id="异步Redis客户端"><a href="#异步Redis客户端" class="headerlink" title="异步Redis客户端"></a>异步Redis客户端</h3><p><img src="//blog.com/2019/06/23/PHP并发IO编程之路/15.png" alt="img"></p>
<h3 id="异步的Web程序"><a href="#异步的Web程序" class="headerlink" title="异步的Web程序"></a>异步的Web程序</h3><p><img src="//blog.com/2019/06/23/PHP并发IO编程之路/16.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序的逻辑是从<code>Redis</code>中读取一个数据，然后显示<code>HTML</code>页面。使用<code>ab</code>压测性能如下：</p>
<p><img src="//blog.com/2019/06/23/PHP并发IO编程之路/23.png" alt="img"></p>
<p>同样的逻辑在<code>php-fpm</code>下的性能测试结果如下：</p>
<p><img src="//blog.com/2019/06/23/PHP并发IO编程之路/24.png" alt="img"></p>
<h3 id="WebSocket程序"><a href="#WebSocket程序" class="headerlink" title="WebSocket程序"></a>WebSocket程序</h3><p><img src="//blog.com/2019/06/23/PHP并发IO编程之路/17.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>swoole</code>内置了<code>websocket</code>服务器，可以基于此实现<code>Web</code>页面主动推送的功能，比如<code>WebIM</code>。有一个开源项目可以作为参考。<a href="https://github.com/matyhtf/php-webim" target="_blank" rel="noopener">https://github.com/matyhtf/php-webim</a></p>
<h3 id="PHP-Swoole协程"><a href="#PHP-Swoole协程" class="headerlink" title="PHP+Swoole协程"></a>PHP+Swoole协程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;异步编程一般使用回调方式，如果遇到非常复杂的逻辑，可能会层层嵌套回调函数。协程就可以解决此问题，可以顺序编写代码，但运行时是异步非阻塞的。腾讯的工程师基于<code>Swoole</code>扩展和<code>PHP5.5</code>的<code>Yield/Generator</code>语法实现类似于<code>Golang</code>的协程，项目名称为<code>TSF（Tencent Server Framework）</code>，开源项目地址：<a href="https://github.com/tencent-php/tsf。目前在腾讯公司的企业QQ、QQ公众号项目以及车轮忽略的查违章项目有大规模应用" target="_blank" rel="noopener">https://github.com/tencent-php/tsf。目前在腾讯公司的企业QQ、QQ公众号项目以及车轮忽略的查违章项目有大规模应用</a> 。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TSF</code>使用也非常简单，下面调用了3个<code>IO</code>操作，完全是串行的写法。但实际上是异步非阻塞执行的。TSF底层调度器接管了程序的执行，在对应的<code>IO</code>完成后才会向下继续执行。</p>
<p><img src="//blog.com/2019/06/23/PHP并发IO编程之路/19.png" alt="img"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/23/epoll使用详解（精髓）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/23/epoll使用详解（精髓）/" itemprop="url">epoll使用详解（精髓）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-23T12:12:57+08:00">
                2019-06-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/" itemprop="url" rel="index">
                    <span itemprop="name">异步与同步</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/" itemprop="url" rel="index">
                    <span itemprop="name">IO</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/" itemprop="url" rel="index">
                    <span itemprop="name">Reactor</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/事件模型/" itemprop="url" rel="index">
                    <span itemprop="name">事件模型</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/事件模型/网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="epoll使用详解（精髓）"><a href="#epoll使用详解（精髓）" class="headerlink" title="epoll使用详解（精髓）"></a>epoll使用详解（精髓）</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html" target="_blank" rel="noopener">https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html</a></p>
</blockquote>
<p><br></p>
<h2 id="epoll函数说明"><a href="#epoll函数说明" class="headerlink" title="epoll函数说明"></a>epoll函数说明</h2><p><code>epoll - I/O event notification facility</code></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>linux</code>的网络编程中，很长的时间都在使用<code>select</code>来做事件触发。在<code>linux</code>新的内核中，有了一种替换它的机制，就是<code>epoll</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>相比于<code>select</code>，<code>epoll</code>最大的好处在于它不会随着监听<code>fd</code>数目的增长而降低效率</strong>。因为<strong>在内核中的<code>select</code>实现中，它是采用轮询来处理的，轮询的<code>fd</code>数目越多，自然耗时越多</strong>。并且，在<code>linux/posix_types.h</code>头文件有这样的声明：<br><code>#define __FD_SETSIZE    1024</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;表示<code>select</code>最多同时监听1024个<code>fd</code>，当然，可以通过修改头文件再重编译内核来扩大这个数目，但这似乎并不治本。</p>
<p><code>epoll</code>的接口非常简单，一共就三个函数：</p>
<ol>
<li><p><code>int epoll_create(int size)</code></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建一个<code>epoll</code>的句柄，<code>size</code>用来告诉内核这个监听的数目一共有多大。这个参数不同于<code>select()</code>中的第一个参数，给出最大监听的<code>fd+1</code>的值。需要注意的是，当创建好<code>epoll</code>句柄后，它就是会占用一个<code>fd</code>值，在<code>linux</code>下如果查看<strong><code>/proc/进程id/fd/</code></strong>，是能够看到这个<code>fd</code>的，所以在使用完<code>epoll</code>后，必须调用<code>close()</code>关闭，否则可能导致<code>fd</code>被耗尽。</p>
</li>
</ol>
<ol start="2">
<li><p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)</code></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>epoll</code>的事件注册函数，它不同与<code>select()</code>是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。</p>
<p>第一个参数是<code>epoll_create()</code>的返回值</p>
<p>第二个参数表示动作，用三个宏来表示：</p>
<pre><code>`EPOLL_CTL_ADD`：注册新的`fd`到`epfd`中；
`EPOLL_CTL_MOD`：修改已经注册的`fd`的监听事件；
`EPOLL_CTL_DEL`：从`epfd`中删除一个`fd`；
</code></pre><p>第三个参数是需要监听的<code>fd</code></p>
<p>第四个参数是告诉内核需要监听什么事</p>
</li>
</ol>
<p>   <code>struct epoll_event</code>结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">__uint32_t</span> u32;</span><br><span class="line">    <span class="keyword">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">__uint32_t</span> events; <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data; <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>events</code>可以是以下几个宏的集合：<br><code>EPOLLIN</code> ：<strong>表示对应的文件描述符可以读</strong>（包括对端<code>SOCKET</code>正常关闭）；<br><code>EPOLLOUT</code>：<strong>表示对应的文件描述符可以写</strong>；<br><code>EPOLLPRI</code>：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；<br><code>EPOLLERR</code>：表示对应的文件描述符发生错误；<br><code>EPOLLHUP</code>：表示对应的文件描述符被挂断；<br><code>EPOLLET</code>： <strong>将<code>EPOLL</code>设为边缘触发(<code>Edge Triggered</code>)模式，这是相对于水平触发(<code>Level Triggered</code>)来说的</strong>。<br><code>EPOLLONESHOT</code>：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个<code>socket</code>的话，需要再次把这个<code>socket</code>加入到<code>EPOLL</code>队列里</p>
<ol start="3">
<li><p><code>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)</code></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;等待事件的产生，类似于<code>select()</code>调用。</p>
<p>参数<code>events</code>用来从内核得到事件的集合，<code>maxevents</code>告之内核这个<code>events</code>有多大，这个<code>maxevents</code>的值不能大于创建<code>epoll_create()</code>时的<code>size</code>，参数<code>timeout</code>是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>
</li>
</ol>
<ol start="4">
<li><p>关于<code>ET、LT</code>两种工作模式：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>ET</code>模式仅当状态发生变化的时候才获得通知,这里所谓的状态的变化并不包括缓冲区中还有未处理的数据</strong>,也就是说,如果要采用ET模式,需要一直<code>read/write</code>直到出错为止,很多人反映为什么采用<code>ET</code>模式只接收了一部分数据就再也得不到通知了,大多因为这样;而<strong>LT模式是只要有数据没有处理就会一直通知下去的</strong>。</p>
</li>
</ol>
<ol start="5">
<li><p>如何来使用<code>epoll</code>呢？</p>
<p>通过在包含一个头文件<code>#include &lt;sys/epoll.h&gt;</code> 以及几个简单的<code>API</code>将可以大大的提高你的网络服务器的支持人数。</p>
</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先通过<code>create_epoll(int maxfds)</code>来创建一个<code>epoll</code>的句柄，其中<code>maxfds</code>为你<code>epoll</code>所支持的最大句柄数。这个函数会返回一个新的<code>epoll</code>句柄，之后的所有操作将通过这个句柄来进行操作。在用完之后，记得用<code>close()</code>来关闭这个创建出来的<code>epoll</code>句柄。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之后在你的网络主循环里面，每一次的调用<code>epoll_wait(int epfd, epoll_event events, int max events, int timeout)</code>来查询所有的网络接口，看哪一个可以读，哪一个可以写了。基本的语法为：<br><code>nfds = epoll_wait(kdpfd, events, maxevents, -1);</code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中<code>kdpfd</code>为用<code>epoll_create</code>创建之后的句柄，<code>events</code>是一个<code>epoll_event*</code>的指针，当<code>epoll_wait</code>这个函数操作成功之后，<code>epoll_events</code>里面将储存所有的读写事件。<code>max_events</code>是当前需要监听的所有<code>socket</code>句柄数。最后一个<code>timeout</code>是<code>epoll_wait</code>的超时，为0的时候表示马上返回，为-1的时候表示一直等下去，直到有事件范围，为任意正整数的时候表示等这么长的时间，如果一直没有事件，则范围。<strong>一般如果网络主循环是单独的线程的话，可以用-1来等，这样可以保证一些效率，如果是和主逻辑在同一个线程的话，则可以用0来保证主循环的效率</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>epoll_wait</code>范围之后应该是一个循环，遍利所有的事件。</p>
<h2 id="epoll使用模板"><a href="#epoll使用模板" class="headerlink" title="epoll使用模板"></a>epoll使用模板</h2><p>几乎所有的<code>epoll</code>程序都使用下面的框架：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( ; ; )</span><br><span class="line">    &#123;</span><br><span class="line">        nfds = epoll_wait(epfd,events,<span class="number">20</span>,<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(events[i].data.fd==listenfd) <span class="comment">//有新的连接</span></span><br><span class="line">            &#123;</span><br><span class="line">                connfd = accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen); <span class="comment">//accept这个连接</span></span><br><span class="line">                ev.data.fd=connfd;</span><br><span class="line">                ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">                epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev); <span class="comment">//将新的fd添加到epoll的监听队列中</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( events[i].events&amp;EPOLLIN ) <span class="comment">//接收到数据，读socket</span></span><br><span class="line">            &#123;</span><br><span class="line">                n = read(sockfd, line, MAXLINE)) &lt; <span class="number">0</span>    <span class="comment">//读</span></span><br><span class="line">                ev.data.ptr = md;     <span class="comment">//md为自定义类型，添加数据</span></span><br><span class="line">                ev.events=EPOLLOUT|EPOLLET;</span><br><span class="line">                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);<span class="comment">//修改标识符，等待下一个循环时发送数据，异步处理的精髓</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events&amp;EPOLLOUT) <span class="comment">//有数据待发送，写socket</span></span><br><span class="line">            &#123;</span><br><span class="line">                struct myepoll_data* md = (myepoll_data*)events[i].data.ptr;    <span class="comment">//取数据</span></span><br><span class="line">                sockfd = md-&gt;fd;</span><br><span class="line">                send( sockfd, md-&gt;ptr, <span class="built_in">strlen</span>((<span class="keyword">char</span>*)md-&gt;ptr), <span class="number">0</span> );        <span class="comment">//发送数据</span></span><br><span class="line">                ev.data.fd=sockfd;</span><br><span class="line">                ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev); <span class="comment">//修改标识符，等待下一个循环时接收数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//其他的处理</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="完整的服务器端例子"><a href="#完整的服务器端例子" class="headerlink" title="完整的服务器端例子"></a>完整的服务器端例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_MAX 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 5000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFTIM 1000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> sock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> opts;</span><br><span class="line">    opts=fcntl(sock,F_GETFL);</span><br><span class="line">    <span class="keyword">if</span>(opts&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fcntl(sock,GETFL)"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    opts = opts|O_NONBLOCK;</span><br><span class="line">    <span class="keyword">if</span>(fcntl(sock,F_SETFL,opts)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">"fcntl(sock,SETFL,opts)"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, maxi, listenfd, connfd, sockfd,epfd,nfds, portnumber;</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">    <span class="keyword">char</span> line[MAXLINE];</span><br><span class="line">    <span class="keyword">socklen_t</span> clilen;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( <span class="number">2</span> == argc )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( (portnumber = atoi(argv[<span class="number">1</span>])) &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Usage:%s portnumber/a/n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Usage:%s portnumber/a/n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明epoll_event结构体的变量,ev用于注册事件,数组用于回传要处理的事件</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>,<span class="title">events</span>[20];</span></span><br><span class="line">    <span class="comment">//生成用于处理accept的epoll专用的文件描述符</span></span><br><span class="line"></span><br><span class="line">    epfd=epoll_create(<span class="number">256</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//把socket设置为非阻塞方式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//setnonblocking(listenfd);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置与要处理的事件相关的文件描述符</span></span><br><span class="line"></span><br><span class="line">    ev.data.fd=listenfd;</span><br><span class="line">    <span class="comment">//设置要处理的事件类型</span></span><br><span class="line"></span><br><span class="line">    ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">    <span class="comment">//ev.events=EPOLLIN;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册epoll事件</span></span><br><span class="line"></span><br><span class="line">    epoll_ctl(epfd,EPOLL_CTL_ADD,listenfd,&amp;ev);</span><br><span class="line">    bzero(&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    <span class="keyword">char</span> *local_addr=<span class="string">"127.0.0.1"</span>;</span><br><span class="line">    inet_aton(local_addr,&amp;(serveraddr.sin_addr));<span class="comment">//htons(portnumber);</span></span><br><span class="line"></span><br><span class="line">    serveraddr.sin_port=htons(portnumber);</span><br><span class="line">    bind(listenfd,(sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line">    listen(listenfd, LISTENQ);</span><br><span class="line">    maxi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">        <span class="comment">//等待epoll事件的发生</span></span><br><span class="line"></span><br><span class="line">        nfds=epoll_wait(epfd,events,<span class="number">20</span>,<span class="number">500</span>);</span><br><span class="line">        <span class="comment">//处理所发生的所有事件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(events[i].data.fd==listenfd)<span class="comment">//如果新监测到一个SOCKET用户连接到了绑定的SOCKET端口，建立新的连接。</span></span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                connfd = accept(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen);</span><br><span class="line">                <span class="keyword">if</span>(connfd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    perror(<span class="string">"connfd&lt;0"</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//setnonblocking(connfd);</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">char</span> *str = inet_ntoa(clientaddr.sin_addr);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"accapt a connection from "</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="comment">//设置用于读操作的文件描述符</span></span><br><span class="line"></span><br><span class="line">                ev.data.fd=connfd;</span><br><span class="line">                <span class="comment">//设置用于注测的读操作事件</span></span><br><span class="line"></span><br><span class="line">                ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">                <span class="comment">//ev.events=EPOLLIN;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//注册ev</span></span><br><span class="line"></span><br><span class="line">                epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;ev);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events&amp;EPOLLIN)<span class="comment">//如果是已经连接的用户，并且收到数据，那么进行读入。</span></span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"EPOLLIN"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">if</span> ( (sockfd = events[i].data.fd) &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> ( (n = read(sockfd, line, MAXLINE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (errno == ECONNRESET) &#123;</span><br><span class="line">                        close(sockfd);</span><br><span class="line">                        events[i].data.fd = <span class="number">-1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span></span><br><span class="line">                        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"readline error"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">                    close(sockfd);</span><br><span class="line">                    events[i].data.fd = <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                line[n] = '/0';</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"read "</span> &lt;&lt; line &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="comment">//设置用于写操作的文件描述符</span></span><br><span class="line"></span><br><span class="line">                ev.data.fd=sockfd;</span><br><span class="line">                <span class="comment">//设置用于注测的写操作事件</span></span><br><span class="line"></span><br><span class="line">                ev.events=EPOLLOUT|EPOLLET;</span><br><span class="line">                <span class="comment">//修改sockfd上要处理的事件为EPOLLOUT</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events&amp;EPOLLOUT) <span class="comment">// 如果有数据发送</span></span><br><span class="line"></span><br><span class="line">            &#123;</span><br><span class="line">                sockfd = events[i].data.fd;</span><br><span class="line">                write(sockfd, line, n);</span><br><span class="line">                <span class="comment">//设置用于读操作的文件描述符</span></span><br><span class="line"></span><br><span class="line">                ev.data.fd=sockfd;</span><br><span class="line">                <span class="comment">//设置用于注测的读操作事件</span></span><br><span class="line"></span><br><span class="line">                ev.events=EPOLLIN|EPOLLET;</span><br><span class="line">                <span class="comment">//修改sockfd上要处理的事件为EPOLIN</span></span><br><span class="line"></span><br><span class="line">                epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;ev);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/34/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><span class="page-number current">35</span><a class="page-number" href="/page/36/">36</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/36/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
