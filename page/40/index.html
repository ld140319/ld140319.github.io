<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/page/40/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/page/40/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/21/如何设计具备幂等性的服务/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/21/如何设计具备幂等性的服务/" itemprop="url">如何设计具备幂等性的服务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-21T12:12:57+08:00">
                2019-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/幂等性/" itemprop="url" rel="index">
                    <span itemprop="name">幂等性</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="如何设计具备幂等性的服务"><a href="#如何设计具备幂等性的服务" class="headerlink" title="如何设计具备幂等性的服务"></a>如何设计具备幂等性的服务</h1><h2 id="幂等的目的"><a href="#幂等的目的" class="headerlink" title="幂等的目的"></a>幂等的目的</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为何会存在需要服务的幂等，在互联网中由于网络的不稳定和一些业务重复确认设计，对一个接口的调用存在重试的机制，<strong>为了确保执行同一个请求执行一次和执行多次的效果是一样的，所以就存在了幂等的设计</strong>。 举个例子，如果在转账的交易中，A给B进行一笔转账，如果没有幂等性，很可能就因为各种原因导致了A给B进行了多笔转账，在银行系统中，这个就是重大的灾难。</p>
<h2 id="幂等的定义"><a href="#幂等的定义" class="headerlink" title="幂等的定义"></a>幂等的定义</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;服务的幂等可能划分为2个层面，一个是从<strong>接口的请求</strong>层面，一个是从<strong>业务</strong>层面考虑。</p>
<h3 id="请求层面"><a href="#请求层面" class="headerlink" title="请求层面"></a>请求层面</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从请求层面考虑，就是<strong>一个接口得保证请求一个和请求多次得到的效果是一致的</strong>。 如果用数据表达式是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f...f(f(x)) = f(x) </span><br><span class="line">x是参数</span><br><span class="line">f是执行函数</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把相同的参数传给执行函数，不管执行了多少次，结果是一致的。</p>
<h3 id="业务层面"><a href="#业务层面" class="headerlink" title="业务层面"></a>业务层面</h3><p>从业务角度出来，保证重复执行不会对正常的业务造成影响。</p>
<blockquote>
<p>一个用户在一次购买中不能重复下单</p>
<p>库存剩下了1个商品，现在有10个人抢购，怎么保证不超卖</p>
<p>MQ的生产者是不需要保证幂等，很可能把同一条消息发送多次，需要保证MQ消费端去重，MQ消费者保证这批消息只会执行一个</p>
</blockquote>
<h2 id="导致非幂等原因"><a href="#导致非幂等原因" class="headerlink" title="导致非幂等原因"></a>导致非幂等原因</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先了解下为何会出现不幂等的原因，因为<strong><code>retry</code>重试</strong>，如果取消<code>retry</code>机制，是否就能杜绝不幂等呢，答案应该是肯定的，但取消<code>retry</code>是否现实，我们来看看究竟在什么场合会出现<code>retry</code></p>
<blockquote>
<p>用户进行下订单，调用下单接口超时，调用方又发起一次创建下单接口。</p>
<p>用户下单进行扣减库存，调用扣减库存接口超时了，调用方又发起一次扣减库存接口。</p>
<p>下单完毕后，生产者发送一条MQ，MQ超时没有及时响应ACK，生产者又再发送一条MQ，消费者连续就收到了两条MQ</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从整个系统或业务层面其实很难去做到去<code>retry</code>，所以在一些接口的幂等性还是需要我们自己来做。</p>
<h1 id="幂等作用范围"><a href="#幂等作用范围" class="headerlink" title="幂等作用范围"></a>幂等作用范围</h1><h3 id="读-写请求层面范围幂等"><a href="#读-写请求层面范围幂等" class="headerlink" title="读/写请求层面范围幂等"></a>读/写请求层面范围幂等</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;读没有造成数据的改变，只有写请求才会造成数据改变。</p>
<h3 id="架构层面范围幂等"><a href="#架构层面范围幂等" class="headerlink" title="架构层面范围幂等"></a>架构层面范围幂等</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;究竟在哪些层会造成数据的改变</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反向代理？网关？业务逻辑？数据访问？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从架构层面出发，哪些层会对数据造成改变，只有造成数据改变的层才需要做出幂等，很显然，数据访问层直接操作<code>DB</code>和<code>Cache</code>（业务逻辑层也可能访问操作<code>cache</code>），从请求层面来看，我们需要对数据访问层进行幂等操作。</p>
<h4 id="数据访问层哪些操作需要幂等"><a href="#数据访问层哪些操作需要幂等" class="headerlink" title="数据访问层哪些操作需要幂等"></a>数据访问层哪些操作需要幂等</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从数据层面出发，数据访问层 也就提供了<code>CRUD</code>四个请求层面,先站在数据层出发，看看是否可以对数据访问层进行一定改造让数据访问层达到幂等性</p>
<h5 id="Create-Select-操作"><a href="#Create-Select-操作" class="headerlink" title="Create / Select 操作"></a>Create / Select 操作</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into user (name,pm) values (&apos;petty&apos;,18)</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于<code>user</code>表的主键是自增ID，所以每次插入都会新增一条，可以考虑进行改造，让<code>prikey</code>程序实现而不依赖数据库，或者<strong>创建具备unique的索引，确保不会出现重复录入的行</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert into user (id,name,pm) values (100,&apos;petty&apos;,18) </span><br><span class="line"></span><br><span class="line">insert into user (id,name,pm) values (100,&apos;petty&apos;,18) </span><br><span class="line">[error : Duplicate entry &apos;100&apos; for key &apos;PRIMARY&apos;]</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实无论是否考虑到幂等性，在分布式服务中，都应该尽量避免使用数据库直接生成Id的方式去创建主键。</p>
<h5 id="Update-操作"><a href="#Update-操作" class="headerlink" title="Update 操作"></a>Update 操作</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对数据库的update操作简单来说，有【绝对值】修改<code>set [ num = 100 ]</code>，【相对值】修改<code>set [ num++ ]</code>：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绝对值修改，例如商品下架</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update product status = -1 where pid=1</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;属于天然幂等，如论执行多少次，结果都一直，不需要改造</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;（可能有人会有疑问说，如果又有另外一个线程把status修改成0，然后retry又把status修改成-1，那就达不到幂等效果，其实这个是另外一个问题了，这个不是本接口幂等的问题，而是业务隔离的问题）</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相对值修改，年龄增加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update xx set pm=pm++ where id = 100</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个就是明显的不具备幂等性，解决思路，现<strong>在程序层中查出数值进行计算</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update xx set pm=19 where id = 100</span><br><span class="line">替换</span><br><span class="line">update xx set pm=pm++ where id = 100 and pm = 18</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里可以在数据层面解决幂等性，不过这里多查了一次<code>sql</code>也会带来性能上的一个问题。<strong>先查询出旧年龄pm=18、然后+1，直接update pm=19</strong></p>
<h5 id="Delete-操作"><a href="#Delete-操作" class="headerlink" title="Delete 操作"></a>Delete 操作</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from xx order by pm desc limit 10</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>delete</code>道理跟<code>update</code>一致，回到业务中，除非我们想<code>drop</code>掉整个表，不然其实不可以 <code>delete</code>掉相对的条件的范围，一般都是需要查询出来哪些确切要<code>delete</code>的<code>id</code>，然后针对这批<code>id</code>进行<code>delete</code></p>
<h3 id="业务层面的幂等"><a href="#业务层面的幂等" class="headerlink" title="业务层面的幂等"></a>业务层面的幂等</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面从数据层面对<code>CRUD</code>做幂等处理，不过幂等性更多是考虑到业务场景，看一个例子。</p>
<h4 id="状态机控制"><a href="#状态机控制" class="headerlink" title="状态机控制"></a>状态机控制</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如我们有一个订单，假如订单的状态有：未确认-&gt;已经创建-&gt;已付款-&gt;已确认</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">update order set status = 已经创建 where orderid=1 and status = 未确认</span><br><span class="line"></span><br><span class="line">update order set status = 已经创建 where orderid=1 and status = 未确认</span><br><span class="line">【无效】</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过在设计状态字段，<strong>使用状态机的机制，确保<code>status</code>必须按照业务的流程往下走，这样在第二次更新时也会无效达到了幂等性的效果</strong>。</p>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>（<strong>相同时间同时执行</strong>）</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;刚说到在<code>MQ</code>的消费场景中，可能出现多次消费的情况，这个情况只能由消费者自己解决，举个例子：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当用户下订单因为生产者不需要幂等产生了2个<code>MQ</code>，分别<code>msg=xx001,msg=xx002</code>,他们的<code>orderid</code>都是001，两个消息都发送给了<code>MQ</code>，<code>MQ</code>再将两个消息发送给2个消费者。两个消费者现在用<code>orderid</code>为<code>key</code>，组成了一把分布式锁，<strong>两个消费者同时去获取这一把锁，不过它们之间只能有一个消费者获取成功，或者成功的消费者将消费这个<code>mq</code>并执行，或者不成功的消费者将取消执行</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>分布式锁主要起到的作用是解决并行的问题，将原本可能出问题的并行转为串性</strong>。</p>
<p>分布式锁解决不了的问题：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一个消费线程获取锁之后，很快就执行了，然后把锁释放掉。另外一个线程因为<code>MQ</code>时延等问题在第一个线程执行完之后才接收到<code>MQ</code>，又获取到分布式锁，又将接口再一次执行。（<strong>不同时间重复执行</strong>）</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分布式锁其实并不解决幂等性问题，但是可以看得出来，这两次接口的执行并不是并发执行，两次是一个串行关系，<strong>只要是串行关系，那可以借助状态机的机器去解决</strong>。这个时候就变成了一个业务隔离的问题</p>
<h4 id="去重表"><a href="#去重表" class="headerlink" title="去重表"></a>去重表</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个场景适合业务中<strong>有唯一插入的场景</strong>，例如在支付的场景中，订单只能被支付一次，可以把<code>orderid</code>作为一个唯一标示。新建一张<strong>去重表</strong>，并把<code>orderid</code>作为唯一索引，在写入订单表时，联通去重表一起写入并放在同一个事务中，如果重复调用，会由去重表抛出唯一索引约束的异常，进行回滚。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/18/seq命令的使用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/18/seq命令的使用/" itemprop="url">seq命令的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-18T12:12:57+08:00">
                2019-06-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/shell/" itemprop="url" rel="index">
                    <span itemprop="name">shell</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/shell/bash/" itemprop="url" rel="index">
                    <span itemprop="name">bash</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="seq命令的使用"><a href="#seq命令的使用" class="headerlink" title="seq命令的使用"></a>seq命令的使用</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://www.cnblogs.com/mjbjtunlp/p/5813245.html" target="_blank" rel="noopener">https://www.cnblogs.com/mjbjtunlp/p/5813245.html</a></p>
</blockquote>
<p><br></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;作用：<code>seq</code>命令用于以指定增量从首数开始打印数字到尾数，即产生从某个数到另外一个数之间的所有整数，并且可以对整数的格式、宽度、分割符号进行控制</p>
<p><strong>语法：</strong></p>
<p>　　[1] <code>seq</code> [选项]    尾数</p>
<p>　　[2]<code>seq</code> [选项]    首数  尾数</p>
<p>　　[3] <code>seq</code> [选项]    首数  增量 尾数</p>
<p><strong>选项：</strong></p>
<p>​    <code>-f, --format</code>=格式</p>
<p>   <code>-s, --separator</code>=字符串，使用指定的字符串分割数字（默认使用个<code>&quot;\n&quot;</code>分割）</p>
<p>​    <code>-w, --sequal-width</code>  在列前添加0 使得宽度相同</p>
<p><strong>实例：</strong></p>
<p>​    [1] 产生5以内的整数</p>
<p>​        命令：<code>seq 5</code></p>
<p>​        输出：<img src="//blog.com/2019/06/18/seq命令的使用/976201-20160827162556772-2059715282.png" alt="img"></p>
<p>​     [2]产生-2~10内的整数，增量为2</p>
<p>​        命令：<code>seq -2 2 10</code></p>
<p>　　　输出：<img src="//blog.com/2019/06/18/seq命令的使用/976201-20160827162820351-41968942.png" alt="img"></p>
<p>​     [3] 产生98~101之间的整数，并且要求输出数字宽度相同，不足的用空格补足。</p>
<p>​        命令： <code>seq -f &quot;%3g&quot; 98 101</code>    </p>
<p>​        输出：  <img src="//blog.com/2019/06/18/seq命令的使用/976201-20160827161508507-1389247466.png" alt="img"></p>
<p>​        命令：<code>seq -f &quot;%03g&quot; 98 101</code></p>
<p>  　　 输出：<img src="//blog.com/2019/06/18/seq命令的使用/976201-20160827161734054-1465978411.png" alt="img"> </p>
<p>​         注意：通过%后添加0替代空格补足空位</p>
<p>​     [4] 产生98~101之间的整数，并且要求数字之间的分隔符为”:::”。</p>
<p>​         命令：<code>seq -s &quot;:::&quot; -f &quot;%03g&quot; 98 101</code></p>
<p>​         输出：<img src="//blog.com/2019/06/18/seq命令的使用/976201-20160827162143444-2105797256.png" alt="img"></p>
<p>​     [5]输出98~100之间的整数，要求宽度一致</p>
<p>​         命令：<code>seq -w 98 101</code></p>
<p>​         输出：<img src="//blog.com/2019/06/18/seq命令的使用/976201-20160827162317772-255774939.png" alt="img"> </p>
<p>　　　 注意：<code>-w</code>选项不能和<code>-f</code>选项一起用，输出是同宽的 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/18/分布式事务解决方案与适用场景分析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/18/分布式事务解决方案与适用场景分析/" itemprop="url">分布式事务解决方案与适用场景分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-18T12:12:57+08:00">
                2019-06-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/分布式事务/" itemprop="url" rel="index">
                    <span itemprop="name">分布式事务</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分布式事务解决方案与适用场景分析"><a href="#分布式事务解决方案与适用场景分析" class="headerlink" title="分布式事务解决方案与适用场景分析"></a>分布式事务解决方案与适用场景分析</h1><h2 id="基于-XA-协议的应用场景"><a href="#基于-XA-协议的应用场景" class="headerlink" title="基于 XA 协议的应用场景"></a>基于 XA 协议的应用场景</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>XA</code>协议在架构上与 <code>TCC</code>模型相比，最大的不同是<strong><code>XA</code> 直接作用于资源层，而后者作用于服务层</strong>。</p>
<p><img src="//blog.com/2019/06/18/分布式事务解决方案与适用场景分析/nibOZpaQKw080RxcCq2iaV6zia55TdALJ0NwNwqVMDkvD2LJdehdFIvYx60qmdIH9uXFn9HSTC5KCEZnuwo0iaz0tA.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;资源层更普适，并且对业务几乎没有侵入，但是为了适应各种业务场景使用，需要严格遵循事务<code>ACID</code>特性；服务层更接近业务，可以针对不同业务做特定的优化处理，追求更高的极限性能。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，并不是说 <code>XA</code> 协议只能作用于单个服务内部的多资源场景，跨服务的多资源场景也是可以的，只不过同样需要额外的事务传递机制。</p>
<p><img src="//blog.com/2019/06/18/分布式事务解决方案与适用场景分析/nibOZpaQKw080RxcCq2iaV6zia55TdALJ0NEz5BvMwgtbib8RQFclFfmbKsbWWjZoaiaANuufmRf1B6FeVL9kHZKiauA.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在《分布式事务综述》一中介绍过，<code>XA</code> 协议通过每个 <code>RM</code>（<code>Resource Manager</code>，资源管理器）的<strong>本地事务隔离性来保证全局隔离，并且需要通过串行化隔离级别来保证分布式事务一致性</strong>。但是，串行化隔离级别存在一定的性能问题，如下所示： </p>
<p><img src="//blog.com/2019/06/18/分布式事务解决方案与适用场景分析/nibOZpaQKw080RxcCq2iaV6zia55TdALJ0NdqDia1ZSSJve3GoYq252DmCfB6KFnmY2sjpNiaa8PCXfEt252KHlK5Hg.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在串行化隔离级别下，会为本来不加锁的 <code>Select</code>快照读操作都加上读锁，导致锁持有时间增加，并发性能进一步降低</strong>。当实现了无锁的全局一致性读取以后，比如分布式<code>MVCC</code>，可以大幅减少锁持有时间，并发性能会获得较大提升。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是不管怎么优化实现，分布式事务的热点数据并发性能最高就是趋近于单机本地事务。所以，无论是基于<code>XA</code> 协议实现的分布式事务，还是单机本地事务，都是存在<strong>热点数据并发性能极限</strong>的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么 <code>XA</code> 协议最大的作用是什么呢？其<strong>最大的作用在于数据库资源横向扩展时，能保证多资源访问的事务属性</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>当单台 <code>RM</code> 机器达到资源性能瓶颈，无法满足业务增长需求时，就需要横向扩展 <code>RM</code> 资源，形成 RM 集群</strong>。通过横向扩展资源，提升非热点数据的并发性能，这对于大体量的互联网产品来说，是至关重要的。</p>
<p><img src="//blog.com/2019/06/18/分布式事务解决方案与适用场景分析/nibOZpaQKw080RxcCq2iaV6zia55TdALJ0N4jcp3ibibYbION7iclIKhPicnoDjib55cCUZoia72z6k2HZlVP5cxgiaSibXvQ.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上图为例，假设单台 <code>RM</code> 的非热点数据并发性能为 <code>100 TPS</code>，那么 5台 RM 就是<code>500 TPS</code>，就算一个分布式事务平均涉及 2 台 <code>RM</code>，也有 <code>250 TPS</code>，提升了 2.5 倍的非热点并发能力。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综上所述，基于 <code>XA</code>协议实现的分布式事务并不能提升热点并发性能，其意义<strong>在于横向扩展资源提升非热点数据并发性能时，能严格保证对多资源访问的事务<code>ACID</code>特性</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至于热点数据并发性能问题，对于一般的应用来说，经过 <code>SQL</code> 层面一定的性能优化之后，其并发性能基本就能够满足业务的需求。如果经过优化，达到性能极限之后，还不能满足，就需要上升到业务层面，根据业务特点，通过专门的业务逻辑或业务架构优化来实现。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>直接在资源层实现分布式事务的另外一点好处是其普适性，可以对上层业务屏蔽底层实现细节</strong>。这一点在云服务时代特别有用，云服务面对的是大量的中小企业，甚至是个人开发者，业务诉求不尽相同，普适、标准的分布式事务产品是非常有必要的，可以让开发者从底层技术细节中脱离出来，更专注于业务逻辑的实现，从而获得更高效、快速的业务发展。</p>
<h2 id="基于-TCC-模型的应用场景"><a href="#基于-TCC-模型的应用场景" class="headerlink" title="基于 TCC 模型的应用场景"></a>基于 TCC 模型的应用场景</h2><p><img src="//blog.com/2019/06/18/分布式事务解决方案与适用场景分析/nibOZpaQKw080RxcCq2iaV6zia55TdALJ0NQCjjyZPtoeDq2ia0bHsGCkq5y62TQiaW3pGuIDxMwdyedYA1PBjFHavQ.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>TCC</code>分布式事务模型直接作用于服务层</strong>。不与具体的服务框架耦合，与底层<code>RPC</code>协议无关，与底层存储介质无关，可以<strong>灵活选择业务资源的锁定粒度，减少资源锁持有时间，可扩展性好，可以说是为独立部署的 <code>SOA</code> 服务而设计的</strong>。</p>
<h3 id="TCC-模型优势"><a href="#TCC-模型优势" class="headerlink" title="TCC 模型优势"></a>TCC 模型优势</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于<code>TCC</code> 分布式事务模型，笔者认为其在业务场景应用上，有两方面的意义。</p>
<h4 id="跨服务的分布式事务"><a href="#跨服务的分布式事务" class="headerlink" title="跨服务的分布式事务"></a>跨服务的分布式事务</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一部分的作用与 <code>XA</code>类似，服务的拆分，也可以认为是资源的横向扩展，只不过方向不同而已。</p>
<p>横向扩展可能沿着两个方向发展：</p>
<ol>
<li><p><strong>功能扩展</strong>。根据功能对数据进行分组，并将不同的功能组分布在多个不同的数据库上，这实际上就是<code>SOA</code>架构下的服务化。</p>
</li>
<li><p><strong>数据分片</strong>，在功能组内部将数据拆分到多个数据库上，为横向扩展增加一个新的维度。</p>
</li>
</ol>
<p>下图简要阐释了横向数据扩展策略：</p>
<p><img src="//blog.com/2019/06/18/分布式事务解决方案与适用场景分析/nibOZpaQKw080RxcCq2iaV6zia55TdALJ0Nslwp0paqsg78DIx90iaSdujgDI9dxlG2TNZichmVWhdeGwjC5dGpIONw.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;横向扩展的两种方法可以同时进行运用：用户信息（<code>Users</code>）、产品信息（<code>Products</code>）与交易信息（<code>Trans</code>）三个不同功能组可以存储在不同的数据库中。另外，每个功能组内根据其业务量可以再拆分到多个数据库中，各功能组可以相互独立地进行扩展。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，<code>TCC</code>的其中一个作用就是<strong>在按照功能横向扩展资源时，保证多资源访问的事务属性</strong>。</p>
<h3 id="两阶段拆分"><a href="#两阶段拆分" class="headerlink" title="两阶段拆分"></a>两阶段拆分</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TCC</code>另一个作用就是把两阶段拆分成了两个独立的阶段，通过<strong>资源业务锁定</strong>的方式进行关联。资源业务锁定方式的好处在于，既<strong>不会阻塞其他事务在第一阶段对于相同资源的继续使用，也不会影响本事务第二阶段的正确执行</strong>。</p>
<p><img src="//blog.com/2019/06/18/分布式事务解决方案与适用场景分析/nibOZpaQKw080RxcCq2iaV6zia55TdALJ0Nv5CXjEh0hxhaib4QsLnn0yXktgjoOmTc9tkwpvTiaPiavzj7rN1iax31aw.png" alt="img"></p>
<h2 id="XA模型的并发事务"><a href="#XA模型的并发事务" class="headerlink" title="XA模型的并发事务"></a>XA模型的并发事务</h2><p><img src="//blog.com/2019/06/18/分布式事务解决方案与适用场景分析/nibOZpaQKw080RxcCq2iaV6zia55TdALJ0NHOXakGakfImRpggjBGbIa8F8sdGzqxyYEiaRLXuGySJoGqFXpXxKxZQ.png" alt="img"></p>
<h2 id="TCC-模型的并发事务"><a href="#TCC-模型的并发事务" class="headerlink" title="TCC 模型的并发事务"></a>TCC 模型的并发事务</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以发现<code>TCC</code> 模型进一步减少了资源锁的持有时间。同时，<strong>从理论上来说，只要业务允许，事务的第二阶段什么时候执行都可以，反正资源已经业务锁定，不会有其他事务动用该事务锁定的资源</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这对业务有什么好处呢？拿支付宝的担保交易场景来说，简化情况下，只需要涉及两个服务，交易服务和账务服务。交易作为主业务服务，账务作为从业务服务，提供<code>Try、Commit、Cancel</code>接口：</p>
<ol>
<li><p><code>Try</code> 接口扣除用户可用资金，转移到预冻结资金。预冻结资金就是业务锁定方案，每个事务第二阶段只能使用本事务的预冻结资金，<strong>在第一阶段执行结束后，其他并发事务也可以继续处理用户的可用资金</strong>。</p>
</li>
<li><p><code>Commit</code>接口扣除预冻结资金，增加中间账户可用资金（担保交易不能立即把钱打给商户，需要有一个中间账户来暂存）。</p>
</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设只有一个中间账户的情况下，每次调用支付服务的 <code>Commit</code> 接口，都会锁定中间账户，中间账户存在<strong>热点性能问题</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，在担保交易场景中，七天以后才需要将资金从中间账户划拨给商户，中间账户并不需要对外展示。因此，在执行完支付服务的第一阶段后，就可以认为本次交易的支付环节已经完成，并向用户和商户返回支付成功的结果，并不需要马上执行支付服务二阶段的 <code>Commit</code> 接口，等到低锋期时，再<strong>慢慢消化，异步地执行</strong>。</p>
<p><img src="//blog.com/2019/06/18/分布式事务解决方案与适用场景分析/nibOZpaQKw080RxcCq2iaV6zia55TdALJ0NuWvK79bUTagbPV9TCEKZx9wdHV3LhlUmtBBftKPDAdlUdOSDM8GgNA.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能部分读者认为担保交易比较特殊，其实直付交易（直接把钱打到商户账户的交易模式，<code>Commit</code> 接口扣除预冻结资金以后，不是转移到中间账务，而是直接转移到商户账户）也可以这样使用，只要提前告知商户，高峰期交易资金不是实时到账，但保证在一定时间之内结算完成，商户应该也是可以理解的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就是 <strong><code>TCC</code>分布式事务模型的二阶段异步化功能，从业务服务的第一阶段执行成功，主业务服务就可以提交完成，然后再由框架异步的执行各从业务服务的第二阶段</strong>。</p>
<h2 id="通用型-TCC-解决方案"><a href="#通用型-TCC-解决方案" class="headerlink" title="通用型 TCC 解决方案"></a>通用型 TCC 解决方案</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通用型 <code>TCC</code>解决方案就是最典型的 <code>TCC</code> 分布式事务模型实现，<strong>所有从业务服务都需要参与到主业务服务的决策当中</strong>。</p>
<p><img src="//blog.com/2019/06/18/分布式事务解决方案与适用场景分析/nibOZpaQKw080RxcCq2iaV6zia55TdALJ0NPe5xicdLjdwettIPudZvQsQ4C5jeccG0TqYXjrz6f4UuzibwZeZA6Tvg.png" alt="img"></p>
<p><strong>适用场景</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于从业务服务是<strong>同步调用</strong>，其结果会影响到主业务服务的决策，因此通用型 <code>TCC</code> 分布式事务解决方案<strong>适用于执行时间确定且较短的业务</strong>，比如互联网金融企业最核心的三个服务：交易、支付、账务：</p>
<p><img src="//blog.com/2019/06/18/分布式事务解决方案与适用场景分析/nibOZpaQKw080RxcCq2iaV6zia55TdALJ0NEasXhLVvmU8C0EzlAD9iblquCpSib14usG9vyCcd6VibX7TicYCK5eiazMw.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当用户发起一笔交易时，首先访问交易服务，创建交易订单；然后交易服务调用支付服务为该交易创建支付订单，执行收款动作，最后支付服务调用账务服务记录账户流水和记账。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了保证三个服务一起完成一笔交易，要么同时成功，要么同时失败，可以使用通用型<code>TCC</code>解决方案，将<strong>这三个服务放在一个分布式事务中，交易作为主业务服务，支付作为从业务服务，账务作为支付服务的嵌套从业务服务，由 <code>TCC</code>模型保证事务的原子性</strong>。</p>
<p><img src="//blog.com/2019/06/18/分布式事务解决方案与适用场景分析/nibOZpaQKw080RxcCq2iaV6zia55TdALJ0Nbe9Lw0t7tL3ibYJmH6EWoAygCKlbqc8mKEHXu0EyEbuGicDuBJVMgmAw.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>支付服务的 <code>Try</code> 接口创建支付订单，开启嵌套分布式事务，并调用账务服务的<code>Try</code> 接口；账务服务在<code>Try</code> 接口中冻结买家资金</strong>。一阶段调用完成后，交易完成，提交本地事务，<strong>由 <code>TCC</code>框架完成分布式事务各从业务服务二阶段的调用</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;支付服务二阶段先调用账务服务的 <code>Confirm</code>接口，解冻买家资金；增加卖家可用资金。调用成功后，支付服务修改支付订单为完成状态，完成支付。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当支付和账务服务二阶段都调用完成后，整个分布式事务结束。</p>
<h2 id="异步确保型-TCC-解决方案"><a href="#异步确保型-TCC-解决方案" class="headerlink" title="异步确保型 TCC 解决方案"></a>异步确保型 TCC 解决方案</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>异步确保型 <code>TCC</code> 解决方案的直接从业务服务是可靠消息服务，而真正的从业务服务则通过消息服务解耦，作为消息服务的消费端，异步地执行</strong>。</p>
<p><img src="//blog.com/2019/06/18/分布式事务解决方案与适用场景分析/nibOZpaQKw080RxcCq2iaV6zia55TdALJ0NOURfhGTQicVq8IjOJ5myiaUPNl01BjhdvCCls0fYWGnbm9KuNdXVNuuQ.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>可靠消息服务需要提供<code>Try，Confirm，Cancel</code> 三个接口。<code>Try</code>接口预发送，只负责持久化存储消息数据；<code>Confirm</code> 接口确认发送，这时才开始真正的投递消息；<code>Cancel</code> 接口取消发送，删除消息数据</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;消息服务的消息数据独立存储，独立伸缩，降低从业务服务与消息系统间的耦合，<strong>在消息服务可靠的前提下，实现分布式事务的最终一致性</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此解决方案虽然增加了消息服务的维护成本，但<strong>由于消息服务代替从业务服务实现了 <code>TCC</code>接口，从业务服务不需要任何改造，接入成本非常低</strong>。</p>
<p><strong>适用场景</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于从业务服务消费消息是一个异步的过程，执行时间不确定，可能会导致<strong>不一致时间窗口增加</strong>。因此，异步确保性<code>TCC</code> 分布式事务解决方案<strong>只适用于对最终一致性时间敏感度较低的一些被动型业务（从业务服务的处理结果不影响主业务服务的决策，只被动的接收主业务服务的决策结果）</strong>。比如会员注册服务和邮件发送服务：</p>
<p><img src="//blog.com/2019/06/18/分布式事务解决方案与适用场景分析/nibOZpaQKw080RxcCq2iaV6zia55TdALJ0NCSmDP6UJKNt26DmA5sdkLLciaRnhJfepLEDfsklNF4R2ScFaCtL3zGg.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当用户注册会员成功，需要给用户发送一封邮件，告诉用户注册成功，并提示用户激活该会员。但要注意两点：</p>
<ol>
<li><p>如果用户注册成功，一定要给用户发送一封邮件；</p>
</li>
<li><p>如果用户注册失败，一定不能给用户发送邮件。</p>
</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，这同样需要会员服务和邮件服务保证原子性，要么都执行，要么都不执行。不一样的是，邮件服务只是一种被动型的业务，并不影响用户是否能够注册成功，它只需要在用户注册成功以后发送邮件给用户即可，<strong>邮件服务不需要参与到会员服务的活动决策中</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于此种业务场景，可以使用异步确保型<code>TCC</code>分布式事务解决方案，如下：</p>
<p><img src="//blog.com/2019/06/18/分布式事务解决方案与适用场景分析/nibOZpaQKw080RxcCq2iaV6zia55TdALJ0NU4UaibIxnqTLXkpGHTHA2sazrAZEekericgwn10qKxXwYvk17h0D7nrw.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由可靠消息服务来解耦会员和邮件服务，会员服务与消息服务组成 <code>TCC</code>事务模型，保证事务原子性。然后通过消息服务的可靠特性，确保消息一定能够被邮件服务消费，从而使得会员与邮件服务在同一个分布式事务中。同时，邮件服务也不会影响会员服务的执行过程，只在会员服务执行成功后被动接收发送邮件的请求。</p>
<h2 id="补偿型-TCC-解决方案"><a href="#补偿型-TCC-解决方案" class="headerlink" title="补偿型 TCC 解决方案"></a>补偿型 TCC 解决方案</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;补偿型<code>TCC</code> 解决方案与通用型 <code>TCC</code> 解决方案的结构相似，其从业务服务也需要参与到主业务服务的活动决策当中。但不一样的是，前者的从业务服务只需要提供 <code>Do</code>和 <code>Compensate</code> 两个接口，而后者需要提供三个接口。</p>
<p><img src="//blog.com/2019/06/18/分布式事务解决方案与适用场景分析/nibOZpaQKw080RxcCq2iaV6zia55TdALJ0N3VqJzbZyCwDZ1ib5pFvC69NasLV5CJanjUQqqT56dgrseEMDkRuJOibQ.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Do</code>接口直接执行真正的完整业务逻辑，完成业务处理，业务执行结果外部可见；<code>Compensate</code> 操作用于业务补偿，抵消或部分抵消正向业务操作的业务结果，<code>Compensate</code>操作需满足幂等性</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与通用型解决方案相比，<strong>补偿型解决方案的从业务服务不需要改造原有业务逻辑，只需要额外增加一个补偿回滚逻辑即可，业务改造量较小</strong>。但要注意的是，<strong>业务在一阶段就执行完整个业务逻辑，无法做到有效的事务隔离，当需要回滚时，可能存在补偿失败的情况，还需要额外的异常处理机制，比如人工介入</strong>。</p>
<p><strong>适用场景</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于存在回滚补偿失败的情况，补偿型 <code>TCC</code>分布式事务解决方案<strong>只适用于一些并发冲突较少或者需要与外部交互的业务</strong>，这些外部业务不属于被动型业务，其执行结果会影响主业务服务的决策，比如机票代理商的机票预订服务：</p>
<p><img src="//blog.com/2019/06/18/分布式事务解决方案与适用场景分析/nibOZpaQKw080RxcCq2iaV6zia55TdALJ0N1NpiaGAmTTWkLdmXwfPSIcJMNhdmI6icj5BfJcMxxdq6FibnvyUUyPFkA.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该机票服务提供多程机票预订服务，可以同时预订多趟行程航班机票，比如从北京到圣彼得堡，需要第一程从北京到莫斯科，以及第二程从莫斯科到圣彼得堡。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当用户预订机票时，肯定希望能<strong>同时预订</strong>这两趟航班的机票，只预订一趟航班对用户来说没有意义。因此，对于这样的业务服务同样提出了原子性要求，如果其中一趟航班的机票预订失败，另外一趟需要能够取消预订。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，<strong>由于航空公司相对于机票代理商来说属于外部业务，只提供订票接口和取消预订接口，想要推动航空公司改造是极其困难的。因此，对于此类业务服务，可以使用补偿型 <code>TCC</code> 分布式事务解决方案</strong>，如下：</p>
<p><img src="//blog.com/2019/06/18/分布式事务解决方案与适用场景分析/nibOZpaQKw080RxcCq2iaV6zia55TdALJ0NntcwQyt3wnlv2urCEtJIKyv1vKnPY9Fv3XHlMhaobuibodLq2IUmfgA.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网关服务在原有逻辑基础上增加 <code>Compensate</code>接口，负责调用对应航空公司的取消预订接口。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在用户发起机票预订请求时，机票服务先通过网关 <code>Do</code>接口，调用各航空公司的预订接口，如果所有航班都预订成功，则整个分布式事务直接执行成功；<strong>一旦某趟航班机票预订失败，则分布式事务回滚，由<code>TCC</code> 事务框架调用各网关的 <code>Compensate</code> 补偿接口，其再调用对应航空公司的取消预订接口。通过这种方式，也可以保证多程机票预订服务的原子性</strong>。</p>
<h2 id="总-结"><a href="#总-结" class="headerlink" title="总 结"></a>总 结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于现在的互联网应用来说，资源横向扩展提供了更多的灵活性，是一种比较容易实现的向外扩展方案，但是同时也明显增加了复杂度，引入一些新的挑战，比如资源之间的数据一致性问题。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;横向数据扩展既可以按数据分片扩展，也可以按功能扩展。<code>XA</code> 与<code>TCC</code> 模型在这一点上的作用类似，都能在横向扩展资源的同时，保证多资源访问的事务属性，只不过前者作用于数据分片时，后者作用于功能扩展时。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>XA</code> 模型另外一个意义在于其普适性，抛开性能问题的情况下，几乎可以适用于所有业务模式，这对于一些基础性的技术产品来说是非常有用的，比如分布式数据库、云服务的分布式事务框架等</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>TCC</code>模型除了跨服务的分布式事务这一层作用之外，还具有两阶段划分的功能，通过业务资源锁定，允许第二阶段的异步执行，而异步化思想正是解决热点数据并发性能问题的利器之一</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文结合具体的业务场景和例子，对比分析了各分布式事务解决方案在性能、热点冲突、接入复杂度和适用场景等方面的能力，希望能帮助各位读者对分布式事务有更深一层的理解。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;业务各有各的不同，有些业务能容忍短期不一致，有些业务的操作可以幂等，无论什么样的分布式事务解决方案都有其优缺点，没有一个银弹能够适配所有。因此，业务需要什么样的解决方案，还需要结合自身的业务需求、业务特点、技术架构以及各解决方案的特性，综合分析，才能找到最适合的方案。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/17/算法之美-栈和队列/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/17/算法之美-栈和队列/" itemprop="url">算法之美-栈和队列</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-17T12:12:57+08:00">
                2019-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/栈/" itemprop="url" rel="index">
                    <span itemprop="name">栈</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/栈/队列/" itemprop="url" rel="index">
                    <span itemprop="name">队列</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/栈/队列/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="算法之美-栈和队列"><a href="#算法之美-栈和队列" class="headerlink" title="算法之美-栈和队列"></a>算法之美-栈和队列</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s/TVFNmT9t6qVINia2nsRLaQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/TVFNmT9t6qVINia2nsRLaQ</a></p>
</blockquote>
<p><br></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈与队列分别是两种数据结构，不同语言对于栈和队列有着不同的声明，在<code>java</code>中 <code>Stack</code>类是继承自 <code>Vector</code> 集合的子类，<code>Queue</code> 则是以接口形式存在，常用的其实现类是 <code>LinkedList</code>这个双向队列。在C++的标准模版库也是有这两个数据结构定义的具体类的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;栈数据结构的特点是<code>FILO（first in last out）</code> 即先进后出，队列则是<code>FIFO（first in first out）</code>即先进先出。相信栈与队列的数据结构的基本特点大家也是熟记于胸了。下面就带大家看一道面试题来带大家看下这两者在面试题中的形式。</p>
<h2 id="由两个栈实现一个队列-（✭✭✩✩✩）"><a href="#由两个栈实现一个队列-（✭✭✩✩✩）" class="headerlink" title="由两个栈实现一个队列 （✭✭✩✩✩）"></a>由两个栈实现一个队列 （✭✭✩✩✩）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;题目难度两颗星，主要考察了对于栈和队列的数据结构特点。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于一个栈来说遵循 <code>pop</code> 操作时从栈的顶部取一个元素，对于队列来说 <code>poll</code>操作时从队列队首取一个元素。所以该题翻译过来就是<strong>使用两个栈定义一种先放入的元素，最先被取出的数据结构</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此题应考虑到两种情况，首先最简单的一种情况，假设有 1，2，3，4，5 个元素依次进入自定义的队列，再依次取出。由于是<strong>进栈操作都进行完了才进行出栈操作</strong>，所以我们只需在元素出队时，将进栈元素倒入另一个空栈中即可。示意图如下：</p>
<p><img src="//blog.com/2019/06/17/算法之美-栈和队列/zKFJDM5V3WwkXYNnmwYGPbayIQEowS1WsmALGJr0ibozeOUJJpicto7wkvq9YWXpYWFM7A0rUqUGB3BZ9ib13NYyw.jpeg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再一种情况是，如果<strong><code>add poll</code>操作是交替进行的</strong>，那么如何保证数据结构先进先出的定义呢？比如先放入 1，2，3然后要进行一次取出操作取出 1，随后在进行 <code>add</code> 操作放入4，5，这种情况下如何操作两个栈，才能保证之后再取出的时候元素为 2，3，4，5 顺序？</p>
<p>实际上我们只需要保证一下两点就可以：</p>
<ol>
<li><p><strong>无论如果 StackA（最开始add元素的那个栈） 要往 StackB 中压入元素，那么必须选择一次性全部压入。</strong></p>
</li>
<li><p><strong>无论什么时候从队列中取元素，必须保证元素是从 StackB 中 pop 出的，也就是说，当 StackB 不为空的时候绝不能再次向 StackB 中压入元素。</strong></p>
</li>
</ol>
<p>为了方便理解可以看下边这幅图：</p>
<p><img src="//blog.com/2019/06/17/算法之美-栈和队列/zKFJDM5V3WwkXYNnmwYGPbayIQEowS1WbY7l8tZJ6VcvQ1lC7cP0n2LvV9WxZnfXHTnicpBO8D9fwPPEvpXI0hQ.jpeg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;明白了需要注意的点后就是该写代码的时候了，需要注意的点在图中已经用红色字体标出了，也就是<strong>在存入元素一直往 StackA 中存，取元素是从 StackB 中取，但要要注意的是取的时候需要保证 StackB 为空的时候要先将 StackA 中元素一次性压如 StackB 中，在进行从 StackB 中取的操作</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span>  <span class="title">TwoStackQueue</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;E&gt; stackA;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;E&gt; stackB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TwoStackQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackA = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stackB = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加元素逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 要添加的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 这里只是遵循 Queue 的习惯，这里简单处理返回 true 即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">        stackA.push(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 去除元素的时候需要判断两个地方，StackA &amp; StackB 是否都为空</span></span><br><span class="line"><span class="comment">     * StackB 为空的时候讲StackA中的元素全部依次压入 StackB</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回队列中的元素 如果队列为空返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果队列中没有元素则直接返回空，也可以选择抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (stackB.isEmpty() &amp;&amp; stackA.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stackB.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!stackA.isEmpty())&#123;</span><br><span class="line">                stackB.add(stackA.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stackB.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * peek 操作不取出元素，只返回队列头部的元素值 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 队列头部的元素值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果队列中没有元素则直接返回空，也可以选择抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (stackB.isEmpty() &amp;&amp; stackA.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stackB.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span> (!stackA.isEmpty())&#123;</span><br><span class="line">                stackB.add(stackA.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stackB.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的 C++ 解法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">TStackQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;T&gt; stackA;</span><br><span class="line">    <span class="built_in">stack</span>&lt;T&gt; stackB;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> TStackQueue&lt;T&gt;::add(T node) &#123;</span><br><span class="line">    stackA.push(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T TStackQueue&lt;T&gt;::poll()&#123;</span><br><span class="line">    <span class="keyword">if</span> (stackB.empty() &amp;&amp; stackA.empty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stackB.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stackA.empty()) &#123;</span><br><span class="line">            stackB.push(stackA.top());</span><br><span class="line">            stackA.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T node = stackB.top();</span><br><span class="line">    stackB.pop();</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两个队列实现一个栈-（✭✭✩✩✩）"><a href="#两个队列实现一个栈-（✭✭✩✩✩）" class="headerlink" title="两个队列实现一个栈 （✭✭✩✩✩）"></a>两个队列实现一个栈 （✭✭✩✩✩）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上道题我们完成了两个栈实现一个队列的题目，那么两个队列实现一个栈又该注意哪些呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先<strong>队列是先进先出，我们可以发现队列无论怎么倒，我们不能逆序一个队列</strong>。既然不能套用上题的解法，那么就得另谋出路，但是可以预知无非就是两个队列进行交替的入队出队操作，那么唯一要做的就是<strong>判断目前出队的值是否是按照放入元素顺序中最后放入的元素。</strong> 依旧画图举例</p>
<p><img src="//blog.com/2019/06/17/算法之美-栈和队列/zKFJDM5V3WwkXYNnmwYGPbayIQEowS1WibAv0b51FQjovJoWqiaRq0azXAib2DPic2xUYNbthrRdElpYMQyMZpiakxA.jpeg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们只看首次取出操作，那么需要注意一点， <strong>如何判断哪一次取出操作后 QueueA 为空？</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事实上作为 <code>Queue</code> 作为容器，我们可以<strong>通过事先定义好的方法 <code>queue.size()</code> 去判断一个队列中元素的个数</strong>，有人可能说这是犯规，其实不是的。题目中给出是让你用队列去实现，那么<strong>队列中公共 <code>API</code>都是你可以用的</strong>。所以可以想象出下面的伪代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果 queueA 的大小不为 0 则循环取出元素</span></span><br><span class="line"><span class="keyword">while</span>(queueA.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//被取出的元素</span></span><br><span class="line">    <span class="keyword">int</span> result = queueA.poll();</span><br><span class="line">    <span class="comment">// 这里注意我们取出元素后再去判断一次，队列是否为空，如果为空代表是最后一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(queueA.size() != <span class="number">0</span>)&#123;</span><br><span class="line">        queueB.add(result)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上文我们只是说了一次取出操作，那么一次取出操作后，再次放入元素应该怎么放，我们似乎又遇到了困难。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与上题不同的是，我们应该先思考如果连续两次取出应该怎么操作，上面一次取出后 <code>QueueA</code> 空了，所以我们如果按照相同的思路将 B 中的元素倒入 A 中，那么将会得到 3 ，这看起来没什么问题。那么如果下一步进行的 <code>push</code> 操作，那么应该放入 <code>QueueA</code> 还是 <code>QueueB</code> 中才能保证元素先进后出的规则呢，很容易想到是放入 B 中。 那么总结一下操作要点：</p>
<ol>
<li><strong>任何时候两个队列总有一个是空的。</strong></li>
<li><strong>添加元素总是向非空队列中 add 元素。</strong></li>
<li><strong>取出元素的时候总是将元素除队尾最后一个元素外，导入另一空队列中，最后一个元素出队。</strong></li>
</ol>
<p>接上图我们开看第一次取出操作后可能的两种操作情况：</p>
<p><img src="//blog.com/2019/06/17/算法之美-栈和队列/zKFJDM5V3WwkXYNnmwYGPbayIQEowS1WyCg0gxke8rl9vG0KImujBdjiaPClp0KiaTzhRGfyZG3tl9NFsRXC1IBw.jpeg" alt="img"></p>
<p>思路缕清楚了，那么时候写代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoQueueStack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Queue&lt;E&gt; queueA;</span><br><span class="line">   <span class="keyword">private</span> Queue&lt;E&gt; queueB;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">TwoQueueStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       queueA = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       queueB = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 选一个非空的队列入队</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (queueA.size() != <span class="number">0</span>) &#123;</span><br><span class="line">           System.out.println(<span class="string">"从 queueA 入队 "</span> + e);</span><br><span class="line">           queueA.add(e);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (queueB.size() != <span class="number">0</span>) &#123;</span><br><span class="line">           System.out.println(<span class="string">"从 queueB 入队 "</span> + e);</span><br><span class="line">           queueB.add(e);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">"从 queueA 入队 "</span> + e);</span><br><span class="line">           queueA.add(e);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> e;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (queueA.size() == <span class="number">0</span> &amp;&amp; queueB.size() == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       E result = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (queueA.size() != <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">while</span> (queueA.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               result = queueA.poll();</span><br><span class="line">               <span class="keyword">if</span> (queueA.size() != <span class="number">0</span>) &#123;</span><br><span class="line">                   System.out.println(<span class="string">"从 queueA 出队 并 queueB 入队 "</span> + result);</span><br><span class="line">                   queueB.add(result);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">"从 queueA 出队 "</span> + result);</span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">while</span> (queueB.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               result = queueB.poll();</span><br><span class="line">               <span class="keyword">if</span> (queueB.size() != <span class="number">0</span>) &#123;</span><br><span class="line">                   System.out.println(<span class="string">"从 queueB 出队 并 queueA 入队 "</span> + result);</span><br><span class="line">                   queueA.add(result);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           System.out.println(<span class="string">"从 queueB 出队"</span> + result);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了方便大家理解我将文章进行下测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       TwoQueueStack&lt;Integer&gt; queueStack = <span class="keyword">new</span> TwoQueueStack&lt;&gt;();</span><br><span class="line">       queueStack.push(<span class="number">1</span>);</span><br><span class="line">       queueStack.push(<span class="number">2</span>);</span><br><span class="line">       queueStack.push(<span class="number">3</span>);</span><br><span class="line">       queueStack.push(<span class="number">4</span>);</span><br><span class="line">       queueStack.pop();</span><br><span class="line">       queueStack.pop();</span><br><span class="line">       queueStack.push(<span class="number">5</span>);</span><br><span class="line">       queueStack.pop();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>结果为下面所示,看上去我们的代码是对的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">从 queueA 入队 1</span><br><span class="line">从 queueA 入队 2</span><br><span class="line">从 queueA 入队 3</span><br><span class="line">从 queueA 入队 4</span><br><span class="line">从 queueA 出队 并 queueB 入队 1</span><br><span class="line">从 queueA 出队 并 queueB 入队 2</span><br><span class="line">从 queueA 出队 并 queueB 入队 3</span><br><span class="line">从 queueA 出队 4</span><br><span class="line">从 queueB 出队 并 queueA 入队 1</span><br><span class="line">从 queueB 出队 并 queueA 入队 2</span><br><span class="line">从 queueB 出队3</span><br><span class="line">从 queueA 入队 5</span><br><span class="line">从 queueA 出队 并 queueB 入队 1</span><br><span class="line">从 queueA 出队 并 queueB 入队 2</span><br><span class="line">从 queueA 出队 5</span><br></pre></td></tr></table></figure>
<p>附C++ 代码实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">TQueueStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; node)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;T&gt; queueA;</span><br><span class="line">    <span class="built_in">queue</span>&lt;T&gt; queueB;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> TQueueStack&lt;T&gt;::push(<span class="keyword">const</span> T&amp; node)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入到非空队列，如果均为空则插入到queueB中</span></span><br><span class="line">    <span class="keyword">if</span> (queueA.size() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        queueB.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        queueA.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T TQueueStack&lt;T&gt;::pop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (queueA.size() == <span class="number">0</span> &amp;&amp; queueB.size() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    T head;</span><br><span class="line">    <span class="keyword">if</span> (queueA.size() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (queueA.size()&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//queueA中的元素依次删除，并插入到queueB中，其中queueA删除最后一个元素</span></span><br><span class="line">            <span class="comment">//相当于从栈中弹出队尾元素</span></span><br><span class="line">            T&amp; data = queueA.front();</span><br><span class="line">            queueA.pop();</span><br><span class="line">            queueB.push(data);</span><br><span class="line">        &#125;</span><br><span class="line">        head = queueA.front();</span><br><span class="line">        queueA.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (queueB.size()&gt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//queueB 中的元素依次删除，并插入到 queueA 中，其中 queueB 删除最后一个元素</span></span><br><span class="line">            <span class="comment">//相当于从栈中弹出队尾元素</span></span><br><span class="line"></span><br><span class="line">            T&amp; data = queueB.front();</span><br><span class="line">            queueB.pop();</span><br><span class="line">            queueA.push(data);</span><br><span class="line">        &#125;</span><br><span class="line">        head = queueB.front();</span><br><span class="line">        queueB.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="判断出栈顺序是否符合要求（✭✭✭✩✩）"><a href="#判断出栈顺序是否符合要求（✭✭✭✩✩）" class="headerlink" title="判断出栈顺序是否符合要求（✭✭✭✩✩）"></a>判断出栈顺序是否符合要求（✭✭✭✩✩）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经历了上两道题，大家是不是感觉对栈和队列更反感，哦不对是更了解了呢。（额~ 一不小心把实话说&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;出来了）。下面我们来看第二道题这是一个有关于出栈顺序的判断的题目:</p>
<blockquote>
<p>题目: 输入两个整数数组，第一个表示一个栈的压入序列，请写一个函数，判断第二个数组是否为该栈的出栈序列，假设数组中的所有数字均不相等。例如序列 <strong>1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列</strong>。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到这道题我们首先应该去理解题目中的怎么去判断是否符合出栈顺序，其实题目想要表达的意思是如果以数组 A 的方式进栈但并不是一次全部进栈，比如我们<strong>先进栈1，2，3，4 然后出栈 4，然后进栈 5，然后在出栈 5，3，2，1</strong>。 那么什么情况下是不可能满足的出栈顺序呢？比如 1，肯定是比 2 先进栈的，所以 2肯定比 1先出栈。所以解题的关键就在于，<strong>如何判断数组2 中的元素，是按数组1 中某种进栈顺序操作的出栈序列</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;思路是如果我们在进栈的同时维护一个出栈角标，如果栈顶元素等于 <code>popA[popIndex]</code> 的时候，将角标加一，并出栈该元素，并继续判断下一个栈顶元素，<strong>如果栈顶元素不等于 <code>popA[popIndex]</code> 的时候继续入栈元素，直到所有元素入栈完毕如果，栈不为空则表示 <code>popA</code>不是一个出栈序列</strong>。通过下图可以更好的理解题目要考察的内容：</p>
<p><img src="//blog.com/2019/06/17/算法之美-栈和队列/zKFJDM5V3WwkXYNnmwYGPbayIQEowS1WMZnwibjFIFajILlPODxgX4IR8l0ticiaxCOqT8YCBFYaNBkT79MdCcHnA.jpeg" alt="img"></p>
<p>所以在编程的只需要注意一下三点：</p>
<ol>
<li><strong>执行放入操作后，如果栈顶的元素等于对应角标在 popA 数组中的元素值，那么就需要出栈该元素，同时角标加1</strong></li>
<li><strong>如果栈顶的元素不等于对应角标在 popA 数组中的元素值，那么就执行放入操作</strong>。</li>
<li><strong>待所有的元素都被放入栈中，此时如果栈为空，那么 popA 就是一个出栈序列，反之则不是。</strong></li>
</ol>
<p>下面看代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span>[] pushA, <span class="keyword">int</span>[] popA)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len = pushA.length;</span><br><span class="line"></span><br><span class="line">       Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> pushIndex = <span class="number">0</span>, popIndex = <span class="number">0</span>; pushIndex &lt; len; pushIndex++) &#123;</span><br><span class="line">           stack.push(pushA[pushIndex]);</span><br><span class="line">           <span class="comment">//如果栈顶元素等于 popA[popIndex] 则一直出栈且 popIndex++</span></span><br><span class="line">           <span class="keyword">while</span> (popIndex &lt; popA.length &amp;&amp; popA[popIndex] == stack.peek()) &#123;</span><br><span class="line">               stack.pop();</span><br><span class="line">               popIndex++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushA, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushA() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,j = <span class="number">0</span> ;i &lt; pushA.size();)&#123;</span><br><span class="line">            <span class="built_in">stack</span>.push_back(pushA[i++]);</span><br><span class="line">            <span class="keyword">while</span>(j &lt; popA.size() &amp;&amp; <span class="built_in">stack</span>.back() == popA[j])&#123;</span><br><span class="line">                <span class="built_in">stack</span>.pop_back();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">   <span class="keyword">int</span>[] pushA = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span>[] popA1 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span>[] popA2 = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">   System.out.println(<span class="string">"popA1 是否是出栈队列 "</span> + solution.IsPopOrder(pushA, popA1));</span><br><span class="line">   System.out.println(<span class="string">"popA2 是否是出栈队列 "</span> + solution.IsPopOrder(pushA, popA2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line"><span class="comment">//popA1 是否是出栈队列 false</span></span><br><span class="line"><span class="comment">//popA2 是否是出栈队列 true</span></span><br></pre></td></tr></table></figure>
<p>初始状态如下：</p>
<p><strong><img src="//blog.com/2019/06/17/算法之美-栈和队列/wKioL1cDyRLi8XHmAAAZr1lwySE538.jpg" alt="wKioL1cDyRLi8XHmAAAZr1lwySE538.jpg"></strong></p>
<p>步骤1：把 1 进行压栈，并将下标后移，如下图所示，</p>
<p><strong><img src="//blog.com/2019/06/17/算法之美-栈和队列/wKiom1cDylKBp0UVAAAZXJdSkEc733.jpg" alt="wKiom1cDylKBp0UVAAAZXJdSkEc733.jpg"></strong></p>
<p>步骤2：依次进行判断并压栈，当4进栈后，此时栈顶元素等于出栈数组下标所指向的元素，将4出栈，如下图所示</p>
<p><strong><img src="//blog.com/2019/06/17/算法之美-栈和队列/wKiom1cDyyqjn0KRAAAcrb47EtM216.jpg" alt="wKiom1cDyyqjn0KRAAAcrb47EtM216.jpg"></strong></p>
<p>步骤3：将 4 出栈，并将出栈数组的下标后移，继续判断栈顶元素是否为当前出栈数组下标对应的元素，是，则出栈，否则继续往后执行</p>
<p><strong><img src="//blog.com/2019/06/17/算法之美-栈和队列/wKioL1cDzF3AM8AvAAAgxKZ3QV0572.jpg" alt="wKioL1cDzF3AM8AvAAAgxKZ3QV0572.jpg"></strong></p>
<p>步骤4：重复上述步骤，直到入栈数组中的下标走到尽头<img src="//blog.com/2019/06/17/算法之美-栈和队列/wKioL1cDzPqQWS4MAAAiFxItk1Q465.jpg" alt="wKioL1cDzPqQWS4MAAAiFxItk1Q465.jpg"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>当最后一个元素入栈后，此时只需循环判断栈顶元素是否与出栈数组当前下标对应的元素相等，如果该序列合法，则栈中的元素最终都会出栈，不合法则栈永远不为空 </strong>          【5匹配完成以后，此时stack栈顶元素是3，<code>popIndex=2</code>】</p>
<p><img src="//blog.com/2019/06/17/算法之美-栈和队列/wKiom1cDzayRidTnAAAjYyBAB20771.jpg" alt="wKiom1cDzayRidTnAAAjYyBAB20771.jpg"></p>
<p>此时，栈为空，则该序列合法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/17/用设计模式去掉没必要的状态变量 —— 状态模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/17/用设计模式去掉没必要的状态变量 —— 状态模式/" itemprop="url">用设计模式去掉没必要的状态变量 —— 状态模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-17T12:12:57+08:00">
                2019-06-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/代码规范与技巧/" itemprop="url" rel="index">
                    <span itemprop="name">代码规范与技巧</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/代码规范与技巧/代码技巧/" itemprop="url" rel="index">
                    <span itemprop="name">代码技巧</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/代码规范与技巧/代码技巧/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/代码规范与技巧/代码技巧/设计模式/状态模式/" itemprop="url" rel="index">
                    <span itemprop="name">状态模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="用设计模式去掉没必要的状态变量-——-状态模式"><a href="#用设计模式去掉没必要的状态变量-——-状态模式" class="headerlink" title="用设计模式去掉没必要的状态变量 —— 状态模式"></a>用设计模式去掉没必要的状态变量 —— 状态模式</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://juejin.im/post/5d004621f265da1bc37f0674" target="_blank" rel="noopener">https://juejin.im/post/5d004621f265da1bc37f0674</a></p>
</blockquote>
<p><br></p>
<h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是在<code>UI</code>开发中经常会遇到的场景：界面有两种状态，每一种状态下界面元素对应的操作都不同。比如在 <code>offline</code> 状态下点击大叉会直接退出应用，而在<code>login</code>状态下点击大叉会退出登录。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最简单直观的方案就是用<code>int</code>值来保存当前状态，根据<code>int</code>值不同会运行不同分支的操作。</p>
<h2 id="方案一：状态变量-if-else"><a href="#方案一：状态变量-if-else" class="headerlink" title="方案一：状态变量 + if-else"></a>方案一：状态变量 + if-else</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="comment">//'离线状态'</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_OFFLINE = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//'登陆状态'</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_LOGIN = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//'当前状态'</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentState = STATE_OFFLINE;</span><br><span class="line">    <span class="comment">//显示状态的控件</span></span><br><span class="line">    <span class="keyword">private</span> TextView tvState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//省略了设置布局文件和设置点击监听</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//'当按钮点击时执行的操作'</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentState == STATE_OFFLINE) &#123;</span><br><span class="line">            logIn();</span><br><span class="line">            setStateText(<span class="string">"login"</span>);</span><br><span class="line">            setState(STATE_LOGIN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//'当大叉被点击时执行的操作'</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCloseClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentState == STATE_OFFLINE) &#123;</span><br><span class="line">            finish();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentState == STATE_LOGIN) &#123;</span><br><span class="line">            logOut();</span><br><span class="line">            setStateText(<span class="string">"offline"</span>);</span><br><span class="line">            setState(STATE_OFFLINE);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStateText</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        tvState.setText(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//'设置当前状态'</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单直观，状态变量配合 <code>if-else</code> 就能实现需求。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>新需要来了，新增群组功能，当登陆成功后，再次点击登陆按钮就能加入群组</strong>。<strong>在群组时点击大叉会退出群组</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新需求增加了一种状态，界面上的两个操作按钮也因此增加了两种新的操作。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小场面，只需要新增<code>if-else</code> 就能搞定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity2</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_OFFLINE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_LOGIN = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//'新增群组状态'</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATE_IN_GROUP = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentState = STATE_OFFLINE;</span><br><span class="line">    <span class="keyword">private</span> TextView tvState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentState == STATE_OFFLINE) &#123;</span><br><span class="line">            logIn();</span><br><span class="line">            setStateText(<span class="string">"login"</span>);</span><br><span class="line">            setState(STATE_LOGIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//'按钮新增对群组状态的响应代码'</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (currentState == STATE_LOGIN) &#123;</span><br><span class="line">            joinGroup();</span><br><span class="line">            setStateText(<span class="string">"in group"</span>);</span><br><span class="line">            setState(STATE_IN_GROUP);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCloseClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentState == STATE_OFFLINE) &#123;</span><br><span class="line">            finish();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentState == STATE_LOGIN) &#123;</span><br><span class="line">            logOut();</span><br><span class="line">            setStateText(<span class="string">"offline"</span>);</span><br><span class="line">            setState(STATE_OFFLINE);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//'大叉新增对群组状态的响应代码'</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (currentState == STATE_IN_GROUP) &#123;</span><br><span class="line">            quitGroup();</span><br><span class="line">            tvState.setText(<span class="string">"login"</span>);</span><br><span class="line">            setState(STATE_LOGIN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前看起来还不是太糟，但随着状态的增加，<code>if-else</code> 分支就会原来越多，代码可读性会持续下降。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更关键的是这<strong>不符合开闭原则，即当新增功能的时候不允许修改原有代码</strong>。而在<code>demo</code> 中新增状态的时候，不得不修改<code>onCloseClick()</code>和<code>onButtonClick</code>。<code>demo</code> 中的逻辑非常简单，这两个函数的调用者只有一个，分别是按钮和大叉。真实项目中调用者可能分布在各个角落，对于这种函数，你敢轻易改吗？一不小心就可能修改出<code>bug</code> 。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需求变更：在离线状态增加确认，即离线时点击按钮弹框确认是否需要登录，点击大叉弹框确认是否需要退出应用。如果使用上述方案，就需要全局搜索<code>STATE_OFFLINE</code>，找到所有访问它的地方，一个个的做修改（可能散布在 <code>n</code>个类中，增加了<code>n</code>个类出<code>bug</code>的可能性）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;吐槽完缺点后，看看<code>状态模式</code>是怎么解决问题的。</p>
<h2 id="方案二：状态模式"><a href="#方案二：状态模式" class="headerlink" title="方案二：状态模式"></a>方案二：状态模式</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个场景中，<strong>变化的是状态，增加一层抽象把变化封装起来是设计模式的惯用手段</strong>。看下如何把状态封装起来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCloseClick</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onButtonClick</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>新增一层抽象，这层抽象的实例表示一个具体的状态，抽象中的方法表示该状态可以执行的操作</strong>。</p>
<p>现在有离线、登陆、进群组这三个状态，分别对应着三个<code>State</code>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//'离线状态'</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OfflineState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MainActivity mainActivity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OfflineState</span><span class="params">(MainActivity mainActivity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainActivity = mainActivity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCloseClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mainActivity.finish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mainActivity.logIn();</span><br><span class="line">        mainActivity.setState(mainActivity.getLoginState());</span><br><span class="line">        mainActivity.setStateText(<span class="string">"login"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//'登陆状态'</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MainActivity mainActivity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginState</span><span class="params">(MainActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainActivity = activity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCloseClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mainActivity.logOut();</span><br><span class="line">        mainActivity.setState(mainActivity.getOfflineState());</span><br><span class="line">        mainActivity.setStateText(<span class="string">"offline"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mainActivity.joinGroup();</span><br><span class="line">        mainActivity.setState(mainActivity.getInGroupState());</span><br><span class="line">        mainActivity.setStateText(<span class="string">"in group"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//'进群组状态'</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InGroupState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MainActivity mainActivity;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InGroupState</span><span class="params">(MainActivity mainActivity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainActivity = mainActivity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCloseClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mainActivity.quitGroup();</span><br><span class="line">        mainActivity.setState(mainActivity.getLoginState());</span><br><span class="line">        mainActivity.setStateText(<span class="string">"login"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonClick</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>MainActivity</code>页面持有各个状态的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="comment">//'离线状态实例'</span></span><br><span class="line">    <span class="keyword">private</span> State offlineState;</span><br><span class="line">    <span class="comment">//'登陆状态实例'</span></span><br><span class="line">    <span class="keyword">private</span> State loginState;</span><br><span class="line">    <span class="comment">//'进群组状态实例'</span></span><br><span class="line">    <span class="keyword">private</span> State inGroupState;</span><br><span class="line">    <span class="comment">//'当前状态'</span></span><br><span class="line">    <span class="keyword">private</span> State currentState;</span><br><span class="line">    <span class="keyword">private</span> TextView tvState;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">//省略了布局和设置监听器</span></span><br><span class="line">        initState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//'初始化状态'</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        offlineState = <span class="keyword">new</span> OfflineState(<span class="keyword">this</span>);</span><br><span class="line">        loginState = <span class="keyword">new</span> LoginState(<span class="keyword">this</span>);</span><br><span class="line">        inGroupState = <span class="keyword">new</span> InGroupState(<span class="keyword">this</span>);</span><br><span class="line">        setStateText(<span class="string">"offline"</span>);</span><br><span class="line">        setState(offlineState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//'将点击按钮操作委托给当前状态'</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState.onButtonClick();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//'将点击大叉操作委托给当前状态'</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCloseClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState.onCloseClick();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//'变更当前状态'</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//'获取指定状态'</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getOfflineState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> offlineState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getLoginState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loginState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getInGroupState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inGroupState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStateText</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        tvState.setText(state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方案的有趣之处在于：<strong>将“在每个方法内处理不同状态” 转变成 “在同一个状态类内部实现所有方法”</strong>。怎么听上去有种换汤不换药的感觉？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实不然，<strong>状态模式在新增状态时，让原本的每一个状态“对修改关闭”</strong>，让<code>MainActivity</code>“对扩展开放”（因为新增状态不要修改<code>onCloseClick()</code>和<code>onButtonClick()</code>）</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;又是一个“把变的东西封装起来，用多态来应对变化”的设计模式。</p>
<h2 id="状态模式-vs-策略模式"><a href="#状态模式-vs-策略模式" class="headerlink" title="状态模式 vs 策略模式"></a>状态模式 vs 策略模式</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分析设计模式总是逃不掉相互比较，因为有几个长的真的很像。策略模式的详细讲解和应用可以分别移步<a href="https://juejin.im/post/5ccf031ee51d456e2a64b35d" target="_blank" rel="noopener">这里</a>和<a href="https://juejin.im/post/5ce0e55ae51d451075366eeb" target="_blank" rel="noopener">这里</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它们俩的实现方式和目的可以说几乎相同，都是通过接口定义行为，通过组合持有行为实例，通过多态动态地替换行为。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但它们的适用场景略有区别：<strong>策略模式是在外部定义了一个行为，并由外部发起一次性的行为替换，而状态模式在内部定义了多个行为，并由内部原因持续地发生行为替换</strong>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/39/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/39/">39</a><span class="page-number current">40</span><a class="page-number" href="/page/41/">41</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/41/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
