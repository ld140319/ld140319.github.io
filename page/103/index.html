<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/page/103/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/page/103/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/04/07/OAuth 2.0 的一个简单解释/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/07/OAuth 2.0 的一个简单解释/" itemprop="url">OAuth 2.0 的一个简单解释</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-07T12:12:57+08:00">
                2019-04-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/用户身份验证/" itemprop="url" rel="index">
                    <span itemprop="name">用户身份验证</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/用户身份验证/token认证/" itemprop="url" rel="index">
                    <span itemprop="name">token认证</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/用户身份验证/token认证/OAuth-2-0/" itemprop="url" rel="index">
                    <span itemprop="name">OAuth 2.0</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="OAuth-2-0-的一个简单解释"><a href="#OAuth-2-0-的一个简单解释" class="headerlink" title="OAuth 2.0 的一个简单解释"></a>OAuth 2.0 的一个简单解释</h1><blockquote>
<p>原文地址：<a href="http://www.ruanyifeng.com/blog/2019/04/oauth_design.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/04/oauth_design.html</a></p>
</blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">OAuth 2.0</a> 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。</p>
<p>这个标准比较抽象，使用了很多术语，初学者不容易理解。其实说起来并不复杂，下面我就通过一个简单的类比，帮助大家轻松理解，OAuth 2.0 到底是什么。</p>
<h2 id="一、快递员问题"><a href="#一、快递员问题" class="headerlink" title="一、快递员问题"></a>一、快递员问题</h2><p>我住在一个大型的居民小区。</p>
<p><img src="//blog.com/2019/04/07/OAuth 2.0 的一个简单解释/bg2019040401.jpg" alt="img"></p>
<p>小区有门禁系统。</p>
<p><img src="//blog.com/2019/04/07/OAuth 2.0 的一个简单解释/bg2019040402.jpg" alt="img"></p>
<p>进入的时候需要输入密码。</p>
<p><img src="//blog.com/2019/04/07/OAuth 2.0 的一个简单解释/bg2019040403.jpg" alt="img"></p>
<p>我经常网购和外卖，每天都有快递员来送货。我必须找到一个办法，让快递员通过门禁系统，进入小区。</p>
<p><img src="//blog.com/2019/04/07/OAuth 2.0 的一个简单解释/bg2019040404.jpg" alt="img"></p>
<p>如果我把自己的密码，告诉快递员，他就拥有了与我同样的权限，这样好像不太合适。万一我想取消他进入小区的权力，也很麻烦，我自己的密码也得跟着改了，还得通知其他的快递员。</p>
<p>有没有一种办法，让快递员能够自由进入小区，又不必知道小区居民的密码，而且他的唯一权限就是送货，其他需要密码的场合，他都没有权限？</p>
<h2 id="二、授权机制的设计"><a href="#二、授权机制的设计" class="headerlink" title="二、授权机制的设计"></a>二、授权机制的设计</h2><p>于是，我设计了一套授权机制。</p>
<p>第一步，门禁系统的密码输入器下面，增加一个按钮，叫做”获取授权”。快递员需要首先按这个按钮，去申请授权。</p>
<p>第二步，他按下按钮以后，屋主（也就是我）的手机就会跳出对话框：有人正在要求授权。系统还会显示该快递员的姓名、工号和所属的快递公司。</p>
<p>我确认请求属实，就点击按钮，告诉门禁系统，我同意给予他进入小区的授权。</p>
<p>第三步，门禁系统得到我的确认以后，向快递员显示一个进入小区的令牌（access token）。令牌就是类似密码的一串数字，只在短期内（比如七天）有效。</p>
<p>第四步，快递员向门禁系统输入令牌，进入小区。</p>
<p>有人可能会问，为什么不是远程为快递员开门，而要为他单独生成一个令牌？这是因为快递员可能每天都会来送货，第二天他还可以复用这个令牌。另外，有的小区有多重门禁，快递员可以使用同一个令牌通过它们。</p>
<h2 id="三、互联网场景"><a href="#三、互联网场景" class="headerlink" title="三、互联网场景"></a>三、互联网场景</h2><p>我们把上面的例子搬到互联网，就是 OAuth 的设计了。</p>
<p>首先，居民小区就是储存用户数据的网络服务。比如，微信储存了我的好友信息，获取这些信息，就必须经过微信的”门禁系统”。</p>
<p>其次，快递员（或者说快递公司）就是第三方应用，想要穿过门禁系统，进入小区。</p>
<p>最后，我就是用户本人，同意授权第三方应用进入小区，获取我的数据。</p>
<p><strong>简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</strong></p>
<h2 id="四、令牌与密码"><a href="#四、令牌与密码" class="headerlink" title="四、令牌与密码"></a>四、令牌与密码</h2><p>令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。</p>
<p>（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</p>
<p>（2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</p>
<p>（3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</p>
<p>上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。</p>
<p>注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以<strong>令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。</strong>这也是为什么令牌的有效期，一般都设置得很短的原因。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/04/04/理解高性能网络模型/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/04/理解高性能网络模型/" itemprop="url">理解高性能网络模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-04T12:12:57+08:00">
                2019-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/" itemprop="url" rel="index">
                    <span itemprop="name">异步与同步</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/" itemprop="url" rel="index">
                    <span itemprop="name">IO</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/" itemprop="url" rel="index">
                    <span itemprop="name">Reactor</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/事件模型/" itemprop="url" rel="index">
                    <span itemprop="name">事件模型</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/异步与同步/IO/Reactor/事件模型/网络编程/" itemprop="url" rel="index">
                    <span itemprop="name">网络编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="理解高性能网络模型"><a href="#理解高性能网络模型" class="headerlink" title="理解高性能网络模型"></a>理解高性能网络模型</h1><h1 id="1-服务端处理网络请求"><a href="#1-服务端处理网络请求" class="headerlink" title="1 服务端处理网络请求"></a>1 服务端处理网络请求</h1><p>首先看看服务端处理网络请求的典型过程：</p>
<p><img src="//blog.com/2019/04/04/理解高性能网络模型/165a72396ad36eda.png" alt="服务端处理网络请求流程图"></p>
<p>可以看到，主要处理步骤包括：</p>
<ul>
<li>1、获取请求数据 客户端与服务器建立连接发出请求，服务器接受请求（1-3）</li>
<li>2、构建响应 当服务器接收完请求，并在用户空间处理客户端的请求，直到构建响应完成（4）</li>
<li>3、返回数据 服务器将已构建好的响应再通过内核空间的网络I/O发还给客户端（5-7）</li>
</ul>
<p>设计服务端并发模型时，主要有如下两个关键点：</p>
<ul>
<li>服务器如何管理连接，获取输入数据</li>
<li>服务器如何处理请求</li>
</ul>
<p>以上两个关键点最终都与操作系统的I/O模型以及线程(进程)模型相关，下面详细介绍这两个模型</p>
<h1 id="2-I-O模型"><a href="#2-I-O模型" class="headerlink" title="2 I/O模型"></a>2 I/O模型</h1><h1 id="2-1-概念理论"><a href="#2-1-概念理论" class="headerlink" title="2.1 概念理论"></a>2.1 概念理论</h1><p>介绍操作系统的I/O模型之前，先了解一下几个概念：</p>
<ul>
<li>阻塞调用与非阻塞调用 <ul>
<li><strong>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回</strong></li>
<li><strong>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程</strong></li>
</ul>
</li>
</ul>
<p><strong>两者的最大区别在于被调用方在收到请求到返回结果之前的这段时间内，调用方是否一直在等待</strong>。阻塞是指调用方一直在等待而且别的事情什么都不做。非阻塞是指调用方先去忙别的事情</p>
<ul>
<li>同步处理与异步处理<ul>
<li><strong>同步处理是指被调用方得到最终结果之后才返回给调用方</strong></li>
<li><strong>异步处理是指被调用方先返回应答，然后再计算调用结果，计算完最终结果后再通知并返回给调用方</strong></li>
</ul>
</li>
<li>阻塞、非阻塞和同步、异步的区别 阻塞、非阻塞和同步、异步其实针对的对象是不一样的： <strong>阻塞、非阻塞的讨论对象是调用者</strong> <strong>同步、异步的讨论对象是被调用者</strong></li>
<li>recvfrom函数 recvfrom函数(经socket接收数据)，这里把它视为系统调用</li>
</ul>
<p>一个输入操作通常包括两个不同的阶段</p>
<ul>
<li>等待数据准备好</li>
<li>从内核向进程复制数据</li>
</ul>
<p><strong>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区</strong></p>
<p>实际应用程序在系统调用完成上面2步操作时，调用方式的阻塞、非阻塞，操作系统在处理应用程序请求时处理方式的同步、异步处理的不同，参考<strong>《UNIX网络编程卷1》</strong>，可以分为5种I/O模型</p>
<h2 id="2-2-阻塞式I-O模型-blocking-I-O）"><a href="#2-2-阻塞式I-O模型-blocking-I-O）" class="headerlink" title="2.2 阻塞式I/O模型(blocking I/O）"></a>2.2 阻塞式I/O模型(blocking I/O）</h2><p><img src="//blog.com/2019/04/04/理解高性能网络模型/165a72396a811072.png" alt="阻塞式I/O模型"></p>
<p><strong>简介</strong> :</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在阻塞式I/O模型中，<strong>应用程序在从调用recvfrom开始到它返回有数据报准备好这段时间是阻塞的</strong>，recvfrom返回成功后，应用进程开始处理数据报</p>
<p><strong>比喻</strong>：</p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个人在钓鱼，当没鱼上钩时，就坐在岸边一直等</p>
<p><strong>优点</strong> ：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序简单，<strong>在阻塞等待数据期间进程/线程挂起，基本不会占用CPU资源</strong></p>
<p><strong>缺点</strong> ：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>每个连接需要独立的进程/线程单独处理，当并发请求量大时为了维护程序，内存、线程切换开销较大</strong>，这种模型在实际生产中很少使用</p>
<h2 id="2-3-非阻塞式I-O模型-non-blocking-I-O）"><a href="#2-3-非阻塞式I-O模型-non-blocking-I-O）" class="headerlink" title="2.3 非阻塞式I/O模型(non-blocking I/O）"></a>2.3 非阻塞式I/O模型(non-blocking I/O）</h2><p><img src="//blog.com/2019/04/04/理解高性能网络模型/165a72396af89a4a.png" alt="非阻塞式I/O模型"></p>
<p><strong>简介</strong> ：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在非阻塞式I/O模型中，应用程序把一个套接口设置为非阻塞就是告诉内核，<strong>当所请求的I/O操作无法完成时，不要将进程睡眠，而是返回一个错误</strong>，应用程序基于I/O操作函数将不断的轮询数据是否已经准备好，如果没有准备好，<strong>继续轮询，直到数据准备好为止</strong></p>
<p><strong>比喻</strong> ：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;边钓鱼边玩手机，隔会再看看有没有鱼上钩，有的话就迅速拉杆</p>
<p><strong>优点</strong> ：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不会阻塞在内核的等待数据过程，每次发起的I/O请求可以立即返回，<strong>不用阻塞等待</strong>，实时性较好</p>
<p><strong>缺点</strong>：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>轮询将会不断地询问内核，这将占用大量的CPU时间，系统资源利用率较低</strong>，所以一般Web服务器不使用这种I/O模型</p>
<h2 id="2-4-I-O复用模型-I-O-multiplexing）"><a href="#2-4-I-O复用模型-I-O-multiplexing）" class="headerlink" title="2.4 I/O复用模型(I/O multiplexing）"></a>2.4 I/O复用模型(I/O multiplexing）</h2><p><img src="//blog.com/2019/04/04/理解高性能网络模型/165a72396cc78d98.png" alt="I/O复用模型"></p>
<p><strong>简介</strong> ：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在I/O复用模型中，会用到select或poll函数或epoll函数(Linux2.6以后的内核开始支持)，这两个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以<strong>同时阻塞多个I/O操作，而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数</strong></p>
<p><strong>比喻</strong> ：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;放了一堆鱼竿，在岸边一直守着这堆鱼竿，直到有鱼上钩</p>
<p><strong>优点</strong>：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 可以基于一个阻塞对象，同时在多个描述符上等待就绪，而<strong>不是使用多个线程(每个文件描述符一个线程)，这样可以大大节省系统资源</strong></p>
<p><strong>缺点</strong> ：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当连接数较少时效率相比多线程+阻塞I/O模型效率较低，可能延迟更大，因为<strong>单个连接处理需要2次系统调用，占用时间会有增加</strong></p>
<h2 id="2-5-信号驱动式I-O模型（signal-driven-I-O"><a href="#2-5-信号驱动式I-O模型（signal-driven-I-O" class="headerlink" title="2.5 信号驱动式I/O模型（signal-driven I/O)"></a>2.5 信号驱动式I/O模型（signal-driven I/O)</h2><p><img src="//blog.com/2019/04/04/理解高性能网络模型/165a72396ceccf52.png" alt="信号驱动式I/O模型"></p>
<p><strong>简介</strong>：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在信号驱动式I/O模型中，<strong>应用程序使用套接口进行信号驱动I/O，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据</strong></p>
<p><strong>比喻</strong> ：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;鱼竿上系了个铃铛，当铃铛响，就知道鱼上钩，然后可以专心玩手机</p>
<p><strong>优点</strong> ：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线程并没有在等待数据时被阻塞，可以提高资源的利用率</p>
<p><strong>缺点</strong></p>
<ul>
<li>信号I/O在大量IO操作时可能会因为信号队列溢出导致没法通知</li>
<li>信号驱动I/O尽管对于处理UDP套接字来说有用，即这种信号通知意味着到达一个数据报，或者返回一个异步错误。但是，对于TCP而言，信号驱动的I/O方式近乎无用，因为导致这种通知的条件为数众多，每一个来进行判别会消耗很大资源，与前几种方式相比优势尽失</li>
</ul>
<h2 id="2-6-异步I-O模型（asynchronous-I-O）"><a href="#2-6-异步I-O模型（asynchronous-I-O）" class="headerlink" title="2.6 异步I/O模型（asynchronous I/O）"></a>2.6 异步I/O模型（asynchronous I/O）</h2><p><img src="//blog.com/2019/04/04/理解高性能网络模型/165a723ae253818f.png" alt="异步I/O模型"></p>
<p><strong>简介</strong> ：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由POSIX规范定义，应用程序告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到应用程序的缓冲区）完成后通知应用程序。这种模型与信号驱动模型的主要区别在于：<strong>信号驱动I/O是由内核通知应用程序何时启动一个I/O操作，而异步I/O模型是由内核通知应用程序I/O操作何时完成</strong></p>
<p><strong>优点</strong> ：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;异步 I/O 能够充分利用 DMA 特性，让 I/O 操作与计算重叠</p>
<p><strong>缺点</strong>：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 要实现真正的异步 I/O，操作系统需要做大量的工作。目前 Windows 下通过 IOCP 实现了真正的异步 I/O，而在 Linux 系统下，Linux2.6才引入，目前 AIO 并不完善，因此在 Linux 下实现高并发网络编程时都是以 IO复用模型模式为主</p>
<h2 id="2-5-5种I-O模型总结"><a href="#2-5-5种I-O模型总结" class="headerlink" title="2.5 5种I/O模型总结"></a>2.5 5种I/O模型总结</h2><p><img src="//blog.com/2019/04/04/理解高性能网络模型/165a723ae2b8fb2a.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上图中我们可以看出，可以看出，越往后，阻塞越少，理论上效率也是最优。其五种I/O模型中，前四种属于同步I/O，因为其中真正的I/O操作(recvfrom)将阻塞进程/线程，只有异步I/O模型才于POSIX定义的异步I/O相匹配</p>
<h1 id="3-线程模型"><a href="#3-线程模型" class="headerlink" title="3 线程模型"></a>3 线程模型</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;介绍完服务器如何基于I/O模型管理连接，获取输入数据，下面介绍基于进程/线程模型，服务器如何处理请求</p>
<p>值得说明的是，具体选择线程还是进程，更多是与平台及编程语言相关，例如C语言使用线程和进程都可以(例如Nginx使用进程，Memcached使用线程)，Java语言一般使用线程(例如Netty)，为了描述方便，下面都使用线程来进程描述</p>
<h2 id="3-1-传统阻塞I-O服务模型"><a href="#3-1-传统阻塞I-O服务模型" class="headerlink" title="3.1 传统阻塞I/O服务模型"></a>3.1 传统阻塞I/O服务模型</h2><p><img src="//blog.com/2019/04/04/理解高性能网络模型/165a723ae480ba5f.png" alt="传统阻塞I/O服务模型"></p>
<p><strong>特点</strong></p>
<ul>
<li>采用阻塞式I/O模型获取输入数据</li>
<li>每个连接都需要独立的线程完成数据输入，业务处理，数据返回的完整操作</li>
</ul>
<p><strong>存在问题</strong></p>
<ul>
<li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大</li>
<li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在read操作上，造成线程资源浪费</li>
</ul>
<h2 id="3-2-Reactor模式"><a href="#3-2-Reactor模式" class="headerlink" title="3.2 Reactor模式"></a>3.2 Reactor模式</h2><p>针对传统传统阻塞I/O服务模型的2个缺点，比较常见的有如下解决方案：</p>
<ul>
<li><strong>基于I/O复用模型，多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接。当某条连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理</strong></li>
<li><strong>基于线程池复用线程资源，不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务</strong></li>
</ul>
<p><strong>I/O复用结合线程池，这就是Reactor模式基本设计思想</strong></p>
<p><img src="//blog.com/2019/04/04/理解高性能网络模型/165a723ae52f75de.png" alt="Reactor"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Reactor模式</strong>，是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。 <strong>服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor模式也叫Dispatcher模式，即I/O多了复用统一监听事件，收到事件后分发(Dispatch给某进程)</strong>，是编写高性能网络服务器的必备技术之一</p>
<p>Reactor模式中有2个关键组成：</p>
<ul>
<li><strong>Reactor Reactor在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应</strong>。 它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人</li>
<li><strong>Handlers 处理程序执行I/O事件要完成的实际事件</strong>，类似于客户想要与之交谈的公司中的实际官员。Reactor通过调度适当的处理程序来响应I/O事件，处理程序执行非阻塞操作</li>
</ul>
<p>根据Reactor的数量和处理资源池线程的数量不同，有3种典型的实现：</p>
<ul>
<li>单Reactor单线程</li>
<li>单Reactor多线程</li>
<li>主从Reactor多线程</li>
</ul>
<p>下面详细介绍这3种实现</p>
<h3 id="3-2-1-单Reactor单线程"><a href="#3-2-1-单Reactor单线程" class="headerlink" title="3.2.1 单Reactor单线程"></a>3.2.1 单Reactor单线程</h3><p><img src="//blog.com/2019/04/04/理解高性能网络模型/165a723ae57487c5.png" alt="单Reactor单线程"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中，select是前面<strong>I/O复用模型</strong>介绍的标准网络编程API，可以实现应用程序通过一个阻塞对象监听多路连接请求，其他方案示意图类似</p>
<p><strong>方案说明</strong></p>
<ul>
<li>Reactor对象通过select监控客户端请求事件，收到事件后通过dispatch进行分发</li>
<li>如果是建立连接请求事件，则由Acceptor通过accept处理连接请求，然后创建一个Handler对象处理连接完成后的后续业务处理</li>
<li>如果不是建立连接事件，则Reactor会分发调用连接对应的Handler来响应</li>
<li>Handler会完成read-&gt;业务处理-&gt;send的完整业务流程</li>
</ul>
<p><strong>优点</strong> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</p>
<p><strong>缺点</strong></p>
<ul>
<li>性能问题：只有一个线程，无法完全发挥多核CPU的性能 Handler在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li>
<li>可靠性问题：线程意外跑飞，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li>
</ul>
<p><strong>使用场景</strong> ：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端的数量有限，业务处理非常快速，比如Redis，业务处理的时间复杂度O(1)</p>
<h3 id="3-2-2-单Reactor多线程"><a href="#3-2-2-单Reactor多线程" class="headerlink" title="3.2.2 单Reactor多线程"></a>3.2.2 单Reactor多线程</h3><p><img src="//blog.com/2019/04/04/理解高性能网络模型/165a723ae74362df.png" alt="单Reactor多线程"></p>
<p><strong>方案说明</strong>：</p>
<ul>
<li>Reactor对象通过select监控客户端请求事件，收到事件后通过dispatch进行分发</li>
<li>如果是建立连接请求事件，则由Acceptor通过accept处理连接请求，然后创建一个Handler对象处理连接完成后的续各种事件</li>
<li>如果不是建立连接事件，则Reactor会分发调用连接对应的Handler来响应</li>
<li>Handler只负责响应事件，不做具体业务处理，通过read读取数据后，会分发给后面的Worker线程池进行业务处理</li>
<li>Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理</li>
<li>Handler收到响应结果后通过send将响应结果返回给client</li>
</ul>
<p><strong>优点</strong> ：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以充分利用多核CPU的处理能力</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>多线程数据共享和访问比较复杂</li>
<li>Reactor承担所有事件的监听和响应，在单线程中运行，高并发场景下容易成为性能瓶颈</li>
</ul>
<h3 id="3-2-3-主从Reactor多线程"><a href="#3-2-3-主从Reactor多线程" class="headerlink" title="3.2.3 主从Reactor多线程"></a>3.2.3 主从Reactor多线程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对单Reactor多线程模型中，Reactor在单线程中运行，高并发场景下容易成为性能瓶颈，可以让Reactor在多线程中运行</p>
<p><img src="//blog.com/2019/04/04/理解高性能网络模型/165a723b8948bc3f.png" alt="主从Reactor多线程"></p>
<p><strong>方案说明</strong>：</p>
<ul>
<li>Reactor主线程MainReactor对象通过select监控建立连接事件，收到事件后通过Acceptor接收，处理建立连接事件</li>
<li>Accepto处理建立连接事件后，MainReactor将连接分配Reactor子线程给SubReactor进行处理</li>
<li>SubReactor将连接加入连接队列进行监听，并创建一个Handler用于处理各种连接事件</li>
<li>当有新的事件发生时，SubReactor会调用连接对应的Handler进行响应</li>
<li>Handler通过read读取数据后，会分发给后面的Worker线程池进行业务处理</li>
<li>Worker线程池会分配独立的线程完成真正的业务处理，如何将响应结果发给Handler进行处理</li>
<li>Handler收到响应结果后通过send将响应结果返回给client</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理</li>
<li>父线程与子线程的数据交互简单，Reactor主线程只需要把新连接传给子线程，子线程无需返回数据</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模型在许多项目中广泛使用，包括Nginx主从Reactor多进程模型，Memcached主从多线程，Netty主从多线程模型的支持</p>
<h3 id="3-2-4-总结"><a href="#3-2-4-总结" class="headerlink" title="3.2.4 总结"></a>3.2.4 总结</h3><p>3种模式可以用个比喻来理解： 餐厅常常雇佣接待员负责迎接顾客，当顾客入坐后，侍应生专门为这张桌子服务</p>
<ul>
<li>单Reactor单线程 接待员和侍应生是同一个人，全程为顾客服务</li>
<li>单Reactor多线程 1个接待员，多个侍应生，接待员只负责接待</li>
<li>主从Reactor多线程 多个接待员，多个侍应生</li>
</ul>
<p>Reactor模式具有如下的优点：</p>
<ul>
<li>响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的</li>
<li>编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；</li>
<li>可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源</li>
<li>可复用性，Reactor模型本身与具体事件处理逻辑无关，具有很高的复用性</li>
</ul>
<h2 id="3-3-Proactor模型"><a href="#3-3-Proactor模型" class="headerlink" title="3.3 Proactor模型"></a>3.3 Proactor模型</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Reactor模式中，Reactor等待某个事件或者可应用或个操作的状态发生（比如文件描述符可读写，或者是socket可读写），然后把这个事件传给事先注册的Handler（事件处理函数或者回调函数），由后者来做实际的读写操作，其中的读写操作都需要应用程序同步操作，所以Reactor是非阻塞同步网络模型。如果把I/O操作改为异步，即交给操作系统来完成就能进一步提升性能，这就是异步网络模型Proactor</p>
<p><img src="//blog.com/2019/04/04/理解高性能网络模型/165a723b8a22eb00.png" alt="Proactor"></p>
<p>Proactor是和异步I/O相关的，<strong>详细方案</strong>如下：</p>
<ul>
<li>ProactorInitiator创建Proactor和Handler对象，并将Proactor和Handler都通过AsyOptProcessor（Asynchronous Operation Processor）注册到内核</li>
<li>AsyOptProcessor处理注册请求，并处理I/O操作</li>
<li>AsyOptProcessor完成I/O操作后通知Proactor</li>
<li>Proactor根据不同的事件类型回调不同的Handler进行业务处理</li>
<li>Handler完成业务处理</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看出Proactor和Reactor的区别：Reactor是在事件发生时就通知事先注册的事件（读写在应用程序线程中处理完成）；Proactor是在事件发生时基于异步I/O完成读写操作（由内核完成），待I/O操作完成后才回调应用程序的处理器来处理进行业务处理</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;理论上Proactor比Reactor效率更高，异步I/O更加充分发挥DMA(Direct Memory Access，直接内存存取)的优势，但是有如下缺点：</p>
<ul>
<li>编程复杂性 由于异步操作流程的事件的初始化和事件完成在时间和空间上都是相互分离的，因此开发异步应用程序更加复杂。应用程序还可能因为反向的流控而变得更加难以Debug</li>
<li>内存使用 缓冲区在读或写操作的时间段内必须保持住，可能造成持续的不确定性，并且每个并发操作都要求有独立的缓存，相比Reactor模式，在socket已经准备好读或写前，是不要求开辟缓存的</li>
<li>操作系统支持 Windows 下通过 IOCP 实现了真正的异步 I/O，而在 Linux 系统下，Linux2.6才引入，目前异步I/O还不完善</li>
</ul>
<p>因此在Linux下实现高并发网络编程都是以Reactor模型为主</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://link.juejin.im/?target=https%3A%2F%2Ftime.geekbang.org%2Fcolumn%2Fintro%2F81%3Fcode%3DOK4eM0TBPTKGPRCzcZdzIeXjPACLfY3KCzATXOSWzXE%253D" target="_blank" rel="noopener">从0开始学架构 —— Alibaba技术专家李运华</a></p>
<p><a href="https://juejin.im/book/5b4bc28bf265da0f60130116?referrer=598ff735f265da3e1c0f9643" target="_blank" rel="noopener">Netty入门与实战</a></p>
<p><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.merlinblog.site%2Fposts%2Fa4602dea%2F" target="_blank" rel="noopener">技术: Linux网络IO模型</a></p>
<p><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.itran.cc%2F2016%2F05%2F08%2Fduo-xian-cheng-wang-luo-fu-wu-mo-xing%2F" target="_blank" rel="noopener">多线程网络服务模型</a></p>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzI3NzE0NjcwMg%3D%3D%26mid%3D2650121924%26idx%3D1%26sn%3D2b34c54391347fc81e11702fa5bfea09%26chksm%3Df36bbbe5c41c32f309aa85aa6c027d644052233864db85655839530d111ca37339ea1b81ef71%26mpshare%3D1%26scene%3D1%26srcid%3D0827POjeNpUaga1gKNqMuUiY%23rd" target="_blank" rel="noopener">IO中的阻塞、非阻塞、同步、异步</a></p>
<p>UNIX网络编程卷1：套接字联网API（第3版）</p>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Ftech.youzan.com%2Fyi-bu-wang-luo-mo-xing%2F" target="_blank" rel="noopener">异步网络模型</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/04/04/Chaos——阅文分布式ID生成系统/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/04/Chaos——阅文分布式ID生成系统/" itemprop="url">Chaos——阅文分布式ID生成系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-04T12:12:57+08:00">
                2019-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/分布式ID生成/" itemprop="url" rel="index">
                    <span itemprop="name">分布式ID生成</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Chaos——阅文分布式ID生成系统"><a href="#Chaos——阅文分布式ID生成系统" class="headerlink" title="Chaos——阅文分布式ID生成系统"></a>Chaos——阅文分布式ID生成系统</h1><p><img src="//blog.com/2019/04/04/Chaos——阅文分布式ID生成系统/1.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;从<code>mongodb</code>的<code>objectid</code>到<code>twitter</code>的<code>snowflake</code>，目前国内的几个互联网大厂也开始重视到了分布式系统中数据id，甚至一些大厂已经公开了它们关于id生成器的设计和实现。我们当然也注意到了分布式系统中id的重要性，并且在系统开始开发的时候就设计并且实现了一个id生成器。我们称之为：Chaos。Chaos目前已经在我们内部运行了2年之久，在这2年内故障率为惊人0，可靠性达到不可思议的100%。那么我们为什么要设计Chaos呢？Chaos又和别人家的id生成器有什么不同呢？这些问题，首先得从我们以往的经验开始。</p>
<p><img src="//blog.com/2019/04/04/Chaos——阅文分布式ID生成系统/2.webp" alt="img"></p>
<h2 id="过往使用id的经验"><a href="#过往使用id的经验" class="headerlink" title="过往使用id的经验"></a>过往使用id的经验</h2><h3 id="int自增"><a href="#int自增" class="headerlink" title="int自增"></a>int自增</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;通常情况下，说到id，我们第一个想到的就是int自增类型。它被各种“最佳实践”、教科书、论文…所推荐。然而，其实它已经老态龙钟，略显颓势，和这个年代脱节了！  从学校到社会；从教科书到实际系统；从办公自动化到erp系统，不管什么时候，不管什么年代，我们接受到对于数据id的设计原则都是这样的：</p>
<ol>
<li>唯一标识，确保不重复；</li>
<li><strong>确保数据库主键是无意义的</strong>；</li>
<li><strong>采用int作为主键值</strong>；</li>
<li>减少主键的变动；</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在单机、单数据库、dal+proc的年代，这些原则是可取的、现实的、最佳实践。依照这些原则我们也一直用的很好。直到有一天，数据猛增，单表破千万甚至上亿，需要考虑拆分单表的时候，问题来了： <strong>每个表的主键都是自增，数据库扩容怎么玩？</strong> </p>
<p><img src="//blog.com/2019/04/04/Chaos——阅文分布式ID生成系统/3.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;进过一番努力，终于在数据库的int自增中找到一个属性：步长。可以根据数据表的个数来设置步长，这样就不会重复了。比如将一个单表分成3个表，那么就把步长设置为3，3个表的id就会按照如下的方式来增长：</p>
<ol>
<li>table-1 : 0,3,6,9,12…</li>
<li>table-2 : 1,4,7,10,13…</li>
<li>table-3 : 2,5,8,11,14…</li>
</ol>
<p>这样确实解决了id可能重复的问题，但是同时带来了一个很让人抓狂的问题：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>每次扩容，都需要根据数据库表的数量来定义步长，一旦有疏忽，整个数据将会受到灾难性的破坏，严重的情况是根本无法重新平衡。</strong></p>
<p>所以int自增只能在单表的情况下才有很好的表现，一旦数据超过单表的最大限度，扩容是一件很麻烦的事情。</p>
<h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;因为int自增id难扩容的原因，我们想起了string。其实当时不是没有想过用int来自己组合一个id，但是因为那个年代普遍还是x32机器，x64刚刚开始起来，很多系统还没升级到x64，所以对于当时的系统来说，int的值太小了。一个id需要包含很多的信息，特别对于分布式系统来说，<strong>包含业务信息简直就是一定需要的</strong>，（PS：这里不得不说一下：我们的教材很多时候不能与时俱进的。各位谨记：理论是理论，实践是实践。）所以我们第一想到了GUID（UUID）来作为id。  </p>
<h3 id="GUID-UUID"><a href="#GUID-UUID" class="headerlink" title="GUID/UUID"></a>GUID/UUID</h3><p>GUID作为id确实规避了int自增的问题，因为对于GUID来说：</p>
<ol>
<li>肯定是唯一的，几乎不太可能碰见碰撞的问题；</li>
<li><strong>也没有业务的意义，都是根据统一的规则（并非业务规则）生成</strong>；看上去倒是一个很好的id解决办法，确实也有很多公司使用它，但是GUID也存在几个问题：</li>
<li>表的切分貌似只能有一种方法来确定了：hash（guid）% table-count；</li>
<li><strong>无法排序，对表的主键并不友好</strong>；</li>
<li>因为无业务意义，所以人类的<strong>识别度不高</strong>；那么怎么解决这些问题呢？自然而然的，我们想到了DIY字符串。</li>
</ol>
<h3 id="自定义String"><a href="#自定义String" class="headerlink" title="自定义String"></a>自定义String</h3><p>自定义String确实是我们当时的解决方案。因为相比于GUID，自定义String有太多的优势了：</p>
<ol>
<li>自定义的string可以塞入任何你想要的信息，可定制性很强；</li>
<li>可以轻松的实现分库分表运算，并且不仅仅限制在hash算法；</li>
<li>人类的识别度很高，可以用字符串明确的标识；</li>
<li>可以使用本地生成，根本无延时；但是它还是字符串，和GUID一样，缺点中除了切分方法和识别度，最重要的几个缺点还是存在：</li>
<li><strong>string太长，并且并且对于的运算过慢</strong>；</li>
<li><strong>对排序和索引支持很不友好，对主键的索引块是破坏性的</strong>；就这些缺点来说，在现在这个时代，已经不可能被我们选择了，那么我们到底要什么样的id呢？  </li>
</ol>
<p><strong>重要但很少考虑的问题</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这里主要说一下id对于数据库索引的支持不友好问题！众所周知，我们目前使用的数据库，不管是sqlserver，oracle还是mysql，数据库的索引几乎都是清一色的btree或者是其衍生版。在数据库的主键中，当插入数据的时候（假设我们从来不会更新主键信息），db会主动的维护一个btree的结构，但这个结构最终会落到磁盘上，在磁盘上，索引的格式我们简化如图所示：</p>
<p><img src="//blog.com/2019/04/04/Chaos——阅文分布式ID生成系统/4.webp" alt="img"></p>
<p>每一小块表示一个id对应的信息，每一个大块表示磁盘的文件块大小，每个索引最后都会被像这样子连接起来。如图看起来好像没问题，那么问题来了，如果我要插入一个id=15的值呢？结果就会像下图：</p>
<p><img src="//blog.com/2019/04/04/Chaos——阅文分布式ID生成系统/5.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;因为前后的索引磁盘块都已经占满（或者是到一个阀值），数据库就会主动将原来的索引链短裂开，插入新数据，再连接上彼此的索引。这种操作相比依次的插入，会带来更多的磁盘io操作。然而，<strong>如果使用string类型的id（特别是guid），因为没办法确定顺序，所以拆开索引-插入索引的操作将会经常发生，性能当然会有问题了</strong>。</p>
<h2 id="初涉id"><a href="#初涉id" class="headerlink" title="初涉id"></a>初涉id</h2><h3 id="基本分析"><a href="#基本分析" class="headerlink" title="基本分析"></a>基本分析</h3><p>在业务系统中，很多地方都会使用到id，主要的地方一共就几种：</p>
<ol>
<li>书、卷、章节等id；</li>
<li>分布式系统中，系统调用的错误码；</li>
</ol>
<p>对于id的几个需求：</p>
<ol>
<li>最基本：作为数据库记录的主键；</li>
<li>加强型：被索引，对索引友好；</li>
<li>附带价值：作为分库分表的依据；</li>
<li>扩展功能：对象唯一标识，比如sessionid、批号、错误号；</li>
</ol>
<p>具体的分析一下在业务规则下的id，它必须具有一下的一些特性：</p>
<ol>
<li><strong>分库分表</strong>：因为分库分表的方式各种各样，并且会随着业务的改变而变化，所以对于一个id来说，在最基本的几种分库分表的方案中，它必须要包括时间戳、随机数、类型位、数据库标识等几种属性；</li>
<li><strong>高可用性</strong>：机器位，这是为了分布式系统中id必须唯一而设置的；</li>
<li><strong>数据可读性必须强</strong>；</li>
<li><strong>递增</strong>还是随机？每秒递增？？累加递增？？</li>
</ol>
<h3 id="基本诉求"><a href="#基本诉求" class="headerlink" title="基本诉求"></a>基本诉求</h3><p>id必须要具备以下一些功能或者说特性：</p>
<ol>
<li>唯一，必须唯一；</li>
<li>短，尽可能的短；</li>
<li>生成速度足够快；</li>
<li>运算足够简单，快速；</li>
<li>附带实体业务信息，比如时间、类型等；</li>
<li>部分信息可以自定义，比如路由信息；</li>
<li>不仅机器能识别，人类也可以识别；</li>
<li>对索引友好；</li>
<li>根据业务规则，能自定义排序等业务规则；</li>
</ol>
<h3 id="基本方向"><a href="#基本方向" class="headerlink" title="基本方向"></a>基本方向</h3><ol>
<li><p>必须足够短，最好是uint32，最长uint64；</p>
</li>
<li><p>必须系统原生支持，不需要扩展类型；</p>
</li>
<li><p>比较运算足够快；</p>
</li>
<li><p>必须递增，可排序并对索引友好；</p>
</li>
<li><p>id必须带业务性质，符合望文生义原则，通过id可以知道这个数据存在的数据库、表等信息，如果是错误号，必须能知道所发生的服务器；</p>
</li>
</ol>
<h2 id="id的水还是很深的"><a href="#id的水还是很深的" class="headerlink" title="id的水还是很深的"></a>id的水还是很深的</h2><h3 id="snowflake"><a href="#snowflake" class="headerlink" title="snowflake"></a>snowflake</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;考虑实现id，twitter的snowflake算法是一个无法回避的问题，分析snowflake的算法，其实它有几个重要的特点：首先：snowflake由时间戳-机器位-随机数组成，分别是41位、10位、12位其次：snowflake选择了使用uint64类型，所以在这个算法下，最大值就是0XFFFF FFFF FFFF FFFF；来看一个例子，比如有一个数：<strong>9223  3720 3257 7650 688</strong>  这个数代表了什么意思呢？首先得分析它的二进制，这个数的二进制是：<strong>0111 1111 1111 1111 1111 1111 1111 1111 0000 0001 0001 0000 0100 0000 0000 0000</strong>  然后通过snowflake的组成机制，算得这个数的真实要代表的数：<strong>2199023251472-264-0</strong> 不得不说，这种二进制移位的方法对于机器来说非常的简单、运算也更快，但是对于程序员来说，简直就是天书。所以对于snowflake算法，我们并不满意，其实snowflake不满意的并不仅仅这一项，还有2个业务的问题snowflake也无法解决：</p>
<ol>
<li><strong>没有类型信息</strong>；</li>
<li><strong>分库分表没有数据库定位信息</strong>；</li>
</ol>
<h3 id="Chaos的设计"><a href="#Chaos的设计" class="headerlink" title="Chaos的设计"></a>Chaos的设计</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Chaos首先确定的就是放弃二进制而选用十进制。使用十进制最主要的原因就是id的特殊场景。一般来说，id对于一个对象就像是身份证对于你一样，如果不去办银行卡、订酒店、飞机票…，在日常的生活中，几乎没啥用；回到系统，当程序员要注意一个id的时候，基本上就是当且仅当系统出问题了，需要排查。如果排错的时候，使用的还是snowflake这种的二进制移位方法，同时外面催促的电话频繁响起（玩玩这时候老板的电话特别多），然后第一句就是：怎么又出问题了？你能第一时间确定这个id到底来自哪里？什么类型？用处是什么？这些基本问题吗？这种情况下，你会有什么想法——直接想打人！  </p>
<h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Chaos也和snowflake一样，选用了uint64类型，但是因为Chaos是10进制，所以对于Chaos，uint64的最大值是  <strong>1844 6744 0737 0955 1656</strong>  那么Chaos最大值只能是  <strong>9999 9999 9999 9999 999</strong>  直观来看，就是Chaos的id少了一位。这又是为什么呢？接着来看：和snowklake一样，Chaos也是选择了使用指定位数来确定业务信息，只是不同的是，Chaos的位数是10进制位数。我们的算法：<strong>：时间戳-随机数位-类型位-机器位-数据库标识</strong>  ，<strong>10位 + 4位 + 2位 + 1位 + 2位</strong>这里就可以解释为什么Chaos的id会少一位了！因为Chaos的id最前面的几位是时间戳，而u64的最大值最前面的数值是1，这样Chaos的时间戳就会很容易溢出。所以Chaos设计的id干脆少一位，这样不管最前面的数值多大，就算是9，因为少了一位，所以肯定不会溢出。</p>
<h5 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;在Chaos中，选择了序列号而并不是随机数来解决数的唯一性问题。之所以不选择随机数，是因为随机数在5位数的情况下，万分之一的碰撞概率对于10k qps的压力来说还是挺大的，所以随机数并不是一个很好的方案。<strong>序列号其实就是一个计数器，从0-9999计数，9999后直接归0.这种累加方式在Chaos中被称之为累加递增</strong>。但是还有<strong>一些业务它确实需要一个每次都是从0开始的数，这种情况下的递增在Chaos中被称之为每秒递增</strong>。从方案上来说，结合业务，<strong>累加递增更适合做分库分表的操作，累加递增可以让数据更加均衡的被分配到每个库和每个表中；而每秒递增更适合于有排序的情况</strong>。</p>
<h5 id="递增性分析"><a href="#递增性分析" class="headerlink" title="递增性分析"></a>递增性分析</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;上面讲到的序列号递增方法，因为序列号是id的一部分，所以<strong>序列号的递增性其实决定了整个id的递增性</strong>。也就是说，序列号决定了id的递增性。例如：</p>
<p><strong>累加递增：秒内进位</strong></p>
<p>429497-9998-01-1-00</p>
<p>429498-9999-01-1-00</p>
<p>429498-0000-01-1-00</p>
<p><strong>每秒递增：设计成每秒10k个，超过不会放出id</strong></p>
<p>429496-0000-01-1-00</p>
<p>429497-0000-01-1-00</p>
<p>429498-0000-01-1-00</p>
<p>所以查看这上面的id，我们可以总结如下：<img src="//blog.com/2019/04/04/Chaos——阅文分布式ID生成系统/6.webp" alt="img">累加递增：长时间（2s内）内保证单调递增，短时间（1s内）内不保证单调递增每秒递增：它肯定是递增的，因为每秒都会从0开始，单位时间内都是单调递</p>
<h4 id="id生成器"><a href="#id生成器" class="headerlink" title="id生成器"></a>id生成器</h4><p>对于分库分表的使用，chaos生成的id使用示意如下：<img src="//blog.com/2019/04/04/Chaos——阅文分布式ID生成系统/7.webp" alt="img"></p>
<p>对于错误号的使用，chaos生成的id使用示意如下：<img src="//blog.com/2019/04/04/Chaos——阅文分布式ID生成系统/8.webp" alt="img"></p>
<h4 id="服务器设计"><a href="#服务器设计" class="headerlink" title="服务器设计"></a>服务器设计</h4><p><img src="//blog.com/2019/04/04/Chaos——阅文分布式ID生成系统/9.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;chaos采用了水平的&nbsp;&nbsp;&nbsp;&nbsp;分布式设计。服务器都是无状态的，也是去中心化的。这样的设计可以更好的来适应后面压力增大后对于服务器的需求。目前Chaos只支持一个集群中最多有10台服务器提供id服务。是不是感觉少了一些，其实也够用了。并未按照chaos的设计需求，10台chaos每秒可以生成：10(台) <em> 100(类型数) </em> 10000(每秒最大数量）= 1000 0000个id。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>id，其实就是一个19位的数字。对于id来说，技术含量不在于纯技术，而在于对系统的架构控制</strong>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/04/04/分布式系统唯一ID/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/04/分布式系统唯一ID/" itemprop="url">分布式系统唯一ID</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-04T12:12:57+08:00">
                2019-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/分布式ID生成/" itemprop="url" rel="index">
                    <span itemprop="name">分布式ID生成</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分布式系统唯一ID"><a href="#分布式系统唯一ID" class="headerlink" title="分布式系统唯一ID"></a>分布式系统唯一ID</h1><h2 id="什么是分布式系统唯一ID"><a href="#什么是分布式系统唯一ID" class="headerlink" title="什么是分布式系统唯一ID"></a>什么是分布式系统唯一ID</h2><p>在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识。</p>
<p>如在金融、电商、支付、等产品的系统中，数据日渐增长，对数据分库分表后需要有一个唯一ID来标识一条数据或消息，数据库的自增ID显然不能满足需求，此时一个能够生成全局唯一ID的系统是非常必要的。</p>
<p>如在金融、电商、支付、等产品的系统中，数据日渐增长，对数据分库分表后需要有一个唯一ID来标识一条数据或消息，数据库的自增ID显然不能满足需求，此时一个能够生成全局唯一ID的系统是非常必要的。</p>
<h2 id="分布式系统唯一ID的特点"><a href="#分布式系统唯一ID的特点" class="headerlink" title="分布式系统唯一ID的特点"></a>分布式系统唯一ID的特点</h2><p><img src="//blog.com/2019/04/04/分布式系统唯一ID/1.jpg" alt="img"></p>
<ol>
<li><strong>全局唯一性</strong>：不能出现重复的ID号，既然是唯一标识，这是最基本的要求。</li>
<li><strong>趋势递增</strong>：在MySQL InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用B-tree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。</li>
<li><strong>单调递增</strong>：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求。</li>
<li><strong>信息安全</strong>：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。</li>
</ol>
<p>同时除了对ID号码自身的要求，业务还<strong>对ID号生成系统的可用性要求极高</strong>，想象一下，如果ID生成系统瘫痪，这就会带来一场灾难。</p>
<p>由此总结下一个ID生成系统应该做到如下几点：</p>
<ol>
<li>平均延迟和TP999延迟都要尽可能低；</li>
<li>可用性5个9；</li>
<li>高QPS。</li>
</ol>
<h2 id="分布式系统唯一ID的实现方案"><a href="#分布式系统唯一ID的实现方案" class="headerlink" title="分布式系统唯一ID的实现方案"></a>分布式系统唯一ID的实现方案</h2><p><img src="//blog.com/2019/04/04/分布式系统唯一ID/4.jpg" alt="阿里P8架构师谈：分布式系统全局唯一ID简介、特点、5种生成方式"></p>
<h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p>UUID(Universally Unique Identifier)的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的36个字符，示例：550e8400-e29b-41d4-a716-446655440000，到目前为止业界一共有5种方式生成UUID，详情见IETF发布的UUID规范 A Universally Unique IDentifier (UUID) URN Namespace。</p>
<p>优点：</p>
<ul>
<li>性能非常高：本地生成，没有网络消耗。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不易于存储：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。</li>
<li>信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</li>
<li>ID作为主键时在特定的环境会存在一些问题，比如做DB主键的场景下，UUID就非常不适用：</li>
</ul>
<h3 id="数据库生成"><a href="#数据库生成" class="headerlink" title="数据库生成"></a>数据库生成</h3><p>以MySQL举例，利用给字段设置auto_increment_increment和auto_increment_offset来保证ID自增，每次业务使用下列SQL读写MySQL得到ID号。</p>
<p><img src="//blog.com/2019/04/04/分布式系统唯一ID/2.jpg" alt="阿里P8架构师谈：分布式系统全局唯一ID简介、特点、5种生成方式"></p>
<p>这种方案的优缺点如下：</p>
<p>优点：</p>
<ul>
<li>非常简单，利用现有数据库系统的功能实现，成本小，有DBA专业维护。</li>
<li>ID号单调自增，可以实现一些对ID有特殊要求的业务。</li>
</ul>
<p>缺点：</p>
<ul>
<li>强依赖DB，当DB异常时整个系统不可用，属于致命问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。</li>
<li>ID发号性能瓶颈限制在单台MySQL的读写性能。</li>
</ul>
<h3 id="Redis生成ID"><a href="#Redis生成ID" class="headerlink" title="Redis生成ID"></a>Redis生成ID</h3><p>当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。</p>
<p>这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 INCR和INCRBY来实现。</p>
<p>比较适合使用Redis来生成每天从0开始的流水号。比如订单号=日期+当日自增长号。可以每天在Redis中生成一个Key，使用INCR进行累加。</p>
<p>优点：</p>
<p>1）不依赖于数据库，灵活方便，且性能优于数据库。</p>
<p>2）数字ID天然排序，对分页或者需要排序的结果很有帮助。</p>
<p>缺点：</p>
<p>1）如果系统中没有Redis，还需要引入新的组件，增加系统复杂度。</p>
<p>2）需要编码和配置的工作量比较大。</p>
<h3 id="利用zookeeper生成唯一ID"><a href="#利用zookeeper生成唯一ID" class="headerlink" title="利用zookeeper生成唯一ID"></a>利用zookeeper生成唯一ID</h3><p>zookeeper主要通过其znode数据版本来生成序列号，可以生成32位和64位的数据版本号，客户端可以使用这个版本号来作为唯一的序列号。</p>
<p>很少会使用zookeeper来生成唯一ID。主要是由于需要依赖zookeeper，并且是多步调用API，如果在竞争较大的情况下，需要考虑使用分布式锁。因此，性能在高并发的分布式环境下，也不甚理想。</p>
<h3 id="snowflake（雪花算法）方案"><a href="#snowflake（雪花算法）方案" class="headerlink" title="snowflake（雪花算法）方案"></a>snowflake（雪花算法）方案</h3><p>这种方案大致来说是一种以划分命名空间（UUID也算，由于比较常见，所以单独分析）来生成ID的一种算法，这种方案把64-bit分别划分成多段，分开来标示机器、时间等，比如在snowflake中的64-bit分别表示如下图（图片来自网络）所示：</p>
<p><img src="//blog.com/2019/04/04/分布式系统唯一ID/3.jpg" alt="阿里P8架构师谈：分布式系统全局唯一ID简介、特点、5种生成方式"></p>
<p>41-bit的时间可以表示（1L&lt;&lt;41）/(1000L<em>3600</em>24*365)=69年的时间，10-bit机器可以分别表示1024台机器。如果我们对IDC划分有需求，还可以将10-bit分5-bit给IDC，分5-bit给工作机器。这样就可以表示32个IDC，每个IDC下可以有32台机器，可以根据自身需求定义。12个自增序列号可以表示2^12个ID，理论上snowflake方案的QPS约为409.6w/s，这种分配方式可以保证在任何一个IDC的任何一台机器在任意毫秒内生成的ID都是不同的。</p>
<p>这种方式的优缺点是：</p>
<p>优点：</p>
<ul>
<li>毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。</li>
<li>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。</li>
<li>可以根据自身业务特性分配bit位，非常灵活。</li>
</ul>
<p>缺点：</p>
<ul>
<li>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</li>
</ul>
<h3 id="Mongdb-objectID"><a href="#Mongdb-objectID" class="headerlink" title="Mongdb objectID"></a>Mongdb objectID</h3><p>MongoDB官方文档 ObjectID可以算作是和snowflake类似方法，通过“时间+机器码+pid+inc”共12个字节，通过4+3+2+3的方式最终标识成一个24长度的十六进制字符。)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/04/04/万亿级调用系统：微信序列号生成器架构设计及演变/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/04/万亿级调用系统：微信序列号生成器架构设计及演变/" itemprop="url">万亿级调用系统：微信序列号生成器架构设计及演变</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-04T12:12:57+08:00">
                2019-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/分布式ID生成/" itemprop="url" rel="index">
                    <span itemprop="name">分布式ID生成</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="万亿级调用系统：微信序列号生成器架构设计及演变"><a href="#万亿级调用系统：微信序列号生成器架构设计及演变" class="headerlink" title="万亿级调用系统：微信序列号生成器架构设计及演变"></a>万亿级调用系统：微信序列号生成器架构设计及演变</h1><blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650992918&amp;idx=1&amp;sn=be5121c3c57257291a30715ef7130a90&amp;scene=25&amp;srcid=0614mzkBXzwOEA5p534BXlv0&amp;pass_ticket=MRV0khdA3hk63n8L3hYA9nDxCnbh3yoGKM1LQx%2BRDk0%3D#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650992918&amp;idx=1&amp;sn=be5121c3c57257291a30715ef7130a90&amp;scene=25&amp;srcid=0614mzkBXzwOEA5p534BXlv0&amp;pass_ticket=MRV0khdA3hk63n8L3hYA9nDxCnbh3yoGKM1LQx%2BRDk0%3D#wechat_redirect</a></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;微信在立项之初，就已确立了<strong>利用数据版本号实现终端与后台的数据增量同步机制，确保发消息时消息可靠送达对方手机</strong>，避免了大量潜在的家庭纠纷。时至今日，微信已经走过第五个年头，这套同步机制仍然在消息收发、朋友圈通知、好友数据更新等需要数据同步的地方发挥着核心的作用。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;而在这同步机制的背后，需要一个高可用、高可靠的序列号生成器来产生同步数据用的版本号。这个序列号生成器我们称之为seqsvr，目前已经发展为一个每天万亿级调用的重量级系统，其中每次申请序列号平时调用耗时1ms，99.9%的调用耗时小于3ms，服务部署于数百台4核CPU服务器上。<strong>本文会重点介绍seqsvr的架构核心思想，以及seqsvr随着业务量快速上涨所做的架构演变。</strong></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="//blog.com/2019/04/04/万亿级调用系统：微信序列号生成器架构设计及演变/1.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>微信服务器端为每一份需要与客户端同步的数据（例如消息）都会赋予一个唯一的、递增的序列号（后文称为sequence），作为这份数据的版本号。</strong>在客户端与服务器端同步的时候，客户端会带上已经同步下去数据的最大版本号<strong>，后台会根据客户端最大版本号与服务器端的最大版本号，计算出需要同步的增量数据，返回给客户端</strong>。这样不仅保证了客户端与服务器端的数据同步的可靠性，同时也大幅减少了同步时的冗余数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这里不用乐观锁机制来生成版本号，而是使用了一个独立的seqsvr来处理序列号操作，一方面因为业务有大量的sequence查询需求——查询已经分配出去的最后一个sequence，而基于seqsvr的查询操作可以做到非常轻量级，避免对存储层的大量IO查询操作；另一方面微信用户的不同种类的数据存在不同的Key-Value系统中，使用统一的序列号有助于避免重复开发，同时业务逻辑可以很方便地判断一个用户的各类数据是否有更新。</p>
<p>从seqsvr申请的、用作数据版本号的sequence，具有两种基本的性质：</p>
<blockquote>
<ol>
<li>递增的64位整型变量</li>
<li>每个用户都有自己独立的64位sequence空间</li>
</ol>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;举个例子，小明当前申请的sequence为100，那么他下一次申请的sequence，可能为101，也可能是110，总之一定大于之前申请的100。而小红呢，她的sequence与小明的sequence是独立开的，假如她当前申请到的sequence为50，然后期间不管小明申请多少次sequence怎么折腾，都不会影响到她下一次申请到的值（很可能是51）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这里用了每个用户独立的64位sequence的体系，而不是用一个全局的64位（或更高位）sequence，很大原因是<strong>全局唯一的sequence会有非常严重的申请互斥问题，不容易去实现一个高性能高可靠的架构</strong>。对微信业务来说，每个用户独立的64位sequence空间已经满足业务要求。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>目前sequence用在终端与后台的数据同步外，同时也广泛用于微信后台逻辑层的基础数据一致性cache中，大幅减少逻辑层对存储层的访问。</strong>虽然一个用于终端——后台数据同步，一个用于后台cache的一致性保证，场景大不相同。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;但我们仔细分析就会发现，两个场景都是利用sequence可靠递增的性质来实现数据的一致性保证，这就要求我们的<strong>seqsvr保证分配出去的sequence是稳定递增的，一旦出现回退必然导致各种数据错乱、消息消失</strong>；另外，这两个场景都非常普遍，我们在使用微信的时候会不知不觉地对应到这两个场景：小明给小红发消息、小红拉黑小明、小明发一条失恋状态的朋友圈，一次简单的分手背后可能申请了无数次sequence。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;微信目前拥有数亿的活跃用户，每时每刻都会有海量sequence申请，这对seqsvr的设计也是个极大的挑战。那么，既要sequence可靠递增，又要能顶住海量的访问，要如何设计seqsvr的架构？我们先从seqsvr的架构原型说起。</p>
<h2 id="架构原型"><a href="#架构原型" class="headerlink" title="架构原型"></a>架构原型</h2><p><img src="//blog.com/2019/04/04/万亿级调用系统：微信序列号生成器架构设计及演变/2.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;不考虑seqsvr的具体架构的话，它应该是一个巨大的64位数组，而我们每一个微信用户，都在这个大数组里独占一格8bytes的空间，这个格子就放着用户已经<strong>分配出去的最后一个sequence：cur_seq。每个用户来申请sequence的时候，只需要将用户的cur_seq+=1，保存回数组，并返回给用户</strong>。</p>
<p><img src="//blog.com/2019/04/04/万亿级调用系统：微信序列号生成器架构设计及演变/3.webp" alt="img"></p>
<h3 id="预分配中间层"><a href="#预分配中间层" class="headerlink" title="预分配中间层"></a><strong>预分配中间层</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>任何一件看起来很简单的事，在海量的访问量下都会变得不简单。</strong>前文提到，seqsvr需要保证分配出去的sequence递增（数据可靠），还需要满足海量的访问量（每天接近万亿级别的访问）。<strong>满足数据可靠的话，我们很容易想到把数据持久化到硬盘</strong>，但是按照目前每秒千万级的访问量（~10^7 QPS），基本没有任何硬盘系统能扛住。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;后台架构设计很多时候是一门关于权衡的哲学，针对不同的场景去考虑能不能降低某方面的要求，以换取其它方面的提升。仔细考虑我们的需求，我们<strong>只要求递增，并没有要求连续，也就是说出现一大段跳跃是允许的</strong>（例如分配出的sequence序列：1,2,3,10,100,101）。于是我们实现了一个简单优雅的策略：</p>
<blockquote>
<ol>
<li>内存中储存最近一个分配出去的sequence：cur_seq，以及分配上限：max_seq</li>
<li>分配sequence时，将cur_seq++，同时与分配上限max_seq比较：如果cur_seq &gt; max_seq，将分配上限提升一个步长max_seq += step，并持久化max_seq</li>
<li>重启时，读出持久化的max_seq，赋值给cur_seq</li>
</ol>
</blockquote>
<p><img src="//blog.com/2019/04/04/万亿级调用系统：微信序列号生成器架构设计及演变/4.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这样通过增加一个<strong>预分配sequence的中间层</strong>，在保证sequence不回退的前提下，大幅地提升了分配sequence的性能。实际应用中每次提升的步长为10000，那么<strong>持久化的硬盘IO次数从之前~10^7 QPS降低到~10^3 QPS</strong>，处于可接受范围。<strong>在正常运作时分配出去的sequence是顺序递增的，只有在机器重启后，第一次分配的sequence会产生一个比较大的跳跃，跳跃大小取决于步长大小</strong>。</p>
<h3 id="分号段共享存储"><a href="#分号段共享存储" class="headerlink" title="分号段共享存储"></a><strong>分号段共享存储</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;请求带来的硬盘IO问题解决了，可以支持服务平稳运行，但该模型还是存在一个问题：<strong>重启时要读取大量的max_seq数据加载到内存中</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;我们可以简单计算下，以目前uid（用户唯一ID）上限2^32个、一个max_seq 8bytes的空间，数据大小一共为32GB，从硬盘加载需要不少时间。另一方面，出于数据可靠性的考虑，必然需要一个可靠存储系统来保存max_seq数据，重启时通过网络从该可靠存储系统加载数据。<strong>如果max_seq数据过大的话，会导致重启时在数据传输花费大量时间，造成一段时间不可服务</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;为了解决这个问题，我们<strong>引入号段Section的概念，uid相邻的一段用户属于一个号段，而同个号段内的用户共享一个max_seq，这样大幅减少了max_seq数据的大小，同时也降低了IO次数</strong>。</p>
<p><img src="//blog.com/2019/04/04/万亿级调用系统：微信序列号生成器架构设计及演变/5.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;目前seqsvr一个Section包含10万个uid，max_seq数据只有300+KB，为我们实现从可靠存储系统读取max_seq数据重启打下基础。</p>
<h3 id="工程实现"><a href="#工程实现" class="headerlink" title="工程实现"></a><strong>工程实现</strong></h3><p>工程实现在上面两个策略上做了一些调整，主要是出于数据可靠性及灾难隔离考虑</p>
<blockquote>
<ol>
<li>把存储层和缓存中间层分成两个模块StoreSvr及AllocSvr。StoreSvr为存储层，利用了多机NRW策略来保证数据持久化后不丢失；<strong>AllocSvr则是缓存中间层，部署于多台机器，每台AllocSvr负责若干号段的sequence分配，分摊海量的sequence申请请求</strong>。</li>
<li>整个系统又按uid范围进行分Set，每个Set都是一个完整的、独立的StoreSvr+AllocSvr子系统。<strong>分Set设计目的是为了做灾难隔离，一个Set出现故障只会影响该Set内的用户，而不会影响到其它用户</strong>。</li>
</ol>
</blockquote>
<p><img src="//blog.com/2019/04/04/万亿级调用系统：微信序列号生成器架构设计及演变/6.webp" alt="img"></p>
<h4 id="容灾设计"><a href="#容灾设计" class="headerlink" title="容灾设计"></a><strong>容灾设计</strong></h4><p>&nbsp;&nbsp;&nbsp;&nbsp;接下来我们会介绍seqsvr的容灾架构。我们知道，后台系统绝大部分情况下并没有一种唯一的、完美的解决方案，同样的需求在不同的环境背景下甚至有可能演化出两种截然不同的架构。既然架构是多变的，那纯粹讲架构的意义并不是特别大，期间也会讲下seqsvr容灾设计时的一些思考和权衡，希望对大家有所帮助。</p>
<p>seqsvr的容灾模型在五年中进行过一次比较大的重构，提升了可用性、机器利用率等方面。其中不管是重构前还是重构后的架构，seqsvr一直遵循着两条架构设计原则：</p>
<blockquote>
<ol>
<li>保持自身架构简单</li>
<li>避免对外部模块的强依赖</li>
</ol>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这两点都是基于seqsvr可靠性考虑的，毕竟seqsvr是一个与整个微信服务端正常运行息息相关的模块。按照我们对这个世界的认识，系统的复杂度往往是跟可靠性成反比的，想得到一个可靠的系统一个关键点就是要把它做简单。相信大家身边都有一些这样的例子，设计方案里有很多高大上、复杂的东西，同时也总能看到他们在默默地填一些高大上的坑。当然简单的系统不意味着粗制滥造，我们要做的是理出最核心的点，然后在满足这些核心点的基础上，针对性地提出一个足够简单的解决方案。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;那么，<strong>seqsvr最核心的点是什么呢？每个uid的sequence申请要递增不回退。</strong>这里我们发现，如果seqsvr满足这么一个约束：<strong>任意时刻任意uid有且仅有一台AllocSvr提供服务，就可以比较容易地实现sequence递增不回退的要求</strong>。</p>
<p><img src="//blog.com/2019/04/04/万亿级调用系统：微信序列号生成器架构设计及演变/7.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;但也由于这个约束，<strong>多台AllocSvr同时服务同一个号段的多主机模型在这里就不适用了</strong>。我们只能采用单点服务的模式，<strong>当某台AllocSvr发生服务不可用时，将该机服务的uid段切换到其它机器来实现容灾</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这里<strong>需要引入一个仲裁服务，探测AllocSvr的服务状态，决定每个uid段由哪台AllocSvr加载</strong>。出于可靠性的考虑，仲裁模块并不直接操作AllocSvr，而是将加载配置写到StoreSvr持久化，然后AllocSvr定期访问StoreSvr读取最新的加载配置，决定自己的加载状态。</p>
<p><img src="//blog.com/2019/04/04/万亿级调用系统：微信序列号生成器架构设计及演变/8.webp" alt="img"></p>
<p>通过更新加载配置把0~2号段从AllocSvrA迁移到AllocSvrB</p>
<p>同时，为了避免失联AllocSvr提供错误的服务，返回脏数据，AllocSvr需要跟StoreSvr保持租约。这个租约机制由以下两个条件组成：</p>
<blockquote>
<ol>
<li>租约失效：AllocSvr N秒内无法从StoreSvr读取加载配置时，AllocSvr停止服务</li>
<li>租约生效：AllocSvr读取到新的加载配置后，立即卸载需要卸载的号段，需要加载的新号段等待N秒后提供服务</li>
</ol>
</blockquote>
<p><img src="//blog.com/2019/04/04/万亿级调用系统：微信序列号生成器架构设计及演变/9.webp" alt="img"></p>
<p><strong>AllocSvrB严格保证在AllocSvrA停止服务后提供服务</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这两个条件保证了切换时，新AllocSvr肯定在旧AllocSvr下线后才开始提供服务。但这种<strong>租约机制也会造成切换的号段存在小段时间的不可服务</strong>，不过由于<strong>微信后台逻辑层存在重试机制及异步重试队列，小段时间的不可服务是用户无感知的，而且出现租约失效、切换是小概率事件，整体上是可以接受的</strong>。</p>
<p>到此讲了AllocSvr容灾切换的基本原理，接下来会介绍整个seqsvr架构容灾架构的演变</p>
<h5 id="容灾1-0架构：主备容灾"><a href="#容灾1-0架构：主备容灾" class="headerlink" title="容灾1.0架构：主备容灾"></a>容灾1.0架构：主备容灾</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;最初版本的seqsvr采用了<strong>主机+冷备机容灾模式：全量的uid空间均匀分成N个Section，连续的若干个Section组成了一个Set，每个Set都有一主一备两台AllocSvr</strong>。正常情况下只有主机提供服务；在主机出故障时，<strong>仲裁服务切换主备，原来的主机下线变成备机，原备机变成主机后加载uid号段提供服务</strong>。</p>
<p><img src="//blog.com/2019/04/04/万亿级调用系统：微信序列号生成器架构设计及演变/10.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;可能看到前文的叙述，有些同学已经想到这种容灾架构。一主机一备机的模型设计简单，并且具有不错的可用性——毕竟主备两台机器同时不可用的概率极低，相信很多后台系统也采用了类似的容灾策略。</p>
<h5 id="设计权衡"><a href="#设计权衡" class="headerlink" title="设计权衡"></a>设计权衡</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;主备容灾存在一些明显的缺陷，比如<strong>备机闲置</strong>导致有一半的空闲机器；比如主备切换的时候，备机在瞬间要接受主机所有的请求，容易导致<strong>备机过载</strong>。既然一主一备容灾存在这样的问题，为什么一开始还要采用这种容灾模型？事实上，架构的选择往往跟当时的背景有关，seqsvr诞生于微信发展初期，也正是微信快速扩张的时候，选择一主一备容灾模型是出于以下的考虑：</p>
<blockquote>
<ol>
<li>架构简单，可以快速开发</li>
<li>机器数少，机器冗余不是主要问题</li>
<li><strong>Client端更新AllocSvr的路由状态很容易实现</strong></li>
</ol>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;前两点好懂，人力、机器都不如时间宝贵。而第三点比较有意思，下面展开讲下：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;微信后台绝大部分模块使用了一个自研的RPC框架，seqsvr也不例外。在这个RPC框架里，调用端读取本地机器的client配置文件，决定去哪台服务端调用。这种模型对于无状态的服务端，是很好用的，也很方便实现容灾。我们可以在client配置文件里面写<strong>“对于号段x，可以去SvrA、SvrB、SvrC三台机器的任意一台访问”，实现三主机容灾</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;但<strong>在seqsvr里，AllocSvr是预分配中间层，并不是无状态的</strong>。而前面我们提到，<strong>AllocSvr加载哪些uid号段，是由保存在StoreSvr的加载配置决定的</strong>。那么这时候就尴尬了，业务想要申请某个uid的sequence，Client端其实并不清楚具体去哪台AllocSvr访问，client配置文件只会跟它说“AllocSvrA、AllocSvrB…这堆机器的某一台会有你想要的sequence”。换句话讲，原来负责提供服务的AllocSvrA故障，仲裁服务决定由AllocSvrC来替代AllocSvrA提供服务，<strong>Client要如何获知这个路由信息的变更</strong>？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这时候假如我们的AllocSvr采用了主备容灾模型的话，事情就变得简单多了。我们可以在client配置文件里写：对于某个uid号段，要么是AllocSvrA加载，要么是AllocSvrB加载。Client端发起请求时，尽管Client端并不清楚AllocSvrA和AllocSvrB哪一台真正加载了目标uid号段，但是Client端可以先尝试给其中任意一台AllocSvr发请求，就算这次请求了错误的AllocSvr，那么就知道另外一台是正确的AllocSvr，再发起一次请求即可。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;也就是说，<strong>对于主备容灾模型，最多也只会浪费一次的试探请求来确定AllocSvr的服务状态，额外消耗少，编码也简单</strong>。可是，如果Svr端采用了其它复杂的容灾策略，那么<strong>基于静态配置的框架就很难去确定Svr端的服务状态</strong>：Svr发生状态变更，Client端无法确定应该向哪台Svr发起请求。这也是为什么一开始选择了主备容灾的原因之一。</p>
<h3 id="主备容灾的缺陷"><a href="#主备容灾的缺陷" class="headerlink" title="主备容灾的缺陷"></a><strong>主备容灾的缺陷</strong></h3><p>在我们的实际运营中，容灾1.0架构存在两个重大的不足：</p>
<blockquote>
<ol>
<li><strong>扩容、缩容非常麻烦</strong></li>
<li><strong>一个Set的主备机都过载，无法使用其他Set的机器进行容灾</strong></li>
</ol>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在主备容灾中，Client和AllocSvr需要使用完全一致的配置文件。变更这个配置文件的时候，<strong>由于无法实现在同一时间更新给所有的Client和AllocSvr</strong>，因此需要非常复杂的人工操作来保证变更的正确性（包括需要使用iptables来做请求转发，具体的详情这里不做展开）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;对于第二个问题，<strong>常见的方法是用一致性Hash算法替代主备，一个Set有多台机器，过载机器的请求被分摊到多台机器，容灾效果会更好</strong>。<strong>在seqsvr中使用类似一致性Hash的容灾策略也是可行的，只要Client端与仲裁服务都使用完全一样的一致性Hash算法，这样Client端可以启发式地去尝试，直到找到正确的AllocSvr</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;例如对于某个uid，仲裁服务会优先把它分配到AllocSvrA，如果AllocSvrA挂掉则分配到AllocSvrB，再不行分配到AllocSvrC。那么Client在访问AllocSvr时，按照AllocSvrA -&gt; AllocSvrB -&gt; AllocSvrC的顺序去访问，也能实现容灾的目的。但这种方法仍然没有克服前面主备容灾面临的配置文件变更的问题，运营起来也很麻烦。</p>
<h4 id="容灾2-0架构：嵌入式路由表容灾"><a href="#容灾2-0架构：嵌入式路由表容灾" class="headerlink" title="容灾2.0架构：嵌入式路由表容灾"></a><strong>容灾2.0架构：嵌入式路由表容灾</strong></h4><p><img src="//blog.com/2019/04/04/万亿级调用系统：微信序列号生成器架构设计及演变/11.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;最后我们另辟蹊径，采用了一种不同的思路：既然Client端与AllocSvr存在路由状态不一致的问题，那么<strong>让AllocSvr把当前的路由状态传递给Client端，打破之前只能根据本地Client配置文件做路由决策的限制</strong>，从根本上解决这个问题。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;所以在2.0架构中，我们<strong>把AllocSvr的路由状态嵌入到Client请求sequence的响应包中，在不带来额外的资源消耗的情况下，实现了Client端与AllocSvr之间的路由状态一致</strong>。具体实现方案如下：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>seqsvr所有模块使用了统一的路由表，描述了uid号段到AllocSvr的全映射。这份路由表由仲裁服务根据AllocSvr的服务状态生成，写到StoreSvr中，由AllocSvr当作租约读出，最后在业务返回包里旁路给Client端</strong>。</p>
<p><img src="//blog.com/2019/04/04/万亿级调用系统：微信序列号生成器架构设计及演变/12.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;把路由表嵌入到请求响应包看似很简单的架构变动，却是整个seqsvr容灾架构的技术奇点。利用它解决了路由状态不一致的问题后，可以实现一些以前不容易实现的特性。例如<strong>灵活的容灾策略，让所有机器都互为备机，在机器故障时，把故障机上的号段均匀地迁移到其它可用的AllocSvr上；还可以根据AllocSvr的负载情况，进行负载均衡，有效缓解AllocSvr请求不均的问题，大幅提升机器使用率</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;另外在运营上也得到了大幅简化。之前对机器进行运维操作有着繁杂的操作步骤，而新架构只需要更新路由即可轻松实现上线、下线、替换机器，<strong>不需要关心配置文件不一致的问题，避免了一些由于人工误操作引发的故障</strong>。</p>
<p><img src="//blog.com/2019/04/04/万亿级调用系统：微信序列号生成器架构设计及演变/13.webp" alt="img"></p>
<h3 id="路由同步优化"><a href="#路由同步优化" class="headerlink" title="路由同步优化"></a><strong>路由同步优化</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;把路由表嵌入到取sequence的请求响应包中，那么会引入一个类似“先有鸡还是先有蛋”的哲学命题：没有路由表，怎么知道去哪台AllocSvr取路由表？另外，取sequence是一个超高频的请求，如何避免嵌入路由表带来的带宽消耗？</p>
<p>这里通过<strong>在Client端内存缓存路由表以及路由版本号来解决</strong>，请求步骤如下：</p>
<blockquote>
<ol>
<li>Client根据本地共享内存缓存的路由表，选择对应的AllocSvr；如果路由表不存在，随机选择一台AllocSvr</li>
<li>对选中的AllocSvr发起请求，请求带上本地路由表的版本号</li>
<li>AllocSvr收到请求，除了处理sequence逻辑外，<strong>判断Client带上版本号是否最新，如果是旧版则在响应包中附上最新的路由表</strong></li>
<li>Client收到响应包，除了处理sequence逻辑外，判断响应包是否带有新路由表。<strong>如果有，更新本地路由表，并决策是否返回第1步重试</strong></li>
</ol>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;基于以上的请求步骤，在本地路由表失效的时候，使用少量的重试便可以拉到正确的路由，正常提供服务。重试便可以拉到正确的路由，正常提供服务。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/102/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/102/">102</a><span class="page-number current">103</span><a class="page-number" href="/page/104/">104</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/104/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
