<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/page/42/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/page/42/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/16/关于分布式事务、两阶段提交协议、三阶提交协议/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/16/关于分布式事务、两阶段提交协议、三阶提交协议/" itemprop="url">关于分布式事务、两阶段提交协议、三阶提交协议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-16T12:12:57+08:00">
                2019-06-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/分布式事务/" itemprop="url" rel="index">
                    <span itemprop="name">分布式事务</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关于分布式事务、两阶段提交协议、三阶提交协议"><a href="#关于分布式事务、两阶段提交协议、三阶提交协议" class="headerlink" title="关于分布式事务、两阶段提交协议、三阶提交协议"></a>关于分布式事务、两阶段提交协议、三阶提交协议</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s/o2Hm-2JdBB-8dSyDYCaqew" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/o2Hm-2JdBB-8dSyDYCaqew</a></p>
</blockquote>
<p><br></p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随着大型网站的各种高并发访问、海量数据处理等场景越来越多，如何实现网站的高可用、易伸缩、可扩展、安全等目标就显得越来越重要。为了解决这样一系列问题，大型网站的架构也在不断发展。提高大型网站的高可用架构，不得不提的就是分布式。在<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=402369369&amp;idx=1&amp;sn=f48638cf81162f11a4710647ad81bb1a&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">分布式一致性</a>一文中主要介绍了分布式系统中存在的一致性问题。本文将简单介绍如何有效的解决分布式的一致性问题,其中包括什么是<strong>分布式事务</strong>，<strong>二阶段提交</strong>和<strong>三阶段提交</strong>。</p>
</blockquote>
<h2 id="分布式一致性回顾"><a href="#分布式一致性回顾" class="headerlink" title="分布式一致性回顾"></a>分布式一致性回顾</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在分布式系统中，为了保证数据的高可用，通常，我们会将数据保留多个副本(<code>replica</code>)，这些副本会放置在不同的物理的机器上。为了对用户提供正确的增\删\改\差等语义，我们需要<strong>保证这些放置在不同物理机器上的副本是一致的</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解决这种分布式一致性问题，前人在性能和数据一致性的反反复复权衡过程中总结了许多典型的协议和算法。其中比较著名的有<strong>二阶提交协议</strong>（<code>Two Phase Commitment Protocol</code>）、<strong>三阶提交协议</strong>（<code>Three Phase Commitment Protocol</code>）和<strong>Paxos算法</strong>。</p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分布式事务是指会涉及到操作多个数据库的事务。其实就是将对同一库事务的概念扩大到了对多个库的事务。目的是为了保证分布式系统中的数据一致性。<strong>分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）</strong></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。由于存在事务机制，可以保证每个独立节点上的数据操作可以满足<code>ACID</code>。但是，<strong>相互独立的节点之间无法准确的知道其他节点中的事务执行情况</strong>。所以从理论上讲，两台机器理论上无法达到一致的状态。如果想让分布式部署的多台机器中的数据保持一致性，那么就要保证在所有节点的数据写操作，要不全部都执行，要么全部的都不执行。但是，一台机器在执行本地事务的时候无法知道其他机器中的本地事务的执行结果。所以他也就不知道本次事务到底应该<code>commit</code>还是 <code>roolback</code>。所以，<strong>常规的解决办法就是引入一个“协调者”的组件来统一调度所有分布式节点的执行</strong>。</p>
<h2 id="XA规范"><a href="#XA规范" class="headerlink" title="XA规范"></a>XA规范</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>X/Open 组织</code>（即现在的 <code>Open Group</code>）定义了分布式事务处理模型。<code>X/Open DTP</code>模型（ 1994 ）包括应用程序（ <code>AP</code>）、事务管理器（ <code>TM</code>）、资源管理器（<code>RM</code> ）、通信资源管理器（ <code>CRM</code>）四部分。一般，常见的事务管理器（ <code>TM</code> ）是交易中间件，常见的资源管理器（<code>RM</code>）是数据库，常见的通信资源管理器（<code>CRM</code>）是消息中间件。    </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常把一个数据库内部的事务处理，如对多个表的操作，作为本地事务看待。数据库的事务处理对象是本地事务，而分布式事务处理的对象是全局事务。   </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>所谓全局事务，是指分布式事务处理环境中，多个数据库可能需要共同完成一个工作，这个工作即是一个全局事务</strong>，例如，一个事务中可能更新几个不同的数据库。对数据库的操作发生在系统的各处但必须全部被提交或回滚。此时<strong>一个数据库对自己内部所做操作的提交不仅依赖本身操作是否成功，还要依赖与全局事务相关的其它数据库的操作是否成功，如果任一数据库的任一操作失败，则参与此事务的所有数据库所做的所有操作都必须回滚</strong>。    </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一般情况下，某一数据库无法知道其它数据库在做什么，因此，<strong>在一个<code>DTP</code>环境中，交易中间件是必需的，由它通知和协调相关数据库的提交或回滚</strong>。而一个数据库只将其自己所做的操作（可恢复）影射到全局事务中。    </p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>XA</code> 就是<code>X/Open DTP</code> 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。 <code>XA</code> 接口函数由数据库厂商提供。 </p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>二阶提交协议</strong>和<strong>三阶提交协议</strong>就是根据这一思想衍生出来的。可以说二阶段提交其实就是实现<strong>XA分布式事务</strong>的关键(确切地说：<strong>两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做</strong>)</p>
<h2 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h2><blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二阶段提交(<code>Two-phaseCommit</code>)是指，在计算机网络以及数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(<code>Algorithm</code>)。通常，二阶段提交也被称为是一种协议(<code>Protocol</code>)。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的<code>ACID</code>特性，需要<strong>引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交</strong>(比如将更新后的数据写入磁盘等等)。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，<strong>二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</strong></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓的两个阶段是指：第一阶段：<strong>准备阶段(投票阶段)</strong>和第二阶段：<strong>提交阶段（执行阶段）</strong>。</p>
<h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务协调者(事务管理器)给每个参与者(资源管理器)<strong>发送<code>Prepare</code>消息</strong>，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，<strong>写本地的<code>redo</code>和<code>undo</code>日志，但不提交</strong>，到达一种“万事俱备，只欠东风”的状态。</p>
<p>可以进一步将准备阶段分为以下三个步骤：</p>
<blockquote>
<p>1）协调者节点向所有参与者节点询问是否可以执行提交操作(<code>vote</code>)，并开始等待各参与者节点的响应。</p>
<p>2）参与者节点执行询问发起为止的所有事务操作，并将<code>Undo</code>信息和<code>Redo</code>信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）</p>
<p>3）各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</p>
</blockquote>
<h3 id="提交阶段"><a href="#提交阶段" class="headerlink" title="提交阶段"></a>提交阶段</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(<code>Rollback</code>)消息；否则，发送提交(<code>Commit</code>)消息；<strong>参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源</strong>。(注意:<strong>必须在最后阶段释放锁资源</strong>)</p>
<p>接下来分两种情况分别讨论提交阶段的过程。</p>
<p>当协调者节点从所有参与者节点获得的相应消息都为”同意”时:</p>
<p><img src="//blog.com/2019/06/16/关于分布式事务、两阶段提交协议、三阶提交协议/6fuT3emWI5Lqut1j2qrFBIK8ATlownEHAQHeVHOMrvVvicqZPIOD2AZZbwIjXicuQcVU74ZFr1rQfYicOV79hbsYw.jpeg" alt="img"></p>
<blockquote>
<p>1）协调者节点向所有参与者节点发出”正式提交(<code>commit</code>)”的请求。</p>
<p>2）<strong>参与者节点正式完成操作，并释放在整个事务期间内占用的资源</strong>。</p>
<p>3）参与者节点向协调者节点发送”完成”消息。</p>
<p>4）协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果任一参与者节点在第一阶段返回的响应消息为<strong>“中止”</strong>，或者 协调者节点在第一阶段的询问<strong>超时</strong>之前无法获取所有参与者节点的响应消息时：</p>
<p><img src="//blog.com/2019/06/16/关于分布式事务、两阶段提交协议、三阶提交协议/6fuT3emWI5Lqut1j2qrFBIK8ATlownEHQKLQWM7tXezNPhYic8puWsTIL8DlIfOrkbMjZrQF7TtU9iauTAia6Xrwg.jpeg" alt="img"></p>
<blockquote>
<p>1）协调者节点向所有参与者节点发出”回滚操作(<code>rollback</code>)”的请求。</p>
<p>2）<strong>参与者节点利用之前写入的<code>Undo</code>信息执行回滚，并释放在整个事务期间内占用的资源</strong>。</p>
<p>3）参与者节点向协调者节点发送”回滚完成”消息。</p>
<p>4）协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</p>
</blockquote>
<p>　　不管最后结果如何，第二阶段都会结束当前事务。</p>
<h3 id="两阶段提交存在的缺陷"><a href="#两阶段提交存在的缺陷" class="headerlink" title="两阶段提交存在的缺陷"></a>两阶段提交存在的缺陷</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>二阶段提交看起来确实能够提供原子性的操作</strong>，但是不幸的事，二阶段提交还是有几个<strong>缺点</strong>的：</p>
<h4 id="同步阻塞问题"><a href="#同步阻塞问题" class="headerlink" title="同步阻塞问题"></a>同步阻塞问题</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</p>
<h4 id="单点故障"><a href="#单点故障" class="headerlink" title="单点故障"></a>单点故障</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于协调者的重要性，<strong>一旦协调者发生故障。参与者会一直阻塞下去</strong>。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</p>
<h4 id="数据不一致"><a href="#数据不一致" class="headerlink" title="数据不一致"></a>数据不一致</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在二阶段提交的阶段二中，当协调者向参与者发送<code>commit</code>请求之后，发生了局部网络异常或者在发送<code>commit</code>请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了<code>commit</code>请求。而在这部分参与者接到<code>commit</code>请求之后就会执行<code>commit</code>操作。但是其他部分未接到<code>commit</code>请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</p>
<h4 id="二阶段无法解决的问题"><a href="#二阶段无法解决的问题" class="headerlink" title="二阶段无法解决的问题"></a>二阶段无法解决的问题</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;协调者再发出<code>commit</code>消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么<strong>即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷，所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。</p>
<h2 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h2><blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三阶段提交（<code>Three-phase commit</code>），也叫三阶段提交协议（<code>Three-phase commit protocol</code>），是二阶段提交（<code>2PC</code>）的改进版本。</p>
</blockquote>
<p><img src="//blog.com/2019/06/16/关于分布式事务、两阶段提交协议、三阶提交协议/6fuT3emWI5Lqut1j2qrFBIK8ATlownEHN6HxHibONgPYq84xyFmBt3o4j1nSib2Fzfyy8ZrwzBxwEibsUxqkqj9Ww.jpeg" alt="img"></p>
<p>与两阶段提交不同的是，三阶段提交有两个改动点。</p>
<blockquote>
<p>1、引入超时机制。同时<strong>在协调者和参与者中都引入超时机制</strong>。</p>
<p>2、在第一阶段和第二阶段中插入一个准备阶段。保证了<strong>在最后提交阶段之前各参与节点的状态是一致的</strong>。 </p>
<p>​      第一阶段：保证所有资源满足条件后才进行第二阶段</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是说，除了引入超时机制之外，<code>3PC</code>把<code>2PC</code>的准备阶段再次一分为二，这样三阶段提交就有<code>CanCommit</code>、<code>PreCommit</code>、<code>DoCommit</code>三个阶段。</p>
<h3 id="CanCommit阶段"><a href="#CanCommit阶段" class="headerlink" title="CanCommit阶段"></a>CanCommit阶段</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>3PC</code>的<code>CanCommit</code>阶段其实和<code>2PC</code>的准备阶段很像。协调者向参与者发送<code>CanCommit</code>请求，参与者如果可以提交就返回<code>Yes</code>响应，否则返回<code>No</code>响应。</p>
<blockquote>
<p><strong>1.事务询问</strong> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;协调者向参与者发送<code>CanCommit</code>请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</p>
<p><strong>2.响应反馈</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 参与者接到<code>CanCommit</code>请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No</p>
</blockquote>
<blockquote>
<p>解决检查资源是否满足条件</p>
</blockquote>
<h3 id="PreCommit阶段"><a href="#PreCommit阶段" class="headerlink" title="PreCommit阶段"></a>PreCommit阶段</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;协调者根据参与者的反应情况来决定是否可以记性事务的<code>PreCommit</code>操作。根据响应情况，有以下两种可能：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。</strong></p>
<blockquote>
<p><strong>1.发送预提交请求</strong> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;协调者向参与者发送<code>PreCommit</code>请求，并进入<code>Prepared</code>阶段。</p>
<p><strong>2.事务预提交</strong> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>参与者接收到<code>PreCommit</code>请求后，会执行事务操作，并将<code>undo</code>和<code>redo</code>信息记录到事务日志中</strong>。</p>
<p><strong>3.响应反馈</strong> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果参与者成功的执行了事务操作，则返回<code>ACK</code>响应，同时开始等待最终指令。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</strong></p>
<blockquote>
<p><strong>1.发送中断请求</strong> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;协调者向所有参与者发送<code>abort</code>请求。</p>
<p><strong>2.中断事务</strong> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>参与者收到来自协调者的<code>abort</code>请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断</strong>。</p>
</blockquote>
<h3 id="doCommit阶段"><a href="#doCommit阶段" class="headerlink" title="doCommit阶段"></a>doCommit阶段</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该阶段进行真正的事务提交，也可以分为以下两种情况：</p>
<p><strong>执行提交</strong></p>
<blockquote>
<p><strong>1.发送提交请求</strong> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;协调接收到参与者发送的<code>ACK</code>响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送<code>doCommit</code>请求。</p>
<p><strong>2.事务提交</strong> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参与者接收到<code>doCommit</code>请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</p>
<p><strong>3.响应反馈</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 事务提交完之后，向协调者发送<code>Ack</code>响应。</p>
<p><strong>4.完成事务</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 协调者接收到所有参与者的<code>ack</code>响应之后，完成事务。</p>
</blockquote>
<p><strong>中断事务</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;协调者没有接收到参与者在第二阶段发送的<code>ACK</code>响应（<strong>可能是接受者发送的不是<code>ACK</code>响应，也可能响应超时</strong>），那么就会执行中断事务。</p>
<blockquote>
<p><strong>1.发送中断请求</strong> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;协调者向所有参与者发送<code>abort</code>请求</p>
<p><strong>2.事务回滚</strong> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>参与者接收到<code>abort</code>请求之后，利用其在阶段二记录的<code>undo</code>信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源</strong>。</p>
<p><strong>3.反馈结果</strong> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参与者完成事务回滚之后，向协调者发送<code>ACK</code>消息</p>
<p><strong>4.中断事务</strong> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;协调者接收到参与者反馈的<code>ACK</code>消息之后，执行事务的中断。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在<code>doCommit</code>阶段，如果参与者无法及时接收到来自协调者的<code>doCommit</code>或者<code>rebort</code>请求时，会在等待超时之后，会继续进行事务的提交</strong>。（其实这个应该是基于概率来决定的，<strong>当进入第三阶段时，说明参与者在第二阶段已经收到了<code>PreCommit</code>请求</strong>，那么协调者产生<code>PreCommit</code>请求的前提条件是他在第二阶段开始之前，收到所有参与者的<code>CanCommit</code>响应都是Yes。（一旦参与者收到了<code>PreCommit</code>，意味他知道大家其实都同意修改了）所以，一句话概括就是，<strong>当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到<code>commit</code>或者<code>abort</code>响应，但是他有理由相信：成功提交的几率很大</strong>。 ）</p>
<blockquote>
<p>第一阶段协调者接收响应超时  =&gt;  第二阶段发起<code>abort</code>请求，回滚  【如在第二阶段协调者宕机了，也没有什么影响，没有发起<code>PreCommit</code>，没有锁定资源】</p>
<p>第二阶段协调者接收响应超时  =&gt;  第三阶段发起<code>rebort</code>请求，回滚</p>
<p>参与者超时未接收到<code>PreCommit</code> 请求  =&gt;  自动回滚</p>
<p>参与者超时未接收到<code>doCommit</code>  请求 =&gt;  自动提交 ，但存在<strong>数据一致性问题</strong></p>
<p>（由于网络原因，协调者发送的<code>abort</code>响应没有及时被参与者接收到，那么参与者在等待超时之后执行了<code>commit</code>操作。这样就和其他接到<code>abort</code>命令并执行回滚的参与者之间存在数据不一致的情况。）</p>
</blockquote>
<h2 id="2PC与3PC的区别"><a href="#2PC与3PC的区别" class="headerlink" title="2PC与3PC的区别"></a>2PC与3PC的区别</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相对于<code>2PC</code>，<code>3PC</code>主要解决的单点故障问题，并减少阻塞，因为<strong>一旦参与者无法及时收到来自协调者的信息之后，他会默认执行<code>commit</code></strong>。而不会一直持有事务资源并处于阻塞状态。但是这种机制也会导致数据一致性问题，因为，<strong>由于网络原因，协调者发送的<code>abort</code>响应没有及时被参与者接收到，那么参与者在等待超时之后执行了<code>commit</code>操作</strong>。这样就和其他接到<code>abort</code>命令并执行回滚的参与者之间存在数据不一致的情况。</p>
<hr>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;了解了<code>2PC</code>和<code>3PC</code>之后，我们可以发现，<strong>无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题</strong>。Google Chubby的作者Mike Burrows说过， </p>
<blockquote>
<p>there is only one consensus protocol, and that’s Paxos” – all other approaches are just broken versions of Paxos.</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;意即<strong>世上只有一种一致性算法，那就是Paxos</strong>，所有其他一致性算法都是<code>Paxos</code>算法的不完整版。后面的文章会介绍这个公认为难于理解但是行之有效的<code>Paxos</code>算法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/16/分布式事务解决方案汇总/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/16/分布式事务解决方案汇总/" itemprop="url">分布式事务解决方案汇总</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-16T12:12:57+08:00">
                2019-06-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/分布式事务/" itemprop="url" rel="index">
                    <span itemprop="name">分布式事务</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分布式事务解决方案汇总"><a href="#分布式事务解决方案汇总" class="headerlink" title="分布式事务解决方案汇总"></a>分布式事务解决方案汇总</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s/7u5zfrLzk38tDwOfDEkuqw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/7u5zfrLzk38tDwOfDEkuqw</a></p>
</blockquote>
<p><br></p>
<h2 id="随处可见的分布式事务问题"><a href="#随处可见的分布式事务问题" class="headerlink" title="随处可见的分布式事务问题"></a>随处可见的分布式事务问题</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在“集中式”的架构中，很多系统用的是<code>Oracle</code>这种大型数据库，把整个业务数据放在这样一个强大的数据库里面，利用数据库的参照完整性机制、事务机制，避免出现数据一致性问题。这正是数据库之所以叫“数据库”而不是“存储”的一个重要原因，就是数据库强大的数据一致性保证。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但到了分布式时代，人们对数据库进行了分库分表，同时在上面架起一个个的服务。到了微服务时代，服务的粒度拆得更细，导致一个无法避免的问题：数据库的事务机制不管用了，因为数据库本身只能保证单机事务，对于分布式事务，只能靠业务系统解决。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如做一个服务，最初底下只有一个数据库，用数据库本身的事务来保证数据一致性。随着数据量增长到一定规模，进行了分库，这时数据库的事务就不管用了，<strong>如何保证多个库之间的数据一致性呢？</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再以电商系统为例，比如有两个服务，一个是订单服务，背后是订单数据库；一个是库存服务，背后是库存数据库，下订单的时候需要扣库存。无论先创建订单，后扣库存，还是先扣库存，后创建订单，都无法保证两个服务一定会调用成功，<strong>如何保证两个服务之间的数据一致性呢？</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样的案例在微服务架构中随处可见：凡是一个业务操作，需要调用多个服务，并且都是写操作的时候，就可能会出现有的服务调用成功，有的服务调用失败，导致只部分数据写入成功，也就出现了服务之间的数据不一致性。</p>
<h2 id="分布式事务解决方案汇总-1"><a href="#分布式事务解决方案汇总-1" class="headerlink" title="分布式事务解决方案汇总"></a>分布式事务解决方案汇总</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，以一个典型的分布式事务问题——“转账”为例，详细探讨分布式事务的各种解决方案。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以支付宝为例，要把一笔钱从支付宝的余额转账到余额宝，支付宝的余额在系统A，背后有对应的<code>DB1</code>；余额宝在系统B，背后有对应的<code>DB2</code>；蚂蚁借呗在系统C，背后有对应的<code>DB3</code>，这些系统之间都要支持相关转账。所谓“转账”，就是转出方的系统里面账号要扣钱，转入方的系统里面账号要加钱，如何保证两个操作在两个系统中同时成功呢？</p>
<h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><h4 id="2PC理论"><a href="#2PC理论" class="headerlink" title="2PC理论"></a>2PC理论</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在讲<code>MySQL Binlog</code>和<code>Redo Log</code>的一致性问题时，已经用到了<code>2PC</code>。当然，那个场景只是内部的分布式事务问题，只涉及单机的两个日志文件之间的数据一致性；<code>2PC</code>是应用在两个数据库或两个系统之间。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>2PC</code>有两个角色：事务协调者和事务参与者。具体到数据库的实现来说，每一个数据库就是一个参与者，调用方也就是协调者。<code>2PC</code>是指事务的提交分为两个阶段，如图10-1所示。</p>
<ul>
<li>阶段1：准备阶段。协调者向各个参与者发起询问，说要执行一个事务，各参与者可能回复<code>YES、NO</code>或超时。</li>
<li>阶段2：提交阶段。如果所有参与者都回复的是<code>YES</code>，则事务协调者向所有参与者发起事务提交操作，即<code>Commit</code>操作，所有参与者各自执行事务，然后发送<code>ACK</code>。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有一个参与者回复的是<code>NO</code>，或者超时了，则事务协调者向所有参与者发起事务回滚操作，所有参与者各自回滚事务，然后发送<code>ACK</code>，如图10-2所示。</p>
<p><img src="//blog.com/2019/06/16/分布式事务解决方案汇总/icNyEYk3VqGk4IOVlA6W3fnHWJLOsz6VeOQ00ADBtrSwwFJGeUSNY1icvvicpxiaSHEE5sAiaCK2zJ6ib3PbfMS5gTqQ.jpeg" alt="img"></p>
<p><em>2PC事务提交示意图</em></p>
<p><img src="//blog.com/2019/06/16/分布式事务解决方案汇总/icNyEYk3VqGk4IOVlA6W3fnHWJLOsz6VecYM0fXSm3vWPrWae2dZNKDAKNWvnFiajNBXZIJ21mc3XNboUwYUKsqQ.jpeg" alt="img"></p>
<p><em>事务回滚示意图</em></p>
<p>所以，无论事务提交，还是事务回滚，都是两个阶段。</p>
<h4 id="2PC的实现"><a href="#2PC的实现" class="headerlink" title="2PC的实现"></a>2PC的实现</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过分析可以发现，要实现<code>2PC</code>，<strong>所有参与者都要实现三个接口：<code>Prepare、Commit、Rollback</code>，这也就是<code>XA</code>协议</strong>，在<code>Java</code>中对应的接口是<code>javax.transaction.xa.XAResource</code>，通常的数据库也都实现了这个协议。开源的<code>Atomikos</code>也基于该协议提供了<code>2PC</code>的解决方案，有兴趣的读者可以进一步研究。</p>
<h4 id="2PC的问题"><a href="#2PC的问题" class="headerlink" title="2PC的问题"></a>2PC的问题</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>2PC</code>在数据库领域非常常见，但它存在几个问题：</p>
<ul>
<li>问题1：<strong>性能问题</strong>。在阶段1，锁定资源之后，要等所有节点返回，然后才能一起进入阶段2，不能很好地应对高并发场景。=&gt; <strong>锁住资源时间长</strong></li>
<li>问题2：阶段1完成之后，如果在阶段2事务<strong>协调者宕机</strong>，则所有的参与者接收不到<code>Commit</code>或<code>Rollback</code>指令，将处于<strong>“悬而不决”状态</strong>。 =&gt;  <strong>协调者宕机后，参与者不知道如何处理，资源一直被锁住</strong></li>
<li>问题3：阶段1完成之后，在阶段2，事务协调者向所有的参与者发送了<code>Commit</code>指令，但其中一个参与者超时或出错了（没有正确返回<code>ACK</code>），则其他参与者提交还是回滚呢？ 也不能确定。=&gt; <strong>数据一致性问题</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解决<code>2PC</code>的问题，又引入了<code>3PC</code>。<code>3PC</code>存在类似宕机如何解决的问题，因此还是没能彻底解决问题，此处不再详述。</p>
<blockquote>
<p>增加了超时控制，超时后自动提交或回滚，防止资源一直被锁住，但仍然存在数据一致性问题</p>
<p>增加了资源预检阶段</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>2PC</code>除本身的算法局限外，还有一个使用上的限制，就是它<strong>主要用在两个数据库之间（数据库实现了<code>XA</code>协议）</strong>。但以支付宝的转账为例，是两个系统之间的转账，而不是底层两个数据库之间直接交互，所以没有办法使用<code>2PC</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不仅支付宝，其他业务场景基本都采用了微服务架构，不会直接在底层的两个业务数据库之间做一致性，而是在两个服务上面实现一致性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正因为<code>2PC</code>有诸多问题和不便，在实践中一般很少使用，而是采用下面要讲的各种方案。</p>
<h3 id="最终一致性（消息中间件）"><a href="#最终一致性（消息中间件）" class="headerlink" title="最终一致性（消息中间件）"></a>最终一致性（消息中间件）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般的思路是通过消息中间件来实现<strong>“最终一致性”</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统A收到用户的转账请求，系统A先自己扣钱，也就是更新<code>DB1</code>；然后通过消息中间件给系统B发送一条加钱的消息，系统B收到此消息，对自己的账号进行加钱，也就是更新<code>DB2</code>。</p>
<p>这里面有一个<strong>关键的技术问题</strong>：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统A给消息中间件发消息，是一次网络交互；更新<code>DB1</code>，也是一次网络交互。系统A是先更新<code>DB1</code>，后发送消息，还是先发送消息，后更新<code>DB1</code>？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设先更新<code>DB1</code>成功，发送消息网络失败，重发又失败，怎么办？又假设先发送消息成功，更新<code>DB1</code>失败。消息已经发出去了，又不能撤回，怎么办？或者消息中间件提供了消息撤回的接口，但是又调用失败怎么办？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为这是<strong>两次网络调用，两个操作不是原子的，无论谁先谁后，都是有问题的</strong>。</p>
<p><img src="//blog.com/2019/06/16/分布式事务解决方案汇总/icNyEYk3VqGk4IOVlA6W3fnHWJLOsz6VeOR8E4VNhg9d66TYQ3d9RNtedhGxE6mz8bCUuWtnolbBIPoPTd5E9jQ.jpeg" alt="img"></p>
<p><em>消息中间件实现最终一致性</em></p>
<p>下面来看最终一致性的几种具体实现思路：</p>
<h4 id="最终一致性：错误的方案0"><a href="#最终一致性：错误的方案0" class="headerlink" title="最终一致性：错误的方案0"></a>最终一致性：错误的方案0</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有人可能会想，可以把“发送加钱消息”这个网络调用和更新<code>DB1</code>放在同一个事务里面，如果发送消息失败，更新<code>DB</code>自动回滚。这样不就可以保证两个操作的原子性了吗？</p>
<p>这个方案看似正确，其实是错误的，原因有两点：</p>
<p>（1）网络的2将军问题：发送消息失败，<strong>发送方并不知道是消息中间件没有收到消息，还是消息已经收到了，只是返回<code>response</code>的时候失败了</strong>？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>如果已经收到消息了，而发送端认为没有收到，执行<code>update DB</code>的回滚操作，则会导致账户A的钱没有扣，账户B的钱却被加了</strong>。</p>
<p>（2）把网络调用放在数据库事务里面，<strong>可能会因为网络的延时导致数据库长事务</strong>。严重的会阻塞整个数据库，风险很大。</p>
<h4 id="最终一致性：第1种实现方式（业务方自己实现）"><a href="#最终一致性：第1种实现方式（业务方自己实现）" class="headerlink" title="最终一致性：第1种实现方式（业务方自己实现）"></a>最终一致性：第1种实现方式（业务方自己实现）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设消息中间件没有提供“事务消息”功能，比如用的是<code>Kafka</code>。该如何解决这个问题呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;消息中间件实现最终一致性示意图如图所示。</p>
<p>（1）系统A<strong>增加一张消息表</strong>，系统A不再直接给消息中间件发送消息，而是<strong>把消息写入到这张消息表中</strong>。</p>
<p>​         把<code>DB1</code>的扣钱操作（表1）和写入消息表（表2）这两个操作<strong>放在一个数据库事务里，保证两者的原子性</strong>。</p>
<p><img src="//blog.com/2019/06/16/分布式事务解决方案汇总/icNyEYk3VqGk4IOVlA6W3fnHWJLOsz6Ve3dgoU40NqVJpaoiayFnL3ywml6IWXuadYxpCKS5V3euptibnr8ibiav9jg.jpeg" alt="img"></p>
<p><em>消息中间件实现最终一致性示意图</em></p>
<p>（2）系统A准备一个<strong>后台程序，源源不断地把消息表中的消息传送给消息中间件</strong>。如果失败了，也不断尝试<strong>重传</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为网络的2将军问题，系统A发送给消息中间件的消息网络超时了，消息中间件可能已经收到了消息，也可能没有收到。系统A会再次发送该消息，直到消息中间件返回成功。所以，<strong>系统A允许消息重复，但消息不会丢失，顺序也不会打乱</strong>。</p>
<p>（3）通过上面的两个步骤，系统A<strong>保证了消息不丢失，但消息可能重复</strong>。系统B对消息的消费要解决下面两个问题：</p>
<p>问题1：<strong>丢失消费</strong>。系统B从消息中间件取出消息（此时还在内存里面），如果处理了一半，系统B宕机并再次重启，此时这条消息未处理成功，怎么办？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案：通过<strong>消息中间件的<code>ACK</code>机制</strong>，凡是发送<code>ACK</code>的消息，系统B重启之后消息中间件不会再次推送；凡是没有发送<code>ACK</code>的消息，系统B重启之后消息中间件会再次推送。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但这又会引发一个新问题，就是下面问题2的重复消费：即使系统B把消息处理成功了，但是正要<strong>发送ACK的时候宕机了，消息中间件以为这条消息没有处理成功，系统B再次重启的时候又会收到这条消息，系统B就会重复消费这条消息</strong>（对应加钱类的场景，账号里面的钱就会加两次）</p>
<p>问题2：<strong>重复消费</strong>。除了<code>ACK</code>机制，可能会引起重复消费；系统A的后台任务也可能给消息中间件重复发送消息。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解决重复消息的问题，<strong>系统B增加一个判重表。判重表记录了处理成功的消息ID和消息中间件对应的offset</strong>（以<code>Kafka</code>为例），系统B宕机重启，可以定位到<code>offset</code>位置，从这之后开始继续消费。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次接收到新消息，<strong>先通过判重表进行判重，实现业务的幂等</strong>。同样，对<code>DB2</code>的加钱<strong>操作和消息写入判重表两个操作，要在一个DB的事务里面完成</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里要补充的是，消息的判重不止判重表一种方法。<strong>如果业务本身就有业务数据，可以判断出消息是否重复了，就不需要判重表了</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上面三步，实现了消息在发送方的不丢失、在接收方的不重复，联合起来就是消息的不漏不重，严格实现了系统A和系统B的最终一致性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但这种方案有一个缺点：<strong>系统A需要增加消息表，同时还需要一个后台任务，不断扫描此消息表，会导致消息的处理和业务逻辑耦合，额外增加业务方的开发负担</strong>。</p>
<h4 id="最终一致性：第二种实现方式（基于RocketMQ事务消息）"><a href="#最终一致性：第二种实现方式（基于RocketMQ事务消息）" class="headerlink" title="最终一致性：第二种实现方式（基于RocketMQ事务消息）"></a>最终一致性：第二种实现方式（基于RocketMQ事务消息）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了能通过消息中间件解决该问题，同时又不和业务耦合，<code>RocketMQ</code>提出了<strong>“事务消息”</strong>的概念，如图所示。</p>
<p><img src="//blog.com/2019/06/16/分布式事务解决方案汇总/icNyEYk3VqGk4IOVlA6W3fnHWJLOsz6VeGkqO3jcENN3soic79onicPSibdxyc6qj1elllhzIG71UAgFryq64LaicRA.jpeg" alt="img"></p>
<p><em>RocketMQ事务消息示意图</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RocketMQ</code>不是提供一个单一的“发送”接口，而是<strong>把消息的发送拆成了两个阶段，Prepare阶段（消息预发送）和Confirm阶段（确认发送）</strong>。具体使用方法如下：</p>
<p>步骤1：系统A调用<code>Prepare</code>接口，预发送消息。此时消息保存在消息中间件里，但消息中间件不会把消息给消费方消费，消息只是暂存在那。</p>
<p>步骤2：系统A更新数据库，进行扣钱操作。</p>
<p>步骤3：系统A调用<code>Comfirm</code>接口，确认发送消息。此时消息中间件才会把消息给消费方进行消费。</p>
<p>显然，这里有两种异常场景：</p>
<p>场景1：步骤1成功，步骤2成功，步骤3失败或超时，怎么处理？</p>
<p>场景2：步骤1成功，步骤2失败或超时，步骤3不会执行。怎么处理？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就涉及<code>RocketMQ</code>的关键点：<code>RocketMQ</code>会<strong>定期（默认是<code>1min</code>）扫描所有的预发送但还没有确认的消息，回调给发送方，询问这条消息是要发出去，还是取消</strong>。发送方根据自己的业务数据，知道这条消息是应该发出去（<code>DB</code>更新成功了），还是应该取消（<code>DB</code>更新失败）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对比最终一致性的两种实现方案会发现，<strong><code>RocketMQ</code>最大的改变其实是把“扫描消息表”这件事不让业务方做，而是让消息中间件完成</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至于消息表，其实还是没有省掉。因为消息中间件要询问发送方事物是否执行成功，还需要一个<strong>“变相的本地消息表”</strong>，记录事务执行状态和消息发送状态。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时<strong>对于消费方，还是没有解决系统重启可能导致的重复消费问题，这只能由消费方解决</strong>。<strong>需要设计判重机制，实现消息消费的幂等</strong>。</p>
<h4 id="人工介入"><a href="#人工介入" class="headerlink" title="人工介入"></a>人工介入</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论方案1，还是方案2，发送端把消息成功放入了队列中，但如果消费端消费失败怎么办？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果消费失败了，则可以重试，但还一直失败怎么办？是否要自动回滚整个流程？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案是人工介入。从工程实践角度来讲，这种整个流程自动回滚的代价是非常巨大的，不但实现起来很复杂，还会引入新的问题。比如自动回滚失败，又如何处理？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>对应这种发生概率极低的事件，采取人工处理会比实现一个高复杂的自动化回滚系统更加可靠，也更加简单</strong>。</p>
<h3 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>2PC</code>通常用来解决两个数据库之间的分布式事务问题，比较局限。现在企业采用的是各式各样的<code>SOA</code>服务，更需要解决两个服务之间的分布式事务问题。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解决<code>SOA</code>系统中的分布式事务问题，支付宝提出了<code>TCC</code>。<code>TCC</code>是<code>Try、Confirm、Cancel</code>三个单词的缩写，其实是一个<strong>应用层面的<code>2PC</code>协议</strong>，<code>Confirm</code>对应<code>2PC</code>中的事务提交操作，<code>Cancel</code>对应<code>2PC</code>中的事务回滚操作，如图所示。</p>
<p>（1）准备阶段：调用方调用所有服务方提供的<code>Try</code>接口，该阶段各调用方做资源检查和资源锁定，为接下来的阶段2做准备。</p>
<p>（2）提交阶段：如果所有服务方都返回<code>YES</code>，则进入提交阶段，事务管理器调用各服务方的<code>Confirm</code>接口，各服务方进行事务提交。如果有一个服务方在阶段1返回<code>NO</code>或者超时了，则事务管理器调用各服务方的<code>Cancel</code>接口。</p>
<p><img src="//blog.com/2019/06/16/分布式事务解决方案汇总/icNyEYk3VqGk4IOVlA6W3fnHWJLOsz6VeKeFbvPOlL2NJ2w972bBVyXufZVdGAibqGl63berwVSmUP0MxTg6xbZA.jpeg" alt="img"></p>
<p><em>TCC事务提交示意图</em></p>
<p><img src="//blog.com/2019/06/16/分布式事务解决方案汇总/icNyEYk3VqGk4IOVlA6W3fnHWJLOsz6VeHHT4EWMjzdJ3tMQbMzLPmic6dydcOeqkSG8ZBmoYmmibfCtpN6gKMaXg.jpeg" alt="img"></p>
<p><em>TCC事务回滚示意图</em></p>
<p><strong>修正一下：try是由调用方发起的，confirm/cancel是由事务管理器发起的，图中的调用方有一点点问题</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里有一个关键问题：<code>TCC</code>既然也借鉴<code>2PC</code>的思路，那么它是如何解决<code>2PC</code>的问题的呢？也就是说，在阶段2，调用方发生宕机，或者某个服务超时了，如何处理呢？</p>
<p>答案是：<strong>不断重试</strong>！不管是<code>Confirm</code>失败了，还是<code>Cancel</code>失败了，都不断重试。这就<strong>要求<code>Confirm</code>和<code>Cancel</code>都必须是幂等操作</strong>。注意，这里的<strong>重试是由事务管理器来执行的，而不是让业务方自己去做</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面以一个转账的事件为例，来说明<code>TCC</code>的过程。假设有三个账号A、B、C，通过<code>SO</code>A提供的转账服务操作。A、B同时分别要向C转30元、50元，最后C的账号<code>+80</code>元，A、B各减30元、50元。</p>
<p>阶段1：分别对账号A、B、C执行<code>Try</code>操作，A、B、C三个账号在三个不同的<code>SOA</code>服务里面，也就是分别调用三个服务的<code>Try</code>接口。具体来说，就是账号A锁定30元，账号B锁定50元，检查账号C的合法性，比如账号C是否违法被冻结，账号C是否已注销。</p>
<blockquote>
<p>这里的锁定我认为就是增加一个字段，预变更金额  ，更新预变更金额的值  即-30  -50  </p>
<p>后续的并发请求判断金额时要从可用金额中扣掉预变更金额   即<strong>转账金额 &lt;= 可用金额 - 预变更金额</strong></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，在这个场景里面，对应的“扣钱”的Try操作就是“锁定”，对应的“加钱”的Try操作就是检查账号合法性，为的是保证接下来的阶段2扣钱可扣、加钱可加！</p>
<p>阶段2：A、B、C的Try操作都成功，执行<code>Confirm</code>操作，即分别调用三个<code>SOA</code>服务的<code>Confirm</code>接口。A、B扣钱，C加钱。如果任意一个失败，则不断重试，直到成功为止。</p>
<blockquote>
<p>A、B更新可用金额、预变更金额   =》 可用金额 = 可用金额  +  预变更金额    预变更金额  = 0</p>
<p>C更新可用金额 =&gt; 可用金额 += 80</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从案例可以看出，<code>Try</code>操作主要是为了“保证业务操作的前置条件都得到满足”，然后在<code>Confirm</code>阶段，因为前置条件都满足了，所以可以不断重试保证成功。</p>
<h3 id="事务状态表-调用方重试-接收方幂等"><a href="#事务状态表-调用方重试-接收方幂等" class="headerlink" title="事务状态表+调用方重试+接收方幂等"></a>事务状态表+调用方重试+接收方幂等</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样以转账为例，介绍一种类似于<code>TCC</code>的方法。<code>TCC</code>的方法通过<code>TCC</code>框架内部来做，下面介绍的方法是业务方自己实现的。</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>参与者仍然要实现3个接口（try、confirm、cancel），try成功以后，把要调用的接口信息、参数写入事务状态表接口，后台程序扫描重试，保证成功</strong></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>调用方维护一张事务状态表（或者说事务日志、日志流水），在每次调用之前，落盘一条事务流水，生成一个全局的事务ID</strong>。事务状态表的表结构如表1所示。</p>
<p><em>表1  事务状态表的表结构</em></p>
<table>
<thead>
<tr>
<th>事务ID</th>
<th>事 务 内 容</th>
<th>事务状态（枚举类型）</th>
</tr>
</thead>
<tbody>
<tr>
<td>ID1</td>
<td>操作1：账号A减30<br>操作2：账号B减50<br>操作3：账号C加80</td>
<td>状态1：初始<br>状态2：操作1成功<br>状态3：操作1、2成功<br>状态4：操作1、2、3成功</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初始是状态1，每调用成功1个服务则更新1次状态，最后所有系统调用成功，状态更新到状态4，状态2、3是中间状态。当然，也可以不保存中间状态，只设置两个状态：<code>Begin</code>和<code>End</code>。事务开始之前的状态是<code>Begin</code>，全部结束之后的状态是<code>End</code>。如果某个事务一直停留在<code>Begin</code>状态，则说明该事务没有执行完毕。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后<strong>有一个后台任务，扫描状态表，在过了某段时间后（假设1次事务执行成功通常最多花费30s），状态没有变为最终的状态4，说明这条事务没有执行成功</strong>。于是重新调用系统A、B、C。保证这条流水的最终状态是状态4（或<code>End</code>状态）。当然，<strong>系统A、B、C根据全局的事务ID做幂等操作，所以即使重复调用也没有关系</strong>。</p>
<p>补充说明：</p>
<p>（1）如果后台任务<strong>重试多次仍然不能成功，要为状态表加一个<code>Error</code>状态，通过人工介入干预</strong>。</p>
<p>（2）对于调用方的同步调用，如果部分成功，此时给客户端返回什么呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;答案是不确定，或者说暂时未知。只能告诉用户该笔钱转账超时，请稍后再来确认。</p>
<p>（3）对于同步调用，调用方调用A或B失败的时候，可以重试三次。如果重试三次还不成功，则放弃操作，再交由后台任务后续处理。</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;补充说明（2）（3）的意思是<code>confirm、cancel</code>接口首先还是由调用方取尝试调用，如果不成功，由后台进程扫描重试。不建议这么做，<strong>建议所有的<code>confirm、cancel</code>都有后台进程来发起调用，跟<code>tcc</code>一样，调用方只管<code>try</code>操作</strong>。</p>
</blockquote>
<h3 id="对账"><a href="#对账" class="headerlink" title="对账"></a>对账</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把上一节的方案扩展一下，岂止事务有状态，系统中的各种数据对象都有状态，或者说都有各自完整的生命周期，同时数据与数据之间存在着关联关系。我们可以很好地<strong>利用这种完整的生命周期和数据之间的关联关系，来实现系统的一致性，这就是“对账”</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前面，我们把注意力都放在了“过程”中，而在“对账”的思路中，将把注意力转移到“结果”中。什么意思呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前面的方案中，<strong>无论最终一致性，还是<code>TCC</code>、事务状态表，都是为了保证“过程的原子性”，也就是多个系统操作（或系统调用），要么全部成功，要么全部失败</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但所有的“过程”都必然产生“结果”，<strong>过程是我们所说的“事务”，结果就是业务数据</strong>。一个过程如果部分执行成功、部分执行失败，则意味着结果是不完整的。<strong>从结果也可以反推出过程出了问题，从而对数据进行修补，这就是“对账”的思路</strong>！</p>
<p>下面举几个对账的例子。</p>
<p><strong>案例1：</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;电商网站的订单履约系统。一张订单从“已支付”，到“下发给仓库”，到“出仓完成”。假定从“已支付”到“下发给仓库”最多用1个小时；从“下发给仓库”到“出仓完成”最多用8个小时。意味着只要发现1个订单的状态过了1个小时之后还处于“已支付”状态，就认为订单下发没有成功，需要重新下发，也就是“重试”。同样，只要发现订单过了8个小时还未出仓，这时可能会发出报警，仓库的作业系统是否出了问题……诸如此类。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个案例跟事务的状态很类似：<strong>一旦发现系统中的某个数据对象过了一个限定时间生命周期仍然没有走完，仍然处在某个中间状态，就说明系统不一致了，要进行某种补偿操作（比如重试或报警）</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;更复杂一点：订单有状态，库存系统的库存也有状态，优惠系统的优惠券也有状态，<strong>根据业务规则，这些状态之间进行比对，就能发现系统某个地方不一致，做相应的补偿</strong>。</p>
<p><strong>案例2：</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微博的关注关系。需要存两张表，一张是关注表，一张是粉丝表，这两张表各自都是分库分表的。假设A关注了B，需要先以A为主键进行分库，存入关注表；再以B为主键进行分库，存入粉丝表。也就是说，一次业务操作，要向两个数据库中写入两条数据，如何保证原子性？</p>
<p><strong>案例3：</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;电商的订单系统也是分库分表的。订单通常有两个常用的查询维度，一个是买家，一个是卖家。如果按买家分库，按卖家查询就不好做；如果按卖家分库，按买家查询就不好做。这种通常会把订单数据冗余一份，按买家进行分库分表存一份，按卖家再分库分表存一份。和案例2存在同样的问题：一个订单要向两个数据库中写入两条数据，如何保证原子性？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果把案例2、案例3的问题看作为一个分布式事务的话，可以用最终一致性、TCC、事务状态表去实现，但这些方法都太重，一个简单的方法是“对账”。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>因为两个库的数据是冗余的，可以先保证一个库的数据是准确的，以该库为基准校对另外一个库</strong>。</p>
<p>对账又分为全量对账和增量对账：</p>
<p>（1）全量对账。比如每天晚上运作一个定时任务，比对两个数据库。</p>
<p>（2）增量对账</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以是一个定时任务，基于数据库的更新时间；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也<strong>可以基于消息中间件，每一次业务操作都抛出一个消息到消息中间件，然后由一个消费者消费这条消息，对两个数据库中的数据进行比对（当然，消息可能丢失，无法百分之百地保证，还是需要全量对账来兜底）</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总之，<strong>对账的关键是要找出“数据背后的数学规律”</strong>。有些规律比较直接，谁都能看出来，比如案例2、案例3的冗余数据库；有些规律隐含一些，比如案例1的订单履约的状态。找到了规律就可以基于规律进行数据的比对，发现问题，然后补偿。</p>
<h3 id="妥协方案：弱一致性-基于状态的补偿"><a href="#妥协方案：弱一致性-基于状态的补偿" class="headerlink" title="妥协方案：弱一致性+基于状态的补偿"></a>妥协方案：弱一致性+基于状态的补偿</h3><p>可以发现：</p>
<ul>
<li>“最终一致性”是一种异步的方法，数据有一定延迟；</li>
<li><code>TCC</code>是一种异步方法，但<code>TCC</code>需要两个阶段，性能损耗较大；</li>
<li>事务状态表也是一种异步方法，但每次要记事务流水，要更新事务状态，很烦琐，性能也有损耗；</li>
<li>“对账”也是一个事后过程；</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要一个同步的方案，既要让系统之间保持一致性，又要有很高的性能，支持高并发，应该怎么处理呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;电商网站的下单至少需要两个操作：创建订单和扣库存。订单系统有订单的数据库和服务，库存系统有库存的数据库和服务。先创建订单，后扣库存，可能会创建订单成功，扣库存失败；反过来，先扣库存，后创建订单，可能会扣库存成功，创建订单失败。如何保证创建订单 + 扣库存两个操作的原子性，同时还要能抵抗线上的高并发流量？</p>
<p><img src="//blog.com/2019/06/16/分布式事务解决方案汇总/icNyEYk3VqGk4IOVlA6W3fnHWJLOsz6VeaNNaJVmVmtH6Qk72Z3TEJPMHrkzKbc14VOwNTLcoZ16SGJBKH4lIicQ.jpeg" alt="img"></p>
<p><em>电商系统的下单场景</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果用最终一致性方案，因为是异步操作，如果库存扣减不及时会导致超卖，因此最终一致性的方案不可行；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果用<code>TCC</code>方案，则意味着一个用户请求要调用两次（<code>Try</code>和<code>Confirm</code>）订单服务、两次（<code>Try</code>和<code>Confirm</code>）库存服务，性能又达不到要求；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果用事务状态表，要写事务状态，也存在性能问题；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既要满足高并发，又要达到一致性，鱼和熊掌不能兼得。可以利用业务的特性，采用一种弱一致的方案。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于该需求，有一个关键特性：对于电商的购物来讲，<strong>允许少卖，但不能超卖</strong>。比如有100件东西，卖给99个人，有1件没有卖出去，这是可以接受的；但如果卖给了101个人，其中1个人拿不到货，平台违约，这就不能接受。而该处就利用了这个特性，具体做法如下。</p>
<p><strong>方案1：先扣库存，后创建订单。</strong></p>
<p>如表2所示，有三种情况：</p>
<p>（1）扣库存成功，提交订单成功，返回成功。</p>
<p>（2）扣库存成功，提交订单失败，返回失败，调用方重试（此处可能会多扣库存）。</p>
<p>（3）扣库存失败，不再提交订单，返回失败，调用方重试。</p>
<p><em>表2  先扣库存后创建订单的三种情况</em></p>
<table>
<thead>
<tr>
<th></th>
<th>扣 库 存</th>
<th>创建订单</th>
<th>返回结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Case1</td>
<td>成功</td>
<td>成功</td>
<td>成功</td>
</tr>
<tr>
<td>Case2</td>
<td>成功</td>
<td>失败</td>
<td>失败</td>
</tr>
<tr>
<td>Case3</td>
<td>失败</td>
<td>无</td>
<td>失败</td>
</tr>
</tbody>
</table>
<p><strong>方案2：先创建订单，后扣库存。</strong></p>
<p>如表3所示，也有三种情况：</p>
<p>（1）提交订单成功，扣库存成功，返回成功。</p>
<p>（2）提交订单成功，扣库存失败，返回失败，调用方重试（此处可能会多扣库存）。</p>
<p>（3）提交订单失败，不再扣库存，调用方重试。</p>
<p><em>表3  先创建订单后扣库存的三种情况</em></p>
<table>
<thead>
<tr>
<th></th>
<th>创建订单</th>
<th>扣 库 存</th>
<th>返回结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Case1</td>
<td>成功</td>
<td>成功</td>
<td>成功</td>
</tr>
<tr>
<td>Case2</td>
<td>成功</td>
<td>失败</td>
<td>失败</td>
</tr>
<tr>
<td>Case3</td>
<td>失败</td>
<td>无</td>
<td>失败</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论方案1，还是方案2，<strong>只要最终保证库存可以少扣，不能多扣即可</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，库存多扣了，数据不一致，怎么补偿呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;库存每扣一次，都会生成一条流水记录。这条记录的初始状态是“占用”，等订单支付成功后，会把状态改成“释放”。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>对于那些过了很长时间一直是占用，而不释放的库存，要么是因为前面多扣造成的，要么是因为用户下了单但没有支付</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>通过比对，得到库存系统的“占用又没有释放的库存流水”与订单系统的未支付的订单，就可以回收这些库存，同时把对应的订单取消</strong>。类似12306网站，过一定时间不支付，订单会取消，将库存释放。</p>
<h3 id="妥协方案：重试-回滚-报警-人工修复"><a href="#妥协方案：重试-回滚-报警-人工修复" class="headerlink" title="妥协方案：重试+回滚+报警+人工修复"></a>妥协方案：重试+回滚+报警+人工修复</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上文介绍了基于订单的状态 +库存流水的状态做补偿（或者说叫对账）。如果业务很复杂，状态的维护也很复杂，就可以采用下面这种更加妥协而简单的方法。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按方案1，先扣库存，后创建订单。<strong>不做状态补偿，为库存系统提供一个回滚接口</strong>。创建订单如果失败了，先重试。<strong>如果重试还不成功，则回滚库存的扣减</strong>。<strong>如回滚也失败，则发报警，进行人工干预修复</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总之，根据业务逻辑，通过三次重试或回滚的方法，最大限度地保证一致。实在不一致，就发报警，让人工干预。只要日志流水记录得完整，人工肯定可以修复！通常只要业务逻辑本身没问题，重试、回滚之后还失败的概率会比较低，所以这种办法虽然丑陋，但很实用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本章总结了实践中比较可靠的七种方法：两种最终一致性的方案，两种妥协办法，两种基于状态 + 重试 + 幂等的方法（<code>TCC</code>，状态机+重试+幂等），还有一种对账方法。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实现层面，妥协和对账的办法最容易，最终一致性次之，<code>TCC</code>最复杂。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/15/柔性事务-TCC两阶段补偿型/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/15/柔性事务-TCC两阶段补偿型/" itemprop="url">柔性事务-TCC两阶段补偿型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-15T12:12:57+08:00">
                2019-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/分布式事务/" itemprop="url" rel="index">
                    <span itemprop="name">分布式事务</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="柔性事务-TCC两阶段补偿型"><a href="#柔性事务-TCC两阶段补偿型" class="headerlink" title="柔性事务-TCC两阶段补偿型"></a>柔性事务-TCC两阶段补偿型</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="http://www.tianshouzhi.com/api/tutorials/distributed_transaction/388" target="_blank" rel="noopener">http://www.tianshouzhi.com/api/tutorials/distributed_transaction/388</a></p>
</blockquote>
<p><br></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TCC</code>方案是可能是目前最火的一种柔性事务方案了。关于<code>TCC（Try-Confirm-Cancel）</code>的概念，最早是由Pat Helland于2007年发表的一篇名为《<code>Life beyond Distributed Transactions:an Apostate’s Opinion</code>》的论文提出。在该论文中，TCC还是以Tentative-Confirmation-Cancellation命名。正式以Try-Confirm-Cancel作为名称的是Atomikos公司，其注册了TCC商标。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;国内最早关于TCC的报道，应该是InfoQ上对阿里程立博士的一篇采访。经过程博士的这一次传道之后，TCC在国内逐渐被大家广为了解并接受。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atomikos公司在商业版本事务管理器<code>ExtremeTransactions</code>中提供了TCC方案的实现，但是由于其是收费的，因此相应的很多的开源实现方案也就涌现出来，如：<code>tcc-transaction、ByteTCC、spring-cloud-rest-tcc</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TCC</code>的作用主要是解决跨服务调用场景下的分布式事务问题，在本文中，笔者将先介绍一个跨服务的场景案例，并分析其中存在的分布式事务问题；然后介绍<code>TCC</code>的基本概念以及其是如何解决这个问题的。</p>
<h2 id="场景案例"><a href="#场景案例" class="headerlink" title="场景案例"></a>场景案例</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Atomikos官网上&lt;<composite transactions="" for="" soa="">&gt;一文中，以航班预定的案例，来介绍<code>TCC</code>要解决的事务场景。在这里笔者虚构一个完全相同的场景，把自己当做航班预定的主人公，来介绍这个案例。事实上，你可以把本案例当做官方文档案例的一个翻译，只不过把地点从<code>Brussels--&gt;Toronto--&gt;Washington</code>，改成从合肥–&gt;昆明–&gt;大理。</composite></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有一次，笔者买彩票中奖了(纯属虚构)，准备从合肥出发，到云南大理去游玩，然后使用美团App(机票代理商)来订机票。发现没有从合肥直达大理的航班，需要到昆明进行中转。如下图： </p>
<p><img src="//blog.com/2019/06/15/柔性事务-TCC两阶段补偿型/1517793866569016851.png" alt="B121F546-2D0F-45F5-962D-758B07337692.png"></p>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从图中我们可以看出来，从合肥到昆明乘坐的是四川航空，从昆明到大理乘坐的是东方航空。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于使用的是美团<code>App</code>预定，当我选择了这种航班预定方案后，美团<code>App</code>要去四川航空和东方航空各帮我购买一张票。如下图： </p>
<p><img src="//blog.com/2019/06/15/柔性事务-TCC两阶段补偿型/1517793897087064173.png" alt="B87CD059-6891-4A30-A5C4-B8EC7735EADF.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;考虑最简单的情况：美团先去川航帮我买票，如果买不到，那么东航也没必要买了。如果川航购买成功，再去东航购买另一张票。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在问题来了：假设美团先从川航成功买到了票，然后去东航买票的时候，因为天气问题，东航航班被取消了。那么此时，美团必须取消川航的票，因为只有一张票是没用的，不取消就是浪费我的钱。那么如果取消会怎样呢？如果读者有取消机票经历的话，非正常退票，肯定要扣手续费的。在这里，川航本来已经购买成功，现在因为东航的原因要退川航的票，川航应该是要扣代理商的钱的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么美团就要保证，如果任一航班购买失败，都不能扣钱，怎么做呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>两个航空公司都为美团提供以下3个接口：机票预留接口、确认接口、取消接口</strong>。美团App分2个阶段进行调用，如下所示： </p>
<p><img src="//blog.com/2019/06/15/柔性事务-TCC两阶段补偿型/1517793929963047822.png" alt="F58C00A0-976A-4295-818C-C9F96B191060.png"></p>
<p><strong>在第1阶段：</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;美团分别请求两个航空公司预留机票，两个航空公司分别告诉美图预留成功还是失败。航空公司需要保证，机票预留成功的话，之后一定能购买到。</p>
<p><strong>在第2阶段：</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果两个航空公司都预留成功，则分别向两个公司发送确认购买请求。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果两个航空公司任意一个预留失败，则对于预留成功的航空公司也要取消预留。这种情况下，对于之前预留成功机票的航班取消，也不会扣用户的钱，因为购买并没实际发生，之前只是请求预留机票而已。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过这种方案，可以保证两个航空公司购买机票的一致性，要不都成功，要不都失败，即使失败也不会扣用户的钱。如果在两个航班都已经已经确认购买后，再退票，那肯定还是要扣钱的。</p>
<p>​    当然，实际情况肯定这里提到的肯定要复杂，通常航空公司在第一阶段，对于预留的机票，会要求在指定的时间必须确认购买(支付成功)，如果没有及时确认购买，会自动取消。假设川航要求10分钟内支付成功，东航要求30分钟内支付成功。<strong>以较短的时间算，如果用户在10分钟内支付成功的话，那么美团会向两个航空公司都发送确认购买的请求，如果超过10分钟(以较短的时间为准)，那么就不能进行支付</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再次强调，这个案例，可以算是&lt;<composite transactions="" for="" soa="">&gt;中航班预定案例的汉化版。而实际美团App是如何实现这种需要中转的航班预定需求，笔者并不知情。</composite></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，注意这只是一个案例场景，实际情况中，你是很难去驱动航空公司进行接口改造的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Whatever，这个方案提供给我们一种跨服务条用保证事务一致性的一种解决思路，可以把这种方案当做TCC的雏形。 </p>
<h2 id="TCC-的基本概念"><a href="#TCC-的基本概念" class="headerlink" title="TCC 的基本概念"></a>TCC 的基本概念</h2><p><code>TCC</code>是<code>Try-Confirm-Cancel</code>的简称:</p>
<p><strong>Try阶段：</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完成所有业务检查（一致性），预留业务资源(准隔离性)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回顾上面航班预定案例的阶段1，机票就是业务资源，所有的资源提供者(航空公司)预留都成功，try阶段才算成功</p>
<p><strong>Confirm阶段：</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;确认执行业务操作，不做任何业务检查， 只使用<code>Try</code>阶段预留的业务资源。回顾上面航班预定案例的阶段2，美团APP确认两个航空公司机票都预留成功，因此向两个航空公司分别发送确认购买的请求。</p>
<p><strong>Cancel阶段：</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;取消<code>Try</code>阶段预留的业务资源。回顾上面航班预定案例的阶段2，如果某个业务方的业务资源没有预留成功，则取消所有业务资源预留请求。 </p>
<p>敏锐的读者立马会想到，<code>TCC</code>与<code>XA</code>两阶段提交有着异曲同工之妙，下图列出了二者之间的对比：</p>
<p><img src="//blog.com/2019/06/15/柔性事务-TCC两阶段补偿型/1517793973852088232.png" alt="D7087D1B-1E4D-4C0E-8BA4-B2A8B36D0132.png"></p>
<p>  1) 在阶段1：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>XA</code>中，各个<code>RM</code>准备提交各自的事务分支，事实上就是准备提交资源的更新操作(<code>insert、delete、update</code>等)；而在<code>TCC</code>中，是主业务活动请求(<code>try</code>)各个从业务服务预留资源。</p>
<p>  2) 在阶段2：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>XA</code>根据第一阶段每个<code>RM</code>是否都<code>prepare</code>成功，判断是要提交还是回滚。如果都<code>prepare</code>成功，那么就<code>commit</code>每个事务分支，反之则<code>rollback</code>每个事务分支。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TCC</code>中，如果在第一阶段所有业务资源都预留成功，那么<code>confirm</code>各个从业务服务，否则取消(<code>cancel</code>)所有从业务服务的资源预留请求。</p>
<p><code>TCC</code>两阶段提交与<code>XA</code>两阶段提交的区别是：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>XA是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>XA</code>事务中的两阶段提交内部过程是对开发者屏蔽的</strong>，回顾我们之前讲解<code>JTA</code>规范时，通过<code>UserTransaction</code>的<code>commit</code>方法来提交全局事务，这只是一次方法调用，其内部会委派给<code>TransactionManager</code>进行真正的两阶段提交，因此开发者从代码层面是感知不到这个过程的。而<strong>事务管理器在两阶段提交过程中，从<code>prepare</code>到<code>commit/rollback</code>过程中，资源实际上一直都是被加锁的</strong>。<strong>如果有其他人需要更新这两条记录，那么就必须等待锁释放</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>TCC是业务层面的分布式事务，最终一致性，不会一直持有资源的锁。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>TCC</code>中的两阶段提交并没有对开发者完全屏蔽，也就是说从代码层面，开发者是可以感受到两阶段提交的存在</strong>。如上述航班预定案例：在第一阶段，航空公司需要提供<code>try</code>接口(机票资源预留)。在第二阶段，航空公司提需要提供confirm/cancel接口(确认购买机票/取消预留)。开发者明显的感知到了两阶段提交过程的存在。<code>try、confirm/cancel</code>在执行过程中，一般都会开启各自的本地事务，来保证方法内部业务逻辑的<code>ACID</code>特性。其中：</p>
<p>​    1、<code>try</code>过程的本地事务，是保证资源预留的业务逻辑的正确性。</p>
<p>​    2、<code>confirm/cancel</code>执行的本地事务逻辑确认/取消预留资源，以保证最终一致性，也就是所谓的<code>补偿型事务</code>(<code>Compensation-Based Transactions</code>)。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>由于是多个独立的本地事务，因此不会对资源一直加锁</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，这里提到<code>confirm/cancel</code>执行的本地事务是补偿性事务，关于什么是补偿性事务，atomikos 官网上有以下描述： </p>
<p><img src="//blog.com/2019/06/15/柔性事务-TCC两阶段补偿型/1517794010239009939.png" alt="C6467FCC-0325-4DA9-9B21-D263C19710D2.png"></p>
<p>​    红色框中的内容，是对补偿性事务的解释。大致含义是，”<strong>补偿是一个独立的支持<code>ACID</code>特性的本地事务，用于在逻辑上取消服务提供者上一个<code>ACID</code>事务造成的影响</strong>，对于一个长事务(<code>long-running transaction</code>)，与其实现一个巨大的分布式<code>ACID</code>事务，不如使用基于补偿性的方案，把每一次服务调用当做一个较短的本地<code>ACID</code>事务来处理，执行完就立即提交”。</p>
<p>​    在这里，笔者理解为<strong><code>confirm</code>和<code>cancel</code>就是补偿事务，用于取消<code>try</code>阶段本地事务造成的影响</strong>。因为<strong>第一阶段<code>try</code>只是预留资源，之后必须要明确的告诉服务提供者，这个资源你到底要不要，对应第二阶段的<code>confirm/cancel</code></strong>。</p>
<p>​    提示：读者现在应该明白为什么把<code>TCC</code>叫做两阶段补偿性事务了，提交过程分为2个阶段，第二阶段的<code>confirm/cancel</code>执行的事务属于补偿事务。 </p>
<h2 id="TCC事务模型-VS-DTP事务模型"><a href="#TCC事务模型-VS-DTP事务模型" class="headerlink" title="TCC事务模型 VS DTP事务模型"></a><strong>TCC事务模型 VS DTP事务模型</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在介绍完<code>TCC</code>的基本概念之后，我们再来比较一下<code>TCC</code>事务模型和<code>DTP</code>事务模型，如下所示： </p>
<p><img src="//blog.com/2019/06/15/柔性事务-TCC两阶段补偿型/1517794033497049311.png" alt="C014B9B7-F334-4C95-BCEA-59A7897DA651.png"></p>
<p>这两张图看起来差别较大，实际上很多地方是类似的：</p>
<p><strong>1、TCC模型中的主业务服务 相当于 DTP模型中的AP，TCC模型中的从业务服务 相当于 DTP模型中的RM</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>DTP</code>模型中，应用AP操作多个资源管理器<code>RM</code>上的资源；而在<code>TCC</code>模型中，是主业务服务操作多个从业务服务上的资源。例如航班预定案例中，美团App就是主业务服务，而川航和东航就是从业务服务，主业务服务需要使用从业务服务上的机票资源。<strong>不同的是<code>DTP</code>模型中的资源提供者是类似于<code>Mysql</code>这种关系型数据库，而<code>TCC</code>模型中资源的提供者是其他业务服务</strong>。</p>
<p><strong>2、TCC模型中，从业务服务提供的try、confirm、cancel接口 相当于 DTP模型中RM提供的prepare、commit、rollback接口</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>XA</code>协议中规定了<code>DTP</code>模型中定RM需要提供<code>prepare、commit、rollback</code>接口给<code>TM</code>调用，以实现两阶段提交。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而在<code>TCC</code>模型中，从业务服务相当于<code>RM</code>，提供了类似的<code>try、confirm、cancel</code>接口。</p>
<p><strong>3、事务管理器</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DTP</code>模型和<code>TCC</code>模型中都有一个事务管理器。不同的是：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在<code>DTP</code>模型中，阶段1的(<code>prepare</code>)和阶段2的(<code>commit、rollback</code>)，都是由<code>TM</code>进行调用的</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在<code>TCC</code>模型中，阶段1的<code>try</code>接口是主业务服务调用(绿色箭头)，阶段2的(<code>confirm、cancel</code>接口)是事务管理器TM调用(红色箭头)</strong>。这就是 <code>TCC</code> 分布式事务模型的<strong>二阶段异步化功能，从业务服务的第一阶段执行成功，主业务服务就可以提交完成，然后再由事务管理器框架异步的执行各从业务服务的第二阶段</strong>。<strong>这里牺牲了一定的隔离性和一致性的，但是提高了长事务的可用性</strong>。问题来了，既然第二阶段是异步执行的，主业务服务怎么知道异步执行的结果呢？发消息异步通知？返回一个id，后面让业务去查？</p>
<h2 id="TCC如何保证comfirm-cancel执行成功"><a href="#TCC如何保证comfirm-cancel执行成功" class="headerlink" title="TCC如何保证comfirm/cancel执行成功"></a>TCC如何保证comfirm/cancel执行成功</h2><blockquote>
<p>问题：假设a给b转账 在confirm b的时候，数据修改在B本地commit了 然后 发生了network脑裂，事务协调节点没有收到这个confirm feedback，timeout了，事务节点会发出cancel命令，节点a cancel了。网络恢复后b起来后会再和协调节点通信吗？</p>
<p><strong>b commit失败之后，事务协调器是不会给a、b发cancel的，事务协调器会一直重试给b 发commit，直到b commit成功为止 ，这个是2PC的协议这么规定的</strong></p>
</blockquote>
<blockquote>
<p>TCC和XA一样，一阶段成功成功或者失败，决定二阶段commit还是rollback。如果成功了，就只能commit，commit失败可以重试，不能回滚。这里其实有一个隐含的条件，某个事务分支一阶段成功，就需要保证之后一定可以commit成功</p>
</blockquote>
<p><strong>怎么确保一定commit成功？XA二阶段如果commit失败  怎么搞呢 ？</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一阶段资源锁定，如果锁定成功，才会告诉你可以<code>commit</code>，这是前提条件。如果锁定成功，但是不能<code>commit</code>成功，说明<strong>逻辑问题</strong>。（一些基础设施出现问题的情况除外）</p>
<p><strong>多次重试 +  人工干预</strong>，重试是事务管理器<code>TM</code>做的</p>
<blockquote>
<p>XA逻辑一样，prepare成功，就要保证commit可以成功，这是资源管理器RM来保证</p>
</blockquote>
<h2 id="TCC事务的优缺点"><a href="#TCC事务的优缺点" class="headerlink" title="TCC事务的优缺点"></a>TCC事务的优缺点</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>优点：</strong><code>XA</code>两阶段提交资源层面的，而<code>TCC</code>实际上把资源层面二阶段提交上提到了业务层面来实现。<strong>有效了的避免了<code>XA</code>两阶段提交占用资源锁时间过长导致的性能地下问题</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>缺点：</strong>主业务服务和从业务服务都需要进行<strong>改造</strong>，从业务方改造成本更高。还是航班预定案例，原来只需要提供一个购买接口，现在需要改造成<code>try、confirm、canel</code>3个接口，开发成本高。</p>
<p>提示：国内有一些关于<code>TCC</code>方案介绍的文章中，把<code>TCC</code>分成三种类型：</p>
<ul>
<li>通用型<code>TCC</code>，如果我们上面介绍的<code>TCC</code>模型实例，从业务服务需要提供<code>try、confirm、cancel</code></li>
<li>补偿性<code>TCC</code>，从业务服务只需要提供 <code>Do</code>和 <code>Compensate</code> 两个接口</li>
<li>异步确保型 <code>TCC</code>，主业务服务的直接从业务服务是可靠消息服务，而真正的从业务服务则通过消息服务解耦，作为消息服务的消费端，异步地执行。</li>
</ul>
<p>关于这种划分，笔者并不赞同，基于两点：</p>
<p>​    1、笔者在<code>Atomikos</code>官网上参考了多份资料，并没有看到这种划分，猜测应该是这些公司在内部实践中，自行提出的概念。</p>
<p>​    2、对于上面所谓的”补偿性TCC”、”异步确保型 TCC”，从业务服务不需要提供<code>try、confirm、cancel</code>三个接口，在这种情况下，好像称之为<code>TCC</code>也不太合适。 </p>
<h2 id="TCC-For-REST案例"><a href="#TCC-For-REST案例" class="headerlink" title="TCC For REST案例"></a><strong>TCC For REST案例</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过前面的介绍，我们基本已经掌握了<code>TCC</code>的工作原理。在本节中，笔者借用Atomikos官网提供的&lt;<tcc for="" rest="">&gt;进行<code>TCC</code>案例讲解。</tcc></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是，这个案例的主要目的是说明，<strong>在使用基于<code>HTTP</code>的<code>REST</code>服务中，<code>TCC</code>模型中各个参与方的API接口应该如何设计</strong>。通常一个<code>TCC</code>方案是不会依赖于底层通信框架的，例如我们也可以使用业界比较火的<code>spring cloud、dubbo</code>等。这个时候，提供实现类似接口的功能就可以了。</p>
<p>首先我们总结一下<code>TCC</code>模型各个参与方需要提供的<code>API</code>：</p>
<p>​    <strong>Participant API：</strong>从业务服务需要提供的<code>API</code>，其需要<strong>提供<code>try</code>接口供主业务服务调用，需要提供<code>confirm、cancel</code>接口供事务管理器调用</strong>。这里将从业务服务称之为<code>Participant</code>。</p>
<p>​    <strong>Transaction Coordinator API：</strong>事务管理/协调器需要提供的<code>API</code>，其需要提供事务日志上报接口，<strong>让主业务活动上报<code>try</code>阶段各个从业务活动资源是否预留成功的信息</strong></p>
<p>​    <strong>Application：</strong>主业务服务，其不需要提供任何接口，只需要操作上述 <code>Participant、 Transaction Coordinator</code>提供的接口即可。</p>
<p>​    熟悉的配方，熟悉的味道，&lt;<tcc for="" rest="">&gt;采用的依然航班预定案例，如下图所示：</tcc></p>
<p>   <img src="//blog.com/2019/06/15/柔性事务-TCC两阶段补偿型/1517794054204017667.png" alt="72591582-FCFB-4109-A75C-D7269B157249.png"> </p>
<p>其中：</p>
<p><code>Booking Proccess</code>是主业务活动，处理机票预定业务</p>
<p><code>Swiss和easyjet</code>是从业务服务，可以理解为两个不同航空公司的机票预定系统</p>
<p><code>Transaction Coordinator</code>是事务协调器，或者称之为事务管理器。</p>
<p>上图中描述的整体流程如下所示：</p>
<p>1 <code>Booking Proccess</code>接受到一个需要中转的航班预定请求(<code>bookTrip</code>)</p>
<p>​    -1.1：<code>Booking Proccess</code>向<code>swiss</code>发起机票预定请求 <code>R1</code>，其中<code>/booking/A</code>表示<code>swis</code>提供的预留机票资源的<code>try</code>接口</p>
<p>​    -1.2：<code>Booking Proccess</code>向<code>easyjet</code>发起机票预定请求<code>R2</code>，其中<code>/booking/B</code>表示<code>easyjet</code>提供的预留机票资源的<code>try</code>接口</p>
<p>​    -1.3：<code>Booking Proccess</code>将请求1.1、1.2步骤中<code>try</code>的结果合并上报给<code>Transaction Coordinator</code>。</p>
<p>​          -1.3.1 <code>Transaction Coordinator</code> 向<code>swiss</code>发送确认执行业务操作的请求</p>
<p>​          -1.3.2 <code>Transaction Coordinator</code> 向<code>easyjet</code>发送确认执行业务操作的请求</p>
<h3 id="Participant-API"><a href="#Participant-API" class="headerlink" title="Participant API"></a>Participant API</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从业务服务需要提供<code>try、confirm和cancel</code>三个接口，其中<code>try</code>接口是给主业务服务调用的，<code>confirm和cancel</code>是给事务协调器调用的。</p>
<h4 id="try接口"><a href="#try接口" class="headerlink" title="try接口"></a>try接口</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在1.1和1.2步骤中，<code>Booking Proccess</code>向<code>swiss</code>和<code>easyjet</code>提供的<code>try</code>接口分别发起机票预留请求，<code>swiss和easyjet</code>作为参与者，返回的响应格式如下所示 </p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"participantLink"</span>:</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="attr">"uri"</span>:<span class="string">"http://www.example.com/part/123"</span>,</span><br><span class="line">     <span class="attr">"expires"</span>:<span class="string">"2014-01-11T10:15:54Z"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里返回的是一个<code>JSON</code>格式，事实上返回的格式什么是无所谓的，不过<code>Atomikos</code>官方建议使用<code>JSON</code>格式。其中：</p>
<p>​    <code>uri</code> ：表示的是稍后在<code>Confirm</code>确认执行业务操作时，需要调用的<code>url</code></p>
<p>​    <code>expires</code>：表示截止时间，也就是说，如果超过这个时间依然没有确认购买，那么<code>swiss</code>和<code>easyjet</code>将会自动取消这个机票的预留</p>
<h4 id="confirm接口"><a href="#confirm接口" class="headerlink" title="confirm接口"></a>confirm接口</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Transaction Coordinator</code>判断资源都预留成功，解析出<code>json</code>格式中的<code>uri</code>部分，向<code>swiss</code>和<code>easyjet</code>发送确认执行请求(<code>Confirm</code>)，请求格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUT /part/<span class="number">123</span> HTTP/<span class="number">1.1</span></span><br><span class="line">Host: www.example.com</span><br><span class="line">Accept: application/tcc</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意请求头中<code>Accept</code>接受的<code>MIME</code>类型, 暗示了客户端的语义期望。 这个并不是强制的。   </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果<code>swiss</code>和<code>easyjet</code>都确认执行成功，应该返回<code>204</code>，表示执行成功</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 204 No Content</span><br></pre></td></tr></table></figure>
<p>​    需要注意的是，<strong>如果在截止时间(<code>expires</code>)后发送确认执行的请求，<code>swiss</code>和<code>easyjet</code>应该返回404</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 404 Not Found</span><br></pre></td></tr></table></figure>
<p>​    而<strong><code>Transaction Coordinator</code>自身也应该有这种超时判断，以为较小的<code>expires</code>为准，当超过这个时间时，就不应该发送<code>confirm</code>确认执行的请求</strong>。</p>
<p>​    而<strong>在<code>expires</code>之前如果确认执行失败，<code>Transaction Coordinator</code>应该进行重试</strong>。</p>
<h4 id="cancel接口-可选实现"><a href="#cancel接口-可选实现" class="headerlink" title="cancel接口(可选实现)"></a>cancel接口(可选实现)</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;参与者可以选择是否显式的提供<code>cancel</code>接口，如果提供了。<code>Transaction Coordinator</code>应该发送<code>DELETE</code>请求，告诉参与者取消资源预留，格式如下</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELETE /part/123 HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Accept: application/tcc</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果取消成功，则返回</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 204 No Content</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果取消失败，也不会影响结果。前面提到过，资源预留都有一个<code>expires</code>截止时间，超过这个截止时间，参与者就可以主动取消这个预留的资源。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果是因为超时，参与者自行取消资源预留的情况下，应该返回</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 404 Not Found</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 另外，由于参与具备超时自动取消预留的功能，因此<code>DELETE</code>接口是可选的。如果参与者不提供DELETE接口来支持显式<code>cancel</code>，可以返回</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 405 Method Not Allowed</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过笔者还是建议显式的提供<code>cancel</code>接口，例如，如果<code>swiss</code>预留成功，<code>easyjet</code>预留失败。对于预留失败的情况，其实我们已经没有必要进行<code>cancel</code>了。但是swiss预留成功了，<strong>如果等待超时自动取消，可能会比较耗时，通过显式提供<code>cancel</code>接口，来更快的取消预留的资源</strong>，将机票卖给其他客户。</p>
<h3 id="Transaction-Coordinator-API"><a href="#Transaction-Coordinator-API" class="headerlink" title="Transaction Coordinator API"></a>Transaction Coordinator API</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TCC</code>模型中，<strong>主业务服务需要将事务日志上报给事务管理器/协调器，然后由协调器来调用从业务服务的<code>confirm</code>或者<code>cancel</code>接口</strong>。因此事务管理器/协调器必须提供一个事务日志上报的接口。而本节就是介绍这个接口接受的参数类型和响应类型。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主业务服务在第一阶段，调用各个从业务服务的<code>try</code>接口，并且将响应合并起来上传报给<code>Transaction Coordinator</code>。考虑一下，这里应该分为2种情况：</p>
<p>1、所有的<code>try</code>接口都调用成功了，因此主业务服务希望<code>Transaction Coordinator</code>向各个从业务服务进行<code>confirm</code></p>
<p>2、<code>try</code>接口部分成功，部分失败。因此主业务服务希望<code>Transaction Coordinator</code>对已经<code>try</code>成功的从业务服务都进行<code>cancel</code></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此对<code>Transaction Coordinator</code>来说，需要提供2个事务日志上报接口：<code>confirm</code>接口、<code>cancel</code>接口。</p>
<h4 id="confirm接口-1"><a href="#confirm接口-1" class="headerlink" title="confirm接口"></a>confirm接口</h4><p>请求格式如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUT /coordinator/confirm HTTP/1.1</span><br><span class="line">Host: www.taas.com</span><br><span class="line">Content-Type: application/tcc+json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"participantLinks"</span>: [</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="attr">"uri"</span>: <span class="string">"http://www.example.com/part1"</span>,</span><br><span class="line">     <span class="attr">"expires"</span>: <span class="string">"2014-01-11T10:15:54Z"</span></span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">     <span class="attr">"uri"</span>: <span class="string">"http://www.example.com/part2"</span>,</span><br><span class="line">     <span class="attr">"expires"</span>: <span class="string">"2014-01-11T10:15:54+01:00"</span></span><br><span class="line">     &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后协调器会对参与者逐个发起<code>Confirm</code>请求, 如果一切顺利那么将会返回如下结果</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 204 No Content</span><br></pre></td></tr></table></figure>
<p><strong>如果发起<code>Confirm</code>请求的时间太晚, 那么意味着所有被动方都已经进行了超时补偿</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 404 Not Found</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最糟糕的情况就是<strong>有些参与者确认了, 但是有些就没有. 这种情况就应该要返回409, 这种情况在Atomikos中定义为启发式异常</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 409 Conflict</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然, 这种情况应该尽量地避免发生, <strong>要求Confirm与Cancel实现幂等性, 出现差错时协调器可多次对参与者重试以尽量降低启发性异常发生的几率</strong>. 万一409真的发生了, 则应该由请求方主动进行检查或者由协调器返回给请求方详细的执行信息, 例如对每个参与者发起故障诊断的GET请求, 记录故障信息并进行<strong>人工干预</strong>.</p>
<h4 id="cancel接口"><a href="#cancel接口" class="headerlink" title="cancel接口"></a>cancel接口</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个<code>cancel</code>请求跟<code>confirm</code>请求类似, 都是使用<code>PUT</code>请求, 唯一的区别是<code>URI</code>的不同</p>
<p>唯一可预见的响应就是</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 204 No Content</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为<strong>当预留资源没有被确认时最后都会被释放, 所以参与者返回其他错误也不会影响最终一致性</strong>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/15/分布式事务概述/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/15/分布式事务概述/" itemprop="url">分布式事务概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-15T12:12:57+08:00">
                2019-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/分布式事务/" itemprop="url" rel="index">
                    <span itemprop="name">分布式事务</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分布式事务概述"><a href="#分布式事务概述" class="headerlink" title="分布式事务概述"></a>分布式事务概述</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="http://www.tianshouzhi.com/api/tutorials/distributed_transaction" target="_blank" rel="noopener">http://www.tianshouzhi.com/api/tutorials/distributed_transaction</a></p>
</blockquote>
<p><br></p>
<h2 id="1、事务简介"><a href="#1、事务简介" class="headerlink" title="1、事务简介"></a>1、事务简介</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务(<code>Transaction</code>)是访问并可能更新数据库中各种数据项的一个程序执行单元(<code>unit</code>)。在关系数据库中，一个事务由一组<code>SQL</code>语句组成。事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为<code>ACID</code>特性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>原子性（atomicity）</strong>：个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>一致性（consistency）</strong>：事务必须是使数据库从一个一致性状态变到另一个一致性状态，事务的中间状态不能被观察到的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>隔离性（isolation）</strong>：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。隔离性又分为四个级别：读未提交(<code>read uncommitted</code>)、读已提交(<code>read committed</code>，解决脏读)、可重复读(<code>repeatable read</code>，解决虚读)、串行化(<code>serializable</code>，解决幻读)。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>持久性（durability）</strong>：持久性也称永久性（<code>permanence</code>），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</p>
<p>​    任何事务机制在实现时，都应该考虑事务的<code>ACID</code>特性，包括：本地事务、分布式事务，及时不能都很好的满足，也要考虑支持到什么程度。</p>
<h2 id="2、本地事务"><a href="#2、本地事务" class="headerlink" title="2、本地事务"></a>2、本地事务</h2><p>​        大多数场景下，我们的应用都只需要操作单一的数据库，这种情况下的事务称之为本地事务(<code>Local Transaction</code>)。本地事务的<code>ACID</code>特性是数据库直接提供支持。本地事务应用架构如下所示：</p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517792718575090439.png" alt="0B73AA36-93FE-4F88-ADDF-940CF369FB95.png"></p>
<p>在<code>JDBC</code>编程中，我们通过<code>java.sql.Connection</code>对象来开启、关闭或者提交事务。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = ... <span class="comment">//获取数据库连接</span></span><br><span class="line">   conn.setAutoCommit(<span class="keyword">false</span>); <span class="comment">//开启事务</span></span><br><span class="line">   <span class="keyword">try</span>&#123;   </span><br><span class="line">       <span class="comment">//...执行增删改查sql </span></span><br><span class="line">       <span class="comment">//提交事务</span></span><br><span class="line">       conn.commit();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">       <span class="comment">//事务回滚</span></span><br><span class="line">       conn.rollback();</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">       <span class="comment">//关闭链接</span></span><br><span class="line">       conn.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>此外，很多<code>java</code>应用都整合了<code>spring</code>，并使用其声明式事务管理功能来完成事务功能。一般使用的步骤如下：</p>
<p>​    1、配置事务管理器。spring提供了一个<code>PlatformTransactionManager</code>接口，其有2个重要的实现类：</p>
<p>​        <code>DataSourceTransactionManager</code>：用于支持本地事务，事实上，其内部也是通过操作<code>java.sql.Connection</code>来开启、提交和回滚事务。</p>
<p>​        <code>JtaTransactionManager</code>：用于支持分布式事务，其实现了<code>JTA</code>规范，使用<code>XA</code>协议进行两阶段提交。需要注意的是，这只是一个代理，我们需要为其提供一个<code>JTA provider</code>，一般是<code>Java EE</code>容器提供的事务协调器(<code>Java EE server&#39;s transaction coordinato</code>)，也可以不依赖容器，配置一个本地的<code>JTA provider</code>。</p>
<p>​    2、 在需要开启的事务的bean的方法上添加<code>@Transitional</code>注解</p>
<p>​    可以看到，<code>spring</code>除了支持本地事务，也支持分布式事务，下面我们先对分布式事务的典型应用场景进行介绍。</p>
<h2 id="3、分布式事务典型场景"><a href="#3、分布式事务典型场景" class="headerlink" title="3、分布式事务典型场景"></a>3、分布式事务典型场景</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当下互联网发展如火如荼，绝大部分公司都进行了数据库拆分和服务化(<code>SOA</code>)。在这种情况下，完成某一个业务功能可能需要横跨多个服务，操作多个数据库。这就涉及到到了分布式事务，用需要操作的资源位于多个资源服务器上，而应用需要保证对于多个资源服务器的数据的操作，要么全部成功，要么全部失败。<strong>本质上来说，分布式事务就是为了保证不同资源服务器的数据一致性</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;典型的分布式事务场景：</p>
<h3 id="1、跨库事务"><a href="#1、跨库事务" class="headerlink" title="1、跨库事务"></a>1、跨库事务</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跨库事务指的是，一个应用某个功能需要操作多个库，不同的库中存储不同的业务数据。笔者见过一个相对比较复杂的业务，一个业务中同时操作了9个库。下图演示了一个服务同时操作2个库的情况： </p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517792759221000634.png" alt="9E8ADF29-420D-41F0-BC93-3B0BD5EB6A02.png"></p>
<h3 id="2、分库分表"><a href="#2、分库分表" class="headerlink" title="2、分库分表"></a>2、分库分表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常一个库数据量比较大或者预期未来的数据量比较大，都会进行水平拆分，也就是分库分表。如下图，将数据库B拆分成了2个库： </p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517792803303066363.png" alt="139B7837-4209-4B36-B0E8-446941C70708.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于分库分表的情况，一般开发人员都会使用一些数据库中间件来降低<code>sql</code>操作的复杂性。如，对于<code>sql：insert into user(id,name) values (1,&quot;tianshouzhi&quot;),(2,&quot;wangxiaoxiao&quot;)</code>。这条<code>sql</code>是操作单库的语法，单库情况下，可以保证事务的一致性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是由于现在进行了分库分表，开发人员希望将1号记录插入分库1，2号记录插入分库2。所以数据库中间件要将其改写为2条<code>sql</code>，分别插入两个不同的分库，此时要保证两个库要不都成功，要不都失败，因此<strong>基本上所有的数据库中间件都面临着分布式事务的问题</strong>。</p>
<h3 id="3、服务化-SOA"><a href="#3、服务化-SOA" class="headerlink" title="3、服务化(SOA)"></a>3、服务化(SOA)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微服务架构是目前一个比较一个比较火的概念。例如上面笔者提到的一个案例，某个应用同时操作了9个库，这样的应用业务逻辑必然非常复杂，对于开发人员是极大的挑战，应该拆分成不同的独立服务，以简化业务逻辑。拆分后，独立服务之间通过<code>RPC</code>框架来进行远程调用，实现彼此的通信。下图演示了一个3个服务之间彼此调用的架构：</p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517792870448000242.png" alt="E5E5F08C-E57B-438C-A5B2-686DC5243254.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Service A</code>完成某个功能需要直接操作数据库，同时需要调用<code>Service B</code>和<code>Service C</code>，而<code>Service B</code>又同时操作了2个数据库，<code>Service C</code>也操作了一个库。需要<strong>保证这些跨服务的对多个数据库的操作要不都成功，要不都失败，实际上这可能是最典型的分布式事务场景</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小结：上述讨论的分布式事务场景中，无一例外的都直接或者间接的操作了多个数据库。如何保证事务的<code>ACID</code>特性，对于分布式事务实现方案而言，是非常大的挑战。同时，<strong>分布式事务实现方案还必须要考虑性能的问题，如果为了严格保证<code>ACID</code>特性，导致性能严重下降，那么对于一些要求快速响应的业务，是无法接受的</strong>。</p>
<h2 id="4、X-Open-DTP模型与XA规范"><a href="#4、X-Open-DTP模型与XA规范" class="headerlink" title="4、X/Open DTP模型与XA规范"></a>4、X/Open DTP模型与XA规范</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>X/Open</code>，即现在的<code>open group</code>，是一个独立的组织，主要负责制定各种行业技术标准。官网地址：<a href="http://www.opengroup.org/" target="_blank" rel="noopener">http://www.opengroup.org/</a>。<code>X/Open</code>组织主要由各大知名公司或者厂商进行支持，这些组织不光遵循<code>X/Open</code>组织定义的行业技术标准，也参与到标准的制定。下图展示了<code>open group</code>目前主要成员(官网截图)： </p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517792913032061556.png" alt="9A3AC451-E44F-47FB-A7D6-20FD18B65723.png"></p>
<p>可以看到，中国人的骄傲，华为，赫然在列！！！此处应该有掌声。</p>
<p>   就分布式事务处理(<code>Distributed Transaction Processing</code>,简称DTP)而言，<code>X/Open</code>主要提供了以下参考文档：</p>
<p>   <code>DTP</code>参考模型： <strong>&lt;<distributed transaction="" processing:="" reference="" model="">&gt;</distributed></strong></p>
<p>   <code>DTP XA</code>规范：<a href="http://pubs.opengroup.org/onlinepubs/009680699/toc.pdf" target="_blank" rel="noopener"> <strong>&lt;&lt; Distributed Transaction Processing: The XA Specification&gt;&gt;</strong></a></p>
<h3 id="4-1-DTP模型"><a href="#4-1-DTP模型" class="headerlink" title="4.1 DTP模型"></a>4.1 DTP模型</h3><h4 id="1、模型元素"><a href="#1、模型元素" class="headerlink" title="1、模型元素"></a>1、模型元素</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   在&lt;<distributed transaction="" processing:="" reference="" model="">&gt;第3版中，规定了构成DTP模型的5个基本元素：</distributed></p>
<p>   <strong>应用程序(Application Program ，简称AP)：</strong>用于定义事务边界(即定义事务的开始和结束)，并且在事务边界内对资源进行操作。</p>
<p>   <strong>资源管理器(Resource Manager，简称RM)：</strong>如数据库、文件系统等，并提供访问资源的方式。</p>
<p>   <strong>事务管理器(Transaction Manager ，简称TM)：</strong>负责分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚等。</p>
<p>   <strong>通信资源管理器(Communication Resource Manager，简称CRM)：</strong>控制一个<code>TM</code>域(<code>TM domain</code>)内或者跨<code>TM</code>域的分布式应用之间的通信。</p>
<p>   <strong>通信协议(Communication Protocol，简称CP)：</strong>提供<code>CRM</code>提供的分布式应用节点之间的底层通信服务。</p>
<p>​    其中由于通信资源管理器(<code>Communication Resource Manager</code>)和通信协议(<code>Communication Protocol</code>)是一对好基友，从<code>Communication Protocol</code>的简称<code>CP</code>上就可以看出来，两个元素的关系不一般，因此有的文章在介绍<code>DTP</code>模型元素时，只提到了通信资源管理器….</p>
<h4 id="2、模型实例-Instance-of-the-Model"><a href="#2、模型实例-Instance-of-the-Model" class="headerlink" title="2、模型实例(Instance of the Model)"></a>2、模型实例(Instance of the Model)</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个<code>DTP</code>模型实例，至少有3个组成部分：<code>AP、RMs、TM</code>。如下所示： </p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517792940751035008.png" alt="F6921BEC-E492-4EB9-AC05-A7E79C6DE027.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这张图类似于我们之前提到的跨库事务的概念，即单个应用需要操作多个库。在这里就是一个<code>AP</code>需要操作多个<code>RM</code>上的资源。<code>AP</code>通过<code>TM</code>来声明一个全局事务，然后操作不同的<code>RM</code>上的资源，最后通知<code>TM</code>来提交或者回滚全局事务。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特别的，<strong>如果分布式事务需要跨多个应用，类似于我们前面的提到的分布式事务场景中的服务化，那么每个模型实例中，还需要额外的加入一个通信资源管理器<code>CRM</code></strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下图中演示了2个模型实例，如何通过<code>CRM</code>来进行通信： </p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517792972975019565.png" alt="7B96339F-DF94-4A7F-8590-F81DB5BC7CDC.png"></p>
<p><code>CRM</code>作为多个模型实例之间通信的桥梁，主要作用如下：</p>
<ul>
<li><p>基本的通信能力：从这个角度，可以将<code>CRM</code>类比为<code>RPC</code>框架，模型实例之间通过<code>RPC</code>调用实现彼此的通信。这一点体现在<code>AP、CRM</code>之间的连线。</p>
</li>
<li><p>事务传播能力：与传统<code>RPC</code>框架不同的是，<code>CRM</code>底层采用<code>OSI TP(Open Systems Interconnection — Distributed Transaction Processing)</code>通信服务，因此<code>CRM</code>具备事务传播能力。这一点体现<code>TM、CRM</code>之间的连线。</p>
</li>
</ul>
<h4 id="3、事务管理器作用域-（TM-domain）"><a href="#3、事务管理器作用域-（TM-domain）" class="headerlink" title="3、事务管理器作用域 （TM domain）"></a>3、事务管理器作用域 （TM domain）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个<code>TM domain</code>中由一个或者多个模型实例组成，这些模型实例使用的都是同一个<code>TM</code>，但是操作的<code>RMs</code>各不相同，由<code>TM</code>来统一协调这些模型实例共同参与形成的全局事务(<code>global transaction</code>)。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下图展示了一个由四个模型实例组成的<code>TM Domain</code>，这四个模型实例使用的都是同一个事务管理器<code>TM1</code>。 </p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517792996911019478.png" alt="28EC2E8D-220B-4E0D-BF4A-058F1AD76909.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TM domain</code>只是列出了最终参与到一个全局事务中，有哪些模型实例，并不关心这些模型实例之间的关系。这就好比，有一个班级，我们只是想知道这个班级中每位同学的名字，但是并不是关心谁是班长、谁是学习委员等。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过显然的，当一个<code>TM domain</code>中存在多个模型实例时，模型实例彼此之间存在一定的层级调用关系。这就是全局事务的树形结构。 </p>
<h4 id="4、全局事务树形结构-Global-Transaction-Tree-Structure"><a href="#4、全局事务树形结构-Global-Transaction-Tree-Structure" class="headerlink" title="4、全局事务树形结构(Global Transaction Tree Structure)"></a>4、全局事务树形结构(Global Transaction Tree Structure)</h4><p>   当一个<code>TM domain</code>中，存在多个模型实例时，会形成一种树形条用关系，如下图所示： </p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517793019813081010.png" alt="95F05F13-D75B-4638-9BA1-6FF36B5A5ADC.png"></p>
<p>其中：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发起分布式事务的模型实例称之为<code>root</code>节点，或者称之为事务的发起者，其他的模型实例可以统称为事务的参与者。事务发起者负责开启整个全局事务，事务参与者各自负责执行自己的事务分支。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而从模型实例之间的相互调用关系来说，调用方称之为上游节点(<code>Superior Node</code>)，被调用方称之为下游节点(<code>Subordinate Node</code>)。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小结：通过对<code>DTP</code>模型的介绍，我们可以看出来，之前提到的分布式事务的几种典型场景实际上在<code>DTP</code>模型中都包含了，甚至比我们考虑的还复杂。<code>DTP</code>模型从最早提出到现在已经有接近30年，到如今依然适用，不得不佩服模型的设计者是很有远见的。 </p>
<h3 id="4-2-XA规范"><a href="#4-2-XA规范" class="headerlink" title="4.2 XA规范"></a>4.2 XA规范</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>DTP</code>本地模型实例中，由<code>AP、RMs</code>和<code>TM</code>组成，不需要其他元素。<code>AP、RM</code>和<code>TM</code>之间，彼此都需要进行交互，如下图所示： </p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517793071823063845.png" alt="93DC1C17-7C88-40A4-8595-F15E89F4CAA1.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这张图中(1)表示<code>AP-RM</code>的交互接口，(2)表示<code>AP-TM</code>的交互接口，(3)表示<code>RM-TM</code>的交互接口。关于这张图，XA规范有以下描述：</p>
<blockquote>
<p>The subject of this X/Open specification is interface (3) in the diagram above, the XA interface by which TMs and RMs interact.</p>
<p>For more details on this model and diagram, including detailed definitions of each component, see the referenced <strong>DTP</strong> guide.</p>
</blockquote>
<p>​    也就是说<strong><code>XA</code>规范的最主要的作用是，就是定义了<code>RM-TM</code>的交互接口</strong>，下图更加清晰了演示了<code>XA</code>规范在<code>DTP</code>模型中发挥作用的位置，从下图中可以看出来，<strong><code>XA</code>仅仅出现在<code>RM</code>和<code>TM</code>的连线上</strong>。</p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517793087671016170.png" alt="1578CD5A-2EE1-4F41-8DE8-B2F615F79571.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>XA</code>规范除了定义的<code>RM-TM</code>交互的接口(<code>XA Interface</code>)之外，还对两阶段提交协议进行了优化。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一些读者可能会<strong>误认为两阶段提交协议是在<code>XA</code>规范中提出来的。事实上： 两阶段协议(<code>two-phase commit</code>)是在<code>OSI TP</code>标准中提出的</strong>；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>DTP</code>参考模型(&lt;<distributed transaction="" processing:="" reference="" model="">&gt;)中，指定了全局事务的提交要使用<code>two-phase commit</code>协议；</distributed></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而<code>XA</code>规范(&lt;&lt; <code>Distributed Transaction Processing: The XA Specification</code>&gt;&gt;)只是定义了两阶段提交协议中需要使用到的接口，也就是上述提到的<code>RM-TM</code>交互的接口，因为两阶段提交过程中的参与方，只有<code>TM</code>和<code>RMs</code>。参见&lt;<distributed transaction="" processing:="" reference="" model="">&gt; 第3版 2.1节，原文如下： </distributed></p>
<blockquote>
<p><strong>Commitment Protocol</strong></p>
<p>A <em>commitment protocol</em> is the synchronisation that occurs at transaction completion. The X/Open DTP Model follows the <em>two-phase commit with presumed rollback</em>1 protocol defined in the referenced OSI TP standards. A description of the basic protocol is given in Section 3.4.3 on page 13. In certain cases, a global transaction may be completed <em>heuristically</em>. Heuristic transaction completion is described in Section 3.4.5 on page 14.</p>
</blockquote>
<h4 id="4-2-1-XA-Interface"><a href="#4-2-1-XA-Interface" class="headerlink" title="4.2.1  XA Interface"></a>4.2.1  XA Interface</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>XA</code>规范中定义的<code>RM</code> 和 <code>TM</code>交互的接口如下图所示： </p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517793103607040894.png" alt="72A58A31-EEA8-474B-B542-8A2928E3CD5C.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于这些接口的详细解释，可以直接参考<code>XA</code>规范。后面在讲解到<code>mysql</code>对<code>XA</code>事务的支持时，我们也会使用到部分命令</p>
<h4 id="4-2-2-两阶段提交协议-2PC"><a href="#4-2-2-两阶段提交协议-2PC" class="headerlink" title="4.2.2 两阶段提交协议(2PC)"></a>4.2.2 两阶段提交协议(2PC)</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两阶段提交协议（<code>Two Phase Commit</code>）不是在XA规范中提出，但是<code>XA</code>规范对其进行了优化，因此统一放到这里进行讲解。而从字面意思来理解，<strong><code>Two Phase Commit</code>，就是将提交(<code>commit</code>)过程划分为2个阶段(<code>Phase</code>)</strong>：</p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517793127448076351.png" alt="D7087D1B-1E4D-4C0E-8BA4-B2A8B36D0132.png"></p>
<blockquote>
<p>   In Phase 1, the TM asks all RMs to <em>prepare to commit</em> (or <em>prepare</em>) transaction branches. This asks whether the RM can guarantee its ability to commit the transaction branch. An RM may have to query other entities internal to that RM.</p>
<p>​    If an RM can commit its work, it records stably the information it needs to do so, then replies affirmatively. A negative reply reports failure for any reason. After making a negative reply and rolling back its work, the RM can discard any knowledge it has of the transaction branch.</p>
<p>   In Phase 2, the TM issues all RMs an actual request to commit or roll back the transaction branch, as the case may be. (Before issuing requests to commit, the TM stably records the fact that it decided to commit, as well as a list of all involved RMs.) All RMs commit or roll back changes to shared resources and then return status to the TM. The TM can then discard its knowledge of the global transaction.</p>
</blockquote>
<h6 id="阶段1"><a href="#阶段1" class="headerlink" title="阶段1"></a>阶段1</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TM</code>通知各个<code>RM</code>准备提交它们的事务分支。如果<code>RM</code>判断自己进行的工作可以被提交，那就就对工作内容进行持久化，再给<code>TM</code>肯定答复；要是发生了其他情况，那给<code>TM</code>的都是否定答复。在发送了否定答复并回滚了已经的工作后，<code>RM</code>就可以丢弃这个事务分支信息。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以<code>mysql</code>数据库为例，在第一阶段，事务管理器向所有涉及到的数据库服务器发出<code>prepare</code>“准备提交”请求，数据库收到请求后执行数据修改和日志记录等处理，处理完成后只是把事务的状态改成”可以提交”,然后把结果返回给事务管理器。</p>
<h6 id="阶段2"><a href="#阶段2" class="headerlink" title="阶段2"></a>阶段2</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TM</code>根据阶段1各个<code>RM prepare</code>的结果，决定是提交还是回滚事务。如果所有的<code>RM</code>都<code>prepare</code>成功，那么<code>TM</code>通知所有的<code>RM</code>进行提交；如果有<code>RM prepare</code>失败的话，则<code>TM</code>通知所有<code>RM</code>回滚自己的事务分支。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以<code>mysql</code>数据库为例，如果第一阶段中所有数据库都<code>prepare</code>成功，那么事务管理器向数据库服务器发出”确认提交”请求，数据库服务器把事务的”可以提交”状态改为”提交完成”状态，然后返回应答。如果在第一阶段内有任何一个数据库的操作发生了错误，或者事务管理器收不到某个数据库的回应，则认为事务失败，回撤所有数据库的事务。数据库服务器收不到第二阶段的确认提交请求，也会把”可以提交”的事务回撤。</p>
<h6 id="XA规范对两阶段提交协议的优化"><a href="#XA规范对两阶段提交协议的优化" class="headerlink" title="XA规范对两阶段提交协议的优化"></a>XA规范对两阶段提交协议的优化</h6><p><code>XA</code>规范对两阶段提交协议有2点优化：</p>
<blockquote>
<p>Protocol Optimisations</p>
<p>• Read-only</p>
<p>​       An RM can respond to the TM’s prepare request by asserting that the RM was not asked to update shared resources in this transaction branch. This response concludes the RM’s involvement in the transaction; the Phase 2 dialogue between the TM and this RM does not occur. The TM need not stably record, in its list of participating RMs, an RM that asserts a read-only role in the global transaction.</p>
<p>However, if the RM returns the read-only optimisation before all work on the global transaction is prepared, global serialisability1 cannot be guaranteed. This is because the RM may release transaction context, such as read locks, before all application activity for that global transaction is finished.</p>
<ol start="2">
<li>One-phase Commit</li>
</ol>
<p>​    A TM can use one-phase commit if it knows that there is only one RM anywhere in the DTP system that is making changes to shared resources. In this optimisation, the TM makes its Phase 2 commit request without having made a Phase 1 prepare request. Since the RM decides the outcome of the transaction branch and forgets about the transaction branch before returning to the TM, there is no need for the TM to record stably these global transactions and, in some failure cases, the TM may not know the outcome.</p>
</blockquote>
<p> <strong>只读断言</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>Phase 1</code>中，<code>RM</code>可以断言“我这边不涉及数据增删改”来答复<code>TM</code>的<code>prepare</code>请求，从而让这个<code>RM</code>脱离当前的全局事务，从而免去了<code>Phase 2</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种优化发生在其他<code>RM</code>都完成<code>prepare</code>之前的话，使用了只读断言的<code>RM</code>早于<code>AP</code>其他动作（比如说这个<code>RM</code>返回那些只读数据给<code>AP</code>）前，就释放了相关数据的上下文（比如读锁之类的），这时候<strong>其他全局事务或者本地事务就有机会去改变这些数据，结果就是无法保障整个系统的可序列化特性——通俗点说那就会有脏读的风险</strong>。</p>
<p><strong>一阶段提交</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要增删改的数据都在同一个<code>RM</code>上，<code>TM</code>可以使用一阶段提交——跳过两阶段提交中的<code>Phase 1</code>，直接执行<code>Phase 2</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种优化的本质是跳过<code>Phase 1</code>，<code>RM</code>自行决定了事务分支的结果，并且在答复TM前就清除掉事务分支信息。对于这种优化的情况，<code>TM</code>实际上也没有必要去可靠的记录全局事务的信息，在一些异常的场景下，此时<code>TM</code>可能不知道事务分支的执行结果。 </p>
<h6 id="两阶段提交协议-2PC-存在的问题"><a href="#两阶段提交协议-2PC-存在的问题" class="headerlink" title="两阶段提交协议(2PC)存在的问题"></a>两阶段提交协议(2PC)存在的问题</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二阶段提交看起来确实能够提供原子性的操作，但是不幸的是，二阶段提交还是有几个缺点的：</p>
<p><strong>同步阻塞问题</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>两阶段提交方案下全局事务的<code>ACID</code>特性，是依赖于<code>RM</code>的</strong>。例如<code>mysql5.7</code>官方文档关于对<code>XA</code>分布式事务的支持有以下介绍：</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/xa.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/xa.html</a></p>
<blockquote>
<p> A global transaction involves several actions that are transactional in themselves, but that all must either complete successfully as a group, or all be rolled back as a group. In essence, this extends ACID properties “up a level” so that multiple ACID transactions can be executed in concert as components of a global operation that also has ACID properties. (As with nondistributed transactions, <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_serializable" target="_blank" rel="noopener">SERIALIZABLE</a> may be preferred if your applications are sensitive to read phenomena. <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read" target="_blank" rel="noopener">REPEATABLE READ</a> may not be sufficient for distributed transactions.)</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大致含义是说，一个全局事务内部包含了多个独立的事务分支，这一组事务分支要不都成功，要不都失败。各个事务分支的<code>ACID</code>特性共同构成了全局事务的<code>ACID</code>特性。也就是将单个事务分支的支持的<code>ACI</code>D特性提升一个层次(<code>up a level</code>)到分布式事务的范畴。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;括号中的内容的意思是： <strong>即使在非分布事务中(即本地事务)，如果对操作读很敏感，我们也需要将事务隔离级别设置为<code>SERIALIZABLE</code></strong>。<strong>而对于分布式事务来说，更是如此，可重复读隔离级别不足以保证分布式事务一致性</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是说，如果我们使用<code>mysql</code>来支持<code>XA</code>分布式事务的话，那么最好将事务隔离级别设置为<code>SERIALIZABLE</code>。 地球人都知道，<code>SERIALIZABLE</code>(串行化)是四个事务隔离级别中最高的一个级别，也是执行效率最低的一个级别。</p>
<p><strong>单点故障</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>由于协调者的重要性，一旦协调者<code>TM</code>发生故障，参与者<code>RM</code>会一直阻塞下去</strong>。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</p>
<p><strong>数据不一致</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在二阶段提交的阶段二中，当协调者向参与者发送<code>commit</code>请求之后，发生了局部网络异常或者在发送<code>commit</code>请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了<code>commit</code>请求。而在这部分参与者接到<code>commit</code>请求之后就会执行<code>commit</code>操作。但是其他部分未接到<code>commit</code>请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致性的现象。【<strong>因为某些原因出现部分提交，导致数据不一致，缺少第二阶段的结果反馈处理</strong>】</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于二阶段提交存在着诸如同步阻塞、单点问题等缺陷，所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。 </p>
<h2 id="5、三阶段提交协议-Three-phase-commit"><a href="#5、三阶段提交协议-Three-phase-commit" class="headerlink" title="5、三阶段提交协议(Three-phase commit)"></a>5、三阶段提交协议(Three-phase commit)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三阶段提交（<code>3PC</code>)，是二阶段提交（<code>2PC</code>）的改进版本。参考维基百科：<a href="https://en.wikipedia.org/wiki/Three-phase_commit_protocol" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Three-phase_commit_protocol</a></p>
<p>与两阶段提交不同的是，三阶段提交有两个改动点。</p>
<p>​    1、<strong>引入超时机制</strong>。同时在协调者和参与者中都引入超时机制。</p>
<p>​    2、<strong>在第一阶段和第二阶段中插入一个准备阶段</strong>。保证了在最后提交阶段之前各参与节点的状态是一致的。也就是说，除了引入超时机制之外，<code>3PC</code>把<code>2PC</code>的准备阶段再次一分为二，这样三阶段提交就有<code>CanCommit、PreCommit、DoCommit</code>三个阶段。</p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517793175448046667.png" alt="9AFDC04C-016D-4CA6-8C04-AE7702264AFC.png"></p>
<h3 id="CanCommit阶段"><a href="#CanCommit阶段" class="headerlink" title="CanCommit阶段"></a>CanCommit阶段</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>3PC</code>的<code>CanCommit</code>阶段其实和<code>2PC</code>的准备阶段很像。协调者向参与者发送<code>commit</code>请求，参与者如果可以提交就返回<code>Yes</code>响应，否则返回<code>No</code>响应。</p>
<p>​    1.事务询问 协调者向参与者发送<code>CanCommit</code>请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</p>
<p>​    2.响应反馈 参与者接到<code>CanCommit</code>请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回<code>Yes</code>响应，并进入预备状态。否则反馈<code>No</code></p>
<h3 id="PreCommit阶段"><a href="#PreCommit阶段" class="headerlink" title="PreCommit阶段"></a>PreCommit阶段</h3><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  协调者根据参与者的反应情况来决定是否可以进行事务的<code>PreCommit</code>操作。根据响应情况，有以下两种可能。</p>
<p>​    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如协调者从所有的参与者获得的反馈都是<code>Yes</code>响应，那么就会执行事务的预执行。</p>
<p>​    1.发送预提交请求 协调者向参与者发送<code>PreCommit</code>请求，并进入<code>Prepared</code>阶段。    </p>
<p>​    2.事务预提交 参与者接收到<code>PreCommit</code>请求后，会执行事务操作，并将<code>undo</code>和<code>redo</code>信息记录到事务日志中。</p>
<p>​    3.响应反馈 如果参与者成功的执行了事务操作，则返回<code>ACK</code>响应，同时开始等待最终指令。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如有任何一个参与者向协调者<strong>发送了<code>No</code>响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断</strong>。</p>
<p>​    1.发送中断请求 协调者向所有参与者发送<code>abort</code>请求。</p>
<p>​    2.中断事务 <strong>参与者收到来自协调者的<code>abort</code>请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断</strong>。</p>
<h3 id="doCommit阶段"><a href="#doCommit阶段" class="headerlink" title="doCommit阶段"></a>doCommit阶段</h3><p>​    该阶段进行真正的事务提交，也可以分为以下两种情况。</p>
<p>​    <strong>Case 1：执行提交</strong></p>
<p>​    1.发送提交请求 协调接收到参与者发送的<code>ACK</code>响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送<code>doCommit</code>请求。</p>
<p>​    2.事务提交 参与者接收到<code>doCommit</code>请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</p>
<p>​    3.响应反馈 事务提交完之后，向协调者发送<code>Ack</code>响应。</p>
<p>​    4.完成事务 协调者接收到所有参与者的<code>ack</code>响应之后，完成事务。</p>
<p>   <strong>Case 2：中断事务</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 协调者没有接收到参与者发送的<code>ACK</code>响应（<strong>可能是接受者发送的不是<code>ACK</code>响应，也可能响应超时</strong>），那么就会执行中断事务。</p>
<p>​    1.发送中断请求 协调者向所有参与者发送<code>abort</code>请求</p>
<p>​    2.事务回滚 参与者接收到<code>abort</code>请求之后，利用其在阶段二记录的<code>undo</code>信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p>
<p>​    3.反馈结果 参与者完成事务回滚之后，向协调者发送<code>ACK</code>消息</p>
<p>​    4.中断事务 协调者接收到参与者反馈的<code>ACK</code>消息之后，执行事务的中断。 </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>doCommit</code>阶段，如果参与者无法及时接收到来自协调者的<code>doCommit</code>或者<code>rebort</code>请求时，会在<strong>等待超时之后，会继续进行事务的提交</strong>。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了<code>PreCommit</code>请求，那么<strong>协调者产生<code>PreCommit</code>请求的前提条件是他在第二阶段开始之前，收到所有参与者的<code>CanCommit</code>响应都是<code>Yes</code></strong>。（一旦参与者收到了<code>PreCommit</code>，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到<code>commit</code>或者<code>abort</code>响应，但是他有理由相信：<strong>成功提交的几率很大</strong>。 ）</p>
<h3 id="小结：2PC与3PC的区别"><a href="#小结：2PC与3PC的区别" class="headerlink" title="小结：2PC与3PC的区别"></a>小结：2PC与3PC的区别</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相对于<code>2PC</code>，<code>3PC</code>主要解决的单点故障问题，<strong>并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行<code>commit</code></strong>。而不会一直持有事务资源并处于阻塞状态。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这种机制也会<strong>导致数据一致性问题，因为由于网络原因，协调者发送的<code>abort</code>响应没有及时被参与者接收到，那么参与者在等待超时之后执行了<code>commit</code>操作。这样就和其他接到<code>abort</code>命令并执行回滚的参与者之间存在数据不一致的情况</strong>。</p>
<p>​    了解了<code>2PC</code>和<code>3PC</code>之后，我们可以发现，<strong>无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题</strong>。<code>Google Chubby</code>的作者<code>Mike Burrows</code>说过，<code>there is only one consensus protocol, and that’s Paxos” – all other approaches are just broken versions of Paxos</code>. 意即世上只有一种一致性算法，那就是<code>Paxos</code>，所有其他一致性算法都是<code>Paxos</code>算法的不完整版。后面的文章会介绍这个公认为难于理解但是行之有效的<code>Paxos</code>算法。   </p>
<h2 id="6、经典的分布式系统理论-CAP"><a href="#6、经典的分布式系统理论-CAP" class="headerlink" title="6、经典的分布式系统理论-CAP"></a>6、经典的分布式系统理论-CAP</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出<code>CAP</code>猜想。Brewer认为在设计一个大规模的分布式系统时会遇到三个特性：<strong>一致性（<code>consistency</code>）、可用性（<code>Availability</code>）、分区容错（<code>partition-tolerance</code>），而一个分布式系统最多只能满足其中的2项</strong>。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了<code>CAP</code>。之后，<code>CAP</code>理论正式成为分布式计算领域的公认定理。 </p>
<p>​    <img src="//blog.com/2019/06/15/分布式事务概述/1517793186986086069.png" alt="Image.png"></p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一致性指<code>“all nodes see the same data at the same time”</code>，即<strong>更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致，不能存在中间状态</strong>。例如对于电商系统用户下单操作，库存减少、用户资金账户扣减、积分增加等操作必须在用户下单操作完成后必须是一致的。不能出现类似于库存已经减少，而用户资金账户尚未扣减，积分也未增加的情况。如果出现了这种情况，那么就认为是不一致的。</p>
<blockquote>
<p>如果的确能像上面描述的那样时刻保证客户端看到的数据都是一致的，那么称之为<strong>强一致性</strong>。</p>
<p>如果允许存在中间状态，只要求经过一段时间后，数据最终是一致的，则称之为<strong>最终一致性</strong>。</p>
<p>如果允许存在部分数据不一致，那么就称之为<strong>弱一致性</strong>。</p>
</blockquote>
<h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可用性是指<strong>系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果</strong>。“有限的时间内”是指，对于用户的一个操作请求，系统必须能够在指定的时间内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的。试想，如果一个下单操作，为了保证分布式事务的一致性，需要10分钟才能处理完，那么用户显然是无法忍受的。<strong>“返回结果”是可用性的另一个非常重要的指标，它要求系统在完成对用户请求的处理后，返回一个正常的响应结果，不论这个结果是成功还是失败</strong>。</p>
<h3 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障</strong>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然一个分布式系统无法同时满足一致性、可用性、分区容错性三个特点，我们就需要抛弃一个，需要明确的一点是，<strong>对于一个分布式系统而言，分区容错性是一个最基本的要求</strong>。<strong>因为既然是一个分布式系统，那么分布式系统中的组件必然需要被部署到不同的节点，否则也就无所谓分布式系统了</strong>。<strong>而对于分布式系统而言，网络问题又是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然需要面对和解决的问题</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此系统架构师往往需要把精力花在如何根据业务特点在C（一致性）和A（可用性）之间寻求平衡。而前面我们提到的<code>X/Open XA</code><strong>两阶段提交协议的分布式事务方案，强调的就是一致性</strong>；由于可用性较低，实际应用的并不多。而<strong>基于<code>BASE</code>理论的柔性事务，强调的是可用性</strong>，目前大行其道，大部分互联网公司采可能会优先采用这种方案。</p>
<h2 id="7、BASE理论与柔性事务"><a href="#7、BASE理论与柔性事务" class="headerlink" title="7、BASE理论与柔性事务"></a>7、BASE理论与柔性事务</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在<code>ACM</code>上发表文章提出<code>BASE</code>理论。文章链接：<a href="https://queue.acm.org/detail.cfm?id=1394128" target="_blank" rel="noopener">https://queue.acm.org/detail.cfm?id=1394128</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>BASE</code>理论是对<code>CAP</code>理论的延伸，核心思想是即使无法做到强一致性（<code>Strong Consistency</code>，<code>CAP</code>的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（<code>Eventual Consitency</code>）</strong>。    </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>BASE</code>是<code>Basically Available</code>（基本可用）、<code>Soft state</code>（软状态）和<code>Eventually consistent</code>（最终一致性）三个短语的缩写</strong>。</p>
<p>​    1.  基本可用（<code>Basically Available</code>）</p>
<p>​        指分布式系统在出现不可预知故障的时候，允许损失部分可用性。</p>
<p>​    2.  软状态（ <code>Soft State</code>）</p>
<p>​        指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性。</p>
<p>​    3.  最终一致（ <code>Eventual Consistency</code>）</p>
<p>​        强调的是所有的数据更新操作，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，<strong>最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>BASE</code>理论面向的是大型高可用可扩展的分布式系统，和传统的事物<code>ACID</code>特性是相反的。它完全不同于<code>ACID</code>的强一致性模型，而是<strong>通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态</strong>。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，<code>ACID</code>特性和<code>BASE</code>理论往往又会结合在一起。</p>
<p><strong>典型的柔性事务方案</strong></p>
<p>​     最大努力通知（非可靠消息、定期校对）</p>
<p>​     可靠消息最终一致性（异步确保型）</p>
<p>​     <code>TCC</code>（两阶段型、补偿型）</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://www.hollischuang.com/archives/666" target="_blank" rel="noopener">http://www.hollischuang.com/archives/666</a></p>
<p><a href="http://www.cnblogs.com/hxsyl/p/4381980.html" target="_blank" rel="noopener">http://www.cnblogs.com/hxsyl/p/4381980.html</a></p>
<p><a href="http://blog.csdn.net/hu_zhiting/article/details/77060582" target="_blank" rel="noopener">http://blog.csdn.net/hu_zhiting/article/details/77060582</a></p>
<p><a href="https://www.zhihu.com/question/31813039" target="_blank" rel="noopener">https://www.zhihu.com/question/31813039</a></p>
<p><a href="https://my.oschina.net/foodon/blog/372703" target="_blank" rel="noopener">https://my.oschina.net/foodon/blog/372703</a></p>
<p><a href="http://blog.jobbole.com/95632/" target="_blank" rel="noopener">http://blog.jobbole.com/95632/</a></p>
<p><a href="http://www.jianshu.com/p/6c1fd2420274" target="_blank" rel="noopener">http://www.jianshu.com/p/6c1fd2420274</a></p>
<p><a href="http://www.linuxidc.com/Linux/2015-11/124942.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2015-11/124942.htm</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/15/RPC框架原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/15/RPC框架原理/" itemprop="url">RPC框架原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-15T12:12:57+08:00">
                2019-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/RPC/" itemprop="url" rel="index">
                    <span itemprop="name">RPC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="RPC框架原理"><a href="#RPC框架原理" class="headerlink" title="RPC框架原理"></a>RPC框架原理</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s/UYL8yD9lusl3ELPSiIDk_A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/UYL8yD9lusl3ELPSiIDk_A</a></p>
</blockquote>
<p><br></p>
<h2 id="RPC介绍"><a href="#RPC介绍" class="headerlink" title="RPC介绍"></a>RPC介绍</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RPC（Remote Procedure Call）</code>：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpx42mlEaAXF7oP6cJhjq9fgwgkJb0Z50DpTib78uUID1DSfFEvVBT8d6VeXQpfb81HRvlc8OZHicicg.jpeg" alt="img"></p>
<p><strong>RPC 是一种技术思想而非一种规范或协议</strong>，常见 <code>RPC</code> 技术和框架有：</p>
<ul>
<li><strong>应用级的服务框架：</strong>阿里的 <code>Dubbo/Dubbox、Google gRPC、Spring Boot/Spring Cloud</code>。</li>
<li><strong>远程通信协议：</strong><code>RMI、Socket、SOAP(HTTP XML)、REST(HTTP JSON)</code>。</li>
<li><strong>通信框架：`</strong>MINA 和 Netty`。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前流行的开源 <code>RPC</code>框架还是比较多的，有阿里巴巴的 <code>Dubbo</code>、<code>Facebook</code> 的<code>Thrift</code>、<code>Google</code> 的 <code>gRPC</code>、<code>Twitter</code> 的 <code>Finagle</code>等。</p>
<p>下面重点介绍三种：</p>
<ul>
<li><p><strong>gRPC</strong>：是 <code>Google</code> 公布的开源软件，基于最新的 <code>HTTP 2.0</code>协议，并支持常见的众多编程语言。<code>RPC</code> 框架是基于<code>HTTP</code>协议实现的，底层使用到了 <code>Netty</code>框架的支持。</p>
</li>
<li><p><strong>Thrift</strong>：是 <code>Facebook</code> 的开源 <code>RPC</code>框架，主要是一个跨语言的服务开发框架。</p>
<p>用户只要在其之上进行二次开发就行，应用对于底层的 <code>RPC</code>通讯等都是透明的。不过这个对于用户来说需要学习特定领域语言这个特性，还是有一定成本的。</p>
</li>
<li><p><strong>Dubbo：</strong>是阿里集团开源的一个极为出名的<code>RPC</code> 框架，在很多互联网公司和企业应用中广泛使用。协议和序列化框架都可以插拔是极其鲜明的特色。</p>
</li>
</ul>
<h2 id="完整的-RPC-框架"><a href="#完整的-RPC-框架" class="headerlink" title="完整的 RPC 框架"></a>完整的 RPC 框架</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个典型<code>RPC</code>的使用场景中，包含了服务发现、负载、容错、网络传输、序列化等组件，其中“<code>RPC</code>协议”就指明了程序如何进行网络传输和序列化。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9b4qWRmW1IAwq3Fq8dMUOqNeHic2oNewr5UQGUDYY9SwiaTEgJvMQvRicg.jpeg" alt="img"></p>
<p><em>图 1：完整 RPC 架构图</em></p>
<p>如下是 <code>Dubbo</code> 的设计架构图，分层清晰，功能复杂：</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9AricvYkj7V0jjho3xcDp2lUASDeR2t2ya8T3M0QWVJj9qUONia9SUu2A.jpeg" alt="img"></p>
<p><em>图 2：Dubbo 架构图</em></p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9GJVibU1E2DSyl5m61ughGiaMhMxwvvCd2RCgp1rBZIutwezeAuZ9ZmYA.jpeg" alt="img"></p>
<h3 id="RPC-核心功能"><a href="#RPC-核心功能" class="headerlink" title="RPC 核心功能"></a>RPC 核心功能</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RPC</code> 的核心功能是指实现一个 <code>RPC</code>最重要的功能模块，就是上图中的”<code>RPC</code> 协议”部分：</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9ZMePFosJpPEia1fY364uZuAsz7SdLC6PLicMamWa8VgEpIbyeUt0LaeA.jpeg" alt="img"></p>
<p><em>图 3：RPC 核心功能</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>一个 RPC 的核心功能主要有 5 个部分组成，分别是：客户端、客户端 Stub、网络传输模块、服务端 Stub、服务端等</strong>。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9mBNXzmALQ3ickB8vkWtG23qaLqBWK8ebj7VndPBqtSelhUhYSqgzfbg.jpeg" alt="img"></p>
<p><em>图 4：RPC 核心功能图</em></p>
<p>下面分别介绍核心 RPC 框架的重要组成：</p>
<ul>
<li><strong>客户端（Client）：</strong>服务调用方。</li>
<li><strong>客户端存根（Client Stub）：</strong>存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端。</li>
<li><strong>服务端存根（Server Stub）：</strong>接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理。</li>
<li><strong>服务端（Server）：</strong>服务的真正提供者。</li>
<li><strong>Network Service：</strong>底层传输，可以是 <code>TCP</code>或<code>HTTP</code>。</li>
</ul>
<h3 id="Python-自带-RPC-Demo"><a href="#Python-自带-RPC-Demo" class="headerlink" title="Python 自带 RPC Demo"></a>Python 自带 RPC Demo</h3><p><strong>Server.py：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> SimpleXMLRPCServer <span class="keyword">import</span> SimpleXMLRPCServer   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_add</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    totle = a + b </span><br><span class="line">    <span class="keyword">return</span> totle</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = SimpleXMLRPCServer((<span class="string">'0.0.0.0'</span>, <span class="number">8080</span>))   <span class="comment">#开启xmlrpcserver</span></span><br><span class="line">    s.register_function(fun_add)                <span class="comment">#注册函数fun_add</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"server is online..."</span></span><br><span class="line">    s.serve_forever()                           <span class="comment">#开启循环等待</span></span><br></pre></td></tr></table></figure>
<p><strong>Client.py：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xmlrpclib <span class="keyword">import</span> ServerProxy            <span class="comment">#导入xmlrpclib的包</span></span><br><span class="line">s = ServerProxy(<span class="string">"http://172.171.5.205:8080"</span>) <span class="comment">#定义xmlrpc客户端</span></span><br><span class="line"><span class="keyword">print</span> s.fun_add(<span class="number">2</span>,<span class="number">3</span>)                            <span class="comment">#调用服务器端的函数</span></span><br></pre></td></tr></table></figure>
<p>开启服务端：</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9IEnicMicIWoaz7icwDeiawSI81VNp3y5XibIrV87fmicBTFHtgFVSVsBPdicw.jpeg" alt="img"></p>
<p>开启客户端：</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9pryvntMVU9Zyyia7Ut1mF2Ra5PRthpPxJKXVVuibLYdZWvsxa1CX9a0w.jpeg" alt="img"></p>
<h4 id="Wireshark-抓包分析过程"><a href="#Wireshark-抓包分析过程" class="headerlink" title="Wireshark 抓包分析过程"></a>Wireshark 抓包分析过程</h4><p>客户端去往服务端：</p>
<ul>
<li><strong>客户端 IP：</strong>172.171.4.176</li>
<li><strong>服务端 IP：</strong>172.171.5.95</li>
</ul>
<p>通信使用 <code>HTTP</code>协议，<code>XML</code>文件传输格式。传输的字段包括：方法名 <code>methodName</code>，两个参数 2，3。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9aONxt2iblUJPIYz09vUbx8DWY4E6QCcP5XH3V7iaKibTOOz1RJrnDbJng.jpeg" alt="img"></p>
<p><em>图 5：Request 抓包</em></p>
<p>服务端返回结果，字段返回值 Value，结果是 5：</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9ezYvAnHuQ1WmWw0QtBqcCn8hpkaZSjUwxn7Zx29ajlASxpjhNjY8wQ.jpeg" alt="img"></p>
<p><em>图 6：Response 抓包</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这两次网络传输中使用了 HTTP 协议，建立 HTTP 协议之间有 TCP 三次握手，断开 HTTP 协议时有 TCP 四次挥手。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG96F49AwWFoHYbxoElGtnoNP6yxcXqWszq2jMdsFSY6BpYouhJYZoXbQ.jpeg" alt="img"></p>
<p><em>图 7：基于 HTTP 协议的 RPC 连接过程</em></p>
<h4 id="详细调用过程"><a href="#详细调用过程" class="headerlink" title="详细调用过程"></a>详细调用过程</h4><p>Python 自带 RPC 的 Demo 小程序的实现过程，流程和分工角色可以用下图来表示：</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9YiaWa3O0o2Kj6e9qIp8p0OLMEzpSleEibLXyIO5YbnpJetfVKFFfD7Dg.jpeg" alt="img"></p>
<p><em>图 8：RPC 调用详细流程图</em></p>
<p>一次 <code>RPC</code>调用流程如下：</p>
<ul>
<li>服务消费者（<code>Client</code> 客户端）通过本地调用的方式调用服务。</li>
<li>客户端存根（<code>Client Stub</code>）接收到调用请求后负责将方法、入参等信息序列化（组装）成能够进行网络传输的消息体。</li>
<li>客户端存根（<code>Client Stub</code>）找到远程的服务地址，并且将消息通过网络发送给服务端。</li>
<li>服务端存根（<code>Server Stub</code>）收到消息后进行解码（反序列化操作）。</li>
<li>服务端存根（<code>Server Stub</code>）根据解码结果调用本地的服务进行相关处理</li>
<li>服务端(<code>Server</code>)本地服务业务处理。</li>
<li>处理结果返回给服务端存根（<code>Server Stub</code>）。</li>
<li>服务端存根（<code>Server Stub</code>）序列化结果。</li>
<li>服务端存根（<code>Server Stub</code>）将结果通过网络发送至消费方。</li>
<li>客户端存根（<code>Client Stub</code>）接收到消息，并进行解码（反序列化）。</li>
<li>服务消费方得到最终结果。</li>
</ul>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9LYtQicicAlAzS86WTmhKaoUBd3J2H6zPdSicTIia3nPRXPnRMiaibUcG5Gbg.jpeg" alt="img"></p>
<h2 id="RPC-核心之功能实现"><a href="#RPC-核心之功能实现" class="headerlink" title="RPC 核心之功能实现"></a>RPC 核心之功能实现</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RPC</code> 的核心功能主要由 5 个模块组成，如果想要自己实现一个 <code>RPC</code>，最简单的方式要实现三个技术点，分别是：</p>
<ul>
<li><strong>服务寻址</strong></li>
<li><strong>数据流的序列化和反序列化</strong></li>
<li><strong>网络传输</strong></li>
</ul>
<h3 id="服务寻址"><a href="#服务寻址" class="headerlink" title="服务寻址"></a>服务寻址</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;服务寻址可以使用 <code>Call ID</code> 映射。在本地调用中，函数体是直接通过函数指针来指定的，但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以<strong>在<code>RPC</code>中，所有的函数都必须有自己的一个 ID</strong>。<strong>这个 ID 在所有进程中都是唯一确定的</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端在做远程过程调用时，必须附上这个 <code>ID</code>。然后我们还需要在客户端和服务端分别维护一个函数和<code>Call ID</code>的对应表。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当客户端需要进行远程调用时，它就查一下这个表，找出相应的 <code>Call ID</code>，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</p>
<p><strong>实现方式：服务注册中心</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要调用服务，首先你需要一个服务注册中心去查询对方服务都有哪些实例。<code>Dubbo</code> 的服务注册中心是可以配置的，官方推荐使用 <code>Zookeeper</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>实现案例：</strong><code>RMI</code>（<code>Remote Method Invocation</code>，远程方法调用）也就是<code>RPC</code>本身的实现方式。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9eiaaJE6ZKgbSSfSr6VUhyEnwaXLAYsaSJoXsFibE2dynRg9MXEaogvibw.jpeg" alt="img"></p>
<p><em>图 9：RMI 架构图</em></p>
<p><strong>Registry(服务发现)：</strong>借助 <code>JNDI</code> 发布并调用了 <code>RMI</code> 服务。实际上，<strong><code>JNDI</code>就是一个注册表，服务端将服务对象放入到注册表中，客户端从注册表中获取服务对象</strong>。</p>
<p><code>RMI</code> 服务在服务端实现之后需要注册到 <code>RMI Server</code> 上，然后客户端从指定的<code>RMI</code> 地址上 <code>Lookup</code>服务，调用该服务对应的方法即可完成远程方法调用。</p>
<p><code>Registry</code>是个很重要的功能，当服务端开发完服务之后，要对外暴露，如果没有服务注册，则客户端是无从调用的，即使服务端的服务就在那里。</p>
<h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时候就<strong>需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式</strong>。</p>
<p>只有二进制数据才能在网络中传输，序列化和反序列化的定义是：</p>
<ul>
<li><strong>将对象转换成二进制流的过程叫做序列化</strong></li>
<li><strong>将二进制流转换成对象的过程叫做反序列化</strong></li>
</ul>
<p>这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。</p>
<h3 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h3><p><strong>网络传输：</strong>远程调用往往用在网络上，客户端和服务端是通过网络连接的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把 <code>Call ID</code> 和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只要能完成这两者的，都可以作为传输层使用。因此，它所<strong>使用的协议其实是不限的，能完成传输就行</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管大部分 <code>RPC</code>框架都使用 TCP 协议，但其实<code>UDP</code>也可以，而 <code>gRPC</code> 干脆就用了 <code>HTTP2</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>TCP 的连接是最常见的，简要分析基于 TCP 的连接：</strong>通常 TCP 连接可以是按需连接（需要调用的时候就先建立连接，调用结束后就立马断掉），也可以是长连接（<strong>客户端和服务器建立起连接之后保持长期持有，不管此时有无数据包的发送，可以配合心跳检测机制定期检测建立的连接是否存活有效</strong>），多个远程过程调用共享同一个连接。</p>
<p>所以，要实现一个 RPC 框架，只需要把以下三点实现了就基本完成了：</p>
<ul>
<li><strong>Call ID 映射：</strong>可以直接使用函数字符串，也可以使用整数 ID。<strong>映射表一般就是一个哈希表</strong>。</li>
<li><strong>序列化反序列化：</strong>可以自己写，也可以使用<code>Protobuf</code> 或者 <code>FlatBuffers</code> 之类的。</li>
<li><strong>网络传输库：</strong>可以自己写 <code>Socket</code>，或者用 <code>Asio，ZeroMQ，Netty</code> 之类。</li>
</ul>
<h2 id="RPC-核心之网络传输协议"><a href="#RPC-核心之网络传输协议" class="headerlink" title="RPC 核心之网络传输协议"></a>RPC 核心之网络传输协议</h2><p>在第三节中说明了要实现一个 <code>RPC</code>，需要选择网络传输的方式。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9AGbpE5ayZm1tmJ9EtssrWOtKz7ibw1DBGCI4hnGaaUn91NXWh9jbZiag.jpeg" alt="img"></p>
<p><em>图 10：网络传输</em></p>
<p>在 RPC 中可选的网络传输方式有多种，可以选择 <code>TCP</code> 协议、<code>UDP</code> 协议、<code>HTTP</code> 协议。</p>
<p>每一种协议对整体的性能和效率都有不同的影响，如何选择一个正确的网络传输协议呢？首先要搞明白各种传输协议在 <code>RPC</code> 中的工作方式。</p>
<h3 id="基于-TCP-协议的-RPC-调用"><a href="#基于-TCP-协议的-RPC-调用" class="headerlink" title="基于 TCP 协议的 RPC 调用"></a>基于 TCP 协议的 RPC 调用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>由服务的调用方与服务的提供方建立 Socket 连接，并由服务的调用方通过 Socket 将需要调用的接口名称、方法名称和参数序列化后传递给服务的提供方，服务的提供方反序列化后再利用反射调用相关的方法</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后将结果返回给服务的调用方，整个基于 <code>TCP</code> 协议的<code>RPC</code>调用大致如此。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是在实例应用中则会进行一系列的封装，如 <code>RMI</code>便是在<code>TCP</code> 协议上传递可序列化的 <code>Java</code>对象。</p>
<h3 id="基于-HTTP-协议的-RPC-调用"><a href="#基于-HTTP-协议的-RPC-调用" class="headerlink" title="基于 HTTP 协议的 RPC 调用"></a>基于 HTTP 协议的 RPC 调用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该方法更像是访问网页一样，只是它的返回结果更加单一简单。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>其大致流程为：</strong>由服务的调用者向服务的提供者发送请求，这种请求的方式可能是 <code>GET、POST、PUT、DELETE</code>等中的一种，服务的提供者可能会根据不同的请求方式做出不同的处理，或者某个方法只允许某种请求方式。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而调用的具体方法则是根据 <code>URL</code> 进行方法调用，而方法所需要的参数可能是对服务调用方传输过去的 <code>XML</code> 数据或者 <code>JSON</code>数据解析后的结果，最后返回<code>JOSN</code> 或者 <code>XML</code> 的数据结果。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于目前有很多开源的 <code>Web</code>服务器，如 <code>Tomcat</code>，所以其实现起来更加容易，就像做 <code>Web</code>项目一样。</p>
<p><strong>两种方式对比</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于 <code>TCP</code> 的协议实现的 <code>RPC</code>调用，由于 <code>TCP</code>协议处于协议栈的下层，能够更加<strong>灵活地对协议字段进行定制，减少网络开销，提高性能，实现更大的吞吐量和并发数</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是需要更多关注底层复杂的细节，实现的代价更高。同时对不同平台，如安卓，iOS 等，需要重新开发出不同的工具包来进行请求发送和相应解析，工作量大，难以快速响应和满足用户需求。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于 <code>HTTP</code> 协议实现的<code>RPC</code>则可以使用<code>JSON</code> 和 <code>XML</code> 格式的请求或响应数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而 <code>JSON</code> 和 <code>XML</code> 作为通用的格式标准（使用 <code>HTTP</code> 协议也需要序列化和反序列化，不过这不是该协议下关心的内容，成熟的 <code>Web</code>程序已经做好了序列化内容），开源的解析工具已经相当成熟，在其上进行二次开发会非常便捷和简单。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是由于<code>HTTP</code>协议是上层协议，发送包含同等内容的信息，使用<code>HTTP</code>协议传输所占用的字节数会比使用 TCP 协议传输所占用的字节数更高。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此<strong>在同等网络下，通过 <code>HTTP</code>协议传输相同内容，效率会比基于 <code>TCP</code>协议的数据效率要低，信息传输所占用的时间也会更长，当然压缩数据，能够缩小这一差距</strong>。</p>
<h3 id="使用-RabbitMQ-的-RPC-架构"><a href="#使用-RabbitMQ-的-RPC-架构" class="headerlink" title="使用 RabbitMQ 的 RPC 架构"></a>使用 RabbitMQ 的 RPC 架构</h3><p>在 <code>OpenStack</code>中服务与服务之间使用 <code>RESTful API</code>调用，而在服务内部则使用<code>RPC</code>调用各个功能模块。</p>
<p>正是由于使用了 <code>RPC</code> 来解耦服务内部功能模块，使得 <code>OpenStack</code> 的服务拥有扩展性强，耦合性低等优点。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>OpenStack</code> 的 <code>RPC</code> 架构中，加入了消息队列 RabbitMQ，这样做的目的是为了保证 <code>RPC</code> 在消息传递过程中的安全性和稳定性</strong>。</p>
<p>下面分析<code>OpenStack</code>中使用 <code>RabbitMQ</code>如何实现 <code>RPC</code>的调用。</p>
<h4 id="RabbitMQ-简介"><a href="#RabbitMQ-简介" class="headerlink" title="RabbitMQ 简介"></a>RabbitMQ 简介</h4><p>以下摘录自知乎：</p>
<p><em>对于初学者，举一个饭店的例子来解释这三个分别是什么吧。不是百分百恰当，但是应该足以解释这三者的区别。</em></p>
<p><strong>RPC：</strong> <em>假设你是一个饭店里的服务员，顾客向你点菜，但是你不会做菜，所以你采集了顾客要点什么之后告诉后厨去做顾客点的菜，这叫<code>RPC(remote procedure call)</code>，因为厨房的厨师相对于服务员而言是另外一个人(在计算机的世界里就是 Remote 的机器上的一个进程)。厨师做好了的菜就是RPC的返回值</em>。</p>
<p><strong>任务队列和消息队列：</strong> <em>本质都是队列，所以就只举一个任务队列的例子。假设这个饭店在高峰期顾客很多，而厨师只有很少的几个，所以服务员们不得不把单子按下单顺序放在厨房的桌子上，供厨师们一个一个做，这一堆单子就是任务队列，厨师们每做完一个菜，就从桌子上的订单里再取出一个单子继续做菜</em>。</p>
<p>角色分担如下图：</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9obO6U81yU9WdPgtkPm8z6SXoYmYTZ8icW6o465IamWpn31MK9N3FXYw.jpeg" alt="img"></p>
<p><em>图 11：RabbitMQ 在 RPC 中角色</em></p>
<p>使用 <code>RabbitMQ</code>的好处：</p>
<ul>
<li><p><strong>同步变异步：</strong>可以使用线程池将同步变成异步，但是缺点是要自己实现线程池，并且强耦合。使用消息队列可以轻松将同步请求变成异步请求。</p>
</li>
<li><p><strong>低内聚高耦合：</strong>解耦，减少强依赖。</p>
</li>
<li><p><strong>流量削峰：</strong>通过消息队列设置请求最大值，超过阀值的抛弃或者转到错误界面。</p>
</li>
<li><p><strong>网络通信性能提高：</strong><code>TCP</code> 的创建和销毁开销大，创建 3 次握手，销毁 4 次分手，高峰时成千上万条的链接会造成资源的巨大浪费，而且操作系统每秒处理 TCP 的数量也是有数量限制的，必定造成性能瓶颈。</p>
</li>
</ul>
<p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RabbitMQ</code> 采用信道通信，不采用 <code>TCP</code> 直接通信。<strong>一条线程一条信道，多条线程多条信道，公用一个 <code>TCP</code>连接</strong>。<strong>一条 <code>TCP</code> 连接可以容纳无限条信道（硬盘容量足够的话），不会造成性能瓶颈</strong>。</p>
<h4 id="RabbitMQ-的三种类型的交换器"><a href="#RabbitMQ-的三种类型的交换器" class="headerlink" title="RabbitMQ 的三种类型的交换器"></a>RabbitMQ 的三种类型的交换器</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RabbitMQ</code> 使用 <code>Exchange</code>（交换机）和 <code>Queue</code>（队列）来实现消息队列。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>RabbitMQ</code> 中一共有三种交换机类型，每一种交换机类型都有很鲜明的特征。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于这三种交换机类型，<code>OpenStack</code> 完成两种 <code>RPC</code>的调用方式。首先简单介绍三种交换机。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9AJTxxbp7Jyumc71AFPwficFGhrI69H2HtzrmdnUt5yqXDzIVuSKUVPQ.jpeg" alt="img"></p>
<p><em>图 12：RabbitMQ 架构图</em></p>
<h5 id="①广播式交换器类型（Fanout）"><a href="#①广播式交换器类型（Fanout）" class="headerlink" title="①广播式交换器类型（Fanout）"></a>①广播式交换器类型（Fanout）</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该类交换器不分析所接收到消息中的<code>Routing Key</code>，<strong>默认将消息转发到所有与该交换器绑定的队列中去</strong>。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9L3bGZXtVQZgvrjQzAmGDQXLCLHXibrP5zRleNkTybYhL0WiaDaZbktibA.jpeg" alt="img"></p>
<p><em>图 13：广播式交换机</em></p>
<p><strong>②直接式交换器类型（Direct）</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该类交换器<strong>需要精确匹配 <code>Routing Key</code> 与 <code>Binding Key</code></strong>，如消息的 <code>Routing Key = Cloud</code>，那么该条消息只能被转发至 <code>Binding Key = Cloud</code> 的消息队列中去。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9u1N2GGY4adI2DMIAJBvhR5J6SDzuDFLeML6vahSFcHQWyibH4VXBlEQ.jpeg" alt="img"></p>
<p><em>图 14：直接式交换机</em></p>
<h5 id="③主题式交换器（Topic-Exchange）"><a href="#③主题式交换器（Topic-Exchange）" class="headerlink" title="③主题式交换器（Topic Exchange）"></a>③主题式交换器（Topic Exchange）</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该类交换器通过消息的 <code>Routing Key</code> 与<code>Binding Key</code> 的<strong>模式匹配，将消息转发至所有符合绑定规则的队列中</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Binding Key</code> 支持通配符，其中<strong><code>“*”</code>匹配一个词组，<code>“#”</code>匹配多个词组（包括零个）</strong>。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9pfcZrhEq53vylD0EricBjadtIYyEMU0HbHroCoHTz04ia0lHFn5cUeBw.jpeg" alt="img"></p>
<p><em>图 15：主题式交换机</em></p>
<blockquote>
<p>当生产者发送消息 <code>Routing Key=F.C.E</code>的时候，这时候只满足 <code>Queue1</code>，所以会被路由到<code>Queue1</code>中。</p>
<p>如果<code>Routing Key=A.C.E</code> 这时候会被同时路由到 <code>Queue1</code> 和<code>Queue2</code> 中，如果<code>Routing Key=A.F.B</code> 时，这里只会发送一条消息到 <code>Queue2</code>中。</p>
</blockquote>
<h4 id="基于-RabbitMQ实现两种-RPC-调用"><a href="#基于-RabbitMQ实现两种-RPC-调用" class="headerlink" title="基于 RabbitMQ实现两种 RPC 调用"></a>基于 RabbitMQ实现两种 RPC 调用</h4><p><code>Nova</code> 基于 <code>RabbitMQ</code> 实现两种 <code>RPC</code>调用：</p>
<ul>
<li><strong>RPC.CALL（调用）</strong></li>
<li><strong>RPC.CAST（通知）</strong></li>
</ul>
<p>其中 <code>RPC.CALL</code> 基于请求与响应方式，<code>RPC.CAST</code> 只是提供单向请求，两种 <code>RPC</code>调用方式在 <code>Nova</code>中均有典型的应用场景。</p>
<h5 id="RPC-CALL"><a href="#RPC-CALL" class="headerlink" title="RPC.CALL"></a>RPC.CALL</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RPC.CALL</code> 是一种双向通信流程，即 <code>RabbitMQ</code>接收消息生产者生成的系统请求消息，消息消费者经过处理之后<strong>将系统相应结果反馈给调用程序</strong>。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG98jnSicmOIAyKeyemXzUyRP3uaOluibkFK5jzYsgmd6cRAXVvH8ObibyWQ.jpeg" alt="img"></p>
<p><em>图 16：RPC.CALL 原理图</em></p>
<p>一个用户通过 <code>Dashboard</code>创建一个虚拟机，界面经过消息封装后发送给 <code>NOVA-API</code>。</p>
<p><strong><code>NOVA-API</code>作为消息生产者，将该消息以 <code>RPC.CALL</code> 方式通过 <code>Topic</code> 交换器转发至消息队列</strong>。</p>
<p>此时，<code>Nova-Compute</code> 作为消息消费者，接收该信息并通过底层虚拟化软件执行相应虚拟机的启动进程。</p>
<p><strong>待用户虚拟机成功启动之后，<code>Nova-Compute</code>作为消息生产者通过<code>Direct</code>交换器和响应的消息队列将虚拟机启动成功响应消息反馈给 <code>Nova-API</code></strong>。</p>
<p>此时<code>Nova-API</code>作为消息消费者接收该消息并通知用户虚拟机启动成功。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG97qkiaIdTiaX1yORBW0T2aiah9TYEZfdbu9PzqXoVeJhPp2pqE2NkalrcA.jpeg" alt="img"></p>
<p><code>RPC.CALL</code> 工作原理如下图：</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9gFu4q9zw8FALr6iawhf9otEEVBNzyDUicKho02dQHCYJ3Ez2iaxxrEdJQ.jpeg" alt="img"></p>
<p><em>图 17：RPC.CALL 具体实现图</em></p>
<p>工作流程：</p>
<ul>
<li>客户端创建 <code>Message</code> 时指定<code>reply_to</code> 队列名、<code>correlation_id</code> 标记调用者。</li>
<li>通过队列，服务端收到消息。调用函数处理，然后返回。</li>
<li>返回的队列是 <code>reply_to</code>指定的队列，并携带 <code>correlation_id</code>。</li>
<li>返回消息到达客户端，客户端根据<code>correlation_id</code> 判断是哪一个函数的调用返回。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有多个线程同时进行远程方法调用，这时建立在 <code>Client Server</code> 之间的 <code>Socket</code>连接上会有很多双方发送的消息传递，前后顺序也可能是随机的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Server</code>处理完结果后，将结果消息发送给<code>Client，Client</code>收到很多消息，怎么知道哪个消息结果是原先哪个线程调用的？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Client</code>线程每次通过<code>Socket</code>调用一次远程接口前，生成一个唯一的<code>ID</code>，即 <code>Request ID</code>（<code>Request ID</code>必需保证在一个 <code>Socket</code> 连接里面是唯一的），一般常常使用<code>AtomicLong</code>从 0 开始累计数字生成唯一<code>ID</code></strong>。</p>
<h5 id="RPC-CAST"><a href="#RPC-CAST" class="headerlink" title="RPC.CAST"></a>RPC.CAST</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RPC.CAST</code> 的远程调用流程与 <code>RPC.CALL</code> 类似，只是<strong>缺少了系统消息响应流程</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个 <code>Topic</code> 消息生产者发送系统请求消息到<code>Topic</code> 交换器，<code>Topic</code> 交换器根据消息的<code>Routing Key</code>将消息转发至共享消息队列。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与共享消息队列相连的所有 <code>Topic</code>消费者接收该系统请求消息，并把它传递给响应的服务端进行处理。</p>
<p>其调用流程如图所示：</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9Hia4FsGJJN2d6RNDTvStloVXMxFCXtGWs5MDPxLvh80W7DfTfyjc2rQ.jpeg" alt="img"></p>
<p><em>图 18：RPC.CAST 原理图</em></p>
<h5 id="连接设计"><a href="#连接设计" class="headerlink" title="连接设计"></a>连接设计</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>RabbitMQ</code> 实现的 <code>RPC</code> 对网络的一般设计思路：消费者是长连接，发送者是短连接</strong>。但可以自由控制长连接和短连接。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>一般消费者是长连接，随时准备接收处理消息</strong>；而且涉及到 <code>RabbitMQ Queues、Exchange 的 auto-deleted</code>等没特殊需求没必要做短连接。<strong>发送者可以使用短连接，不会长期占住端口号，节省端口资源</strong>。</p>
<p><code>Nova</code> 中 <code>RPC</code> 代码设计：</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9ZyMHxa11kdWfQNibCMicicFRNvrmy0SI1uAe9adtibRHd1kXRvPzbx4ia3w.jpeg" alt="img"></p>
<h2 id="RESTful-API-架构"><a href="#RESTful-API-架构" class="headerlink" title="RESTful API 架构"></a>RESTful API 架构</h2><p><code>REST</code> 最大的几个特点为：<strong>资源、统一接口、URI 和无状态</strong>。</p>
<h3 id="①资源"><a href="#①资源" class="headerlink" title="①资源"></a>①资源</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，就是一个具体的实在。</p>
<h3 id="②统一接口"><a href="#②统一接口" class="headerlink" title="②统一接口"></a>②统一接口</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RESTful</code>架构风格规定，数据的元操作，即 <code>CRUD(Create，Read，Update 和 Delete</code>，即数据的增删查改)操作，分别对应于 HTTP 方法：GET 用来获取资源，POST 用来新建资源（也可以用于更新资源），PUT 用来更新资源，DELETE 用来删除资源，这样就统一了数据操作的接口，仅通过 HTTP 方法，就可以完成对数据的所有增删查改工作。</p>
<h3 id="③URL"><a href="#③URL" class="headerlink" title="③URL"></a>③URL</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以用一个 <code>URI</code>（统一资源定位符）指向资源，即每个 <code>URI</code> 都对应一个特定的资源。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要获取这个资源，访问它的 <code>URI</code>就可以，因此<code>URI</code> 就成了每一个资源的地址或识别符。</p>
<h3 id="④无状态"><a href="#④无状态" class="headerlink" title="④无状态"></a>④无状态</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓无状态的，即所有的资源，都可以通过 <code>URI</code>定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而改变。有状态和无状态的区别，举个简单的例子说明一下。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如查询员工的工资，如果查询工资是需要登录系统，进入查询工资的页面，执行相关操作后，获取工资的多少，则这种情况是有状态的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为查询工资的每一步操作都依赖于前一步操作，只要前置操作不成功，后续操作就无法执行。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果输入一个 URI 即可得到指定员工的工资，则这种情况是无状态的，因为获取工资不依赖于其他资源或状态。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;且这种情况下，员工工资是一个资源，由一个 URI 与之对应，可以通过 HTTP 中的 GET 方法得到资源，这是典型的 <code>RESTful</code> 风格。</p>
<h2 id="RPC-和-Restful-API-对比"><a href="#RPC-和-Restful-API-对比" class="headerlink" title="RPC 和 Restful API 对比"></a>RPC 和 Restful API 对比</h2><h3 id="面对对象不同"><a href="#面对对象不同" class="headerlink" title="面对对象不同"></a>面对对象不同</h3><ul>
<li><code>RPC</code>更侧重于<strong>动作</strong>。</li>
<li><code>REST</code> 的主体是<strong>资源</strong>。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RESTful</code> 是面向资源的设计架构，但在系统中有很多对象不能抽象成资源，比如登录，修改密码等而 <code>RPC</code> 可以通过动作去操作资源。所以<strong>在操作的全面性上 RPC 大于 RESTful</strong>。</p>
<h3 id="传输效率"><a href="#传输效率" class="headerlink" title="传输效率"></a>传输效率</h3><ul>
<li><code>RPC</code> 效率更高。<code>RPC</code>，使用自定义的<code>TCP</code>协议，可以让请求报文体积更小，或者使用 <code>HTTP2</code> 协议，也可以很好的<strong>减少报文的体积，提高传输效率</strong>。</li>
</ul>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li><code>RPC</code> 实现复杂，流程繁琐。</li>
<li><code>REST</code> 调用及测试都很方便。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RPC</code> 实现（参见第一节）需要实现编码，序列化，网络传输等。而<code>RESTful</code> 不要关注这些，<code>RESTful</code>实现更简单。</p>
<h3 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a>灵活性</h3><ul>
<li><code>HTTP</code> 相对更规范，更标准，更通用，无论哪种语言都支持 <code>HTTP</code>协议。</li>
<li><code>RPC</code>可以实现跨语言调用，但整体灵活性不如 <code>RESTful</code>。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong><code>RPC</code> 主要用于公司内部的服务调用</strong>，性能消耗低，传输效率高，实现复杂。</p>
<p><strong><code>HTTP</code> 主要用于对外的异构环境</strong>，浏览器接口调用，App 接口调用，第三方接口调用等。</p>
<p><code>RPC</code> 使用场景（大型的网站，内部子系统较多、接口非常多的情况下适合使用 <code>RPC</code>）：</p>
<ul>
<li><strong>长链接。</strong>不必每次通信都要像 <code>HTTP</code> 一样去 3 次握手，减少了网络开销。</li>
<li><strong>注册发布机制。</strong>RPC 框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。</li>
<li><strong>安全性，</strong>没有暴露资源操作。</li>
<li><strong>微服务支持。</strong>就是最近流行的服务化架构、服务化治理，<code>RPC</code> 框架是一个强力的支撑。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/41/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/41/">41</a><span class="page-number current">42</span><a class="page-number" href="/page/43/">43</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/43/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
