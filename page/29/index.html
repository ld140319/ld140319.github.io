<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/page/29/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/page/29/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/07/04/微服务一条龙最佳指南Dockerfile篇/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/04/微服务一条龙最佳指南Dockerfile篇/" itemprop="url">微服务一条龙最佳指南Dockerfile篇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-04T12:12:57+08:00">
                2019-07-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="微服务一条龙最佳指南Dockerfile篇"><a href="#微服务一条龙最佳指南Dockerfile篇" class="headerlink" title="微服务一条龙最佳指南Dockerfile篇"></a>微服务一条龙最佳指南Dockerfile篇</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://zhuanlan.zhihu.com/p/46657853?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=645526066970759168、" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46657853?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=645526066970759168、</a></p>
</blockquote>
<h2 id="1-Dockerfile可能遇到的问题"><a href="#1-Dockerfile可能遇到的问题" class="headerlink" title="1. Dockerfile可能遇到的问题"></a>1. Dockerfile可能遇到的问题</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然 <code>Dockerfile</code>简化了镜像构建的过程，并且把这个过程可以进行版本控制，但是不正当的 <code>Dockerfile</code> 使用也会导致很多问题：<br>（1）<code>docker</code><strong>镜像太大</strong>。如果你经常使用镜像或者构建镜像，一定会遇到那种很大的镜像，甚至有些能达到数G，就像我这次想要构建一个<code>python</code>+<code>node</code>的镜像结果花了1.4G。<br>（2）<code>docker</code> 镜像的<strong>构建时间过长</strong>。每个 <code>build</code> 都会耗费很长时间，对于需要经常构建镜像（比如单元测试）的地方这可能是个大问题，就像你可能每次只改一两行代码，却要花上10多分钟来构建新的镜像，完全是浪费时间。<br>（3）<strong>重复劳动</strong>。多次镜像构建之间大部分内容都是完全一样而且重复的，但是每次都要做一遍，浪费时间和资源。</p>
<h2 id="2-最佳实践指导方针和建议"><a href="#2-最佳实践指导方针和建议" class="headerlink" title="2. 最佳实践指导方针和建议"></a>2. 最佳实践指导方针和建议</h2><h3 id="1-容器应该是短暂的"><a href="#1-容器应该是短暂的" class="headerlink" title="1. 容器应该是短暂的"></a>1. 容器应该是短暂的</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;容器模型是进程而不是机器，不需要开机初始化。在需要时运行，不需要时停止，能够删除后重建，并且配置和启动的最小化。这就是<code>Docker</code>和虚拟机最大的区别，进程化，说白了就是使用宿主机上的虚拟内核来起一个进程，<strong>一个进程代表一个容器，这样可以做到即插即用</strong>。</p>
<h3 id="2-使用-dockerignore文件"><a href="#2-使用-dockerignore文件" class="headerlink" title="2.使用.dockerignore文件"></a>2.使用.dockerignore文件</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>docker build</code> 的时候，忽略部分无用的文件和目录可以提高构建的速度。比如.git目录。<code>dockerignore</code>的定义类似<code>gitignore</code>。具体使用方式可以参考<a href="https://link.zhihu.com/?target=https%3A//docs.docker.com/engine/reference/builder/%23dockerignore-file" target="_blank" rel="noopener">链接</a>。其实大家都是用过<code>gitignore</code>，这里的<code>dockerignore</code>不仅可以忽略部分无用的文件，而且还保证了构建速度的提高，因为一般来说使用 <code>docker build</code>的时候都会直接使用 <code>docker build -t xx .</code>这样直接利用上下文，最好是定义<code>dockerignore</code>文件来忽略部分无用的文件。</p>
<h3 id="3-避免安装不必要的安装包"><a href="#3-避免安装不必要的安装包" class="headerlink" title="3.避免安装不必要的安装包"></a>3.避免安装不必要的安装包</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了减少镜像的复杂性、镜像大小和构建时间，应该避免安装无用的包。例如<code>Python</code>一样，你的工程目录中的<code>requirements</code>文件应该只包含你所需要的包，而不应当是包含一些无用的包，这样不仅浪费构建时间还变相扩大了整个镜像的大小。</p>
<h3 id="4-每个容器只运行一个进程"><a href="#4-每个容器只运行一个进程" class="headerlink" title="4.每个容器只运行一个进程"></a>4.每个容器只运行一个进程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>一个容器只运行一个进程</strong>。容器起到了隔离应用隔离数据的作用，不同的应用运行在不同的容器让集群的纵向扩展以及容器的复用都变的更加简单。需要多个应用交互时请使用 <code>link</code>命令进行组合或者使用<code>docker-compose</code>。这点是很多人没有注意到的问题，因为比如一个容器起了两个进程，我们下次需要对于一个进程做扩展时会以容器为粒度增加容器，实际了把另一个无关容器扩展，这样对于集群的纵向扩展以及容器的复用都有限制，所以，最基本的理念，一个容器只起一个进程。</p>
<h3 id="5-最小化层数"><a href="#5-最小化层数" class="headerlink" title="5.最小化层数"></a>5.最小化层数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要掌握好<code>Dockerfile</code>的可读性和镜像层数之间的平衡。不推荐使用过多的镜像层。记住！<strong>一个指令就会创建一层</strong>，所以，尽最大可能精简你的<code>Dockerfile</code>。</p>
<h3 id="6-多行命令按字母排序"><a href="#6-多行命令按字母排序" class="headerlink" title="6.多行命令按字母排序"></a>6.多行命令按字母排序</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;命令行按字母顺序排序有助于避免重复执行和提高<code>Dockerfile</code>可读性。<code>apt-get update</code> 应与<code>apt-get install</code>组合，换行使用反斜杠（\）。例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="bash">  bzr \</span></span><br><span class="line"><span class="bash">  cvs \</span></span><br><span class="line"><span class="bash">  git \</span></span><br><span class="line"><span class="bash">  mercurial \</span></span><br><span class="line"><span class="bash">  subversion</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里要是把两个命令分开的话问题有会两个，在<code>docker build</code>的时候使用<code>--no-cache</code>这样会把这两个命令当成两个，也就是会多创建一层，增加系统构建时间和大小，如果不使用，系统构建时会把<code>apt-get update</code>当成系统命令，默认不执行，因此可能会导致新的包不会被安装。</p>
<h3 id="7-构建缓存"><a href="#7-构建缓存" class="headerlink" title="7.构建缓存"></a>7.构建缓存</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Dockerfile</code>的每条指令都会将结果提交为新的镜像。下一条指令基于上一条指令的镜像进行构建。如果一个镜像拥有相同的父镜像和指令（除了 <code>ADD</code>)，<code>Docker</code>将会使用镜像而不是执行该指令，即缓存。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，为了有效的利用缓存，<strong>尽量保持<code>Dockerfile</code>一致，并且将不变的放在前面而经常改变放在末尾</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如不希望使用缓存，在执行 <code>docker build</code> 的时候加上参数 <code>--no-cache=true</code> 。</p>
<p><code>Docker</code>匹配镜像决定是否使用缓存的规则如下:</p>
<p>（1）从缓存中存在的基础镜像开始，比较所有子镜像，检查它们构建的指令是否和当前的是否完全一致。如果不一致则缓存不匹配。</p>
<p>（2）多数情况中，比较<code>Dockerfile</code>中的指令是足够的。然而，特定的指令需要做更多的判断。</p>
<p>（3）<code>ADD COPY</code> 指令中，将要添加到镜像中的文件也要被检查。通常是检查文件的校验和(<code>checksum</code>)。</p>
<p>（4）缓存匹配检查并不检查容器中的文件。例如，当使用<code>RUN apt-get -y update</code>命令更新了容器中的文件，并不会被缓存检查策略作为缓存匹配的依据。这也就是说虽然文件更新了，但是命令相同，依旧是使用缓存，所以会导致更新失效。</p>
<h3 id="8-时区"><a href="#8-时区" class="headerlink" title="8.时区"></a>8.时区</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;官方<code>Image</code> 使用的时区基本上都是标准的 <code>UTC</code> 时间，如果容器想使用中国标准时间，基于<code>Debian</code>的系统在<code>Dockerfile</code>中加入</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br><span class="line"><span class="bash">RUN <span class="built_in">echo</span> <span class="string">"Asia/Shanghai"</span> &gt;&gt; /etc/timezone</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于<code>Centos</code>的系统在<code>Dockerfile</code>中加入</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span></span><br></pre></td></tr></table></figure>
<h3 id="9-修改默认源"><a href="#9-修改默认源" class="headerlink" title="9.修改默认源"></a>9.修改默认源</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有时候你可能感觉官方的源更新或者安装软件比较慢，可以在<code>Dockerfile</code>修改官方默认源，例如<code>alpine</code>想使用阿里的源可以在<code>Dockerfile</code>中加入：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> -e <span class="string">"http://mirrors.aliyun.com/alpine/v3.5/</span></span></span><br><span class="line"><span class="bash">main\nhttp://mirrors.aliyun.com/alpine/v3.5/community<span class="string">" &gt; /etc/apk/repositories</span></span></span><br></pre></td></tr></table></figure>
<p>都是知识点！！！</p>
<h3 id="10-正确理解Dockerfile指令"><a href="#10-正确理解Dockerfile指令" class="headerlink" title="10.正确理解Dockerfile指令"></a>10.正确理解Dockerfile指令</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先说说很多人其实并不是一定理解<code>Dockerfile</code>里面每一个指令的含义，以及与其他指令的微小区别，比如<code>add</code>和<code>copy</code>等等。</p>
<h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;推荐使用官方仓库中的镜像作为基础镜像，不用说大家都理解。</p>
<h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把复杂的或过长的 <code>RUN</code>语句写成以<code>\</code>结尾的多行的形式，以提高可读性和可维护性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update 和 apt-get install 一起执行，否则 apt-get install 会出现异常。</span><br><span class="line">这个严重的问题必须要好好提提~~~</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>避免运行 <code>apt-get upgrade</code> 或<code>dist-upgrade</code></strong>，在无特权的容器中，很多必要的包不能正常升级。如果基础镜像过时了，应当联系维护者。 推荐<code>apt-get update &amp;&amp; apt-get install -y package-a package-b</code>这种方式，先更新，之后安装最新的软件包。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y \</span></span><br><span class="line"><span class="bash">    aufs-tools \</span></span><br><span class="line"><span class="bash">    automake \</span></span><br><span class="line"><span class="bash">    build-essential \</span></span><br><span class="line"><span class="bash">    curl \</span></span><br><span class="line"><span class="bash">    dpkg-sig \</span></span><br><span class="line"><span class="bash">    libcap-dev \</span></span><br><span class="line"><span class="bash">    libsqlite3-dev \</span></span><br><span class="line"><span class="bash">    mercurial \</span></span><br><span class="line"><span class="bash">    reprepro \</span></span><br><span class="line"><span class="bash">    ruby1.9.1 \</span></span><br><span class="line"><span class="bash">    ruby1.9.1-dev \</span></span><br><span class="line"><span class="bash">    s3cmd=1.1.* \</span></span><br><span class="line"><span class="bash"> &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br></pre></td></tr></table></figure>
<p>此外,你可以通过移除<code>/var/lib/apt/lists</code>减少镜像大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：官方的Ubuntu和Debian会自动运行apt-get clean，所以不需要显式的调用</span><br></pre></td></tr></table></figure>
<p>注意：官方的<code>Ubuntu</code>和<code>Debian</code>会自动运行<code>apt-get clean</code>，所以不需要显式的调用</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"s3cmd"</span>]</span></span><br><span class="line"><span class="bash">CMD [<span class="string">"--help"</span>]</span></span><br></pre></td></tr></table></figure>
<p>获取帮助：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run s3cmd</span><br></pre></td></tr></table></figure>
<p>或者执行命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run s3cmd ls s3://mybucket</span><br></pre></td></tr></table></figure>
<p>这在镜像名与程序重名时非常有用。</p>
<p><code>ENTRYPOINT</code> 也可以启动自定义脚本： 定义脚本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'postgres'</span> ]; <span class="keyword">then</span></span><br><span class="line">    chown -R postgres <span class="string">"<span class="variable">$PGDATA</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$(ls -A "$PGDATA")</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        gosu postgres initdb</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exec</span> gosu postgres <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line">注意：这段脚本使用了<span class="built_in">exec</span>命令以确保最终应用程序在容器内启动的PID为1。这段脚本允许容器接收Unix signals。</span><br><span class="line">COPY ./docker-entrypoint.sh /</span><br><span class="line">ENTRYPOINT [<span class="string">"/docker-entrypoint.sh"</span>]</span><br></pre></td></tr></table></figure>
<h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;应该尽可能地使用默认端口。例如<code>Apache web</code>服务使用<code>EXPOSE 80</code>，<code>MongoDB</code>使用<code>EXPOSE 27017</code>。</p>
<h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用<code>ENV</code>更新<code>PATH</code>环境变量。例如，<code>ENV PATH /usr/local/nginx/bin:$PATH</code>可以确保<code>CMD [“nginx”]</code>正常运行。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ENV</code>还可以提供程序所需要的环境变量，例如<code>Postgres</code>的 <code>PGDATA</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ENV</code>可以设置版本等信息。使版本信息更易于维护。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> PG_MAJOR <span class="number">9.3</span></span><br><span class="line"><span class="keyword">ENV</span> PG_VERSION <span class="number">9.3</span>.<span class="number">4</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -SL http://example.com/postgres-<span class="variable">$PG_VERSION</span>.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …</span></span><br><span class="line"><span class="bash">ENV PATH /usr/<span class="built_in">local</span>/postgres-<span class="variable">$PG_MAJOR</span>/bin:<span class="variable">$PATH</span></span></span><br></pre></td></tr></table></figure>
<h4 id="ADD-or-COPY"><a href="#ADD-or-COPY" class="headerlink" title="ADD or COPY"></a>ADD or COPY</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然 <code>ADD</code> 与 <code>COPY</code>功能类似，但推荐使用 <code>COPY</code> 。<code>COPY</code>只支持基本的文件拷贝功能，更加的可控。而 <code>ADD</code> 具有更多特定，比如<code>tar</code>文件自动提取，支持<code>URL</code>。 通常需要提取<code>tarball</code>中的文件到容器的时候才会用到 <code>ADD</code> 。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>如果在<code>Dockerfile</code>中使用多个文件，每个文件应使用单独的 <code>COPY</code> 指令。这样，只有出现文件变化的指令才会不使用缓存</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>为了控制镜像的大小，不建议使用 <code>ADD</code> 指令获取<code>URL</code>文件</strong>。<strong>正确的做法是在 <code>RUN</code>指令中使用<code>wget</code> 或 <code>curl</code>来获取文件，并且在文件不需要的时候删除文件</strong>。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/src/things \</span></span><br><span class="line"><span class="bash">    &amp;&amp; curl -SL http://example.com/big.tar.gz \</span></span><br><span class="line"><span class="bash">    | tar -xJC /usr/src/things \</span></span><br><span class="line"><span class="bash">    &amp;&amp; make -C /usr/src/things all</span></span><br></pre></td></tr></table></figure>
<p>一句话，<code>COPY</code>透明度好，它只能干复制的工作，<code>ADD</code>鬼知道他还能干什么~</p>
<h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>VOLUME</code> 通常用作数据卷，对于任何可变的文件，包括数据库文件、代码库、或者容器所创建的文件/目录等都应该使用 <code>VOLUME</code>挂载。这点有点生产环境体验的同学相信不会陌生。</p>
<h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果服务不需要特权来运行，使用<code>USER</code>指令切换到非<code>root</code>用户。使用 <code>RUN groupadd -r mysql &amp;&amp; useradd -r -g mysql mysql</code>之后用<code>USER mysql</code>切换用户</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要避免使用 <code>sudo</code>来提升权限，因为它带来的问题远比它能解决的问题要多。如果你确实需要这样的特性，那么可以选择使用 <a href="https://link.zhihu.com/?target=https%3A//github.com/tianon/gosu" target="_blank" rel="noopener">gosu</a> 。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，<strong>不要反复的切换用户</strong>。减少不必要的<code>layers</code>。</p>
<h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了清晰和可维护性，应该使用<code>WORKDIR</code>来定义工作路径。推荐使用<code>WORKDIR</code>来代替<code>RUN cd … &amp;&amp; do-something</code> 这样的指令。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/07/04/从Docker镜像构建演化史来了解多阶段构建的影响/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/04/从Docker镜像构建演化史来了解多阶段构建的影响/" itemprop="url">从Docker镜像构建演化史来了解多阶段构建的影响</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-04T12:12:57+08:00">
                2019-07-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="从Docker镜像构建演化史来了解多阶段构建的影响"><a href="#从Docker镜像构建演化史来了解多阶段构建的影响" class="headerlink" title="从Docker镜像构建演化史来了解多阶段构建的影响"></a>从Docker镜像构建演化史来了解多阶段构建的影响</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://zhuanlan.zhihu.com/p/60128631" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/60128631</a></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在很多开发者都会慢慢习惯在开发环境通过<code>Docker</code>来构建开发环境，有时候可能会有<strong>环境移植</strong>的问题，所以需要我们写好一套<code>Dockerfile</code>来构建相关的开发镜像，既然说到镜像，那我想问问大家了解<code>Docker</code>镜像的演变史吗？我们现在就来回顾一下吧。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自从2013年<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/DotCloud" target="_blank" rel="noopener">dotCloud公司</a>(现已改名为<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Docker%2C_Inc." target="_blank" rel="noopener">Docker Inc</a>)发布<a href="https://link.zhihu.com/?target=http%3A//tonybai.com/tag/docker" target="_blank" rel="noopener">Docker容器技术</a>以来，到目前为止已经有四年多的时间了。这期间<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Docker_(software" target="_blank" rel="noopener">Docker技术</a>)飞速发展，并催生出一个生机勃勃的、以轻量级容器技术为基础的庞大的容器平台生态圈。作为<code>Docker</code>三大核心技术之一的<strong>镜像技术</strong>在<code>Docker</code>的快速发展之路上可谓功不可没：镜像让容器真正插上了翅膀，实现了容器自身的重用和标准化传播，使得开发、交付、运维流水线上的各个角色真正围绕同一交付物，<code>“test what you write, ship what you test”</code>成为现实。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于已经接纳和使用<code>Docker技术</code>在日常开发工作中的开发者而言，构建<code>Docker镜像</code>已经是家常便饭。但如何更高效地构建以及构建出<code>Size</code>更小的镜像却是很多<code>Docker</code>技术初学者心中常见的疑问，甚至是一些老手都未曾细致考量过的问题。本文将从一个<code>Docker</code>用户角度来阐述<code>Docker</code>镜像构建的演化史，希望能起到一定的解惑作用。</p>
<h2 id="一、镜像：继承中的创新"><a href="#一、镜像：继承中的创新" class="headerlink" title="一、镜像：继承中的创新"></a>一、镜像：继承中的创新</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;谈镜像构建之前，我们先来简要说下<strong>镜像</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Docker</code>技术本质上并不是新技术，而是将已有技术进行了更好地整合和包装。内核容器技术以一种完整形态最早出现在<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Sun_Microsystems" target="_blank" rel="noopener">Sun公司</a>的<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Solaris_(operating_system" target="_blank" rel="noopener">Solaris操作系统</a>)上，<a href="https://link.zhihu.com/?target=http%3A//tonybai.com/tag/solaris" target="_blank" rel="noopener">Solaris</a>是当时最先进的服务器操作系统。2005年Sun发布了<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Solaris_Containers" target="_blank" rel="noopener">Solaris Container</a>技术，从此开启了内核容器之门。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2008年，以Google公司开发人员为主导实现的<code>Linux Container</code>(即<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/LXC" target="_blank" rel="noopener">LXC</a>)功能在被merge到<a href="https://link.zhihu.com/?target=https%3A//www.kernel.org/" target="_blank" rel="noopener">Linux内核</a>中。<code>LXC</code>是一种内核级虚拟化技术，主要基于<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Cgroups%23NAMESPACE-ISOLATION" target="_blank" rel="noopener">Namespaces</a>和<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">Cgroups</a>技术，实现共享一个操作系统内核前提下的进程资源隔离，为进程提供独立的虚拟执行环境，这样的一个虚拟的执行环境就是一个容器。本质上说，<code>LXC</code>容器与现在的<code>Docker</code>所提供容器是一样的。<code>Docker</code>也是基于<code>Namespaces</code>和<code>Cgroups</code>技术之上实现的，<strong><code>Docker</code>的创新之处在于其基于<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/UnionFS" target="_blank" rel="noopener">Union File System</a>技术定义了一套容器打包规范，真正将容器中的应用及其运行的所有依赖都封装到一种特定格式的文件中去，而这种文件就被称为镜像</strong>（即<code>image</code>），原理见下图（引自<code>Docker</code>官网）：</p>
<p><img src="//blog.com/2019/07/04/从Docker镜像构建演化史来了解多阶段构建的影响/v2-d76c5c4e9c2238430b70f3b697f29834_hd.jpg" alt="img"></p>
<p><em>图1：Docker镜像原理</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;镜像是容器的“序列化”标准，这一创新为容器的存储、重用和传输奠定了基础。并且“坐上了巨轮”的容器镜像可以传播到世界每一个角落，这无疑助力了容器技术的飞速发展。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Solaris_Containers" target="_blank" rel="noopener">Solaris Container</a>、<code>LXC</code>等早期内核容器技术不同，<code>Docker</code>为开发者提供了开发者体验良好的工具集，这其中就包括了用于镜像构建的<code>Dockerfile</code>以及一种用于编写<code>Dockerfile</code>领域特定语言。<strong>采用<code>Dockerfile</code>方式构建成为镜像构建的标准方法，其可重复、可自动化、可维护以及分层精确控制</strong>等特点是采用传统采用<code>docker commit</code>命令提交的镜像所不能比拟的。</p>
<h2 id="二、“镜像是个筐”：初学者的认知"><a href="#二、“镜像是个筐”：初学者的认知" class="headerlink" title="二、“镜像是个筐”：初学者的认知"></a>二、“镜像是个筐”：初学者的认知</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>“镜像是个筐，什么都往里面装”</strong>– 这句俏皮话可能是大部分<code>Docker</code>初学者对镜像最初认知的真实写照。这里我们用一个例子来生动地展示一下。我们将<code>httpserver.go</code>这个源文件编译为<code>httpd</code>程序并通过镜像发布，考虑到被编译的源码并非本文重点，这里使用了一个极简的<code>demo</code>代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//httpserver.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"http daemon start"</span>)</span><br><span class="line">        fmt.Println(<span class="string">"  -&gt; listen on port:8080"</span>)</span><br><span class="line">        http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来，我们来编写一个用于构建目标<code>image</code>的<code>Dockerfile</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">From</span> ubuntu:<span class="number">14.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update \</span></span><br><span class="line"><span class="bash">      &amp;&amp; apt-get install -y software-properties-common \</span></span><br><span class="line"><span class="bash">      &amp;&amp; add-apt-repository ppa:gophers/archive \</span></span><br><span class="line"><span class="bash">      &amp;&amp; apt-get update \</span></span><br><span class="line"><span class="bash">      &amp;&amp; apt-get install -y golang-1.9-go \</span></span><br><span class="line"><span class="bash">                            git \</span></span><br><span class="line"><span class="bash">      &amp;&amp; rm -rf /var/lib/apt/lists/*</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ENV GOPATH /root/go</span></span><br><span class="line"><span class="bash">ENV GOROOT /usr/lib/go-1.9</span></span><br><span class="line"><span class="bash">ENV PATH=<span class="string">"/usr/lib/go-1.9/bin:<span class="variable">$&#123;PATH&#125;</span>"</span></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY ./httpserver.go /root/httpserver.go</span></span><br><span class="line"><span class="bash">RUN go build -o /root/httpd /root/httpserver.go \</span></span><br><span class="line"><span class="bash">      &amp;&amp; chmod +x /root/httpd</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">WORKDIR /root</span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"/root/httpd"</span>]</span></span><br></pre></td></tr></table></figure>
<p>构建这个<code>Image</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker build -t repodemo/httpd:latest .</span></span><br><span class="line">//...构建输出这里省略...</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                       TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">repodemo/httpd                   latest              183dbef8eba6        2 minutes ago       550MB</span><br><span class="line">ubuntu                           14.04               dea1945146b9        2 months ago        188MB</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整个镜像的构建过程因环境而定。如果您的网络速度一般，这个构建过程可能会花费你10多分钟甚至更多。最终如我们所愿，基于<code>repodemo/httpd:latest</code>这个镜像的容器可以正常运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># docker run repodemo/httpd</span><br><span class="line">http daemon start</span><br><span class="line">  -&gt; listen on port:8080</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>一个<code>Dockerfile</code>最终生产出一个镜像</strong>。<strong><code>Dockerfile</code>由若干<code>Command</code>组成，每个<code>Command</code>执行结果都会单独形成一个<code>layer</code></strong>。我们来探索一下构建出来的镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker history 183dbef8eba6</span></span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">183dbef8eba6        21 minutes ago      /bin/sh -c <span class="comment">#(nop)  ENTRYPOINT ["/root/httpd"]   0B</span></span><br><span class="line">27aa721c6f6b        21 minutes ago      /bin/sh -c <span class="comment">#(nop) WORKDIR /root                 0B</span></span><br><span class="line">a9d968c704f7        21 minutes ago      /bin/sh -c go build -o /root/httpd /root/h...   6.14MB</span><br><span class="line">... ...</span><br><span class="line">aef7700a9036        30 minutes ago      /bin/sh -c apt-get update       &amp;&amp; apt-get...   356MB</span><br><span class="line">.... ...</span><br><span class="line">&lt;missing&gt;           2 months ago        /bin/sh -c <span class="comment">#(nop) ADD file:8f997234193c2f5...   188MB</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们去除掉那些<code>Size</code>为0或很小的<code>layer</code>，我们看到三个<code>size</code>占比较大的<code>layer</code>，见下图：</p>
<p><img src="//blog.com/2019/07/04/从Docker镜像构建演化史来了解多阶段构建的影响/v2-6857ce7679a543b941a447ce8e523a66_hd.jpg" alt="img"></p>
<p><em>图2：<code>Docker</code>镜像分层探索</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然<strong><code>Docker</code>引擎利用缓存机制可以让同主机下非首次的镜像构建执行得很快</strong>，但是在<code>Docker</code>技术热情催化下的这种构建思路让<code>docker</code>镜像在存储和传输方面的优势荡然无存，要知道一个<code>ubuntu-server 16.04</code>的虚拟机<code>ISO</code>文件的大小也就不过600多MB而已。</p>
<h2 id="三、”理性的回归”：builder模式的崛起"><a href="#三、”理性的回归”：builder模式的崛起" class="headerlink" title="三、”理性的回归”：builder模式的崛起"></a>三、”理性的回归”：builder模式的崛起</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Docker</code>使用者在新技术接触初期的热情“冷却”之后迎来了“理性的回归”。根据上面分层镜像的图示，我们发现最终镜像中包含构建环境是多余的，我们只需要在最终镜像中包含足够支撑<code>httpd</code>运行的运行环境即可，而<code>base image</code>自身就可以满足。于是我们应该<strong>去除不必要的中间层</strong>：</p>
<p><img src="//blog.com/2019/07/04/从Docker镜像构建演化史来了解多阶段构建的影响/v2-26f5de15f54ea857fb99630e1653e58d_hd.jpg" alt="img"></p>
<p><em>图3：去除不必要的分层</em></p>
<p>现在问题来了！如果不在同一镜像中完成应用构建，那么在哪里、由谁来构建应用呢？至少有两种方法：</p>
<ol>
<li>在本地构建并<code>COPY</code>到镜像中；</li>
<li>借助构建者镜像(<code>builder image</code>)构建。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过方法1本地构建有很多局限性，比如：本地环境无法复用、无法很好融入持续集成/持续交付流水线等。<strong>借助<code>builder image</code>进行构建已经成为<code>Docker</code>社区的一个最佳实践，<code>Docker</code>官方为此也推出了各种主流编程语言的官方<code>base image</code></strong>，比如：<a href="https://link.zhihu.com/?target=http%3A//tonybai.com/tag/go" target="_blank" rel="noopener">go</a>、<a href="https://link.zhihu.com/?target=http%3A//tonybai.com/tag/java" target="_blank" rel="noopener">java</a>、node、<a href="https://link.zhihu.com/?target=http%3A//tonybai.com/tag/python" target="_blank" rel="noopener">python</a>以及<a href="https://link.zhihu.com/?target=http%3A//tonybai.com/tag/ruby" target="_blank" rel="noopener">ruby</a>等。借助<code>builder image</code>进行镜像构建的流程原理如下图：</p>
<p><img src="//blog.com/2019/07/04/从Docker镜像构建演化史来了解多阶段构建的影响/v2-d1a528e472d69bee5df1a614df3709c9_hd.jpg" alt="img"></p>
<p><em>图4：借助builder image进行镜像构建的流程图</em></p>
<p>通过原理图，我们可以看到整个目标镜像的构建被分为了两个阶段：</p>
<p>第一阶段：<strong>构建负责编译源码的构建者镜像</strong>；<br>第二阶段：<strong>将第一阶段的输出作为输入，构建出最终的目标镜像</strong>；</p>
<p>我们选择<code>golang:1.9.2</code>作为<code>builder base image</code>，构建者镜像的<code>Dockerfile.build</code>如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Dockerfile.build</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.9</span>.<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /go/src</span></span><br><span class="line"><span class="bash">COPY ./httpserver.go .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN go build -o httpd ./httpserver.go</span></span><br></pre></td></tr></table></figure>
<p>执行构建：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker build -t repodemo/httpd-builder:latest -f Dockerfile.build .</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构建好的应用程序<code>httpd</code>放在了镜像<code>repodemo/httpd-builder</code>中的<code>/go/src</code>目录下，我们需要一些“胶水”命令来连接两个构建阶段，这些命令将<code>httpd</code>从构建者镜像中取出并作为下一阶段构建的输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker create --name extract-httpserver repodemo/httpd-builder</span></span><br><span class="line"><span class="comment"># docker cp extract-httpserver:/go/src/httpd ./httpd</span></span><br><span class="line"><span class="comment"># docker rm -f extract-httpserver</span></span><br><span class="line"><span class="comment"># docker rmi repodemo/httpd-builder</span></span><br></pre></td></tr></table></figure>
<p>通过上面的命令，我们将编译好的<code>httpd</code>程序拷贝到了本地。下面是目标镜像的<code>Dockerfile</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Dockerfile.target</span><br><span class="line"><span class="keyword">From</span> ubuntu:<span class="number">14.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./httpd /root/httpd</span></span><br><span class="line"><span class="bash">RUN chmod +x /root/httpd</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">WORKDIR /root</span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"/root/httpd"</span>]</span></span><br></pre></td></tr></table></figure>
<p>接下来我们来构建目标镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker build -t repodemo/httpd:latest -f Dockerfile.target .</span></span><br></pre></td></tr></table></figure>
<p>我们来看看这个镜像的“体格”：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                       TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">repodemo/httpd                   latest              e3d009d6e919        12 seconds ago      200MB</span><br></pre></td></tr></table></figure>
<p>200MB！目标镜像的<code>Size</code>降为原来的 1/2 还多。</p>
<h2 id="四、“像赛车那样减去所有不必要的东西”：追求最小镜像"><a href="#四、“像赛车那样减去所有不必要的东西”：追求最小镜像" class="headerlink" title="四、“像赛车那样减去所有不必要的东西”：追求最小镜像"></a>四、“像赛车那样减去所有不必要的东西”：追求最小镜像</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面我们构建出的镜像的<code>Size</code>已经缩小到200MB，但这还不够。200MB的“体格”在我们的网络环境下缓存和传输仍然很难令人满意。我们要为镜像进一步减重，减到尽可能的小，就像赛车那样，<strong>为了能减轻重量将所有不必要的东西都拆除掉：我们仅保留能支撑我们的应用运行的必要库、命令，其余的一律不纳入目标镜像</strong>。当然不仅仅是<code>Size</code>上的原因，小镜像还有额外的好处，比如：内存占用小，启动速度快，更加高效；不会因其他不必要的工具、库的漏洞而被攻击，减少了“攻击面”，更加安全。</p>
<p><img src="//blog.com/2019/07/04/从Docker镜像构建演化史来了解多阶段构建的影响/v2-bab570be39ead4ef3b2b794883f54897_hd.jpg" alt="img"></p>
<p><em>图5：目标镜像还能更小些吗？</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般应用开发者不会从<code>scratch</code>镜像从头构建自己的<code>base image</code>以及目标镜像的，开发者会挑选适合的<code>base image</code>。一些“蝇量级”甚至是“草量级”的官方<code>base image</code>的出现为这种情况提供了条件。</p>
<p><img src="//blog.com/2019/07/04/从Docker镜像构建演化史来了解多阶段构建的影响/v2-da1a4099eea4a75194335e1ea7e64f52_hd.jpg" alt="img"></p>
<p><em>图6：一些base image的Size比较(来自<a href="https://link.zhihu.com/?target=http%3A//imagelayers.io" target="_blank" rel="noopener">http://imagelayers.io</a>截图)</em></p>
<p>从图中看，我们有两个选择：<a href="https://link.zhihu.com/?target=https%3A//www.busybox.net/" target="_blank" rel="noopener">busybox</a>和<a href="https://link.zhihu.com/?target=https%3A//alpinelinux.org/" target="_blank" rel="noopener">alpine</a>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;单从<code>image</code>的<code>size</code>上来说，<code>busybox</code>更小。不过<code>busybox</code>默认的<code>libc</code>实现是<code>uClibc</code>，而我们通常运行环境使用的<code>libc</code>实现都是<code>glibc</code>，因此我们要么选择静态编译程序，要么使用<code>busybox:glibc</code>镜像作为<code>base image</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而<code>alpine image</code> 是另外一种蝇量级 <code>base image</code>，它使用了比 <code>glibc</code>更小更安全的<a href="https://link.zhihu.com/?target=http%3A//www.musl-libc.org/" target="_blank" rel="noopener">musl libc</a>库。 不过和 <code>busybox image</code> 相比，<code>alpine image</code> 体积还是略大。除了因为<code>musl</code>比<code>uClibc</code> 大一些之外，<code>alpine</code>还在镜像中添加了自己的包管理系统<code>apk</code>，开发者可以使用<code>apk</code>在基于<code>alpine</code>的镜像中添 加需要的包或工具。因此，对于普通开发者而言，<code>alpine image</code>显然是更佳的选择。不过<code>alpine</code>使用的<code>libc</code>实现为<a href="https://link.zhihu.com/?target=http%3A//www.musl-libc.org/" target="_blank" rel="noopener">musl</a>，与基于<code>glibc</code>上编译出来的应用程序不兼容。如果直接将前面构建出的<code>httpd</code>应用塞入<code>alpine</code>，在容器启动时会遇到下面错误，因为加载器找不到<code>glibc</code>这个动态共享库文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">standard_init_linux.go:185: exec user process caused &quot;no such file or directory&quot;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于Go应用来说，我们可以采用静态编译的程序，但一旦采用静态编译，也就意味着我们将失去一些<code>libc</code>提供的原生能力，比如：在<code>linux</code>上，你无法使用系统提供的<code>DNS</code>解析能力，只能使用<code>Go</code>自实现的<code>DNS</code>解析器。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们还可以采用基于<code>alpine</code>的<code>builder image</code>，<code>golang base image</code>就提供了<code>alpine</code> 版本。 我们就用这种方式构建出一个基于<code>alpine base image</code>的极小目标镜像。</p>
<p><img src="//blog.com/2019/07/04/从Docker镜像构建演化史来了解多阶段构建的影响/v2-1d7ee393b4a0b48459a6f95e92c0ac2d_hd.jpg" alt="img"></p>
<p><em>图7：借助 alpine builder image 进行镜像构建的流程图</em></p>
<p>我们新建两个用于 <code>alpine</code> 版本目标镜像构建的 <code>Dockerfile</code>：<code>Dockerfile.build.alpine</code> 和<code>Dockerfile.target.alpine</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//Dockerfile.build.alpine</span><br><span class="line"><span class="keyword">FROM</span> golang:alpine</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /go/src</span></span><br><span class="line"><span class="bash">COPY ./httpserver.go .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN go build -o httpd ./httpserver.go</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">// Dockerfile.target.alpine</span></span><br><span class="line"><span class="bash">From alpine</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY ./httpd /root/httpd</span></span><br><span class="line"><span class="bash">RUN chmod +x /root/httpd</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">WORKDIR /root</span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"/root/httpd"</span>]</span></span><br></pre></td></tr></table></figure>
<p>构建<code>builder</code>镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  docker build -t repodemo/httpd-alpine-builder:latest -f Dockerfile.build.alpine .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                       TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">repodemo/httpd-alpine-builder    latest              d5b5f8813d77        About a minute ago   275MB</span><br></pre></td></tr></table></figure>
<p>执行“胶水”命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker create --name extract-httpserver repodemo/httpd-alpine-builder</span></span><br><span class="line"><span class="comment"># docker cp extract-httpserver:/go/src/httpd ./httpd</span></span><br><span class="line"><span class="comment"># docker rm -f extract-httpserver</span></span><br><span class="line"><span class="comment"># docker rmi repodemo/httpd-alpine-builder</span></span><br></pre></td></tr></table></figure>
<p>构建目标镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker build -t repodemo/httpd-alpine -f Dockerfile.target.alpine .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                       TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">repodemo/httpd-alpine            latest              895de7f785dd        13 seconds ago      16.2MB</span><br></pre></td></tr></table></figure>
<p>16.2MB！目标镜像的<code>Size</code>降为不到原来的十分之一。我们得到了预期的结果。</p>
<h2 id="五、“要有光，于是便有了光”：对多阶段构建的支持"><a href="#五、“要有光，于是便有了光”：对多阶段构建的支持" class="headerlink" title="五、“要有光，于是便有了光”：对多阶段构建的支持"></a>五、“要有光，于是便有了光”：对多阶段构建的支持</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此，虽然我们实现了目标<code>Image</code>的最小化，但是整个构建过程却是十分繁琐，我们需要准备两个<code>Dockerfile</code>、需要准备“胶水”命令、需要清理中间产物等。作为<code>Docker</code>用户，我们希望用一个<code>Dockerfile</code>就能解决所有问题，于是就有了<code>Docker</code>引擎对<strong>多阶段构建(multi-stage build)</strong>的支持。注意：这个特性非常新，只有<code>Docker 17.05.0-ce</code>及以后的版本才能支持。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们就按照“多阶段构建”的语法将上面的<code>Dockerfile.build.alpine</code>和<code>Dockerfile.target.alpine</code>合并到一个<code>Dockerfile</code>中：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//Dockerfile</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> golang:alpine as builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /go/src</span></span><br><span class="line"><span class="bash">COPY httpserver.go .</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN go build -o httpd ./httpserver.go</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">From alpine:latest</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">WORKDIR /root/</span></span><br><span class="line"><span class="bash">COPY --from=builder /go/src/httpd .</span></span><br><span class="line"><span class="bash">RUN chmod +x /root/httpd</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"/root/httpd"</span>]</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Dockerfile</code>的语法还是很简明和易理解的。即使是你第一次看到这个语法也能大致猜出六成含义。与之前<code>Dockefile</code>最大的不同在于在支持多阶段构建的<code>Dockerfile</code>中我们可以<strong>写多个<code>“From baseimage”</code>的语句了，每个From语句开启一个构建阶段，并且可以通过“as”语法为此阶段构建命名</strong>(比如这里的<code>builder</code>)。我们还可以通过<strong><code>COPY</code>命令在两个阶段构建产物之间传递数据</strong>，比如这里传递的<code>httpd</code>应用，这个工作之前我们是使用“胶水”代码完成的。</p>
<p>构建目标镜像：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker build -t repodemo/httpd-multi-stage .</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># docker images</span></span><br><span class="line">REPOSITORY                       TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">repodemo/httpd-multi-stage       latest              35e494aa5c6f        2 minutes ago       16.2MB</span><br></pre></td></tr></table></figure>
<p>我们看到通过多阶段构建特性构建的<code>Docker Image</code>与我们之前通过<code>builder</code>模式构建的镜像在效果上是等价的。</p>
<h2 id="六、来到现实"><a href="#六、来到现实" class="headerlink" title="六、来到现实"></a>六、来到现实</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;沿着时间的轨迹，<code>Docker</code>镜像构建走到了今天。追求又快又小的镜像已成为了 <code>Docker</code>社区 的共识。社区在自创<code>builder</code>镜像构建的最佳实践后终于迎来了多阶段构建这柄利器，从此构建 出极简的镜像将不再困难。</p>
<h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，我们看过了<code>Docker</code>镜像构建的这个过程，也了解到了我们如何一步步压缩镜像体积的方法，不过<strong>对于正式环境来说，镜像越小并不意味着越好，因为小体积的镜像是有可能会导致一些语言的适配性不是很好，这点还是需要大量测试之后才能正式使用</strong>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/07/03/Docker概念解释/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/03/Docker概念解释/" itemprop="url">Docker概念解释</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-03T12:12:57+08:00">
                2019-07-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Docker概念解释"><a href="#Docker概念解释" class="headerlink" title="Docker概念解释"></a>Docker概念解释</h1><h2 id="一-先从认识容器开始"><a href="#一-先从认识容器开始" class="headerlink" title="一 先从认识容器开始"></a><strong>一 先从认识容器开始</strong></h2><h3 id="1-1-什么是容器？"><a href="#1-1-什么是容器？" class="headerlink" title="1.1 什么是容器？"></a>1.1 什么是容器？</h3><h4 id="先来看看容器较为官方的解释"><a href="#先来看看容器较为官方的解释" class="headerlink" title="先来看看容器较为官方的解释"></a>先来看看容器较为官方的解释</h4><p><strong>一句话概括容器：容器就是将软件打包成标准化单元，以用于开发、交付和部署。</strong></p>
<ul>
<li><strong>容器镜像是轻量的、可执行的独立软件包</strong> ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。</li>
<li><strong>容器化软件适用于基于Linux和Windows的应用，在任何环境中都能够始终如一地运行。</strong></li>
<li><strong>容器赋予了软件独立性</strong>　，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。</li>
</ul>
<h4 id="再来看看容器较为通俗的解释"><a href="#再来看看容器较为通俗的解释" class="headerlink" title="再来看看容器较为通俗的解释"></a>再来看看容器较为通俗的解释</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>如果需要通俗的描述容器的话，我觉得容器就是一个存放东西的地方，就像书包可以装各种文具、衣柜可以放各种衣服、鞋架可以放各种鞋子一样。我们现在所说的容器存放的东西可能更偏向于应用比如网站、程序甚至是系统环境。</strong></p>
<p><img src="//blog.com/2019/07/03/Docker概念解释/v2-3697f23ef1fd390e8f992a01cc67707a_hd.jpg" alt="img"></p>
<h3 id="1-2-图解物理机、虚拟机与容器"><a href="#1-2-图解物理机、虚拟机与容器" class="headerlink" title="1.2 图解物理机、虚拟机与容器"></a>1.2 图解物理机、虚拟机与容器</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于虚拟机与容器的对比在后面会详细介绍到，这里只是通过网上的图片加深大家对于物理机、虚拟机与容器这三者的理解。</p>
<h4 id="物理机"><a href="#物理机" class="headerlink" title="物理机"></a>物理机</h4><p><img src="//blog.com/2019/07/03/Docker概念解释/v2-f2b3e0b4331f0b657ff010cfeee2ff15_hd.jpg" alt="img"></p>
<h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><p><img src="//blog.com/2019/07/03/Docker概念解释/v2-7ecd829d06fe1793c554df4101d4b6b0_hd.jpg" alt="img"></p>
<h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><p><img src="//blog.com/2019/07/03/Docker概念解释/v2-b8476d9538fe1ff63a9acaf91ce4a446_hd.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上面这三张抽象图，我们可以大概可以通过类比概括出： <strong>容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。</strong></p>
<h2 id="二-再来谈谈Docker的一些概念"><a href="#二-再来谈谈Docker的一些概念" class="headerlink" title="二 再来谈谈Docker的一些概念"></a><strong>二 再来谈谈Docker的一些概念</strong></h2><p><img src="//blog.com/2019/07/03/Docker概念解释/v2-fcd40debf627c52dbd9bcbc5cd662512_hd.jpg" alt="img"></p>
<h3 id="2-1-什么是Docker？"><a href="#2-1-什么是Docker？" class="headerlink" title="2.1 什么是Docker？"></a>2.1 什么是Docker？</h3><p>说实话关于<code>Docker</code>是什么并太好说，下面我通过四点向你说明<code>Docke</code>到底是个什么东西。</p>
<ul>
<li><strong>Docker 是世界领先的软件容器平台。</strong></li>
<li><strong>Docker</strong> 使用 <code>Google</code> 公司推出的 <strong>Go 语言</strong> 进行开发实现，基于 <strong>Linux 内核</strong> 的<code>cgroup</code>，<code>namespace</code>，以及<code>AUFS</code>类的<strong>UnionFS</strong>等技术，<strong>对进程进行封装隔离，属于操作系统层面的虚拟化技术。</strong> 由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。<strong>Docke最初实现是基于 LXC.</strong></li>
<li><strong>Docker 能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上：构建杰出的软件。</strong></li>
<li><strong>用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</strong></li>
</ul>
<p><img src="//blog.com/2019/07/03/Docker概念解释/v2-b28c28e0a318ef4b2dee90efd17efe32_hd.jpg" alt="img"></p>
<h3 id="2-2-Docker思想"><a href="#2-2-Docker思想" class="headerlink" title="2.2 Docker思想"></a>2.2 Docker思想</h3><ul>
<li><p><strong>集装箱</strong></p>
</li>
<li><p><strong>标准化</strong></p>
<blockquote>
<p> ①运输方式 </p>
<p> ② 存储方式</p>
<p> ③ API接口</p>
</blockquote>
</li>
<li><p><strong>隔离</strong></p>
</li>
</ul>
<h3 id="2-3-Docker容器的特点"><a href="#2-3-Docker容器的特点" class="headerlink" title="2.3 Docker容器的特点"></a>2.3 Docker容器的特点</h3><ul>
<li><strong>轻量</strong><br>在一台机器上运行的多个 <code>Docker</code>容器可以<strong>共享这台机器的操作系统内核</strong>；它们能够迅速启动，只需占用很少的计算和内存资源。<strong>镜像是通过文件系统层进行构造的，并共享一些公共文件</strong>。这样就能<strong>尽量降低磁盘用量，并能更快地下载镜像</strong>。</li>
</ul>
<ul>
<li><strong>标准</strong><br><code>Docker</code> 容器基于<strong>开放式标准</strong>，能够在所有主流<code>Linux</code>版本、<code>Microsoft Windows</code> 以及包括 <code>VM</code>、裸机服务器和云在内的任何基础设施上运行。</li>
</ul>
<ul>
<li><strong>安全</strong><br><code>Docker</code> 赋予应用的隔离性<strong>不仅限于彼此隔离，还独立于底层的基础设施</strong>。<code>Docker</code> 默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。</li>
</ul>
<h3 id="2-4-为什么要用Docker"><a href="#2-4-为什么要用Docker" class="headerlink" title="2.4 为什么要用Docker"></a>2.4 为什么要用Docker</h3><ul>
<li><em>Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题；</em>——<strong>一致的运行环境</strong></li>
<li><em>可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间；</em>——<strong>更快速的启动时间</strong></li>
<li><em>避免公用的服务器，资源会容易受到其他用户的影响；</em>——<strong>隔离性</strong></li>
<li><em>善于处理集中爆发的服务器使用压力；</em>——<strong>弹性伸缩，快速扩展</strong></li>
<li><em>可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况；</em>——<strong>迁移方便</strong></li>
<li><em>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署；</em>——<strong>持续交付和部署</strong></li>
</ul>
<h2 id="三-容器-VS-虚拟机"><a href="#三-容器-VS-虚拟机" class="headerlink" title="三 容器 VS 虚拟机"></a>三 容器 VS 虚拟机</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单来说： <strong>容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。</strong></p>
<h3 id="3-1-两者对比图"><a href="#3-1-两者对比图" class="headerlink" title="3.1 两者对比图"></a>3.1 两者对比图</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程</strong>；而<strong>容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟</strong>。因此容器要比传统虚拟机更为轻便.</p>
<p><img src="//blog.com/2019/07/03/Docker概念解释/v2-ed3922319dd40c1516897a3609f669db_hd.jpg" alt="img"></p>
<h3 id="3-2-容器与虚拟机-VM-总结"><a href="#3-2-容器与虚拟机-VM-总结" class="headerlink" title="3.2 容器与虚拟机 (VM) 总结"></a>3.2 容器与虚拟机 (VM) 总结</h3><p><img src="//blog.com/2019/07/03/Docker概念解释/v2-65604fcd4989777c3aa88bdf2eab1fe7_hd.jpg" alt="img"></p>
<ul>
<li><strong>容器是一个应用层抽象，用于将代码和依赖资源打包在一起</strong>。多个容器可以在同一台机器上运行，共享操作系统内核，但<strong>各自作为独立的进程在用户空间中运行</strong> 。与虚拟机相比， <strong>容器占用的空间较少</strong>（容器镜像大小通常只有几十兆），<strong>瞬间就能完成启动</strong> 。</li>
</ul>
<ul>
<li><strong>虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器。</strong> 管理程序允许多个<code>VM</code> 在一台机器上运行。每个<code>VM</code>都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此 <strong>占用大量空间</strong> 。而且<code>VM</code> <strong>启动也十分缓慢</strong> 。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过<code>Docker</code>官网，我们知道了这么多<code>Docker</code>的优势，但是大家也没有必要完全否定虚拟机技术，因为两者有不同的使用场景。<strong>虚拟机更擅长于彻底隔离整个运行环境</strong>。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而 <strong>Docker通常用于隔离不同的应用</strong> ，例如前端，后端以及数据库。</p>
<h3 id="3-3-容器与虚拟机-VM-两者是可以共存的"><a href="#3-3-容器与虚拟机-VM-两者是可以共存的" class="headerlink" title="3.3 容器与虚拟机 (VM)两者是可以共存的"></a>3.3 容器与虚拟机 (VM)两者是可以共存的</h3><p>就我而言，对于两者无所谓谁会取代谁，而是两者可以和谐共存。</p>
<p><img src="//blog.com/2019/07/03/Docker概念解释/v2-1629eb3bca8a97ee18f02ae58113951c_hd.jpg" alt="img"></p>
<h2 id="四-Docker基本概念"><a href="#四-Docker基本概念" class="headerlink" title="四 Docker基本概念"></a>四 Docker基本概念</h2><p><code>Docker</code>包括三个基本概念</p>
<ul>
<li><strong>镜像（Image）</strong></li>
<li><strong>容器（Container）</strong></li>
<li><strong>仓库（Repository）</strong></li>
</ul>
<p>理解了这三个概念，就理解了 <code>Docker</code> 的整个生命周期</p>
<p><img src="//blog.com/2019/07/03/Docker概念解释/v2-7daec27fc1dec4c83a6387142e56b9f1_hd.jpg" alt="img"></p>
<h3 id="4-1-镜像（Image）——一个特殊的文件系统"><a href="#4-1-镜像（Image）——一个特殊的文件系统" class="headerlink" title="4.1 镜像（Image）——一个特殊的文件系统"></a>4.1 镜像（Image）——一个特殊的文件系统</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>操作系统分为内核和用户空间</strong>。对于 <code>Linux</code> 而言，内核启动后，会挂载<code>root</code>文件系统为其提供用户空间支持。而<code>Docker</code> 镜像（<code>Image</code>），就相当于是一个 <code>root</code> 文件系统。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</strong> 镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Docker</code>设计时，就充分利用 <strong>Union FS</strong>的技术，将其设计为 <strong>分层存储的架构</strong> 。 镜像实际是由多层文件系统联合组成。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</strong>　比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，<strong>每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<h3 id="4-2-容器（Container-——镜像运行时的实体"><a href="#4-2-容器（Container-——镜像运行时的实体" class="headerlink" title="4.2 容器（Container)——镜像运行时的实体"></a>4.2 容器（Container)——镜像运行时的实体</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，<strong>容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等</strong> 。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照<code>Docker</code>最佳实践的要求，<strong>容器不应该向其存储层内写入任何数据</strong> ，容器存储层要保持无状态化。<strong>所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录</strong>，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， <strong>使用数据卷后，容器可以随意删除、重新 run ，数据却不会丢失。</strong></p>
<h3 id="4-3-仓库（Repository）——集中存放镜像文件的地方"><a href="#4-3-仓库（Repository）——集中存放镜像文件的地方" class="headerlink" title="4.3 仓库（Repository）——集中存放镜像文件的地方"></a>4.3 仓库（Repository）——集中存放镜像文件的地方</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;镜像构建完成后，可以很容易的在当前宿主上运行，但是， <strong>如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry就是这样的服务。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个 <code>Docker Registry</code>中可以包含多个仓库（<code>Repository</code>）；每个仓库可以包含多个标签（<code>Tag</code>）；每个标签对应一个镜像。所以说：<strong>镜像仓库是Docker用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，<strong>一个仓库会包含同一个软件不同版本的镜像</strong>，而<strong>标签就常用于对应该软件的各个版本</strong> 。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>这里补充一下Docker Registry 公开服务和私有 Docker Registry的概念：</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Docker Registry 公开服务</strong> 是开放给用户使用、允许用户管理镜像的 <code>Registry</code> 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最常使用的 <code>Registry</code> 公开服务是官方的 <strong>Docker Hub</strong> ，这也是默认的<code>Registry</code>，并拥有大量的高质量的官方镜像，网址为：<a href="https://link.zhihu.com/?target=https%3A//hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a> 。在国内访问<strong>Docker Hub</strong> 可能会比较慢国内也有一些云服务商提供类似于 <code>Docker Hub</code>的公开服务。比如 <a href="https://link.zhihu.com/?target=https%3A//hub.tenxcloud.com/" target="_blank" rel="noopener">时速云镜像库</a>、<a href="https://link.zhihu.com/?target=https%3A//www.163yun.com/product/repo" target="_blank" rel="noopener">网易云镜像服务</a>、<a href="https://link.zhihu.com/?target=https%3A//www.daocloud.io/" target="_blank" rel="noopener">DaoCloud 镜像市场</a>、<a href="https://link.zhihu.com/?target=https%3A//www.aliyun.com/product/containerservice%3Futm_content%3Dse_1292836" target="_blank" rel="noopener">阿里云镜像库</a>等。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了使用公开服务外，用户还可以在 <strong>本地搭建私有 Docker Registry</strong> 。<code>Docker</code> 官方提供了 <code>Docker Registry</code>镜像，可以直接使用做为私有 <code>Registry</code>服务。开源的 <code>Docker Registry</code> 镜像只提供了 <code>Docker Registry API</code> 的服务端实现，足以支持 <code>docker</code>命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p>
<h2 id="五-最后谈谈：Build-Ship-and-Run"><a href="#五-最后谈谈：Build-Ship-and-Run" class="headerlink" title="五 最后谈谈：Build, Ship, and Run"></a>五 最后谈谈：Build, Ship, and Run</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你搜索<code>Docker</code>官网，会发现如下的字样：<strong>“Docker - Build, Ship, and Run Any App, Anywhere”</strong>。那么Build, Ship, and Run到底是在干什么呢？</p>
<p><img src="//blog.com/2019/07/03/Docker概念解释/v2-c37e03a2dd644b18a37db9d960b3ab4c_hd.jpg" alt="img"></p>
<ul>
<li><strong>Build（构建镜像）</strong> ： 镜像就像是集装箱包括文件以及运行环境等等资源。</li>
<li><strong>Ship（运输镜像）</strong> ：主机和仓库间运输，这里的仓库就像是超级码头一样。</li>
<li><strong>Run （运行镜像）</strong> ：运行的镜像就是一个容器，容器就是运行程序的地方。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Docker 运行过程也就是去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。所以，我们也常常将Docker称为码头工人或码头装卸工，这和Docker的中文翻译搬运工人如出一辙。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/07/03/Docker整体架构图/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/03/Docker整体架构图/" itemprop="url">Docker整体架构图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-03T12:12:57+08:00">
                2019-07-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index">
                    <span itemprop="name">Docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Docker整体架构图"><a href="#Docker整体架构图" class="headerlink" title="Docker整体架构图"></a>Docker整体架构图</h1><h2 id="一、Docker的总架构图"><a href="#一、Docker的总架构图" class="headerlink" title="一、Docker的总架构图"></a>一、Docker的总架构图</h2><p><img src="//blog.com/2019/07/03/Docker整体架构图/docker-architecture.jpg" alt=""></p>
<p><code>docker</code>是一个<code>C/S</code>模式的架构，后端是一个松耦合架构，模块各司其职。</p>
<ol>
<li>用户是使用<code>Docker Client</code>与<code>Docker Daemon</code>建立通信，并发送请求给后者。</li>
<li><code>Docker Daemon</code>作为<code>Docker</code>架构中的主体部分，首先提供<code>Server</code>的功能使其可以接受<code>Docker Client</code>的请求；</li>
<li><code>Engine</code>执行<code>Docker</code>内部的一系列工作，每一项工作都是以一个<code>Job</code>的形式的存在。</li>
<li><code>Job</code>的运行过程中，当需要容器镜像时，则从<code>Docker Registry</code>中下载镜像，并通过镜像管理驱动<code>graphdriver</code>将下载镜像以<code>Graph</code>的形式存储；</li>
<li>当需要为<code>Docker</code>创建网络环境时，通过网络管理驱动<code>networkdriver</code>创建并配置<code>Docker</code>容器网络环境；</li>
<li>当需要限制<code>Docker</code>容器运行资源或执行用户指令等操作时，则通过<code>execdriver</code>来完成。</li>
<li><code>libcontainer</code>是一项独立的容器管理包，<code>networkdriver</code>以及<code>execdriver</code>都是通过<code>libcontainer</code>来实现具体对容器进行的操作。</li>
</ol>
<h2 id="二、Docker各模块组件分析"><a href="#二、Docker各模块组件分析" class="headerlink" title="二、Docker各模块组件分析"></a>二、Docker各模块组件分析</h2><h3 id="（一）Docker-Client-发起请求"><a href="#（一）Docker-Client-发起请求" class="headerlink" title="（一）Docker Client[发起请求]"></a>（一）Docker Client[发起请求]</h3><ol>
<li><code>Docker Client</code>是和<code>Docker Daemon</code>建立通信的客户端。用户使用的可执行文件为<code>docker</code>（类似可执行脚本的命令），<code>docker</code>命令后接参数的形式来实现一个完整的请求命令（例如<code>docker images</code>，<code>docker</code>为命令不可变，<code>images</code>为参数可变）。</li>
<li><code>Docker Client</code>可以通过以下三种方式和<code>Docker Daemon</code>建立通信：<a href="https://www.huweihuang.com/article/docker/docker-architecture/" target="_blank" rel="noopener">tcp://host:port，unix://path_to_socket和fd://socketfd。</a></li>
<li><code>Docker Client</code>发送容器管理请求后，由<code>Docker Daemon</code>接受并处理请求，当<code>Docker Client</code>接收到返回的请求相应并简单处理后，<code>Docker Client</code>一次完整的生命周期就结束了。[一次完整的请求：发送请求→处理请求→返回结果]，与传统的<code>C/S</code>架构请求流程并无不同。</li>
</ol>
<h3 id="（二）Docker-Daemon-后台守护进程"><a href="#（二）Docker-Daemon-后台守护进程" class="headerlink" title="（二）Docker Daemon[后台守护进程]"></a>（二）Docker Daemon[后台守护进程]</h3><ul>
<li><p><code>Docker Daemon</code>的架构图</p>
<p><img src="//blog.com/2019/07/03/Docker整体架构图/docker-daemon.jpg" alt=""></p>
</li>
</ul>
<p><strong>Docker Server[调度分发请求]</strong></p>
<ul>
<li><code>Docker Server</code>的架构图</li>
</ul>
<p><img src="//blog.com/2019/07/03/Docker整体架构图/docker-server.jpg" alt=""></p>
<ol>
<li><code>Docker Server</code>相当于<code>C/S</code>架构的服务端。功能为接受并调度分发<code>Docker Client</code>发送的请求。接受请求后，<code>Server</code>通过路由与分发调度，找到相应的<code>Handler</code>来执行请求。</li>
<li>在<code>Docker</code>的启动过程中，通过包<code>gorilla/mux</code>，创建了一个<code>mux.Router</code>，提供请求的路由功能。在<code>Golang</code>中，<code>gorilla/mux</code>是一个强大的URL路由器以及调度分发器。该<code>mux.Router</code>中添加了众多的路由项，每一个路由项由<code>HTTP</code>请求方法（<code>PUT、POST、GET或DELETE</code>）、<code>URL</code>、<code>Handler</code>三部分组成。</li>
<li>创建完<code>mux.Router</code>之后，<code>Docker</code>将<code>Server</code>的监听地址以及<code>mux.Router</code>作为参数，创建一个<code>httpSrv=http.Server{}</code>，最终执行<code>httpSrv.Serve()</code>为请求服务。</li>
<li>在<code>Server</code>的服务过程中，<code>Server</code>在<code>listener</code>上接受<code>Docker Client</code>的访问请求，并创建一个全新的<code>goroutine</code>来服务该请求。在<code>goroutine</code>中，首先读取请求内容，然后做解析工作，接着找到相应的路由项，随后调用相应的<code>Handler</code>来处理该请求，最后<code>Handler</code>处理完请求之后回复该请求。</li>
</ol>
<h4 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h4><ol>
<li><p><code>Engine</code>是<code>Docker</code>架构中的运行引擎，同时也<code>Docker</code>运行的核心模块。它扮演<code>Docker container</code>存储仓库的角色，并且通过执行<code>job</code>的方式来操纵管理这些容器。</p>
</li>
<li><p>在<code>Engine</code>数据结构的设计与实现过程中，有一个<code>handler</code>对象。该<code>handler</code>对象存储的都是关于众多特定<code>job</code>的<code>handler</code>处理访问。</p>
<p>举例说明，<code>Engine</code>的<code>handler</code>对象中有一项为：<code>{“create”: daemon.ContainerCreate}</code>，则说明当名为<code>&quot;create&quot;</code>的<code>job</code>在运行时，执行的是<code>daemon.ContainerCreate</code>的<code>handler</code>。</p>
</li>
</ol>
<h4 id="job"><a href="#job" class="headerlink" title="job"></a>job</h4><ol>
<li>一个<code>Job</code>可以认为是<code>Docker</code>架构中<code>Engine</code>内部最基本的工作执行单元。<code>Docker</code>可以做的每一项工作，都可以抽象为一个<code>job</code>。例如：在容器内部运行一个进程，这是一个<code>job</code>；创建一个新的容器，这是一个<code>job</code>。<code>Docker Server</code>的运行过程也是一个<code>job</code>，名为<code>serveapi</code>。</li>
<li><code>Job</code>的设计者，把<code>Job</code>设计得与<code>Unix</code>进程相仿。比如说：<code>Job</code>有一个名称，有参数，有环境变量，有标准的输入输出，有错误处理，有返回状态等。</li>
</ol>
<h3 id="（三）Docker-Registry-镜像注册中心"><a href="#（三）Docker-Registry-镜像注册中心" class="headerlink" title="（三）Docker Registry[镜像注册中心]"></a>（三）Docker Registry[镜像注册中心]</h3><ol>
<li><code>Docker Registry</code>是一个存储容器镜像的仓库（注册中心），可理解为云端镜像仓库，按<code>repository</code>来分类，<code>docker pull</code> 按照<code>[repository]:[tag]</code>来精确定义一个<code>image</code>。</li>
<li>在<code>Docker</code>的运行过程中，<code>Docker Daemon</code>会与<code>Docker Registry</code>通信，并实现搜索镜像、下载镜像、上传镜像三个功能，这三个功能对应的<code>job</code>名称分别为<code>&quot;search&quot;</code>，<code>“pull”</code>与<code>“push”</code>。</li>
<li>可分为公有仓库（<code>docker hub</code>）和私有仓库。</li>
</ol>
<h3 id="（四）Graph-docker内部数据库"><a href="#（四）Graph-docker内部数据库" class="headerlink" title="（四）Graph[docker内部数据库]"></a>（四）Graph[docker内部数据库]</h3><ul>
<li><p><code>Graph</code>的架构图</p>
<p><img src="//blog.com/2019/07/03/Docker整体架构图/graph-architecture.jpg" alt=""></p>
</li>
</ul>
<h4 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h4><ol>
<li>已下载镜像的保管者（包括下载镜像和<code>dockerfile</code>构建的镜像）。</li>
<li>一个<code>repository</code>表示某类镜像的仓库（例如<code>Ubuntu</code>），同一个<code>repository</code>内的镜像用<code>tag</code>来区分（表示同一类镜像的不同标签或版本）。一个<code>registry</code>包含多个<code>repository</code>，一个<code>repository</code>包含同类型的多个<code>image</code>。</li>
<li>镜像的存储类型有<code>aufs，devicemapper,Btrfs，Vfs</code>等。其中<code>centos</code>系统使用<code>devicemapper</code>的存储类型。</li>
<li>同时在<code>Graph</code>的本地目录中，关于每一个的容器镜像，具体存储的信息有：该容器镜像的元数据，容器镜像的大小信息，以及该容器镜像所代表的具体<code>rootfs</code>。</li>
</ol>
<h4 id="GraphDB"><a href="#GraphDB" class="headerlink" title="GraphDB"></a>GraphDB</h4><ol>
<li>已下载容器镜像之间关系的记录者。</li>
<li><code>GraphDB</code>是一个构建在<code>SQLite</code>之上的小型图数据库，实现了节点的命名以及节点之间关联关系的记录</li>
</ol>
<h3 id="（五）Driver-执行部分"><a href="#（五）Driver-执行部分" class="headerlink" title="（五）Driver[执行部分]"></a>（五）Driver[执行部分]</h3><p><code>Driver</code>是<code>Docker</code>架构中的驱动模块。通过<code>Driver</code>驱动，<code>Docker</code>可以实现对<code>Docker</code>容器执行环境的定制。即<code>Graph</code>负责镜像的存储，<code>Driver</code>负责容器的执行。</p>
<h4 id="graphdriver"><a href="#graphdriver" class="headerlink" title="graphdriver"></a>graphdriver</h4><ul>
<li><p><code>graphdriver</code>架构图</p>
<p><img src="//blog.com/2019/07/03/Docker整体架构图/graphdriver.jpg" alt=""></p>
</li>
</ul>
<ol>
<li><p><code>graphdriver</code>主要用于完成容器镜像的管理，包括存储与获取。</p>
</li>
<li><p>存储：<code>docker pull</code>下载的镜像由<code>graphdriver</code>存储到本地的指定目录（<code>Graph</code>中）。</p>
</li>
<li><p>获取：<code>docker run（create）</code>用镜像来创建容器的时候由<code>graphdriver</code>到本地<code>Graph</code>中获取镜像。</p>
</li>
</ol>
<h4 id="networkdriver"><a href="#networkdriver" class="headerlink" title="networkdriver"></a>networkdriver</h4><ul>
<li><p><code>networkdriver</code>的架构图</p>
<p><img src="//blog.com/2019/07/03/Docker整体架构图/networkdriver.jpg" alt=""></p>
</li>
</ul>
<ol>
<li><p><code>networkdriver</code>的用途是完成<code>Docker</code>容器网络环境的配置，其中包括</p>
<ul>
<li><code>Docker</code>启动时为<code>Docker</code>环境创建网桥；</li>
<li><code>Docker</code>容器创建时为其创建专属虚拟网卡设备；</li>
<li><code>Docker</code>容器分配<code>IP</code>、端口并与宿主机做端口映射，设置容器防火墙策略等。</li>
</ul>
</li>
</ol>
<h4 id="execdriver"><a href="#execdriver" class="headerlink" title="execdriver"></a>execdriver</h4><ul>
<li><p><code>execdriver</code>的架构图</p>
<p><img src="//blog.com/2019/07/03/Docker整体架构图/execdriver.jpg" alt=""></p>
</li>
</ul>
<ol>
<li><code>execdriver</code>作为<code>Docker</code>容器的执行驱动，负责创建容器运行命名空间，负责容器资源使用的统计与限制，负责容器内部进程的真正运行等。</li>
<li>现在<code>execdriver</code>默认使用<code>native</code>驱动，不依赖于<code>LXC</code>。</li>
</ol>
<h3 id="（六）libcontainer-函数库"><a href="#（六）libcontainer-函数库" class="headerlink" title="（六）libcontainer[函数库]"></a>（六）libcontainer[函数库]</h3><ul>
<li><p><code>libcontainer</code>的架构图</p>
<p><img src="//blog.com/2019/07/03/Docker整体架构图/libcontainer.jpg" alt=""></p>
</li>
</ul>
<ol>
<li><code>libcontainer</code>是<code>Docker</code>架构中一个使用<code>Go</code>语言设计实现的库，设计初衷是希望该库可以不依靠任何依赖，直接访问内核中与容器相关的<code>API</code>。</li>
<li><code>Docker</code>可以直接调用<code>libcontainer</code>，而最终操纵容器的<code>namespace</code>、<code>cgroups</code>、<code>apparmor</code>、网络设备以及防火墙规则等。</li>
<li><code>libcontainer</code>提供了一整套标准的接口来满足上层对容器管理的需求。或者说，<code>libcontainer</code>屏蔽了<code>Docker</code>上层对容器的直接管理。</li>
</ol>
<h3 id="（七）docker-container-服务交付的最终形式"><a href="#（七）docker-container-服务交付的最终形式" class="headerlink" title="（七）docker container[服务交付的最终形式]"></a>（七）docker container[服务交付的最终形式]</h3><ul>
<li><p><code>container</code>架构</p>
<p><img src="//blog.com/2019/07/03/Docker整体架构图/container.jpg" alt=""></p>
</li>
</ul>
<ol>
<li><code>Docker container</code>（<code>Docker</code>容器）是<code>Docker</code>架构中服务交付的最终体现形式。</li>
<li><code>Docker</code>按照用户的需求与指令，订制相应的<code>Docker</code>容器：</li>
<li><ul>
<li>用户通过指定容器镜像，使得<code>Docker</code>容器可以自定义<code>rootfs</code>等文件系统；</li>
<li>用户通过指定计算资源的配额，使得<code>Docker</code>容器使用指定的计算资源；</li>
<li>用户通过配置网络及其安全策略，使得<code>Docker</code>容器拥有独立且安全的网络环境；</li>
<li>用户通过指定运行的命令，使得<code>Docker</code>容器执行指定的工作。</li>
</ul>
</li>
</ol>
<p>附：本文在《docker源码分析》基础上进行整理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/07/02/Sed 命令地址匹配问题总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/02/Sed 命令地址匹配问题总结/" itemprop="url">Sed 命令地址匹配问题总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-02T12:12:57+08:00">
                2019-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/shell/" itemprop="url" rel="index">
                    <span itemprop="name">shell</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/shell/sed/" itemprop="url" rel="index">
                    <span itemprop="name">sed</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/shell/sed/文件操作/" itemprop="url" rel="index">
                    <span itemprop="name">文件操作</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Sed-命令地址匹配问题总结"><a href="#Sed-命令地址匹配问题总结" class="headerlink" title="Sed 命令地址匹配问题总结"></a>Sed 命令地址匹配问题总结</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="http://kodango.com/sed-address-matching-summary" target="_blank" rel="noopener">http://kodango.com/sed-address-matching-summary</a></p>
</blockquote>
<p><br></p>
<p>这个问题来源于<code>ChinaUnix</code>的一篇帖子“<a href="http://bbs.chinaunix.net/forum.php?mod=viewthread&amp;tid=3557086" target="_blank" rel="noopener">sed地址和模式匹配的问题</a>”。</p>
<h2 id="man-sed手册说明"><a href="#man-sed手册说明" class="headerlink" title="man sed手册说明"></a>man sed手册说明</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Sed</code>默认的命令执行范围是全局的，如果想仅对其中部分行执行命令，可以使用地址限制</strong>。在<code>Manual</code>手册中有一节关于地址的描述，摘取部分如下：</p>
<blockquote>
<p>Sed commands can be given with no addresses, in which case the command will be executed for all input lines;</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Sed</code>默认是全局编辑的，因此如果不明确指定行的话，命令会在所有输入行上执行</strong>。</p>
<blockquote>
<p>with one address, in which case the command will only be executed for input lines which match that address;</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果指定一个行地址，那么<code>sed</code>命令就限制在那一行执行。</p>
<blockquote>
<p>or with two addresses, in which case the command will be executed for all input lines which match the inclusive range of lines starting from the first address and continuing to the second address.</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果给了两个地址，即地址对（或者地址范围），则命令在匹配的这个地址范围内执行。但是需要注意的几点是：</p>
<blockquote>
<p>The syntax is addr1,addr2 (i.e., the addresses are separated by a comma); the line which addr1 matched will always be accepted, even if addr2 selects an earlier line; If addr2 is a regexp, it will not be tested against the line that addr1 matched.</p>
</blockquote>
<p>上面的内容，大致意思是说：(a)</p>
<ul>
<li><p>对于像<code>“addr1,addr2”</code>这种形式的地址匹配，<strong>如果addr1匹配，则匹配成功，“开关”打开，在该行上执行命令，此时不管addr2是否匹配，即使addr2在addr1这一行之前</strong>；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@php5<span class="comment"># seq 6 | sed -n '3,1p'  #1在3的前面  addr2在addr1之前，则不匹配，不执行命令，关闭“开关”</span></span><br><span class="line">3</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>接下来读入下一行，看addr2是否匹配</p>
<ol>
<li>如果<strong>addr2在addr1之前</strong>，则不匹配，不执行命令，<strong>关闭“开关”</strong>；</li>
<li>如果<strong>addr2匹配</strong>，则执行命令，同样<strong>开关“关闭”</strong>；</li>
<li>如果addr2在addr1之后，则一直处理到匹配为止，换句话说，<strong>如果addr2一直不匹配，则开关一直不关闭，因此会持续执行命令到最后一行（这种情况一般存在于addr2是正则匹配）</strong>。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@php5<span class="comment"># seq 6 | sed -n '3,/v/p'</span></span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>After the address (or address-range), and before the command, a ! may be inserted, which specifies that the command shall only be executed if the address (or address-range) does not match.</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>如果地址或者地址对之后有一个”!”，表明对匹配的行不执行后面的命令，刚好相反</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@php5<span class="comment"># seq 6 | sed -n '3,/v/!p'</span></span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@php5<span class="comment"># seq 6 | sed -n '1,3!p'</span></span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<h2 id="地址形式"><a href="#地址形式" class="headerlink" title="地址形式"></a>地址形式</h2><p><code>Sed</code>一般至少支持以下形式的地址表示：</p>
<ol>
<li><p><code>number</code>: 这一种情况不多说。</p>
</li>
<li><p><code>first~step</code>: 从<code>first</code>行开始，每隔<code>step</code>行执行一次命令。</p>
<p>详细的内容也可以参照手册:</p>
<blockquote>
<p>Match every step’th line starting with line first. For example,‘sed -n 1~2p’ will print all the odd-numbered lines in theinput stream, and the address 2~5 will match every fifth line, starting with the second. (This is an extension.)</p>
</blockquote>
</li>
<li><p><code>/regexp/</code>: 同第一种方法类似，不过是匹配该正则的那一行。</p>
</li>
<li><p>在匹配行的时候，<strong>$是特殊的标记，匹配最后一行</strong>。<strong>1匹配第一行</strong>，而不是^，这点和正则不大一样。</p>
</li>
</ol>
<p>另外，<code>GNU Sed</code>还支持以下几种特殊的地址对形式：（平常使用的基本是<code>GNU Sed</code>，即<code>gsed</code>）</p>
<ol>
<li><p><code>0,addr2</code></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种形式的地址对，<strong>默认第一个地址是匹配的，也就是匹配开关打开，直到找到匹配addr2的那行为止，匹配开关关闭</strong>。大多数情况下和<code>1, addr2</code>是一样的，除非addr2匹配文件的第一行，在这种时候，0, addr2就在第一行就关闭了，而1, addr2会继续往下找匹配的行。</p>
<blockquote>
<p>Start out in “matched first address” state, until addr2 is found. This is similar to 1,addr2, except that if addr2 matches the very first line of input, the 0,addr2 form will be at the end of its range, whereas the 1,addr2 form will still be at the beginning of its range.</p>
</blockquote>
<p>可以看一个例子：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">root@php5#</span><span class="bash"> seq 6 | sed -n <span class="string">'1, /1/p'</span></span></span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line"><span class="meta">root@php5#</span><span class="bash"> seq 6 | sed -n <span class="string">'0, /1/p'</span></span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>为什么不相同呢？ 解释一下：</p>
<ul>
<li>0, addr2 这种形式默认第一个地址是匹配的，然后直到add2匹配为止。因此上述情况，只要看每一行是否匹配第二个地址就可以了addr2，<strong>因为第一行是匹配的，所以打印到第一行为止</strong>。</li>
<li>1, addr2 这种形式就是普通形式，参考（a）红字说明部分，不管addr2匹配与否，<strong>第一行是匹配的，然后读入第二行（第2行就是2了，不匹配/1/），发现不匹配addr2，继续读，直到最后也没找到匹配，因此打印从第1行到最后一行之间的所有内容</strong>。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这种地址对表示有一个限制，即<strong><code>addr2</code>只能使用<code>/regex/</code>形式(addr1=0时)，如果使用行号，就会出错</strong>，不信可以试试。</p>
</li>
</ol>
<ol start="2">
<li><code>addr1,+N</code>: 从匹配的addr1行开始，连续N行，当然包括addr1这一行。</li>
</ol>
<ol start="3">
<li><code>addr1,~N</code>: 从匹配的addr1行开始，直到某一行，该行的行号是N的倍数为止。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>可以总结出几个关键点：</p>
</li>
<li><ul>
<li><p><strong>地址对<code>addr1, addr2</code>的匹配方式 ，从匹配addr1的那行开始，打开匹配开关，直到匹配addr2的那行结束，关闭匹配开关，之后的行会忽略这个地址对，不再做匹配</strong>。(b)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@php5<span class="comment"># seq 16 | sed -n '3,/6/p' #匹配到行6就停止了，不会匹配16</span></span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>地址对<code>addr1, addr2</code>的匹配方式 ，假设addr1是number，即行号，如果新读入行的行号<strong>大于addr1，则匹配</strong>；小于addr1，则不匹配。(c)</p>
<p>注意：<strong>如果addr2是行号，如果新读入行的行号小于addr2，则匹配，继续往下读</strong>；<strong>大于addr2，则不匹配，关闭匹配开关</strong>。刚好与上面的情况相反（这个比较好理解，可以辅助记住(c)这种情况）。</p>
</li>
</ul>
<ol start="3">
<li><p>最后引用<code>chinaunix</code>上的那个帖子的问题，以下两种情况结果为什么会不一样：</p>
</li>
<li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> seq 6 | sed <span class="string">'1,2d'</span> | sed <span class="string">'1,2d'</span>  <span class="comment"># 结果返回5 6</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> seq 6 | sed -e <span class="string">'1,2d'</span> -e <span class="string">'1,2d'</span> <span class="comment"># 结果返回4 5 6</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>显然这两种情况使用<code>sed</code>的命令形式是不一样的。</p>
</li>
<li></li>
<li><p>第一种利用管道使用了<code>sed</code>两次，结果返回5 6，没什么问题；</p>
</li>
<li></li>
<li><p>第二种情况在同一个<code>sed</code>命令中使用了两次<code>1,2d</code>，按常理应该是返回 <code>3 4 5 6</code>，结果返回<code>4 5 6</code>，第3行竟然也被意外地删除了，为什么呢？</p>
</li>
<li><p>解释：</p>
</li>
<li><p>首先第一行被读入，遇到第一组<code>expression -&gt; 1, 2d</code>，第一行匹配成功（打开匹配开关），执行d命令，d命令清空模式空间的内容，因此不会再执行接下来的命令。</p>
</li>
<li>继续从标准输入读入第二行，同1</li>
<li>读入第三行，第一组<code>expression</code>匹配失败（因为3&gt;2），因此试着<strong>执行第二组<code>expersson-&gt;1,2d</code>，因为3&gt;1，打开匹配开关，执行d。（这里是关键）</strong></li>
<li><strong>读入第四行，执行第二组<code>expersson-&gt;1,2d</code>，因为4&gt;2，匹配失败，关闭匹配开关，同时也不执行d</strong>。</li>
<li>因此，最后第1 2 3行被删除。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/28/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><span class="page-number current">29</span><a class="page-number" href="/page/30/">30</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/30/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
