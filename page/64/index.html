<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/page/64/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/page/64/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/21/如何不影响服务，数据平滑迁移/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/21/如何不影响服务，数据平滑迁移/" itemprop="url">如何不影响服务，数据平滑迁移</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-21T12:12:57+08:00">
                2019-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/微服务/" itemprop="url" rel="index">
                    <span itemprop="name">微服务</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/微服务/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/微服务/架构/数据迁移/" itemprop="url" rel="index">
                    <span itemprop="name">数据迁移</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="如何不影响服务，数据平滑迁移"><a href="#如何不影响服务，数据平滑迁移" class="headerlink" title="如何不影响服务，数据平滑迁移"></a>如何不影响服务，数据平滑迁移</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s/1ZswtROH32_SuaJxeg-vKw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1ZswtROH32_SuaJxeg-vKw</a></p>
</blockquote>
<p><br></p>
<h2 id="适用什么场景？"><a href="#适用什么场景？" class="headerlink" title="适用什么场景？"></a><strong>适用什么场景？</strong></h2><p>互联网有很多“数据量较大，并发量较大，业务复杂度较高”的业务场景，其典型系统分层架构如下：</p>
<p><img src="//blog.com/2019/05/21/如何不影响服务，数据平滑迁移/微信图片_20190521233450.jpg" alt="img"></p>
<p>（1）上游是<strong>业务层biz</strong>，实现个性化的业务逻辑；</p>
<p>（2）中游是<strong>服务层service</strong>，封装数据访问；</p>
<p>（3）下游是<strong>数据层db</strong>，存储固化的业务数据；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;服务化分层架构的好处是，服务层屏蔽下游数据层的复杂性，例如缓存、分库分表、存储引擎等存储细节不需要向调用方暴露，而只向上游提供方便的<code>RPC</code>访问接口，当有一些数据层变化的时候，所有的调用方也不需要升级，只需要服务层升级即可。</p>
<p>互联网架构，很多时候面临着这样一些需求：</p>
<p><img src="//blog.com/2019/05/21/如何不影响服务，数据平滑迁移/微信图片_20190521233857.jpg" alt="img"></p>
<p><strong>（1）底层表结构变更</strong>：数据量非常大的情况下，数据表增加了一些属性，删除了一些属性，修改了一些属性。</p>
<p><img src="//blog.com/2019/05/21/如何不影响服务，数据平滑迁移/微信图片_20190521233901.jpg" alt="img"></p>
<p><strong>（2）分库个数变化</strong>：由于数据量的持续增加，底层分库个数非成倍增加。</p>
<p><img src="//blog.com/2019/05/21/如何不影响服务，数据平滑迁移/微信图片_20190521233905.jpg" alt="img"></p>
<p><strong>（3）底层存储介质变化</strong>：底层存储引擎由一个数据库换为另一个数据库。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;种种需求，都需要进行数据迁移，如何平滑迁移数据，迁移过程不停机，保证系统持续服务，是文本将要讨论的问题。</p>
<h2 id="方案一：停机方案"><a href="#方案一：停机方案" class="headerlink" title="方案一：停机方案"></a><strong>方案一：停机方案</strong></h2><p>在讨论平滑迁移数据方案之前，先看下不平滑的停机数据迁移方案，主要分三个步骤。</p>
<p><img src="//blog.com/2019/05/21/如何不影响服务，数据平滑迁移/微信图片_20190521234014.jpg" alt="img"></p>
<p><strong>步骤一</strong>：<strong>挂</strong>一个类似“为了给广大用户提供更好的服务，服务器会在凌晨0:00-0:400进行停机维护”的<strong>公告</strong>，并在对应时段进行<strong>停机</strong>，这个时段系统没有流量进入。</p>
<p><img src="//blog.com/2019/05/21/如何不影响服务，数据平滑迁移/微信图片_20190521234020.jpg" alt="img"></p>
<p><strong>步骤二</strong>：停机后，研发一个<strong>离线</strong>的数据迁移工具，进行<strong>数据迁移</strong>。针对第一节的三类需求，会分别开发不同的数据迁移工具。</p>
<p>（1）底层表结构变更需求：开发旧表导新表的工具；</p>
<p>（2）分库个数变换需求：开发2库导3库的工具；</p>
<p>（3）底层存储介质变换需求：开发<code>Mongo</code>导<code>Mysql</code>工具；</p>
<p><img src="//blog.com/2019/05/21/如何不影响服务，数据平滑迁移/微信图片_20190521234027.jpg" alt="img"></p>
<p><strong>步骤三</strong>：<strong>恢复服务</strong>，并将流量切到新库，不同的需求，可能会涉及不同服务升级。</p>
<p>（1）底层表结构变更需求：服务要升级到访问新表；</p>
<p>（2）分库个数变换需求：服务不需要升级，只需要改寻库路由配置；</p>
<p>（3）底层存储介质变换需求：服务升级到访问新的存储介质；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总的来说，停机方案是相对直观和简单的，但对服务的可用性有影响，许多游戏公司的服务器升级，游戏分区与合区，可能会采用类似的方案。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了影响服务的可用性，这个方案还有一个缺点，就是必须在指定时间完成升级，这个对研发、测试、运维同学来说，<strong>压力会非常大</strong>，一旦出现问题例如数据不一致，必须在规定时间内解决，否则只能回滚。根据经验，<strong>人压力越大越容易出错</strong>，这个缺点一定程度上是致命的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论如何，停机方案并不是今天要讨论的重点，接下来看一下常见的平滑数据迁移方案。</p>
<h2 id="方案二：追日志方案"><a href="#方案二：追日志方案" class="headerlink" title="方案二：追日志方案"></a><strong>方案二：追日志方案</strong></h2><p>追日志方案，是一个高可用的平滑迁移方案，这个方案主要分为五个步骤。</p>
<p><img src="//blog.com/2019/05/21/如何不影响服务，数据平滑迁移/微信图片_20190521234306.jpg" alt="img"></p>
<p>数据迁移前，上游业务应用通过旧的服务访问旧的数据。</p>
<p><img src="//blog.com/2019/05/21/如何不影响服务，数据平滑迁移/微信图片_20190521234319.jpg" alt="img"></p>
<p><strong>步骤一</strong>：服务进行升级，记录“对旧库上的数据修改”的日志（这里的修改，为数据的insert, delete, update），这个日志不需要记录详细数据，主要记录：</p>
<p>（1）被修改的库；</p>
<p>（2）被修改的表；</p>
<p>（3）被修改的唯一主键；</p>
<p>具体新增了什么行，修改后的数据格式是什么，不需要详细记录。这样的好处是，不管业务细节如何变化，日志的格式是固定的，这样能保证方案的通用性。</p>
<p>这个服务升级风险较小：</p>
<p>（1）写接口是少数接口，改动点较少；</p>
<p>（2）升级只是增加了一些日志，对业务功能没有任何影响；</p>
<p><img src="//blog.com/2019/05/21/如何不影响服务，数据平滑迁移/微信图片_20190521234328.jpg" alt="img"></p>
<p><strong>步骤二</strong>：研发一个数据迁移工具，进行数据迁移。这个数据迁移工具和离线迁移工具一样，把旧库中的数据转移到新库中来。</p>
<p>这个小工具的风险较小：</p>
<p>（1）整个过程依然是旧库对线上提供服务；</p>
<p>（2）小工具的复杂度较低；</p>
<p>（3）任何时间发现问题，都可以把新库中的数据干掉重来；</p>
<p>（4）可以限速慢慢迁移，技术同学没有时间压力；</p>
<p><strong>数据迁移完成之后，就能够切到新库提供服务了么？</strong></p>
<p>答案是否定的，在数据迁移的过程中，旧库依然对线上提供着服务，库中的数据随时可能变化，这个变化并没有反映到新库中来，于是旧库和新库的数据并不一致，所以不能直接切库，需要将数据追平。</p>
<p><strong>哪些数据发生了变化呢？</strong></p>
<p>步骤一中日志里记录的，正是变化的数据。</p>
<p><img src="//blog.com/2019/05/21/如何不影响服务，数据平滑迁移/微信图片_20190521234335.jpg" alt="img"></p>
<p><strong>步骤三</strong>：研发一个读取日志并迁移数据的小工具，要把步骤二迁移数据过程中产生的差异数据追平。这个小工具需要做的是：</p>
<p>（1）读取日志，得到哪个库、哪个表、哪个主键发生了变化；</p>
<p>（2）把旧库中对应主键的记录读取出来；</p>
<p>（3）把新库中对应主键的记录替换掉；</p>
<p>无论如何，原则是数据以旧库为准。</p>
<p>这个小工具的风险也很小：</p>
<p>（1）整个过程依然是旧库对线上提供服务；</p>
<p>（2）小工具的复杂度较低；</p>
<p>（3）任何时间发现问题，大不了从步骤二开始重来；</p>
<p>（4）可以限速慢慢重放日志，技术同学没有时间压力；</p>
<p><strong>日志重放之后，就能够切到新库提供服务了么？</strong></p>
<p>答案依然是否定的，在日志重放的过程中，旧库中又可能有数据发生了变化，导致数据不一致，所以还是不能切库，需要进一步读取日志，追平记录。可以看到，重放日志追平数据的程序是一个while(1)的程序，新库与旧库中的数据追平也会是一个“无限逼近”的过程。</p>
<p><strong>什么时候数据会完全一致呢？</strong></p>
<p><img src="//blog.com/2019/05/21/如何不影响服务，数据平滑迁移/微信图片_20190521234340.jpg" alt="img"></p>
<p><strong>步骤四</strong>：在持续重放日志，追平数据的过程中，研发一个数据校验的小工具，将旧库和新库中的数据进行比对，直到数据完全一致。</p>
<p>这个小工具的风险依旧很小：</p>
<p>（1）整个过程依然是旧库对线上提供服务；</p>
<p>（2）小工具的复杂度较低；</p>
<p>（3）任何时间发现问题，大不了从步骤二开始重来；</p>
<p>（4）可以限速慢慢比对数据，技术同学没有时间压力；</p>
<p><img src="//blog.com/2019/05/21/如何不影响服务，数据平滑迁移/微信图片_20190521234345.jpg" alt="img"></p>
<p><strong>步骤五</strong>：在数据比对完全一致之后，将流量迁移到新库，新库提供服务，完成迁移。</p>
<p>如果步骤四数据一直是99.9%的一致，不能完全一致，也是正常的，可以做一个秒级的旧库readonly，等日志重放程序完全追上数据后，再进行切库切流量。</p>
<p>至此，升级完毕，整个过程能够持续对线上提供服务，不影响服务的可用性。</p>
<h2 id="方案三：双写方案"><a href="#方案三：双写方案" class="headerlink" title="方案三：双写方案"></a><strong>方案三：双写方案</strong></h2><p>双写方案，也是一个高可用的平滑迁移方案，这个方案主要分为四个步骤。</p>
<p><img src="//blog.com/2019/05/21/如何不影响服务，数据平滑迁移/微信图片_20190521234754.jpg" alt="img"></p>
<p>数据迁移前，上游业务应用通过旧的服务访问旧的数据。</p>
<p><img src="//blog.com/2019/05/21/如何不影响服务，数据平滑迁移/微信图片_20190521234759.jpg" alt="img"></p>
<p><strong>步骤一</strong>：服务进行升级，对“对旧库上的数据修改”（这里的修改，为数据的<code>insert, delete, update</code>），在新库上进行相同的修改操作，这就是所谓的“双写”，主要修改操作包括：</p>
<p>（1）旧库与新库的同时<code>insert</code>；</p>
<p>（2）旧库与新库的同时<code>delete</code>；</p>
<p>（3）旧库与新库的同时<code>update</code>；</p>
<p>由于新库中此时是没有数据的，所以双写旧库与新库中的<code>affect rows</code>可能不一样，不过这完全不影响业务功能，只要不切库，依然是旧库提供业务服务。</p>
<p>这个服务升级风险较小：</p>
<p>（1）写接口是少数接口，改动点较少；</p>
<p>（2）新库的写操作执行成功与否，对业务功能没有任何影响；</p>
<p><img src="//blog.com/2019/05/21/如何不影响服务，数据平滑迁移/微信图片_20190521234805.jpg" alt="img"></p>
<p><strong>步骤二</strong>：研发一个数据迁移工具，进行数据迁移。这个数据迁移工具在本文中已经出现第三次了，把旧库中的数据转移到新库中来。</p>
<p>这个小工具的风险较小：</p>
<p>（1）整个过程依然是旧库对线上提供服务；</p>
<p>（2）小工具的复杂度较低；</p>
<p>（3）任何时间发现问题，都可以把新库中的数据干掉重来；</p>
<p>（4）可以限速慢慢迁移，技术同学没有时间压力；</p>
<p><strong>数据迁移完成之后，就能够切到新库提供服务了么？</strong></p>
<p>答案是肯定的，因为前置步骤进行了双写，所以理论上数据迁移完之后，新库与旧库的数据应该完全一致。</p>
<p>由于迁移数据的过程中，旧库新库双写操作在同时进行，<strong>怎么证明数据迁移完成之后数据就完全一致了呢？</strong></p>
<p><img src="//blog.com/2019/05/21/如何不影响服务，数据平滑迁移/微信图片_20190521234811.jpg" alt="img"></p>
<p>如上图所示：</p>
<p>（1）左侧是旧库中的数据，右侧是新库中的数据；</p>
<p>（2）按照<code>primary key</code>从<code>min</code>到<code>max</code>的顺序，分段，限速进行数据的迁移，假设已经迁移到now这个数据段，数据迁移过程中的修改操作分别讨论：</p>
<ul>
<li>假设迁移过程中进行了一个<strong>双insert操作</strong>，旧库新库都插入了数据，数据一致性没有被破坏</li>
<li>假设迁移过程中进行了一个<strong>双delete操作</strong>，这又分为两种情况</li>
</ul>
<p><strong>情况一</strong>：假设这delete的数据属于<code>[min,now]</code>范围，即已经完成迁移，则旧库新库都删除了数据，数据一致性没有被破坏；</p>
<p><strong>情况二</strong>：假设这delete的数据属于<code>[now,max]</code>范围，即未完成迁移，则旧库中删除操作的affect rows为1，新库中删除操作的<code>affect rows</code>为0，但是数据迁移工具在后续数据迁移中，并不会将这条旧库中被删除的数据迁移到新库中，所以数据一致性仍没有被破坏；</p>
<ul>
<li>假设迁移过程中进行了一个<strong>双update操作</strong>，可以认为update操作是一个delete加一个insert操作的复合操作，所以数据仍然是一致的</li>
</ul>
<p>除非，在一种非常极限的情况下：</p>
<p>（1）<code>date-migrate-tool</code><strong>刚好</strong>从旧库中将某一条数据X取出；</p>
<p>（2）在X插入到新库中之前，旧库与新库中<strong>刚好</strong>对X进行了双delete操作；</p>
<p>（3）<code>date-migrate-tool</code>再将X插入到新库中；</p>
<p>这样，会出现新库比旧库多出一条数据X。</p>
<p>但无论如何，为了保证数据的一致性，切库之前，还是需要进行数据校验的。</p>
<p><img src="//blog.com/2019/05/21/如何不影响服务，数据平滑迁移/微信图片_20190521235247.jpg" alt="img"></p>
<p><strong>步骤三</strong>：在数据迁移完成之后，需要使用数据校验的小工具，将旧库和新库中的数据进行比对，完全一致则符合预期，如果出现步骤二中的极限不一致情况，则以旧库中的数据为准。</p>
<p>这个小工具的风险依旧很小：</p>
<p>（1）整个过程依然是旧库对线上提供服务；</p>
<p>（2）小工具的复杂度较低；</p>
<p>（3）任何时间发现问题，大不了从步骤二开始重来；</p>
<p>（4）可以限速慢慢比对数据，技术同学没有时间压力；</p>
<p><img src="//blog.com/2019/05/21/如何不影响服务，数据平滑迁移/微信图片_20190521235253.jpg" alt="img"></p>
<p><strong>步骤四</strong>：数据完全一致之后，将流量切到新库，完成平滑数据迁移。</p>
<p>至此，升级完毕，整个过程能够持续对线上提供服务，不影响服务的可用性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>针对互联网很多“数据量较大，并发量较大，业务复杂度较高”的业务场景，在：</p>
<p>（1）底层表结构变更；</p>
<p>（2）分库个数变化；</p>
<p>（3）底层存储介质变化；</p>
<p>的众多需求下，需要进行数据迁移，完成<strong>“平滑迁移数据，迁移过程不停机，保证系统持续服务”</strong>有两种常见的解决方案。</p>
<p><strong>追日志方案</strong>，五个步骤：</p>
<p>（1）<strong>服务进行升级</strong>，记录“对旧库上的数据修改”的日志；</p>
<p>（2）研发一个数据迁移<strong>小工具</strong>，进行数据迁移；</p>
<p>（3）研发一个读取日志<strong>小工具</strong>，追平数据差异；</p>
<p>（4）研发一个数据比对<strong>小工具</strong>，校验数据一致性；</p>
<p>（5）流量切到新库，完成平滑迁移；</p>
<p><strong>双写方案</strong>，四个步骤：</p>
<p>（1）<strong>服务进行升级</strong>，记录“对旧库上的数据修改”进行新库的双写；</p>
<p>（2）研发一个数据迁移<strong>小工具</strong>，进行数据迁移；</p>
<p>（3）研发一个数据比对<strong>小工具</strong>，校验数据一致性；</p>
<p>（4）流量切到新库，完成平滑迁移；</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/21/Circuit Breaker Pattern（断路器模式）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/21/Circuit Breaker Pattern（断路器模式）/" itemprop="url">Circuit Breaker Pattern（断路器模式）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-21T12:12:57+08:00">
                2019-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/微服务/" itemprop="url" rel="index">
                    <span itemprop="name">微服务</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/微服务/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/微服务/架构/熔断/" itemprop="url" rel="index">
                    <span itemprop="name">熔断</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Circuit-Breaker-Pattern（断路器模式）"><a href="#Circuit-Breaker-Pattern（断路器模式）" class="headerlink" title="Circuit Breaker Pattern（断路器模式）"></a>Circuit Breaker Pattern（断路器模式）</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://blog.csdn.net/joeyangy/article/details/43112687" target="_blank" rel="noopener">https://blog.csdn.net/joeyangy/article/details/43112687</a></p>
</blockquote>
<p><br></p>
<p>当连接使用远端服务或资源时，可能需要花不少精力来做好错误处理。这个模式可以有效提高程序的稳定性和弹性。</p>
<h2 id="Context-and-Problem"><a href="#Context-and-Problem" class="headerlink" title="Context and Problem"></a>Context and Problem</h2><p>​    在像云这种分布式的环境中，应用程序的操作经常访问远端的资源和服务。然而这类操作有可能因为网络响应慢、超时、资源暂时不可用等瞬时性故障（transient faults）而失败。这些故障通常情况下会在一小段时间后自动恢复，而对于一个好的云应用来说，必须要有一个好的策略（比如尝试重试）来处理这种情况。</p>
<p>​    但是有时候错误是由一些难以预期的异常事件导致的，这种情况就可能会花费相对来说较多的时间来处理和修复，并且直接导致部分服务甚至所有服务无法使用。当发生了这种情况时，应用程序再进行不停地重试就没什么意义了，此时应用程序应该尽快将本次操作（包括重试）标为彻底失败，并在应用程序端触发对应的错误处理逻辑。</p>
<p>​    此外，对于一个访问压力很大的服务来说，系统中某部分的异常可能会引发一系列连锁的异常。举个栗子：比如说我们现在有个操作会去调用一个远端服务，并且这个操作实现了超时机制，在指定的时间段内如果对方服务没有响应那么本次操作就会返回一个failure消息。假设此时系统压力很大，不停地有大量并行的请求都调用这个操作，如果此时远端服务出现异常没有响应了，那么这些并行的实例都会被阻塞直到超时。再假设这些被阻塞的请求都拥有一些系统临界资源（比如内存、线程、数据库连接等等），那么这种情况下这些资源会被很快消耗殆尽，这样一来其他一些无关但也用到这些资源的操作也会失败。在这种情况下，我们可能更希望这个操作能够快速失败，仅当服务有可能成功调用时再进行重试（而不是傻傻地来一个操作失败了不停重试调用这个服务）。另外，将超时时间设短一点也许能解决这个问题，但也不能设得太短（为了应对瞬时错误）。</p>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>​    断路器模式能够防止应用程序不停尝试一个极有可能失败的操作，使应用程序能够继续运行而不用花费大量时间来进行没有必要的错误处理或等待异常恢复。另外，断路器模式能够使应用程序能够检测到异常是否已经被修复，如果对应异常已经被修复了，那么应用程序就又可以尝试来调用这个操作了。（断路器模式和单纯的重试区别非常大，具体比较在后面谈到重试模式时再介绍。另外，可以结合现实中的断路器的功能来理解这个模式）。</p>
<p>​    一个断路器相当于是一个可能失败的操作的代理。这个代理会监控最近错误发生的次数，然后通过这些信息来决定是让一个应用程序来调用这个操作还是直接立即返回一个异常。这个代理可以用状态机的形式来实现从而模拟电力电子学中断路器的功能，主要有下面这些状态：</p>
<p><strong>Closed: 应用程序能够直接通过这个代理来调用操作。</strong>在这个代理内部保存了最近发生错误的次数计数器，如果发生了一次失败的调用，那么这个计数器就会增加；如果在一定的时间段内这个计数器的值超过了一个设定的阈值，那么这个代理就会进入Open状态。此时，代理会启动一个超时计时器，当这个计时器到期时，代理就会进入Half-Open状态（设置这个超时器的目的是：在允许应用程序再次调用这个操作之前，给系统一段时间来解决导致异常的错误）。</p>
<p><strong>Open: 这种状态下应用程序的调用请求会立即失败并且收到一个exception。</strong></p>
<p><strong>Half-Open: 这种状态下只允许限量调用这个操作。</strong>如果所有这些调用成功了，那么就认为之前导致异常的错误被解决了，此时代理的状态会被设置成Closed，同时重置错误计数器；如果这些调用中还存在错误的情况，那么就认为这个问题还没有被解决，此时代理的状态被重新设置成Open，并重置超时计时器，从而再给系统一个时间来解决这个问题。一个刚刚恢复的服务可能并不能一下子支持大量的服务请求直到恢复流程彻底走完，否则过大的访问压力也许会导致正在出于恢复过程中的服务再次因为超时或失败，而Half-Open状态能够防止一个刚刚恢复的服务一下子被请求淹没（限量访问，一旦有错就进入Open停止对服务的访问），从而安全地走完它的错误处理/恢复过程。</p>
<p><img src="//blog.com/2019/05/21/Circuit Breaker Pattern（断路器模式）/20150125104554328.jpg" alt="img"></p>
<p>说明：</p>
<p>1.在Closed中的failure counter是基于时间的，每隔一段时间会自动清零。这是为了防止断路器因为一些偶发的错误而进入Open状态。所以总结一下就是从Closed状态切到Open状态需要让错误计数器在一个时间段内达到阈值，否则较低频率出现的错误不会导致进入Open状态。</p>
<p>2.在Half-Open状态中用到的success counter记录的是成功调用的次数。当连续成功的次数达到一个设定的阈值后状态就会切为Closed，在此期间一旦发生失败的调用，状态立即切为Open，success counter在下次状态从Open切换到Half-Open时被重置。</p>
<p>​    </p>
<p>​    实现断路器模式能够提高系统的稳定性和弹性，并使系统在错误恢复过程中保持稳定，同时也将错误对系统性能的影响最小化。通过直接拒绝那些很有可能失败（基本上是一定会失败）的请求而不是不断地无脑重试能够保证系统响应时间的稳定（尽管可能响应的是一个报错消息，那也比因为错误重试导致请求堆积引发更大的问题来的好）。我们也可以在断路器每次状态切换时加上打印或消息通知，这些日志信息可以有效帮助监听系统健康状态，或者在断路器状态变成Open时及时通知维护人员。</p>
<p>​    在实际使用中可以根据实际情况对这个模式进行定制化。比如说你可以将Open状态定时器实现成一个自增的定时器，即最开始超时时间仅为一个很短的时间比如几秒，如果到期切成Half-Open状态又被打回来了，就延长超时时间；再比如说Open状态可以不返回一个异常而是返回一个默认值。</p>
<h2 id="Issues-and-Considerations"><a href="#Issues-and-Considerations" class="headerlink" title="Issues and Considerations"></a>Issues and Considerations</h2><p>当使用这一模式时需要注意以下几点：</p>
<p>1.异常处理。通过断路器来调用一个服务必须要对服务不可用的情况做好异常处理。不同的应用根据自己的需求来定制这个异常处理逻辑。</p>
<p>2.异常类型。一次请求失败的理由五花八门，有些异常相比其他的可能会严重得多（也就是说需要更多时间来做错误处理）。断路器可能需要针对不同的异常来配置不同策略（各种阈值根据不同的异常类型来进行配置）。</p>
<p>3.日志记录。断路器对于每次异常情况都需要添加日志记录使维护人员能够监测系统的监控状况，并协助开发人员来进行改进优化。</p>
<p>4.可恢复性。在实际使用中设置断路器的参数时应该考虑到其所保护操作的恢复特性。举个例子，如果Open超时时间设置得远远超过异常恢复所需要的时间，那么则极有可能出现断路器长时间处于Open状态，即使异常早已被解决，调用者也只会一直受到异常信息。类似的，如果将这个时间设置得相对异常恢复时间来说过分短，那么就会使断路器频繁地在Open状态和Half-Open状态之间跳动，从而使整个应用的响应时间变得非常不稳定。</p>
<p>5.对失败的操作进行测试。举个例子来说，在Open状态下，我们除了使用一个超时计时器来作为Open状态切换到Half-Open状态的依据外，也可以尝试周期地Ping远端服务/资源的IP，以此为依据来判断远端服务/资源是否可用。这种方式实际上是用一种相对来说开销更小的访问模式来测试远端服务的连通性和健康程度。</p>
<p>6.外部手动控制。在一个复杂系统之中，由于不同的异常恢复时间和异常处理流程都不尽相同，我们可以为系统管理员提供一个人工介入的接口来应对一些特殊的情况，比如可以提供重置计数器命令、重置超时器命令等，甚至也可以提供接口使管理员能够手动更改断路器的状态。</p>
<p>7.并发性。同一个断路器有可能同时被大量的请求使用，所以在设计和实现断路器时不能出现阻塞的情景，也要尽可能地减少调用过程中的资源开销。</p>
<p>8.资源差异性。当用一个断路器来控制一类资源（虽然为同一类资源甚至同一个资源，但很有可能是由不同独立的资源提供者组成）访问时需要格外注意。举个例子，一个数据存储器可能是由多个不同的分片组成的，此时存在一种可能就是有些分片可能能够正常的访问，但与此同时另一些分片无法正常访问。此时加在这个数据存储之上的断路器对于访问出现的错误如果混在一起用同样的处理，那么调用者则很有可能会尝试访问那些无法正常访问的分片。</p>
<p>9.对断路器进行加速。有时候尽管断路器没有达到标准的切换条件，但根据响应中所携带的信息已经可以确定要做状态切换以及维持这个状态的时间。比如如果访问一个正在进行重载的资源时收到的响应已经告诉访问端资源正在进行重载，可能需要几分钟，那么此时断路器在收到消息后可以立刻切成Open状态，并根据响应中包含的时间来配置超时时间。</p>
<p>10.调用重试。在Open状态期间，除了简单地对调用者返回一个错误或默认值外，也可以对这些被直接打回去的调用做记录，当资源可用时对这些记录中的调用请求进行重试。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/20/Elasticsearch高性能优化实践/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/20/Elasticsearch高性能优化实践/" itemprop="url">Elasticsearch高性能优化实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-20T12:12:57+08:00">
                2019-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/Elasticsearch/" itemprop="url" rel="index">
                    <span itemprop="name">Elasticsearch</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/Elasticsearch/搜索引擎/" itemprop="url" rel="index">
                    <span itemprop="name">搜索引擎</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/Elasticsearch/搜索引擎/Lucene/" itemprop="url" rel="index">
                    <span itemprop="name">Lucene</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Elasticsearch高性能优化实践"><a href="#Elasticsearch高性能优化实践" class="headerlink" title="Elasticsearch高性能优化实践"></a>Elasticsearch高性能优化实践</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s/k21807E0fLAv9aNDnZtSsw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/k21807E0fLAv9aNDnZtSsw</a></p>
</blockquote>
<p><br></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ES 的默认配置，是综合了数据可靠性、写入速度、搜索实时性等因素。实际使用时，我们需要根据公司要求，进行偏向性的优化。</p>
<h2 id="写优化"><a href="#写优化" class="headerlink" title="写优化"></a>写优化</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们的应用场景要求是，每秒 300 万的写入速度，每条 500 字节左右。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对这种对于搜索性能要求不高，但是对写入要求较高的场景，我们需要尽可能的选择恰当写优化策略。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;综合来说，可以考虑以下几个方面来提升写索引的性能：</p>
<p>加大 <code>Translog Flush</code> ，目的是降低<code>Iops、Writeblock</code>。<br>增加 <code>Index Refresh</code> 间隔，目的是减少 <code>Segment Merge</code>的次数。<br>调整 <code>Bulk</code> 线程池和队列。<br>优化节点间的任务分布。<br>优化<code>Lucene</code> 层的索引建立，目的是降低<code>CPU 及 IO</code>。</p>
<h3 id="批量提交"><a href="#批量提交" class="headerlink" title="批量提交"></a>批量提交</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ES 提供了<code>Bulk API</code> 支持批量操作，当我们有大量的写任务时，可以使用 <code>Bulk</code>来进行批量写入。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次提交的数据量为多少时，能达到最优的性能，主要受到文件大小、网络情况、数据类型、集群状态等因素影响。 </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通用的策略如下：<code>Bulk</code> 默认设置批量提交的数据量不能超过<code>100M</code>。数据条数一般是根据文档的大小和服务器性能而定的，但是单次批处理的数据大小应从<code>5MB～15MB</code>逐渐增加，当性能没有提升时，把这个数据量作为最大值。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以跟着，感受一下 <code>Bulk</code> 接口，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ vi request</span><br><span class="line">$ cat request</span><br><span class="line">&#123; <span class="string">"index"</span> : &#123; <span class="string">"_index"</span> : <span class="string">"chandler"</span>,<span class="string">"_type"</span>: <span class="string">"test"</span>, <span class="string">"_id"</span> : <span class="string">"1"</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">"name"</span> : <span class="string">"钱丁君"</span>,<span class="string">"age"</span>: <span class="string">"18"</span> &#125;</span><br><span class="line"></span><br><span class="line">$ curl -s -H <span class="string">"Content-Type: application/json"</span> -XPOST localhost:9200/_bulk --data-binary @request</span><br><span class="line">&#123;<span class="string">"took"</span>:214,<span class="string">"errors"</span>:<span class="literal">false</span>,<span class="string">"items"</span>:[&#123;<span class="string">"index"</span>:&#123;<span class="string">"_index"</span>:<span class="string">"chandler"</span>,<span class="string">"_type"</span>:<span class="string">"test"</span>,<span class="string">"_id"</span>:<span class="string">"1"</span>,<span class="string">"_version"</span>:1,<span class="string">"result"</span>:<span class="string">"created"</span>,<span class="string">"_shards"</span>:&#123;<span class="string">"total"</span>:2,<span class="string">"successful"</span>:1,<span class="string">"failed"</span>:0&#125;,<span class="string">"_seq_no"</span>:0,<span class="string">"_primary_term"</span>:1,<span class="string">"status"</span>:201&#125;&#125;]&#125;</span><br><span class="line"></span><br><span class="line">$ curl -XGET localhost:9200/chandler/<span class="built_in">test</span>/1?pretty</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"_index"</span> : <span class="string">"chandler"</span>,</span><br><span class="line">  <span class="string">"_type"</span> : <span class="string">"test"</span>,</span><br><span class="line">  <span class="string">"_id"</span> : <span class="string">"1"</span>,</span><br><span class="line">  <span class="string">"_version"</span> : 1,</span><br><span class="line">  <span class="string">"found"</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"_source"</span> : &#123;</span><br><span class="line">    <span class="string">"name"</span> : <span class="string">"钱丁君"</span>,</span><br><span class="line">    <span class="string">"age"</span> : <span class="string">"18"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Bulk 不支持 <code>Gget</code>操作，因为没什么用处。</p>
<h3 id="优化存储设备"><a href="#优化存储设备" class="headerlink" title="优化存储设备"></a>优化存储设备</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ES</code> 是一种密集使用磁盘的应用，在段合并的时候会频繁操作磁盘，所以对磁盘要求较高，当磁盘速度提升之后，集群的整体性能会大幅度提高。</p>
<p>磁盘的选择，提供以下几点建议：</p>
<ol>
<li>使用固态硬盘<code>（Solid State Disk）</code>替代机械硬盘。<code>SSD</code>与机械磁盘相比，具有高效的读写速度和稳定性。</li>
<li>使用 <code>RAID 0</code>。<code>RAID 0</code>条带化存储，可以提升磁盘读写效率。</li>
<li>在 ES 的服务器上挂载多块硬盘。使用多块硬盘同时进行读写操作提升效率，在配置文件 ES 中设置多个存储路径，如下所示：<br><code>path.data:/path/to/data1,/path/to/data2</code></li>
<li>避免使用 <code>NFS（Network File System）</code>等远程存储设备，网络的延迟对性能的影响是很大的。</li>
</ol>
<h3 id="合理使用合并"><a href="#合理使用合并" class="headerlink" title="合理使用合并"></a>合理使用合并</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Lucene</code> 以段的形式存储数据。当有新的数据写入索引时，<code>Lucene</code> 就会自动创建一个新的段。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随着数据量的变化，段的数量会越来越多，消耗的多文件句柄数及 <code>CPU</code> 就越多，查询效率就会下降。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 <code>Lucene</code>段合并的计算量庞大，会消耗大量的<code>I/O</code>，所以 <code>ES</code>默认采用较保守的策略，让后台定期进行段合并，如下所述：</p>
<ol>
<li><p>索引写入效率下降：当段合并的速度落后于索引写入的速度时，<code>ES</code> 会把索引的线程数量减少到 1。<br>这样可以避免出现堆积的段数量爆发，同时在日志中打印出<code>“now throttling indexing”INFO</code>级别的“警告”信息。</p>
</li>
<li><p>提升段合并速度：ES 默认对段合并的速度是 <code>20m/s</code>，如果使用了 <code>SSD</code>，我们可以通过以下的命令将这个合并的速度增加到<code>100m/s</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /_cluster/settings</span><br><span class="line">&#123;</span><br><span class="line">    &quot;persistent&quot; : &#123;</span><br><span class="line">        &quot;indices.store.throttle.max_bytes_per_sec&quot; : &quot;100mb&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="减少-Refresh-的次数"><a href="#减少-Refresh-的次数" class="headerlink" title="减少 Refresh 的次数"></a>减少 Refresh 的次数</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Lucene</code>在新增数据时，采用了延迟写入的策略，默认情况下索引的<code>refresh_interval</code>为 1 秒。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Lucene</code>将待写入的数据先写到内存中，超过 1 秒（默认）时就会触发一次 Refresh，然后 Refresh 会把内存中的的数据刷新到操作系统的文件缓存系统中。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们对搜索的实效性要求不高，可以将 <code>Refresh</code>周期延长，例如 30 秒。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样还可以有效地减少段刷新次数，但这同时意味着需要消耗更多的Heap内存。如下所示<code>index.refresh_interval:30s</code></p>
<h3 id="加大-Flush-设置"><a href="#加大-Flush-设置" class="headerlink" title="加大 Flush 设置"></a>加大 Flush 设置</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Flush</code>的主要目的是把文件缓存系统中的段持久化到硬盘，当<code>Translog</code> 的数据量达到 512MB 或者 30 分钟时，会触发一次 <code>Flush</code>。</p>
<p><code>index.translog.flush_threshold_size</code> 参数的默认值是 512MB，我们进行修改。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;增加参数值意味着文件缓存系统中可能需要存储更多的数据，所以我们需要为操作系统的文件缓存系统留下足够的空间。</p>
<h3 id="减少副本的数量"><a href="#减少副本的数量" class="headerlink" title="减少副本的数量"></a>减少副本的数量</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ES</code>为了保证集群的可用性，提供了<code>Replicas</code>（副本）支持，然而每个副本也会执行分析、索引及可能的合并过程，所以 <code>Replicas</code>的数量会严重影响写索引的效率。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当写索引时，需要把写入的数据都同步到副本节点，副本节点越多，写索引的效率就越慢。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们需要大批量进行写入操作，可以先禁止 <code>Replica</code>复制，设置 <code>index.number_of_replicas: 0</code>关闭副本。在写入完成后，<code>Replica</code> 修改回正常的状态。</p>
<h2 id="读优化"><a href="#读优化" class="headerlink" title="读优化"></a>读优化</h2><h3 id="避免大结果集和深翻"><a href="#避免大结果集和深翻" class="headerlink" title="避免大结果集和深翻"></a>避免大结果集和深翻</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上一篇讲到了集群中的查询流程，例如，要查询从<code>from</code> 开始的 <code>size</code>条数据，则需要在每个分片中查询打分排名在前面的<code>from+size</code> 条数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;协同节点将收集到的<code>n×(from+size)</code>条数据聚合，再进行一次排序，然后从<code>from+size</code> 开始返回 size 条数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当 <code>from、size 或者 n</code>中有一个值很大的时候，需要参加排序的数量也会增长，这样的查询会消耗很多 CPU 资源，从而导致效率的降低。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了提升查询效率，ES 提供了 <code>Scroll</code>和 <code>Scroll-Scan</code>这两种查询模式。</p>
<p><code>Scroll</code>：是为检索大量的结果而设计的。例如，我们需要查询 1～100 页的数据，每页 100 条数据。</p>
<p>如果使用 <code>Search</code>查询：每次都需要在每个分片上查询得分最高的 <code>from+100</code> 条数据，然后协同节点把收集到的 <code>n×(from+100)</code>条数据聚合起来再进行一次排序。</p>
<p><strong>每次返回 <code>from+1</code>开始的 100 条数据，并且要重复执行 100 次</strong>。</p>
<p>如果使用<code>Scroll</code> 查询：在各个分片上查询 10000 条数据，协同节点聚合<code>n×10000</code>条数据进行合并、排序，并将排名前 10000 的结果快照起来。这样做的好处是减少了查询和排序的次数。</p>
<p><code>Scroll</code>初始查询的命令是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ vim scroll</span><br><span class="line">$ cat scroll</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">        <span class="string">"match"</span>: &#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"钱丁君"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"size"</span>:20</span><br><span class="line">&#125;</span><br><span class="line">$ curl -s -H <span class="string">"Content-Type: application/json; charset=UTF-8"</span> -XGET localhost:9200/chandler/<span class="built_in">test</span>/_search?scroll=2m --data-binary @scroll; <span class="built_in">echo</span></span><br><span class="line">&#123;<span class="string">"_scroll_id"</span>:<span class="string">"DnF1ZXJ5VGhlbkZldGNoBQAAAAAAAAAGFlB6Y3QtNk9oUmdpc09Tb21rX2NXQXcAAAAAAAAABxZQemN0LTZPaFJnaXNPU29ta19jV0F3AAAAAAAAAAgWUHpjdC02T2hSZ2lzT1NvbWtfY1dBdwAAAAAAAAAJFlB6Y3QtNk9oUmdpc09Tb21rX2NXQXcAAAAAAAAAChZQemN0LTZPaFJnaXNPU29ta19jV0F3"</span>,<span class="string">"took"</span>:14,<span class="string">"timed_out"</span>:<span class="literal">false</span>,<span class="string">"_shards"</span>:&#123;<span class="string">"total"</span>:5,<span class="string">"successful"</span>:5,<span class="string">"skipped"</span>:0,<span class="string">"failed"</span>:0&#125;,<span class="string">"hits"</span>:&#123;<span class="string">"total"</span>:1,<span class="string">"max_score"</span>:0.8630463,<span class="string">"hits"</span>:[&#123;<span class="string">"_index"</span>:<span class="string">"chandler"</span>,<span class="string">"_type"</span>:<span class="string">"test"</span>,<span class="string">"_id"</span>:<span class="string">"1"</span>,<span class="string">"_score"</span>:0.8630463,<span class="string">"_source"</span>:&#123; <span class="string">"name"</span> : <span class="string">"钱丁君"</span>,<span class="string">"age"</span>: <span class="string">"18"</span> &#125;&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>以上查询语句的含义是，在 <code>chandler</code>索引的<code>test type</code> 里查询字段<code>name</code>包含“钱丁君”的数据。</p>
<p><strong><code>scroll=2m</code> 表示下次请求的时间不能超过 2 分钟，<code>size</code> 表示这次和后续的每次请求一次返回的数据条数</strong>。</p>
<p>在这次查询的结果中除了返回了查询到的结果，还返回了一个 <code>scroll_id</code>，可以把它作为下次请求的参数。</p>
<p>再次请求的命令，如下所示：</p>
<p>因为这次并没有到分片里查询数据，而是直接在生成的快照里面以游标的形式获取数据。</p>
<p>所以这次查询并没有包含 <code>index 和 type</code>，也没有查询条件：<br><code>&quot;scroll&quot;: &quot;2m&quot;</code>：指本次请求的时间不能超过 2 分钟。<br><code>scroll_id</code>：是上次查询时返回的 scroll_id。</p>
<p><code>Scroll-Scan</code>：<code>Scroll</code>是先做一次初始化搜索把所有符合搜索条件的结果缓存起来生成一个快照，然后持续地、批量地从快照里拉取数据直到没有数据剩下。</p>
<p>而这时对索引数据的插入、删除、更新都不会影响遍历结果，因此 <code>Scroll</code>并不适合用来做实时搜索。</p>
<p>其思路和使用方式与<code>Scroll</code> 非常相似，但是<strong><code>Scroll-Scan</code>关闭了<code>Scroll</code>中最耗时的文本相似度计算和排序，使得性能更加高效</strong>。</p>
<p>为了使用 <code>Scroll-Scan</code>，需要执行一个初始化搜索请求，将 <code>search_type</code>设置成 <code>Scan</code>，告诉 <code>ES</code>集群不需要文本相似计算和排序，只是按照数据在索引中顺序返回结果集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">$ vi scroll</span><br><span class="line">$ cat scroll</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &quot;钱丁君&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;size&quot;:20,</span><br><span class="line">    &quot;sort&quot;: [</span><br><span class="line">      &quot;_doc&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">$ curl -H &quot;Content-Type: application/json; charset=UTF-8&quot; -XGET &apos;localhost:9200/chandler/test/_search?scroll=2m&amp;pretty=true&apos; --data-binary @scroll</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_scroll_id&quot; : &quot;DnF1ZXJ5VGhlbkZldGNoBQAAAAAAAABWFlB6Y3QtNk9oUmdpc09Tb21rX2NXQXcAAAAAAAAAVxZQemN0LTZPaFJnaXNPU29ta19jV0F3AAAAAAAAAFgWUHpjdC02T2hSZ2lzT1NvbWtfY1dBdwAAAAAAAABZFlB6Y3QtNk9oUmdpc09Tb21rX2NXQXcAAAAAAAAAWhZQemN0LTZPaFJnaXNPU29ta19jV0F3&quot;,</span><br><span class="line">  &quot;took&quot; : 3,</span><br><span class="line">  &quot;timed_out&quot; : false,</span><br><span class="line">  &quot;_shards&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 5,</span><br><span class="line">    &quot;successful&quot; : 5,</span><br><span class="line">    &quot;skipped&quot; : 0,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot; : &#123;</span><br><span class="line">    &quot;total&quot; : 1,</span><br><span class="line">    &quot;max_score&quot; : null,</span><br><span class="line">    &quot;hits&quot; : [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;_index&quot; : &quot;chandler&quot;,</span><br><span class="line">        &quot;_type&quot; : &quot;test&quot;,</span><br><span class="line">        &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">        &quot;_score&quot; : null,</span><br><span class="line">        &quot;_source&quot; : &#123;</span><br><span class="line">          &quot;name&quot; : &quot;钱丁君&quot;,</span><br><span class="line">          &quot;age&quot; : &quot;18&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;sort&quot; : [</span><br><span class="line">          0</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<code>Elasticsearch 2.1.0</code>版本之后移除了 <code>search_type=scan</code>，使用<code>&quot;sort&quot;: [ &quot;_doc&quot;]</code>进行代替。</p>
<p><code>Scroll 和 Scroll-Scan</code> 有一些差别，如下所示：<br><code>Scroll-Scan</code>不进行文本相似度计算，不排序，按照索引中的数据顺序返回。<br><code>Scroll-Scan</code> 不支持聚合操作。<br><code>Scroll-Scan</code> 的参数 Size 代表着每个分片上的请求的结果数量，每次返回 <code>n×size</code>条数据。而 <code>Scroll</code>每次返回 size 条数据。</p>
<h3 id="选择合适的路由"><a href="#选择合适的路由" class="headerlink" title="选择合适的路由"></a>选择合适的路由</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ES 中所谓的路由和 IP 网络不同，是一个类似于 Tag 的东西。在创建文档的时候，可以通过字段为文档增加一个路由属性的 Tag。在多分片的 ES 集群中，对搜索的查询大致分为如下两种。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>ES 内在机制决定了拥有相同路由属性的文档，一定会被分配到同一个分片上，无论是主分片还是副本</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查询时可以根据 <code>Routing</code> 信息，<strong>直接定位到目标分片，避免查询所有的分片，再经过协调节点二次排序</strong>。</p>
<p>如图 1 所示：</p>
<p><img src="//blog.com/2019/05/20/Elasticsearch高性能优化实践/微信图片_20190520204941.jpg" alt=""></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果在查询条件中不包含<code>Routing</code>，在查询时就遍历所有分片，整个查询主要分为 <code>Scatter、Gather</code> 两个过程：<br><code>Scatter</code>（分发）：请求到达协调节点之后，协调节点将查询请求分发给每个分片。<br><code>Gather</code>（聚合）：协调点在每个分片上完成搜索，再将搜索到的结果集进行排序，将结果数据返回给用户。</p>
<p>如图 2 所示：</p>
<p><img src="//blog.com/2019/05/20/Elasticsearch高性能优化实践/微信图片_20190520205002.jpg" alt=""></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过对比上述两种查询流程，我们不难发现，使用<code>Routing</code>信息查找的效率很高，<strong>避免了多余的查询</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以我们在设计 <code>Elasticsearch Mapping</code>时要合理地利用 <code>Routing</code>信息，来提升查询的效率。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，在大型的本地分类网站中，可以将城市 ID 作为<code>Routing</code> 的条件，让同一个城市的数据落在相同的分片中。</p>
<p>默认的公式如下：<br><code>shard = hash(routing)%number_of_primary_shards</code></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过需要注意的是，根据城市 ID 进行分片时，也会容易出现分片不均匀的情况。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，大型城市的数据过多，而小城市的数据太少，导致分片之间的数据量差异很大。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时就可以进行必要的调整，比如把多个小城市的数据合并到一个分片上，把大城市的数据按区域进行拆分到不同分配。</p>
<h3 id="SearchType"><a href="#SearchType" class="headerlink" title="SearchType"></a>SearchType</h3><p>在 <code>Scatter、Gather</code>的过程中，节点间的数据传输和打分<code>（SearchType）</code>，可以根据不同的场景选择。</p>
<p>如下所示：</p>
<p><code>QUERY_THEN_FETCH</code>：ES 默认的搜索方式。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第1步，先向所有的分片发请求，各分片只返回文档的相似度得分和文档的 ID，然后协调节点按照各分片返回的分数进行重新排序和排名，再取出需要返回给客户端的 Size 个文档 ID。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第 2 步，在相关的分片中取出文档的详细信息并返回给用户。</p>
<p><code>QUERY_AND_FETCH</code></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;协调节点向所有分片发送查询请求，各分片将文档的相似度得分和文档的详细信息一起返回。然后，协调节点进行重新排序，再取出需要返回给客户端的数据，将其返回给客户端。由于<strong>只需要在分片中查询一次</strong>，所以性能是最好的。（<strong>带来的问题就是在模糊搜索时协调节点和各分片节点之间传输的数据量增大了，大部分数据在协调节点进行聚合是都被废弃了</strong>）</p>
<p><code>DFS_QUERY_THEN_FETCH</code></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与 <code>QUERY_THEN_FETCH</code>类似，但它包含一个额外的阶段：在初始查询中执行全局的词频计算，以使得更精确地打分，从而让查询结果更相关。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>QUERY_THEN_FETCH</code>使用的是分片内部的词频信息，而 <code>DFS_QUERY_THEN_FETCH</code>使用访问公共的词频信息，所以相比 <code>QUERY_THEN_FETCH</code>性能更低。</p>
<p><code>DFS_QUERY_AND_FETCH</code></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与 QUERY_AND_FETCH 类似，不过使用的是全局的词频。</p>
<h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于在 <code>Lucene</code>中段具有不变性，每次进行删除操作后不会立即从硬盘中进行实际的删除，而是产生一个<code>.del</code>文件记录删除动作。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随着删除操作的增长，<code>.del</code>文件会越来也多。<strong>当我们进行查询操作的时候，被删除的数据还会参与检索中，然后根据<code>.del</code> 文件进行过滤。<code>.del</code> 文件越多，查询过滤过程越长，进而影响查询的效率</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当机器空闲时，我们可以通过如下命令删除文件，来提升查询的效率：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -XPOST localhost:9200/chandler/_forcemerge?only_expunge_deletes=<span class="literal">true</span></span><br><span class="line">&#123;<span class="string">"_shards"</span>:&#123;<span class="string">"total"</span>:10,<span class="string">"successful"</span>:5,<span class="string">"failed"</span>:0&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定期对不再更新的索引做<code>optimiz</code>e (<code>ES 2.0</code> 以后更改为<code>Force Merge API</code>)。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这 <code>Optimze</code>的实质是对<code>Segment File</code> 强制做合并，可以节省大量的 <code>Segment Memory</code>。</p>
<h3 id="堆大小的设置"><a href="#堆大小的设置" class="headerlink" title="堆大小的设置"></a>堆大小的设置</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ES 默认安装后设置的内存是 1GB，对于任何一个现实业务来说，这个设置都太小了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果是通过解压安装的 ES，则在 ES 安装文件中包含一个<code>jvm.option</code> 文件，添加如下命令来设置 ES 的堆大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms10g</span><br><span class="line">-Xmx10g</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Xms</code>表示堆的初始大小，<code>Xmx</code>表示可分配的最大内存，都是 10GB。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;确保 <code>Xmx 和 Xms</code>的大小是相同的，其<strong>目的是为了能够在 Java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源，可以减轻伸缩堆大小带来的压力</strong>。 </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也可以通过设置环境变量的方式设置堆的大小。服务进程在启动时候会读取这个变量，并相应的设置堆的大小。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ES_HEAP_SIEZE=10g</span><br></pre></td></tr></table></figure>
<p>也可以通过命令行参数的形式，在程序启动的时候把内存大小传递给 ES，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/elasticsearch -Xmx10g -Xms10g</span><br></pre></td></tr></table></figure>
<p>这种设置方式是一次性的，在每次启动 ES 时都需要添加。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设你有一个 64G 内存的机器，按照正常思维思考，你可能会认为把 64G 内存都给 ES 比较好，但现实是这样吗， 越大越好？虽然内存对 ES 来说是非常重要的，但是答案是否定的！</p>
<p>因为 ES 堆内存的分配需要满足以下两个原则：</p>
<ol>
<li><p><strong>不要超过物理内存的 50%</strong></p>
<p><code>Lucene</code> 的设计目的是把底层 OS 里的数据缓存到内存中。</p>
<p><code>Lucene</code>的段是分别存储到单个文件中的，这些文件都是不会变化的，所以很利于缓存，同时操作系统也会把这些段文件缓存起来，以便更快的访问。</p>
<p>如果我们设置的堆内存过大，<code>Lucene</code> 可用的内存将会减少，就会严重影响降低<code>Lucene</code>的全文本查询性能。</p>
</li>
<li><p><strong>堆内存的大小最好不要超过 32GB</strong></p>
<p>在 Java 中，所有对象都分配在堆上，然后有一个 <code>Klass Pointer</code>指针指向它的类元数据。</p>
<p>这个指针在 64 位的操作系统上为 64 位，64 位的操作系统可以使用更多的内存（<code>2^64</code>）。在 32 位的系统上为 32 位，32 位的操作系统的最大寻址空间为 4GB（<code>2^32</code>）。</p>
<p>但是 64 位的指针意味着更大的浪费，因为你的指针本身大了。浪费内存不算，更糟糕的是，更大的指针在主内存和缓存器（例如 <code>LLC, L1</code>等）之间移动数据的时候，会占用更多的带宽。</p>
</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java 使用内存指针压缩（<code>Compressed Oops</code>）技术来解决这个问题。它的指针不再表示对象在内存中的精确位置，而是表示偏移量。这意味着 32 位的指针可以引用 4GB 个 <code>Byte</code>，而不是 4GB 个 <code>bit</code>。也就是说，当堆内存为 32GB 的物理内存时，也可以用 32 位的指针表示。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，在越过那个神奇的边界 32GB 时，指针就会变为普通对象的指针，每个对象的指针都变长了，就会浪费更多的内存，降低了 CPU 的性能，还要让 GC 应对更大的内存。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事实上，当内存到达 40～40GB 时，有效的内存才相当于内存对象指针压缩技术时的 32GB 内存。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以即便你有足够的内存，也尽量不要超过 32G，比如我们可以设置为 31GB：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms31g</span><br><span class="line">-Xmx31g</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32GB 是 ES 一个内存设置限制，那如果你的机器有很大的内存怎么办呢？现在的机器内存普遍增长，甚至可以看到有 300-500GB 内存的机器。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时我们需要根据业务场景，进行恰当内存的分配：</p>
<p>（1） <strong>业务场景是以全文检索为主</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依然可以给 ES 分配小于 32GB 的堆内存，剩下的交给 Lucene 用作操作系统的文件系统缓存，所有的 Segment 都缓存起来，会加快全文检索。</p>
<p>（2）<strong>业务场景中有很多的排序和聚合</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以考虑一台机器上创建两个或者更多 ES 节点，而不要部署一个使用 32+GB 内存的节点。<br>仍然要坚持 50% 原则，假设你有个机器有 128G 内存，你可以创建两个 Node，使用 32G 内存。也就是说 64G 内存给 ES 的堆内存，剩下的 64G 给 <code>Lucene</code>。</p>
<h3 id="服务器配置的选择"><a href="#服务器配置的选择" class="headerlink" title="服务器配置的选择"></a>服务器配置的选择</h3><blockquote>
<p><code>swappiness</code>的值越大，表示越积极使用<code>swap</code>分区，越小表示越积极使用物理内存</p>
</blockquote>
<p><code>Swapping</code> 是性能的坟墓</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在选择 ES 服务器时，要尽可能地选择与当前应用场景相匹配的服务器。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果服务器配置很低，则意味着需要更多的节点，节点数量的增加会导致集群管理的成本大幅度提高。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果服务器配置很高，而在单机上运行多个节点时，也会增加逻辑的复杂度。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在计算机中运行的程序均需在内存执行，若内存消耗殆尽将导致程序无法进行。为了解决这个问题，操作系统使用一种叫作虚拟内存的技术。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>当内存耗尽时，操作系统就会自动把内存中暂时不使用的数据交换到硬盘中，需要使用的时候再从硬盘交换到内存</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果内存交换到磁盘上需要 10 毫秒，从磁盘交换到内存需要 20 毫秒，那么多的操作时延累加起来，将导致几何级增长。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不难看出 <code>Swapping</code>对于性能是多么可怕。所以为了使<code>ES</code>有更好等性能，强烈建议关闭 <code>Swap</code>。</p>
<p>关闭<code>Swap</code>的方式如下：</p>
<p>① 暂时禁用。如果我们想要在 Linux 服务器上暂时关闭，可以执行如下命令，但在服务器重启后失效：<br><code>sudo swapoff -a</code></p>
<p>② 永久性关闭。我们可以修改 <code>/etc/sysctl.conf</code>（不同的操作系统路径有可能不同），增加如下参数：<br><code>vm.swappiness = 1</code>      //0-100，则表示越倾向于使用虚拟内存。</p>
<p>注意：<code>Swappiness</code> 设置为 1 比设置为 0 要好，因为在一些内核版本，<code>Swappness=0</code>会引发 <code>OOM</code>（内存溢出）。</p>
<p><code>Swappiness</code>默认值为 60，当设置为 0 时，在某些操作系统中有可能会触发系统级的 <code>OOM-killer</code>，例如在 <code>Linux</code>内核的内存不足时，为了防止系统的崩溃，会自动强制 <code>Kill</code>一个<code>“bad”</code>进程。</p>
<p>③ 在 ES 中设置。如果上面的方法都不能做到，你需要打开配置文件中的 <code>mlockall</code>开关，它的作用就是运行 <code>JVM</code>锁住内存，禁止 OS 交换出去。</p>
<p>在<code>elasticsearch.yml</code>配置如下：</p>
<p><code>bootstrap.mlockall: true</code></p>
<h3 id="硬盘的选择和设置"><a href="#硬盘的选择和设置" class="headerlink" title="硬盘的选择和设置"></a>硬盘的选择和设置</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果条件允许，则请<strong>尽可能地使用 <code>SSD</code></strong>，它的读写性能将远远超出任何旋转介质的硬盘（如机械硬盘、磁带等）。基于 <code>SSD</code>的 ES 集群节点对于查询和索引性能都有提升。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外无论是使用固态硬盘还是使用机械硬盘，我们都建议<strong>将磁盘的阵列模式设置为 <code>RAID 0</code>，以此来提升磁盘的写性能</strong>。</p>
<h3 id="接入方式"><a href="#接入方式" class="headerlink" title="接入方式"></a>接入方式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ES 提供了<code>Transport Client</code>（传输客户端）和<code>Node Client</code>（节点客户端）的接入方式，这两种方式各有利弊，分别对应不同的应用场景。</p>
<p>① <code>Transport Client</code>：作为一个集群和应用程序之间的通信层，和集群是安全解耦的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于与集群解耦，所以在连接集群和销毁连接时更加高效，适合大量的客户端连接。</p>
<p>② <code>Node Client</code>：把应用程序当作一个集群中的 <code>Client</code>节点（非 <code>Data</code>和 <code>Master</code>节点）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于它是集群的一个内部节点，意味着它可以感知整个集群的状态、所有节点的分布情况、分片的分布状况等。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 <code>Node Client</code>是集群的一部分，所以在接入和退出集群时进行比较复杂操作，并且还会影响整个集群的状态，所以 <code>Node Client</code> 更适合少量客户端，能够提供更好的执行效率。</p>
<h3 id="角色隔离和脑裂"><a href="#角色隔离和脑裂" class="headerlink" title="角色隔离和脑裂"></a>角色隔离和脑裂</h3><p>① 角色隔离</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ES 集群中的数据节点负责对数据进行增、删、改、查和聚合等操作，所以对 CPU、内存和 I/O 的消耗很大。</p>
<p>在搭建 ES 集群时，我们应该对 ES 集群中的节点进行角色划分和隔离。 </p>
<p>候选主节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node.master=true</span><br><span class="line">node.data=false</span><br></pre></td></tr></table></figure>
<p>数据节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node.master=false</span><br><span class="line">node.data=true</span><br></pre></td></tr></table></figure>
<p>最后形成如图 3 所示的逻辑划分：</p>
<p><img src="//blog.com/2019/05/20/Elasticsearch高性能优化实践/微信图片_20190520211427.jpg" alt=""></p>
<p>② 避免脑裂</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网络异常可能会导致集群中节点划分出多个区域，区域发现没有 <code>Master</code>节点的时候，会选举出了自己区域内 Maste 节点 r，导致一个集群被分裂为多个集群，使集群之间的数据无法同步，我们称这种现象为脑裂。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了防止脑裂，我们需要在 <code>Master</code>节点的配置文件中添加如下参数：<br><code>discovery.zen.minimum_master_nodes=（master_eligible_nodes/2）+1</code>       //默认值为1</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中 <code>master_eligible_nodes</code> 为 <code>Master</code> 集群中的节点数。这样做可以避免脑裂的现象都出现，最大限度地提升集群的高可用性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只要不少于 <code>discovery.zen.minimum_master_nodes</code>个候选节点存活，选举工作就可以顺利进行。</p>
<h2 id="ES-实战"><a href="#ES-实战" class="headerlink" title="ES 实战"></a>ES 实战</h2><h3 id="ES-配置说明"><a href="#ES-配置说明" class="headerlink" title="ES 配置说明"></a>ES 配置说明</h3><p>在 ES 安装目录下的 <code>Conf</code> 文件夹中包含了一个重要的配置文件：<code>elasticsearch.yaml</code>。</p>
<p>下面我们列出一些比较重要的配置信息：</p>
<ul>
<li><p><strong>cluster.name：elasticsearch：</strong>配置 ES 的集群名称，默认值是 ES，建议改成与所存数据相关的名称，ES 会自动发现在同一网段下的集群名称相同的节点。</p>
</li>
<li><p><strong>node.nam： “node1”：</strong>集群中的节点名，在同一个集群中不能重复。节点的名称一旦设置，就不能再改变了。当然，也可以设置成服务器的主机名称，例如 node.name:${HOSTNAME}。</p>
</li>
<li><p><strong>noed.master：true：</strong>指定该节点是否有资格被选举成为 Master 节点，默认是 True，如果被设置为 True，则只是有资格成为 Master 节点，具体能否成为 Master 节点，需要通过选举产生。</p>
</li>
<li><p><strong>node.data：true：</strong>指定该节点是否存储索引数据，默认为 True。数据的增、删、改、查都是在 Data 节点完成的。</p>
</li>
<li><p><strong>index.number_of_shards：5：</strong>设置都索引分片个数，默认是 5 片。也可以在创建索引时设置该值，具体设置为多大都值要根据数据量的大小来定。如果数据量不大，则设置成 1 时效率最高。</p>
</li>
<li><p><strong>index.number_of_replicas：1：</strong>设置默认的索引副本个数，默认为 1 个。副本数越多，集群的可用性越好，但是写索引时需要同步的数据越多。</p>
</li>
<li><p><strong>path.conf：/path/to/conf：</strong>设置配置文件的存储路径，默认是 ES 目录下的 Conf 文件夹。建议使用默认值。</p>
</li>
<li><p><strong>path.data：/path/to/data1,/path/to/data2：</strong>设置索引数据多存储路径，默认是 ES 根目录下的 Data 文件夹。切记不要使用默认值，因为若 ES 进行了升级，则有可能数据全部丢失。</p>
<p>可以用半角逗号隔开设置的多个存储路径，在多硬盘的服务器上设置多个存储路径是很有必要的。</p>
</li>
<li><p><strong>path.logs：/path/to/logs：</strong>设置日志文件的存储路径，默认是 ES 根目录下的 Logs，建议修改到其他地方。</p>
</li>
<li><p><strong>path.plugins：/path/to/plugins：</strong>设置第三方插件的存放路径，默认是 ES 根目录下的 Plugins 文件夹。</p>
</li>
<li><p><strong>bootstrap.mlockall：true：</strong>设置为 True 时可锁住内存。因为当 JVM 开始 Swap 时，ES 的效率会降低，所以要保证它不 Swap。</p>
</li>
<li><p><strong>network.bind_host：192.168.0.1：</strong>设置本节点绑定的 IP 地址，IP 地址类型是 IPv4 或 IPv6，默认为 0.0.0.0。</p>
</li>
<li><p><strong>network.publish_host：192.168.0.1：</strong>设置其他节点和该节点交互的 IP 地址，如果不设置，则会进行自我判断。</p>
</li>
<li><p><strong>network.host：192.168.0.1：</strong>用于同时设置 bind_host 和 publish_host 这两个参数。</p>
</li>
<li><p><strong>http.port：9200：</strong>设置对外服务的 HTTP 端口，默认为 9200。ES 的节点需要配置两个端口号，一个对外提供服务的端口号，一个是集群内部使用的端口号。</p>
<p>http.port 设置的是对外提供服务的端口号。注意，如果在一个服务器上配置多个节点，则切记对端口号进行区分。</p>
</li>
<li><p><strong>transport.tcp.port：9300：</strong>设置集群内部的节点间交互的 TCP 端口，默认是 9300。注意，如果在一个服务器配置多个节点，则切记对端口号进行区分。</p>
</li>
<li><p><strong>transport.tcp.compress：true：</strong>设置在节点间传输数据时是否压缩，默认为 False，不压缩。</p>
</li>
<li><p><strong>discovery.zen.minimum_master_nodes：1：</strong>设置在选举 Master 节点时需要参与的最少的候选主节点数，默认为 1。如果使用默认值，则当网络不稳定时有可能会出现脑裂。</p>
<p>合理的数值为(master_eligible_nodes/2)+1，其中 master_eligible_nodes 表示集群中的候选主节点数。</p>
</li>
<li><p><strong>discovery.zen.ping.timeout：3s：</strong>设置在集群中自动发现其他节点时 Ping 连接的超时时间，默认为 3 秒。</p>
<p>在较差的网络环境下需要设置得大一点，防止因误判该节点的存活状态而导致分片的转移。</p>
</li>
</ul>
<h3 id="常用接口"><a href="#常用接口" class="headerlink" title="常用接口"></a>常用接口</h3><h4 id="索引类"><a href="#索引类" class="headerlink" title="索引类"></a><strong>索引类</strong></h4><p>通过下面的接口创建一个索引名称为<code>indexname</code>且包含 3 个分片、1 个副本的索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT http://localhost:9200/indexname?pretty</span><br><span class="line">content-type →application/json; charset=UTF-8</span><br><span class="line">&#123;</span><br><span class="line">    &quot;settings&quot;:&#123;</span><br><span class="line">        &quot;number_of_shards&quot; : 3,</span><br><span class="line">        &quot;number_of_replicas&quot; : 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="//blog.com/2019/05/20/Elasticsearch高性能优化实践/微信图片_20190520211818.jpg" alt="img"></p>
<p>通过下面都接口删除索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE http://localhost:9200/indexname</span><br></pre></td></tr></table></figure>
<p><img src="//blog.com/2019/05/20/Elasticsearch高性能优化实践/微信图片_20190520211844.jpg" alt="img"></p>
<p>通过该接口就可以删除索引名称为 <code>indexname</code> 的索引，通过下面的接口可以删除多个索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE http://localhost:9200/indexname1,indexname2</span><br><span class="line">DELETE http://localhost:9200/indexname*</span><br></pre></td></tr></table></figure>
<p>通过下面的接口可以删除集群下的全部索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE http://localhost:9200/_all</span><br><span class="line">DELETE http://localhost:9200/*</span><br></pre></td></tr></table></figure>
<p>进行全部索引删除是很危险的，我们可以通过在配置文件中添加下面的配置信息，来关闭使用 _all 和使用通配符删除索引的接口，使用删除索引职能通过索引的全称进行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">action.destructive_requires_name: true</span><br></pre></td></tr></table></figure>
<p>通过下面的接口获取索引的信息，其中，<code>Pretty</code>参数用语格式化输出结构，以便更容易阅读：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http://localhost:9200/indexname?pretty</span><br></pre></td></tr></table></figure>
<p><img src="//blog.com/2019/05/20/Elasticsearch高性能优化实践/微信图片_20190520211909.jpg" alt="img"></p>
<p>通过下面的接口关闭、打开索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST http://localhost:9200/indexname/_close</span><br><span class="line">POST http://localhost:9200/indexname/_open</span><br></pre></td></tr></table></figure>
<p><img src="//blog.com/2019/05/20/Elasticsearch高性能优化实践/微信图片_20190520211932.jpg" alt="img"></p>
<p>通过下面的接口获取一个索引中具体 <code>Type</code> 的<code>Mapping</code>映射：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http://localhost:9200/indexname/typename/_mapping?pretty</span><br></pre></td></tr></table></figure>
<p>当一个索引中有多个 <code>Type</code> 时，获得 <code>Mapping</code>时要加上 <code>Typename</code>。</p>
<h4 id="Document-操作"><a href="#Document-操作" class="headerlink" title="Document 操作"></a><strong>Document 操作</strong></h4><p>安装 <code>ES</code> 和 <code>Kibana</code> 之后，进入<code>Kibana</code>操作页面，然后进去的<code>DevTools</code> 执行下面操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#添加一条document</span><br><span class="line">PUT /test_index/test_type/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;test_content&quot;:&quot;test test&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#查询</span><br><span class="line">GET /test_index/test_type/1</span><br><span class="line"></span><br><span class="line">#返回</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;test_index&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;test_type&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 2,</span><br><span class="line">  &quot;found&quot; : true,</span><br><span class="line">  &quot;_source&quot; : &#123;</span><br><span class="line">    &quot;test_content&quot; : &quot;test test&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="//blog.com/2019/05/20/Elasticsearch高性能优化实践/微信图片_20190520212158.jpg" alt="img"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/MOwlO0INfQpNJe7PBoToRWtNjwytxeibgIDE46VFlUlPt1icOA7KDnvPAWaUt7nkEvDOyMbj261M7pXyQDJ0atkA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p><code>put /index/type/id</code>说明如下：</p>
<ul>
<li><strong>_index 元数据：</strong>代表这个 Document 存放在哪个 Idnex 中，类似的数据放在一个索引，非类似的数据放不同索引，Index 中包含了很多类似的 Document。</li>
<li><strong>_type 元数据：</strong>代表 Document 属于 Index 中的哪个类别(type)，一个索引通常会划分多个 Type，逻辑上对 Index 中有些许不同的几类数据进行分类。</li>
<li><strong>_id 元数据：</strong>代表 Document 的唯一标识，id 与 Index 和 Type 一起，可以唯一标识和定位一个 Document，可以理解为数据库中主键。我们可以指定 Document 的 id，也可以不指定，由ES自动为我们创建一个 id。</li>
</ul>
<h4 id="接口应用"><a href="#接口应用" class="headerlink" title="接口应用"></a>接口应用</h4><h5 id="Search-接口"><a href="#Search-接口" class="headerlink" title="Search 接口"></a><strong>Search 接口</strong></h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Search</code> 是我们最常用的 <code>API</code>，ES 给我提供了丰富的查询条件，比如模糊匹配 <code>Match</code>，字段判空 <code>Exists</code>，精准匹配 <code>Term</code>和<code>Terms</code>，范围匹配<code>Range</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; </span><br><span class="line">    &quot;bool&quot;: &#123; </span><br><span class="line">      &quot;must&quot;: [     //must_not</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;title&quot;:   &quot;Search&quot;        &#125;&#125;, </span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;content&quot;: &quot;Elasticsearch&quot; &#125;&#125;,</span><br><span class="line">        &#123;&quot;exists&quot;:&#123;&quot;field&quot;:&quot;字段名&quot;&#125;&#125;   //判断字段是否为空</span><br><span class="line">      ],</span><br><span class="line">      &quot;filter&quot;: [ </span><br><span class="line">        &#123; &quot;term&quot;:  &#123; &quot;status&quot;: &quot;published&quot; &#125;&#125;,</span><br><span class="line">        &#123; &quot;terms&quot;:  &#123; &quot;status&quot;: [0,1,2,3] &#125;&#125;,//范围</span><br><span class="line">        &#123; &quot;range&quot;: &#123; &quot;publish_date&quot;: &#123; &quot;gte&quot;: &quot;2015-01-01&quot; &#125;&#125;&#125; //范围gte：大于等于；gt：大于；lte：小于等于；lt：小于</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询索引为 <code>test_index</code>，<code>doc</code> 类型为 <code>test_type</code>的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /test_index/test_type/_search</span><br></pre></td></tr></table></figure>
<p><img src="//blog.com/2019/05/20/Elasticsearch高性能优化实践/微信图片_20190520212327.jpg" alt="img"></p>
<p>查询索引为 <code>test_index</code>，<code>doc</code>类型为<code>test_type</code>，<code>docment</code> 字段 <code>num10</code> 为 4 的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /test_index/test_type/_search?pretty=true</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; </span><br><span class="line">    &quot;bool&quot;: &#123; </span><br><span class="line">      &quot;filter&quot;: [ </span><br><span class="line">        &#123; &quot;term&quot;:  &#123; &quot;num10&quot;: 4 &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="//blog.com/2019/05/20/Elasticsearch高性能优化实践/微信图片_20190520212449.jpg" alt="img"></p>
<p>更多查询条件的组合，大家可以自行测试。</p>
<h5 id="修改-Mapping"><a href="#修改-Mapping" class="headerlink" title="修改 Mapping"></a><strong>修改 Mapping</strong></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/_mapping/my_type</span><br><span class="line">&#123;</span><br><span class="line">  &quot;properties&quot;: &#123;</span><br><span class="line">       &quot;new_field_name&quot;: &#123;</span><br><span class="line">           &quot;type&quot;:     &quot;string&quot;         //字段类型，string、long、boolean、ip</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上是修改 <code>Mapping</code> 结构，然后利用脚本 <code>Script</code>给字段赋值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST my_index/_update_by_query</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;lang&quot;: &quot;painless&quot;,</span><br><span class="line">    &quot;inline&quot;: &quot;ctx._source.new_field_name= &apos;02&apos;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="修改别名"><a href="#修改别名" class="headerlink" title="修改别名"></a><strong>修改别名</strong></h5><p>如下给 <code>Index</code>为 <code>test_index</code>的数据绑定 <code>Alia</code>s 为 <code>test_alias</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">  &quot;actions&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;add&quot;: &#123;      //add,remove</span><br><span class="line">        &quot;index&quot;: &quot;test_index&quot;,</span><br><span class="line">        &quot;alias&quot;: &quot;test_alias&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="//blog.com/2019/05/20/Elasticsearch高性能优化实践/微信图片_20190520212616.jpg" alt="img"></p>
<p>验证别名关联，根据别名来进行数据查询，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /test_alias/test_type/3</span><br></pre></td></tr></table></figure>
<p><img src="//blog.com/2019/05/20/Elasticsearch高性能优化实践/微信图片_20190520212620.jpg" alt="img"></p>
<h5 id="定制返回内容"><a href="#定制返回内容" class="headerlink" title="定制返回内容"></a><strong>定制返回内容</strong></h5><p><strong>_source 元数据：</strong>就是说，我们在创建一个 <code>Document</code>的时候，使用的那个放在 <code>Request Body</code>中的 <code>Json</code>串（所有的<code>Field</code>），默认情况下，在 <code>Get</code> 的时候，会原封不动的给我们返回回来。</p>
<p>定制返回的结果，指定<code>_source</code> 中，返回哪些<code>Field</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#语法：</span><br><span class="line">GET /test_index/test_type/1?_source=test_field2</span><br><span class="line">#返回</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;test_index&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;test_type&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 3,</span><br><span class="line">  &quot;found&quot; : true,</span><br><span class="line">  &quot;_source&quot; : &#123;</span><br><span class="line">    &quot;test_field2&quot; : &quot;test field2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#也可返回多个field使用都好分割</span><br><span class="line">GET /test_index/test_type/1?_source=test_field2,test_field1</span><br></pre></td></tr></table></figure>
<p><img src="//blog.com/2019/05/20/Elasticsearch高性能优化实践/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p><img src="//blog.com/2019/05/20/Elasticsearch高性能优化实践/微信图片_20190520212749.jpg" alt="img"></p>
<h4 id="Java-封装"><a href="#Java-封装" class="headerlink" title="Java 封装"></a><strong>Java 封装</strong></h4><p>组件<code>elasticsearch.jar</code> 提供了丰富 <code>API</code>，不过不利于我们理解和学习，现在我们自己来进行封装。 </p>
<p>组件 <code>API</code>使用 <code>RestClient</code> 封装<code>Document</code> 查询接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fields</span></span><br><span class="line"><span class="comment"> *            查询返回字段，可空</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> date 2019年4月3日下午3:12:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">document</span><span class="params">(String index, String type, String id, List&lt;String&gt; fields)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; paramsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    paramsMap.put(<span class="string">"pretty"</span>, <span class="string">"true"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != fields &amp;&amp; fields.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        String fieldValue = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (String field : fields) &#123;</span><br><span class="line">            fieldValue += field + <span class="string">","</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">""</span>.equals(fieldValue)) &#123;</span><br><span class="line">            paramsMap.put(<span class="string">"_source"</span>, fieldValue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CommonUtils.toString(es.getRestClient()</span><br><span class="line">            .performRequest(<span class="string">"GET"</span>, <span class="string">"/"</span> + index + <span class="string">"/"</span> + type + <span class="string">"/"</span> + id, paramsMap).getEntity().getContent());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工程使用，封装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">searchDocument</span><span class="params">(String index, String type, String id, List&lt;String&gt; fields)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> doc.document(index, type, id, fields);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(e.getMessage());</span><br><span class="line">        ExceptionLogger.log(e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"ES查询失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试用例，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ES交互验证-查询、更新等等操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 钱丁君-chandler 2019年4月3日上午10:27:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(classes = Bootstrap.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ESManagerTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ESBasicManager esBasicManager;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = esBasicManager.searchDocument(ESTagMetadata.INDEX_ALIAS, ESTagMetadata.DOC_TYPE,</span><br><span class="line">                <span class="string">"188787665220752824"</span>, ImmutableList.of(<span class="string">"signup_time"</span>, <span class="string">"tag_days_no_visit_after_1_order"</span>));</span><br><span class="line">        System.out.println(<span class="string">"-----------&gt;"</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-----------&gt;&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;crm_tag_idx_20181218_708672&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;crm_tag_type&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;188787665220752824&quot;,</span><br><span class="line">  &quot;_version&quot; : 1,</span><br><span class="line">  &quot;found&quot; : true,</span><br><span class="line">  &quot;_source&quot; : &#123;</span><br><span class="line">    &quot;signup_time&quot; : &quot;2017-12-24&quot;,</span><br><span class="line">    &quot;tag_days_no_visit_after_1_order&quot; : &quot;339&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/20/使用ElasticSearch的44条建议/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/20/使用ElasticSearch的44条建议/" itemprop="url">使用ElasticSearch的44条建议</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-20T12:12:57+08:00">
                2019-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/Elasticsearch/" itemprop="url" rel="index">
                    <span itemprop="name">Elasticsearch</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/Elasticsearch/搜索引擎/" itemprop="url" rel="index">
                    <span itemprop="name">搜索引擎</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/Elasticsearch/搜索引擎/Lucene/" itemprop="url" rel="index">
                    <span itemprop="name">Lucene</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用ElasticSearch的44条建议"><a href="#使用ElasticSearch的44条建议" class="headerlink" title="使用ElasticSearch的44条建议"></a>使用ElasticSearch的44条建议</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s/ER70p1edqkScx_DAMSsuVA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ER70p1edqkScx_DAMSsuVA</a></p>
</blockquote>
<p><br></p>
<p><section style="max-width: 100%;box-sizing: border-box;color: rgb(62, 62, 62);font-size: 16px;white-space: normal;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 10px;padding-left: 10px;max-width: 100%;box-sizing: border-box;line-height: 1.6;word-wrap: break-word !important;"><p>在搜索业务上摸爬滚打3年，使用的Es版本也从1.x升级到了5.x，扮演的角色也逐渐从Es的使用方变为维护方，这里大致汇总了使用Es过程中踩的一些坑以及一些注意事项，也会穿插一下我们的解法。&nbsp;</p></section></section></section></section><section style="max-width: 100%;box-sizing: border-box;color: rgb(62, 62, 62);font-size: 16px;white-space: normal;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;"><br></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;"><br></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;">01</span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section></p><p style="max-width: 100%;min-height: 1em;color: rgb(62, 62, 62);font-size: 16px;white-space: normal;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;">es中建索引是指创建一个保存数据的目录，用于保存倒排索引，索引创建之后是不可变的（Immutable），只允许新增字段。</p><p style="max-width: 100%;min-height: 1em;color: rgb(62, 62, 62);font-size: 16px;white-space: normal;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><span style="font-size: 12px;color: rgb(136, 136, 136);"><em>因为lucene中field是带类型的，不同类型的字段进入倒排索引后会经过压缩，long/int/short占用的字节长度不一，如果修改字段类型，很可能导致从索引文件中解压字段失败，更不要提string=&gt;int之类的变换了；此外</em></span><em style="color: rgb(136, 136, 136);font-size: 12px;">es会将文档id压缩存储（有序列表-&gt;差值形式-&gt;压缩），并通过跳跃表来提高查询性能，</em><em style="color: rgb(136, 136, 136);font-size: 12px;">倒排索引查出term对应的doc_id集合，再用doc_id取field value用于排序或聚合，其实是lucene的实现，所以要变更索引文件代价很大，需要解压=&gt;变更=&gt;压缩，大量的CPU和io操作。</em></p><section style="max-width: 100%;box-sizing: border-box;white-space: normal;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 10px;padding-left: 10px;max-width: 100%;box-sizing: border-box;line-height: 1.6;word-wrap: break-word !important;"><section style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;"><br></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;"><br></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;">02</span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;">es字段是否索引只能在创建索引时配置，不能在字段创建后再给字段“加索引”。</p><p style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><span style="font-size: 12px;color: rgb(136, 136, 136);"><em>lucene的字段有indexed的属性，如果设置false则不会写入倒排索引文件，如果要后期将某个字段改为indexed，相当于把整个索引重建一次，既然索引都要重建，也就没必要提供类似的功能了。</em></span></p><section style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;"><br></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;"><br></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;">03</span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;">索引字段有为“索引（indexed）”和“存储（stored）”两个属性，只有被“索引”的字段才能在查询/排序条件中使用，只有被“存储”的字段才能在请求的时候返回字段内容。</p><p style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><span style="font-size: 12px;color: rgb(136, 136, 136);"><em>同上，另外要说明的是，如果字段没有被设置为stored，则这个文档在update后会丢失该字段，因为Es的update操作其实是从索引文件中取到stored的原始值，合并后index回去，如果没有存储该字段内容，新生成的文档也不会带有该字段，index后原文档被覆盖也就丢失该字段了。</em></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;"><span style="font-size: 12px;color: rgb(136, 136, 136);"></span></p><section style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;"><br></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;"><br></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;">04</span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;">必须保证索引字段都存储（stored）才能使用update操作，update原理是先从索引中get到原文档内容，然后与传入的欲更新字段合并，作为一个新的文档index回去，如果有字段不是stored，那么update之后该字段就丢失了。</p><p style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><span style="font-size: 12px;color: rgb(136, 136, 136);"><em>同03条注释。</em></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;"><span style="font-size: 12px;color: rgb(136, 136, 136);"></span></p><section style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);font-size: 24px;"><br></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);font-size: 24px;"><br></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);font-size: 24px;">05</span><br></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;">为了提升查询性能，索引文件被设计为不可变文件（便于如跳跃表之类的访问性能优化），在生成后不会发生变更，通过Es看到的数据均为某个时刻引擎打开的快照数据，为了能做到反应数据变化，会有刷新时间refresh_interval的概念。</p><p style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><span style="color: rgb(0, 82, 255);">这里会反复提到近实时（NRT）的概念，希望大家在使用过程中一定明确一点，Es不是一个真实时的存储服务，务必不要用在实时业务场景中。</span></p><p style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><span style="font-size: 12px;color: rgb(136, 136, 136);"><em>假定某个时刻为t，t时刻引擎打开的快照数据</em></span><span style="font-size: 12px;color: rgb(136, 136, 136);"><em><span style="font-size: 12px;background-color: rgb(255, 255, 255);">也就是t时刻的全部有效段文件，t时刻之后写入的数据是不可见的，这些数据会生成新的段，在<em style="color: rgb(136, 136, 136);font-size: 12px;white-space: normal;background-color: rgb(255, 255, 255);">t+refresh_interval时刻，Es会</em></span></em></span><span style="font-size: 12px;color: rgb(136, 136, 136);"><em>重新扫描并打开该时刻的全部有效索引文件，以此近实时的反应数据变化。</em></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;"><span style="font-size: 12px;color: rgb(136, 136, 136);"></span></p><section style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;"><br></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;"><br></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;">06</span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;">es还无法做到资源二级调度（共享线程池/缓存区等，无法按索引隔离资源），所以如果集群内某一个索引发生大量慢查询或者污染缓存区（用低复用率内容踢出其他索引高复用率缓存），会导致search线程池满或者引起gc，阻塞集群内其他索引的响应。</p><p style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><span style="font-size: 12px;color: rgb(136, 136, 136);"><em>如题，重要业务最好保障物理隔离。</em></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;"><span style="font-size: 12px;color: rgb(136, 136, 136);"></span></p><section style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;"><br></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;"><br></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;">07</span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;">es每次refresh需要重新打开所有索引文件（需要解压/刷缓存等），如果索引文件较多且更新频繁，每次refresh的开销会比较大，使机器负载升高，影响查询rt，所以更新频繁的大索引设置的刷新时间会限制到5s以上（实时程度下降），要提高实时性，必须减小索引大小。</p><p style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><span style="font-size: 12px;color: rgb(136, 136, 136);"><em>Es默认是1s刷新，如果索引到达千万级别且更新频繁，rt可能会上升到100ms级别，算算qps是不是很虚呢。</em></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;"><span style="font-size: 12px;color: rgb(136, 136, 136);"></span></p><section style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;"><br></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;"><br></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;">08</span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;">es有window size的概念（from+size），每次查询先从每个shard中取window size条数据，然后在集群中某个节点汇聚数据，排序后取size条数据返回，假设有n个shard，有效数据占比＝size / (n * (from+size))，故Es查询时会限制window size，避免产生过多垃圾数据加重gc和IO负担。</p><p style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><span style="font-size: 12px;color: rgb(136, 136, 136);"><em>如题。</em></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;"><span style="font-size: 12px;color: rgb(136, 136, 136);"></span></p><section style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;"><br></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;"><br></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;color: rgb(26, 173, 25);font-size: 24px;word-wrap: break-word !important;">09</span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;">因为索引文件是不可变的，要反应数据的变化需要一次刷新操作来重新扫描并加载新的索引文件，所以任意时刻查询的数据都是t时刻（扫描并加载索引文件的时刻）的快照数据，刷新时间的长短决定了数据的近实时（nrt）程度。</p><p style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><span style="font-size: 12px;color: rgb(136, 136, 136);"><em>原因见第05条，刷新时间默认1s，可以通过settings API动态调整，一般建议5s，Es/Solr都是nrt（近实时）的服务，务必明确，不要当实时存储来用。</em></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;"><span style="font-size: 12px;color: rgb(136, 136, 136);"></span></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color:#1aad19;"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color:#1aad19;"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color:#1aad19;"><span style="font-size: 24px;">10</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;">es有translog，也就是write ahead log，用来保障数据的故障恢复，写操作都必须保证写translog成功，避免服务挂的时候数据丢失。</p><p style="color: rgb(62, 62, 62);font-size: 16px;white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><span style="font-size: 12px;color: rgb(136, 136, 136);"><em>translog其实也不是绝对的靠谱，有async和request两种模式，如果是async模式（Es1.x只有这个模式），会在内存中积累一定大小或到一定时间后触发flush操作来持久化到磁盘，如果掉电还是有丢数据的可能性，得通过主从副本来保障数据的持久化，如果是request模式（Es5.x默认）则要靠谱的多，每次写操作都会将translog落盘，但是很明显会导致磁盘io压力上升，依赖各自的实际业务场景来取舍。</em></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;"><span style="font-size: 12px;color: rgb(136, 136, 136);"></span></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">11</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;">search操作是检索searcher打开的快照数据，所以search是个近实时操作，取决于快照数据的近实时程度；不同于search，es的get操作可以在保证必要条件的情况下做到真实时，可以从translog中提取文档，拿到最新写入的文档数据。</p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><span style="font-size: 12px;color: rgb(136, 136, 136);"><em>其实get也有refresh和realtime的，要真实时必须指定realtime为true（默认），Es会通过检查versionMap（存储两次刷新间隔中写入数据的元信息）中是否有当前文档的_uid来判断是否触发一次刷新操作（Es是通过searcher来get到文档的，translog只是用来取source），refresh参数用来提示get操作前是否一定进行一次刷新操作（可以达到真实时目的，但是不建议开，性能损耗太大，用realtime就可以达到目的了），另外必须指定preference为_primary，否则还是可能会get到旧版本数据，比如写入时没有指</em></span><span style="font-size: 12px;color: rgb(136, 136, 136);"><em>定wait_for_active_shards，默认只要_primary存活即可，且不保证写入到全部副本，如果副本短时上下线就有可能会导致数据延迟。</em></span></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">12</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;">在假设正常情况下并发更新概率很小的前提下，为了性能考虑，es通过乐观锁解决文档并发更新问题，创建文档时如果不设置version，默认初始version=1，之后每次update时version自增；如果要重置version，只能通过index操作并设置force＝true，来强制重置文档version。</p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><span style="font-size: 12px;color: rgb(136, 136, 136);"><em>如题，另外Es6.x开始已经在考虑取消force参数了。</em></span></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">13</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p>es原生不支持在update时设置version（理论上是可以实现的，给开发组提了个issue：<a href="https://github.com/elastic/elasticsearch/issues/25996，但是没通过），实在要做可以在业务程序中一定程度上模拟带version更新操作" target="_blank" rel="noopener">https://github.com/elastic/elasticsearch/issues/25996，但是没通过），实在要做可以在业务程序中一定程度上模拟带version更新操作</a><span style="color: rgb(62, 62, 62);font-size: 16px;">。</span></p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><span style="font-size: 12px;color: rgb(136, 136, 136);"><em>Es的更新操作就是先get到最新文档，然后与传入的文档合并后再index回去，同时标记原文档为deleted，这个过程就可以将自增的版本号设置为外部版本号。</em></span></p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><span style="font-size: 12px;color: rgb(136, 136, 136);"><em>还有要注意的一点是VersionType尽量不要设置为新version&gt;=原version，可能会导致并发更新时的多个请求的数据有一个或多个被覆盖。</em></span></p></section></section></section></section><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">14</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">es1.x版本默认date类型处理会在format parse失败后尝试用long.valueOf来转换，假设字段配置为date类型，format为YYYY-MM-dd HH:mm:ss，那么传入一个”12345”的string类型，es1.x版本是不会报错的，会把”12345”转成long再转成UTC时间；es5.x版本已经修复这个问题<span style="color: rgb(62, 62, 62);font-size: 16px;">。</span></p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">如题。</em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">15</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">es的source是单独作为一个字段存储的，而且是保持传入的样式原样保存，假设字段A类型为long，如果传入的doc={A: “12345”}，即使A为string类型也是可以正确录入的，但是返回的source中字段A还是保持string形式”12345”，不会转换成配置的long类型<span style="color: rgb(62, 62, 62);font-size: 16px;">。</span></p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">Es作为存储来说更像是一个文档数据库，下文有提到。</em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">16</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">es版本执行写请求时，如果源文档设置的version与已存在的文档冲突（默认策略provided version &gt; stored version算成功），会报version conflict异常，即使是在index或者create操作时显式设置version，也有可能会抛出版本冲突异常<span style="color: rgb(62, 62, 62);font-size: 16px;">。</span></p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">如题，除非修改VersionType为gte（设置force=true也行，不建议做，会强行覆盖原数据），否则有并发更新时，如果别的请求先于你的更新，乐观锁检查就会失败。</em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">17</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">update时可以通过设置retry-on-conflict来降低版本冲突异常出现次数，在遇到version冲突时，引擎会根据设置的retry次数（默认是0）来自动重试，如果重试后更新成功则返回成功，当然在极端情况下（重试n次之后依然冲突）还是会抛version conflict异常<span style="color: rgb(62, 62, 62);font-size: 16px;">。</span></p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">注意，设置retryOnConflict请保证此次操作是幂等的，如果不是，还是在业务程序内处理重试吧，比如一个带状态的字段更新，A请求更新为1，B请求更新为2，B先于A更新成功，A报conflict异常，如果设置了重试，最终的更新结果是状态变为1，sad。</em></p><p style="white-space: normal;"><em style="color: rgb(136, 136, 136);font-size: 12px;"></em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">18</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">es的match操作不走缓存，即使索引量较小（几十万文档），一次匹配全文档的match操作（match: {title: xxx}）至少有几十万次计算（与文档数正相关），如果qps很高，同样会因为集群CPU过高而阻塞search线程池，导致集群无响应<span style="color: rgb(62, 62, 62);font-size: 16px;">。</span></p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">如题，match操作每次都会实打实的计算，耗CPU，搜索应用务必保证基础的结果缓存（需要自己实现）可用，减少match请求次数。</em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">19</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">translog有request落盘的方式（每次写数据都会落盘）和async方式（batch，累积一定量数据后落盘），es5.x默认使用的是request方式，也就是优先保障数据不丢；但es1.x只有async方式，以性能优先，每隔一段时间（默认5s）检查是否需要将translog落盘，在机器掉电情况会有数据丢失风险<span style="color: rgb(62, 62, 62);font-size: 16px;">。</span></p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">translog的持久化参数主要有三个：<em style="white-space: normal;color: rgb(136, 136, 136);font-size: 12px;">index.translog.durability控制通过request还是async方式持久化到磁盘，如果通过async方式，</em></em><em style="color: rgb(136, 136, 136);font-size: 12px;">index.translog.flush_threshold_size控制堆积多少数据后触发一次flush操作，index.translog.sync_interval控制间隔多少时间出发一次flush操作。</em></p><p style="white-space: normal;"><em style="color: rgb(136, 136, 136);font-size: 12px;"></em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color:#1aad19;"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color:#1aad19;"><span style="font-size: 24px;">20</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">如果Es应用场景数据更新很频繁，新对象生命周期很短，如果young区分配比较小，可能会造成大量短生命周期的新对象涌入old区，引起full gc导致集群不能正常响应（视old gc的算法而定，如果是g1则full gc会退化成serial gc），需要控制young区在合适的比例，但是也会造成ygc的停顿时间变长，表现为比较明显的rt毛刺<span style="color: rgb(62, 62, 62);font-size: 16px;">。</span></p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">视gc算法而定，g1算法的ygc也会stw，cms算法在heap超过16g情况下表现不是很好。</em></p><p style="white-space: normal;"><em style="color: rgb(136, 136, 136);font-size: 12px;"></em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color:#1aad19;"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color:#1aad19;"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color:#1aad19;"><span style="font-size: 24px;">21</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">操作es常见的三种异常：DocumentAlreadyExists（文档已存在，有并发create操作易发生），VersionConflict（版本冲突，有并发update操作易发生），DocumentMissing（文档不存在，有并发的create／update／delete操作时易发生）<span style="color: rgb(62, 62, 62);font-size: 16px;">。</span></p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">Es5.x取消了<span style="background-color: rgb(255, 255, 255);">DocumentAlreadyExists异常，也将其视为<span style="background-color: rgb(255, 255, 255);">VersionConflict</span></span>。</em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">22</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">should查询子句在query和filter中语义不同，在filter中should条件必须至少满足一个（is or not的问题），在query中如果同时存在must或must_not条件则不要求should条件必须满足一个（how well的问题，should条件满足会提高查询得分_score），如果要求query中should与filter的语义类似，可以设置bool字句中的minimum_should_match参数为1解决<span style="color: rgb(62, 62, 62);font-size: 16px;">。</span></p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">bool query中的should默认不做必须命中要求（只有should条件除外），bool filter中的should必要至少命中其中一个子条件。</em></p><p style="white-space: normal;"><em style="color: rgb(136, 136, 136);font-size: 12px;"></em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">23</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">推荐将不用来计算相似度的字段的norm属性关闭，比如时间/状态等仅用来filter或aggregation的字段，可以减小索引大小，默认会用1 byte/doc来存储字段的norm值，即使某个文档根本没有对应的字段。</p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;"><span style="background-color: rgb(255, 255, 255);">tf/idf是经典的相似度计算模型，<em style="white-space: normal;color: rgb(136, 136, 136);font-size: 12px;"><span style="background-color: rgb(255, 255, 255);">可以用来理解相似度计算，</span></em>一个查询先分解为n个term，计算每个term的tf/idf值（其中就有norm），然后以该值作为空间向量权重，形成n维向量空间，再应用余弦定理计算n维空间内查询词与文档的相似度，得到文档匹配分。</span></em></p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;"><span style="background-color: rgb(255, 255, 255);">Es5.x默认使用bm25作为相似度计算方法了</span>。</em></p><p style="white-space: normal;"><em style="color: rgb(136, 136, 136);font-size: 12px;"></em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">24</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">Es的核心是倒排索引，也就是term -&gt; doc_id的形式，如果是分词字段，索引过程是先分词，然后将分词后的term与文档id结对成为倒排索引文件，假设索引字段为title=“测试商品”，采用bigram的分词方式，那么最终的倒排索引是”测试”=&gt;id / “试商”=&gt;id / “商品”=&gt;id；match查询则是将查询词分词后转为term，再用term去和倒排索引进行”精确”匹配，比如查询”商品”，分词后term=”商品”，和倒排表精确匹配得到doc_id即是查询结果，如果搜索”商”，分词term=”商”，倒排索引中是没有这个term的，因此查询结果为空；搜索引擎的match查询并不等同与mysql的like查询，如果要搜索类似mysql的”商品%”条件，Es的表现是不太好的。</p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">Es没有B树索引，prefix查询是通过状态机实现的。</em></p><p style="white-space: normal;max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><span style="color:#888888;"><span style="font-size: 12px;"><em>match操作能不能搜到结果主要看存储字段分词后的term能不能与查询条件分词后的term匹配上，假设”美观建筑真好看”分词后得到”美观”/“建筑”/“真”/“好看”/“好”，如果用term搜索”真好看”，那么在倒排表中无法找到对应的词条（term不分词），找不到结果；如果用match搜索”真好看”，那么也会被分词为”真”/“好看”/“好”，这时就可以在倒排表中找到对应的词条了；再比如搜索”观建”，假设分词后得到”观”/“建”/“观建”，虽然字段中存在这几个字符，但是倒排表中并没有，所以也找不到结果。</em></span></span></p><p style="white-space: normal;"><em style="color: rgb(136, 136, 136);font-size: 12px;"></em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">25</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">match_phrase匹配比较严格，在全匹配的基础上还要求字符顺序一致，可以有效提高查询准确率，但是为了保证召回率，一般情况下会搭配一个半匹配match使用，例如：”bool”:{“should”:[{“match_phrase”:{“title”:”test”}},{“match”:{“title”:”test”}}]}。</p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">比如”漂亮又美观的建筑”，通过match查询”漂亮 建筑”可以得到结果，但是通过match_phrase查不到，因为”漂亮”和”建筑”之间的position_gap&gt;1，可以通过slop参数控制position_gap的大小。</em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">26</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">使用scan操作时需注意，es1.x版本init scan不会返回hits，只有在next scroll时才会返回，循环调用scan时注意控制条件，第一次应当判断totalHits&gt;0，后续可以用hits.length&gt;0判断。</p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">scan操作只有Es1.x版本支持，Es5.x版本只提供scroll。</em></p><p style="white-space: normal;"><em style="color: rgb(136, 136, 136);font-size: 12px;"></em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">27</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">es1.x版本scroll和scan是不同的操作，在scan时如果设置size＝10，则返回size num_of_shards条数据，假设索引分了5个shard，共返回50条数据，而普通scroll操作时如果设置size＝10，则最多只会返回size条数据，即使索引分了5个shard，也只会返回10条数据，但是普通scroll效率没有scan高；es5.x对默认排序的scroll操作做了定向优化来替换scan，因此只保留了scroll。</p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">按照段内顺序（doc_id）直接出结果，减去聚合排序步骤，但是得到的结果可以被认为是无序的，doc_id按照写入顺序排列。</em></p><p style="white-space: normal;"><em style="color: rgb(136, 136, 136);font-size: 12px;"></em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">28</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">es的数值类型都是带符号的，尽量将数值字段值控制在signed long范围内[-2^63]~[2^63-1]，否则只能用分拆方法或者用string类型来存储，但是会使排序或者范围查询达不到预期效果。<br></p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">对于java不是很熟悉的同学更需注意，不要因为数值范围限制而导致重建索引。</em></p><p style="white-space: normal;"><em style="color: rgb(136, 136, 136);font-size: 12px;"></em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">29</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">索引mapping默认关闭了自动映射功能，写入不在mapping中的字段会抛出异常，原因是自动映射是根据第一次遇到的字段内容来推断类型的，假设字段A是商品名称且事先未配置mapping，那么如果第一个写入es的doc中字段A内容是”12345”，es就会给字段A定义为long类型，就不符合预期了。</p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">推荐将mapping中的dynamic设置为strict，在出现未配置的字段时抛出异常，避免因为字段自动映射错误而导致重建索引（原因见01条）。</em></p><p style="white-space: normal;"><em style="color: rgb(136, 136, 136);font-size: 12px;"></em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color:#1aad19;"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color:#1aad19;"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color:#1aad19;"><span style="font-size: 24px;">30</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">es通过任务队列来削峰限流，默认search queue=1000，index queue=200，如果短时流量过高导致队列溢出，就会抛出EsExecutionReject异常，而任务队列都是全集群共享的（某索引大量占用队列就会导致其他索引占不到资源，而无法响应），如果多索引共享集群，尽量能控制每个索引的写入速率。</p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">如题，另外最好也能控制每个索引的match qps，避免过多match导致CPU资源耗尽。</em></p><p><em style="color: rgb(136, 136, 136);font-size: 12px;"></em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color:#1aad19;"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color:#1aad19;"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color:#1aad19;"><span style="font-size: 24px;">31</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">慢查询比较多的索引也同样会堵塞es的search任务队列（典型的如单一的海量数据索引，短时一个波峰很容易导致es抛Reject异常），因此线上业务最好根据自身应用场景开启索引的慢查询日志。</p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">Es默认的慢查询阈值有点大（秒级），一般偏存储类的应用能接受的rt在200ms以内，线上业务需要做好慢查询优化，比如没有合理使用用filter缓存/terms条件内id过多/多次sort/match长度过长/索引数据量过大等。</em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">32</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">Es的Java API需要通过捕捉运行时异常来处理异常操作。</p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">如题，写业务代码最好加上try catch代码块。</em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">33</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">es的增改删（cud）操作本质都是lucene的index/delete两种操作的组合，update操作就是先取出stored的原文档字段，与本次操作数据合并后重新index回索引，然后delete原文档，也因此写操作index queue其实就包含了所有增改删的任务。</p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">lucene暴露的接口是addDocument/updateDocument，而addDocument接口还是调用updateDocument方法，不要只看名字，其实updateDocument就是先写入新文档（不是partial update），然后标记老文档为deleted状态。</em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">34</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">Es是一个近实时（NRT）的服务，索引的刷新时间（refresh_interval）控制了文档数据的延时程度，如果设置了-1，则新增文档或被更新的文档必须等到索引的translog达到commit条件触发刷新操作后才能可见。</p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">也就是达</em><em style="color: rgb(136, 136, 136);font-size: 12px;">到index.translog.flush_threshold_size配置的大小，进行一次lucene commit操作，生成新段并打开，注意不要混淆索引的flush操作和translog的fsync操作。</em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">35</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">因为lucene在删除文档时只是标记删除，标记删除的doc_id在查询出候选结果时被用来过滤，标记删除的文档只有在merge阶段才会被物理删除，真正释放磁盘空间和机器资源，一般更新比较多的索引残留的deleted docs会比较多（更新就是index＋delete的组合），在实际的搜索过程中，标记删除的索引文档会和普通文档一样会被加载到内存并纳入计算，也会被decode到doc_id，撑大倒排索引，这直接影响到索引的读写性能。</p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;"><span style="background-color: rgb(255, 255, 255);">Es的删除操作（也就是lucene的删除操作）是先标记删除，并单独在一个文件中存放标记删除的doc_id，用于在查询时将删除文档过滤掉；删除的文档只有在段合并（merge）阶段通过重写索引文件才会物理删除</span></em><em style="color: rgb(136, 136, 136);font-size: 12px;">。</em></p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">更新太频繁导致merge跟不上新产生的标记删除文档，可以通过deleted文档比例来判断更新操作是否过于频繁，尽量合并多个字段的更新为一次请求。</em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">36</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">Es带sort的查询需要在倒排索引匹配结束后，拿到索引文档的id_set（此时无序），然后通过id获取对应字段的值（fielddata/doc_value），通过优先级队列或者其他容器来计算顺序，建议能少做sort就少做。</p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">如题，尽量减少带文档字段排序的请求，如果有多个字段排序，避免第一字段值太单一（第一排序相等，降级到第二字段排序来确定文档顺序）</em></p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">另外尽量避免用string/array/nested等高级类型来做排序，string排序是字典序，多值字段排序会有更多运行时计算，会拖慢查询影响时间。</em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">37</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">Es的_score排序表示按照查询匹配分排序，需要注意两点：1. 比如term之类的精确匹配其得分是固定值的；2. 模糊查询match条件返回的得分经过normalize之后也可能会得到相同的得分，得分相同的查询结果会在结果展示上表现出一定的随机性，建议在_score之后加上第二排序条件，在匹配分相同时保证顺序固定，比如：[{“_score”:”desc”},{“_id”:”desc”}]。</p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">如题，另外需要注意的是，如果查询的意图是match，匹配度最高在前，但是又在sort条件中指定了字段排序，比如time:desc，那么得到的结果是满足match匹配度（默认75%）前提下time越新的越前（一般是不满足期望的）。解决方法可以是设置匹配度100%，要求全部文字匹配，或者用上面提到的方法，将_score排序放到第一位。</em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">38</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">close索引的时候最好先把alias去掉，如果一个alias包含多个索引，其中一个索引带着alias被close掉，用这个alias来检索会失败。</p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">Es可以通过一个alias来关联多个真实索引，可以实现比如按天切分的索引当作单一索引使用，但是如果alias包含了closed状态的索引，Es不会跳过这个索引，而是会抛出IndexClosed异常。</em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">39</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">使用了nested字段类型的索引，其创建某个文档，如果其中嵌套了2个子文档，加上父文档，总共会创建2+1个文档。</p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">使用nested字段类型如果嵌套文档过多，会导致索引极速膨胀，影响读写性能，使用嵌套字段务必先了解清楚业务应用场景。</em></p><p><em style="color: rgb(136, 136, 136);font-size: 12px;"></em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color:#1aad19;"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color:#1aad19;"><span style="font-size: 24px;">40</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">lucene 6.x使用有限状态机FSA来提高模糊查询性能（fuzzy/prefix），但是实现有缺陷，使用了递归来判断状态机是否有限状态，如果前缀查询输入了一个长字符串（状态机很大），在调用Operations.isFinite方法时会导致栈溢出StackOverflow异常，使得执行此查询的索引的shard所在进程直接退出，Es6.x版本修复，6以下版本建议限制查询长度及正则查询，同时控制索引shard个数，避免全集群机器全部宕机。</p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">lucene内部用了一个递归操作来判断状态机是否有限，如果是个无限状态机或者状态机很大，递归太深就会导致栈溢出。。sad。</em></p><p><em style="color: rgb(136, 136, 136);font-size: 12px;"></em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color:#1aad19;"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color:#1aad19;"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color:#1aad19;"><span style="font-size: 24px;">41</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">es5.x版本在update时会判断更新前后的值是否有变化，如果欲更新字段的新值与已存在的值一致，那么会跳过实际的写操作直接返回OK，所以如果发现更新返回成功，但是version没有自增，可以检查是否欲更新字段的值与已存在的值相同。</p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">如果发现更新后version没有变化，可以check一下是否此类情况，如有依赖version自增的业务，这点更是务必明确。</em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">42</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;background-color: rgb(255, 255, 255);">Es作为存储更像是个文档数据库，存的是个json，返回的数据格式也是json反序列化时自动推测的，不会按照预置的mapping字段类型返回，Es设置的mapping对存储内容无效，只是在建索引时类型检查/转换用。</p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">Es的_source内部是lucene的一个indexed=false/stored=true的字段，之所以单独存放到一个_source字段，猜想是为了提高存储内容的访问速度，如果是用lucene索引字段的stored内容，取一次source就需要遍历全部fields了。</em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">43</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p><span class="" style="color: rgb(0, 0, 0);">推荐根据字段的取值来设置字段类型，如小于7个枚举值可以用byte，减少索引文件的overhead，也避免在Es中存储大容量字段，即使不用来索引；可以不索引的字段就不索引（indexed: no），可以减小倒排索引文件，提高读写性能</span><span style="background-color: rgb(255, 255, 255);">。</span></p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">lucene生成的索引文件在存储时会根据字段类型占用的字节长度进行补齐，方便跳跃访问，用精确的字段类型可以减少io上的虚耗。</em></p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">Es中存储的大字段也会在段文件中保存（段文件有很多不同用途文件组成），会影响读写性能（merge操作会变多，也变慢，访问频率如果很高也会导致内存中不断生成大对象）</em></p><section style="white-space: normal;max-width: 100%;box-sizing: border-box;background-color: rgb(255, 255, 255);word-wrap: break-word !important;"><section class="" powered-by="xiumi.us" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="max-width: 100%;box-sizing: border-box;word-wrap: break-word !important;"><section class="" style="padding-right: 20px;padding-left: 20px;max-width: 100%;box-sizing: border-box;line-height: 0.8;word-wrap: break-word !important;"><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;"><br></span></span></p><p style="max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="color: rgb(26, 173, 25);"><span style="font-size: 24px;">44</span></span></p><p style="color: rgb(62, 62, 62);font-size: 16px;max-width: 100%;box-sizing: border-box;min-height: 1em;text-align: center;word-wrap: break-word !important;"><span style="max-width: 100%;box-sizing: border-box;letter-spacing: 0px;color: rgb(26, 173, 25);font-size: 20px;word-wrap: break-word !important;">—</span></p></section></section></section></section><p style="white-space: normal;"><span class=""></span></p><p><span class="" style="color: rgb(0, 0, 0);">分词后的字段会变成小粒度的词条，比如”美观的建筑”分词后可能会变成”美观”/“建筑”（视分词算法而定），不会保留原始内容（”美观的建筑”不会进入倒排表），也就无法用term条件来查询了，只能用match</span><span style="background-color: rgb(255, 255, 255);">。</span></p><p style="font-size: 16px;white-space: normal;color: rgb(62, 62, 62);max-width: 100%;min-height: 1em;background-color: rgb(255, 255, 255);box-sizing: border-box !important;word-wrap: break-word !important;"><em style="color: rgb(136, 136, 136);font-size: 12px;">如果需要同时对某个字段进行多种分词（包括不分词），可以通过multi-field来解决。<em style="color: rgb(136, 136, 136);font-size: 12px;">分词问题详见第24条。</em></em></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/20/eBay Elasticsearch性能优化实践/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/20/eBay Elasticsearch性能优化实践/" itemprop="url">eBay Elasticsearch性能优化实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-20T12:12:57+08:00">
                2019-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/Elasticsearch/" itemprop="url" rel="index">
                    <span itemprop="name">Elasticsearch</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/Elasticsearch/搜索引擎/" itemprop="url" rel="index">
                    <span itemprop="name">搜索引擎</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/Elasticsearch/搜索引擎/Lucene/" itemprop="url" rel="index">
                    <span itemprop="name">Lucene</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="eBay-Elasticsearch性能优化实践"><a href="#eBay-Elasticsearch性能优化实践" class="headerlink" title="eBay Elasticsearch性能优化实践"></a>eBay Elasticsearch性能优化实践</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://blog.csdn.net/dev_csdn/article/details/79044930" target="_blank" rel="noopener">https://blog.csdn.net/dev_csdn/article/details/79044930</a></p>
</blockquote>
<p><br></p>
<p><em>摘要：<code>Elasticsearch</code>是基于<code>Apache Lucene</code>的开源搜索和分析引擎，允许用户以近乎实时的方式存储，搜索和分析数据。虽然<code>Elasticsearch</code>专为快速查询而设计，但其性能在很大程度上取决于用于应用程序的场景，索引的数据量以及应用程序和用户查询数据的速率。这篇文章概述了挑战和调优过程，以及Pronto团队以战略方式构建应对挑战的工具。它还以各种图形配置展示了进行基准测试的一些结果。以下是译文。</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Elasticsearch</code>是基于<code>Apache Lucene</code>的开源搜索和分析引擎，允许用户以近乎实时的方式存储，搜索和分析数据。Pronto是在eBay网站上托管<code>Elasticsearch</code>集群的平台，该平台使得eBay网内部客户易于部署，操作用于全文搜索，实时分析和日志/事件监控的大规模的<code>Elasticsearch</code>。当前Pronto平台管理着60多个<code>Elasticsearch</code>集群和2000多个节点，日采集量达到180亿份文档，日均搜索请求达到35亿份。平台提供从条款，补救以及安全到监控，报警和诊断的全方位的信息。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然<code>Elasticsearch</code>专为快速查询而设计，但其性能在很大程度上取决于用于应用程序的场景，索引的数据量以及应用程序和用户查询数据的速率。这篇文章概述了挑战和调优过程，以及Pronto团队以战略方式构建应对挑战的工具。它还以各种图形配置展示了进行基准测试的一些结果。</p>
<h3 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h3><p>迄今为止所观察到的<code>Pronto / Elasticsearch</code>使用案例面临的挑战包括：</p>
<ol>
<li>高吞吐量：一些集群每天摄取高达5TB的数据，一些集群每天的搜索请求超过4亿。如果<code>Elasticsearch</code>无法及时处理这些请求，那么这些请求将在上游累积。</li>
<li>搜索延迟低：对于性能关键的集群，尤其是面向站点的系统，低搜索延迟的特性是必须具有的，否则用户体验将会受到影响。</li>
<li>由于数据或查询是可变的，所以最佳设置总是在变化。所有情况都没有最佳设置。例如，将索引拆分成更多的分片（代表索引分片，<code>Elasticsearch</code>可以把一个完整的索引分成多个分片，这样的好处是可以把一个大的索引拆分成多个，分布到不同的节点上。构成分布式搜索。<strong>分片的数量只能在索引创建前指定，并且索引创建后不能更改</strong>。）对于耗时的查询是很有好处的，但是这可能会损害其它查询性能。</li>
</ol>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了帮助客户应对这些挑战，Pronto团队从用户案例开始入手并持续整个集群生命周期，构建性能测试、调优和监控的战略方法。</p>
<ol>
<li><strong>评估集群大小</strong>：在一个新的用户案例部署之前，收集客户提供的信息，诸如吞吐量，文档大小，文档数量和搜索类型，以评估<code>Elasticsearch</code>集群的初始大小。</li>
<li><strong>优化索引设计</strong>：与客户一起评审索引设计。</li>
<li><strong>调优索引性能</strong>：根据用户场景调优索引性能和搜索性能。</li>
<li><strong>调优搜索性能</strong>：使用用户真实数据/查询运行性能测试，用<code>Elasticsearch</code>配置参数的组合比较和分析测试结果。</li>
<li><strong>运行性能测试</strong>：在案例启动以后，集群将受到监控，每当数据发生变化，查询更改或者流量增加时，用户都可以自由地重新运行性能测试。</li>
</ol>
<h3 id="评估集群大小"><a href="#评估集群大小" class="headerlink" title="评估集群大小"></a>评估集群大小</h3><p>Pronto团队为每种类型的机器和每个支持的<code>Elasticsearch</code>版本运行基准测试，以收集性能数据，然后将其与客户提供的信息一起用于评估集群的初始大小，这些信息包括：</p>
<ul>
<li>索引吞吐量</li>
<li>文档大小</li>
<li>搜索吞吐量</li>
<li>查询类型</li>
<li>热索引文档计数</li>
<li>保留策略</li>
<li>响应时间要求</li>
<li><code>SLA</code>级别</li>
</ul>
<h3 id="优化索引设计"><a href="#优化索引设计" class="headerlink" title="优化索引设计"></a>优化索引设计</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在开始摄取数据并运行查询之前，请三思而后行。索引代表着什么？Elastic的官方回答是“具有相似特征的文档集合”。那么下一个问题是“应该使用哪些特征来对数据进行分组？应该把所有文件放入一个索引还是多个索引呢？”答案是，这取决于所使用的查询。下面是关于如何根据最常用的查询分组索引的一些建议。</p>
<ul>
<li><p><strong>如果查询有一个过滤字段并且它的值是可枚举的，那么把数据分成多个索引。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，有大量的全球产品信息被摄取到<code>Elasticsearch</code>中，大多数查询都有一个过滤子句“region”（区域），并且很少有机会运行跨区域查询。查询主体可以优化为：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">            &quot;must&quot;: &#123;</span><br><span class="line">                &quot;match&quot;: &#123;</span><br><span class="line">                    &quot;title&quot;: &quot;$&#123;title&#125;&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;filter&quot;: &#123;</span><br><span class="line">                &quot;term&quot;: &#123;</span><br><span class="line">                    &quot;region&quot;: &quot;US&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这种情况下，如果索引按照美国，欧洲等地区分成几个较小的索引，就可以获得更好的性能。然后可以从查询中删除过滤子句。如果需要运行一个跨区域查询，可以将多个索引或通配符传递给<code>Elasticsearch</code>。</p>
<ul>
<li><p><strong>如果查询具有过滤字段并且其值不可枚举，请使用路由</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以通过使用过滤字段值作为路由键来将索引拆分成多个分片，然后删除过滤条件。关于<code>ElasticSearch</code>里的路由功能请参见这篇<a href="http://blog.csdn.net/u010454030/article/details/73554652" target="_blank" rel="noopener">文章</a>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，<code>Elasticsearch</code>有数以百万计的订单，大多数查询需要通过买家ID查询订单。为每个买家创建索引是不可能的，所以不能通过买家ID将数据拆分成多个索引。一个合适的解决方案是使用路由将具有相同买家ID的所有订单放入同一个分片中，然后几乎所有的查询都可以在匹配路由键的分片内完成。</p>
</li>
<li><p><strong>如果查询具有日期范围过滤条件，则按日期分组数据</strong>。这适用于大多数日志记录或监控场景。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以以每天，每周或每月分组索引，然后可以在指定的日期范围内获得索引列表。<code>Elasticsearch</code>只需要查询一个较小的数据集而不是整个数据集。此外，当数据过期时，很容易缩小/删除旧的索引。</p>
</li>
<li><p><strong>明确地设置映射</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Elasticsearch</code>可以动态地创建映射，但可能并不适用于所有场景。例如，<code>Elasticsearch5.x</code>中默认的字符串字段映射是“关键字”和“文本”类型，这在很多场景下是没有必要的。</p>
</li>
<li><p><strong>如果文档使用用户定义的ID或路由索引，请避免不平衡分片。</strong> </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code>Elasticsearch</code>采用随机ID生成器和哈希算法来确保文档均匀地分配给分片。当使用用户定义的ID或路由时，ID或路由键可能不够随机，并且一些分片可能明显比其它分片更大。在这种情况下，在这个分片上的读/写操作将比在其它分片上慢得多。可以优化ID /路由键或使用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-routing-field.html#routing-index-partition" target="_blank" rel="noopener">index.routing_partition_size</a> （在5.3和更高版本中可用）。</p>
</li>
<li><p><strong>使分片均匀分布在节点上</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果一个节点比其它节点有更多的分片，则会比其它节点承担更多的负载，并很有可能成为整个系统的瓶颈。</p>
</li>
</ul>
<h3 id="调优索引性能"><a href="#调优索引性能" class="headerlink" title="调优索引性能"></a>调优索引性能</h3><p>用于索引诸如日志和监控之类的重场景，索引性能是关键指标。这里有一些建议：</p>
<ul>
<li><p><strong>使用批量请求</strong>。</p>
</li>
<li><p><strong>使用多个线程/工作来发送请求</strong>。</p>
</li>
<li><p><strong>增加刷新间隔</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次刷新事件发生时，<code>Elasticsearch</code>都会创建一个新的<code>Lucene</code>段，并在稍后进行合并。增加刷新间隔将降低创建/合并的成本。请注意，<strong>只有在刷新事件发生后才能进行文件搜索</strong>。</p>
</li>
</ul>
<p>  <img src="//blog.com/2019/05/20/eBay Elasticsearch性能优化实践/20180111162906901.png" alt="这里写图片描述"></p>
<p>  性能和刷新间隔之间的关系</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上图可以看出，随着刷新间隔的增大，吞吐量增加，响应时间变快。可以使用下面的请求来检查有多少段以及刷新和合并花费了多少时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Index/_stats?filter_path= indices.**.refresh,indices.**.segments,indices.**.merges1</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>减少副本数量</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Elasticsearch需要为每个索引请求将文档写入主要和所有副本分片</strong>。显然，一个大的副本数会减慢索引速度，但另一方面，增加副本数量将提高搜索性能。这个话题将在本文后面讨论。副本的作用一是提高系统的容错性，当某个节点某个分片损坏或丢失时可以从副本中恢复；二是提高<code>Elasticsearch</code>的查询效率，<code>Elasticsearch</code>会自动对搜索请求进行负载均衡 </p>
</li>
</ul>
<p>  <img src="//blog.com/2019/05/20/eBay Elasticsearch性能优化实践/20180111163256760.png" alt="这里写图片描述"></p>
<p>  性能和副本数量之间的关系</p>
<p>从上面的图中，可以看到随着副本数量的增加，吞吐量下降，响应时间也变慢。</p>
<ul>
<li><p><strong>如果可能，使用自动生成的ID</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Elasticsearch</code>自动生成的ID可以确保是唯一的，以避免版本查询</strong>。如果客户真的需要使用自定义的ID，建议选择一个对<code>Lucene</code>友好的ID，比如零填充顺序ID，<code>UUID-1或者Nano time</code>。这些ID具有一致的顺序模式，压缩良好。相比之下，像<code>UUID-4</code>这样的ID本质上仍旧是随机的，它提供了较差的压缩比，并降低了Lucene的速度。</p>
</li>
</ul>
<h3 id="调优搜索性能"><a href="#调优搜索性能" class="headerlink" title="调优搜索性能"></a>调优搜索性能</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用<code>Elasticsearch</code>的主要原因是其支持通过数据进行搜索。用户应该能够快速地找到所需要查找的信息。搜索性能取决于很多因素：</p>
<ul>
<li><p><strong>如果可能的话，使用过滤语境而不是查询语境</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个查询子句用于回答“这个文档如何与查询子句匹配？” ，<strong>过滤子句用于回答“这个文档是否匹配这个过滤子句？”</strong>。<code>Elasticsearch</code>只需要回答“是”或“否”。<strong>它不需要计算过滤子句的相关性得分，并且可以高速缓存过滤结果</strong>。有关详细信息，请参阅<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-filter-context.html" target="_blank" rel="noopener">查询和过滤语境</a>。 </p>
</li>
</ul>
<p>  <img src="//blog.com/2019/05/20/eBay Elasticsearch性能优化实践/20180112141237179.png" alt="这里写图片描述"></p>
<p>比较查询和过滤</p>
<ul>
<li><p><strong>增加刷新间隔</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正如在<a href="https://www.ebayinc.com/stories/blogs/tech/elasticsearch-performance-tuning-practice-at-ebay/#tune_indexing_performance" target="_blank" rel="noopener">调优索引性能</a>部分所提到的，<code>Elasticsearch</code>每次刷新时都会创建一个新的段。增加刷新间隔将有助于减少段数并降低搜索的IO成本。而且一旦发生刷新并且数据改变，缓存将无效。增加刷新间隔可以使<code>Elasticsearch</code>更高效地利用缓存。</p>
</li>
<li><p><strong>增加副本数量</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Elasticsearch可以在主分片或副本分片上执行搜索。拥有的副本越多，搜索中涉及的节点就越多。</p>
</li>
</ul>
<p><img src="//blog.com/2019/05/20/eBay Elasticsearch性能优化实践/20180111164231991.png" alt="这里写图片描述"></p>
<p>性能和副本数量之间的关系</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上图可以看出，搜索吞吐量几乎与副本数量成线性关系。注意在这个测试中，测试集群有足够的数据节点来确保每个分片都有一个独占节点，如果这个条件不能满足，搜索吞吐量就不会那么好。</p>
<ul>
<li><p><strong>尝试不同的分片数量</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“应该为索引设置多少分片？” 这可能是最常见的问题。不幸的是，所有场景都没有标准的数字，这完全取决于当时的实际情况。</p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>太小的分片数量会使搜索无法扩展</strong>。例如，如果分片数量设置为1，则索引中的所有文档都将存储在一个分片中。对于每个搜索，只能涉及一个节点。如果有很多文件，那是很耗费时间的。另一方面，<strong>创建索引的分片太多也会对性能造成危害，因为<code>Elasticsearch</code>需要在所有分片上运行查询，除非在请求中指定了路由键，然后将所有返回的结果一起取出并合并</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据经验来说，如果索引小于1G，可以将分片数设置为1。对于大多数情况，可以将分片数保留为默认值5，但是如果分片大小超过30GB，应该增加分片数量将索引分成更多的分片。创建索引后，分片数量不能更改，但是可以创建新的索引并使用<code>reindex API</code>转移数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里测试了一个拥有1亿个文档，大约150GB的索引，使用了100个线程发送搜索请求。</p>
<p><img src="//blog.com/2019/05/20/eBay Elasticsearch性能优化实践/20180111164303247.png" alt="这里写图片描述"></p>
<p>性能和分片数量之间的关系</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上图中可以看出，优化后的分片数量为11个。开始的时候，搜索吞吐量增加（响应时间减少），但随着分片数量的增加，搜索吞吐量减少（响应时间增加）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，在这个测试中，就像在副本数量测试中一样，每个分片都有一个独占节点。如果这个条件不能满足，搜索吞吐量就不会像上图所示那样好。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这种情况下，建议尝试一个小于优化值的分片数，因为如果使用大分片数，并且使每个分片都有一个独占数据节点，那么就需要很多个节点。</p>
<ul>
<li><p><strong>节点查询缓存</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-cache.html" target="_blank" rel="noopener">节点查询缓存</a>只缓存正在过滤语境中使用的查询。<strong>与查询子句不同，过滤子句是“是”或“否”的问题</strong>。<strong><code>Elasticsearch</code>使用一个位设置机制来缓存过滤结果，以便后面的查询使用相同的过滤条件进行加速</strong>。请注意，只有保存超过10,000个文档的分段（或文档总数的3％，以较大者为准）才能启用节点查询缓存。有关缓存的更多详细信息，请参阅<a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/filter-caching.html#_independent_query_caching" target="_blank" rel="noopener">关于缓存</a>。</p>
</li>
</ul>
<p>可以使用下面的请求来检验一个节点查询缓存是否有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">GET index_name/_stats?filter_path=indices.**.query_cache</span><br><span class="line">&#123;</span><br><span class="line">  &quot;indices&quot;: &#123;</span><br><span class="line">    &quot;index_name&quot;: &#123;</span><br><span class="line">      &quot;primaries&quot;: &#123;</span><br><span class="line">        &quot;query_cache&quot;: &#123;</span><br><span class="line">          &quot;memory_size_in_bytes&quot;: 46004616,</span><br><span class="line">          &quot;total_count&quot;: 1588886,</span><br><span class="line">          &quot;hit_count&quot;: 515001,</span><br><span class="line">          &quot;miss_count&quot;: 1073885,</span><br><span class="line">          &quot;cache_size&quot;: 630,</span><br><span class="line">          &quot;cache_count&quot;: 630,</span><br><span class="line">          &quot;evictions&quot;: 0</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;total&quot;: &#123;</span><br><span class="line">        &quot;query_cache&quot;: &#123;</span><br><span class="line">          &quot;memory_size_in_bytes&quot;: 46004616,</span><br><span class="line">          &quot;total_count&quot;: 1588886,</span><br><span class="line">          &quot;hit_count&quot;: 515001,</span><br><span class="line">          &quot;miss_count&quot;: 1073885,</span><br><span class="line">          &quot;cache_size&quot;: 630,</span><br><span class="line">          &quot;cache_count&quot;: 630,</span><br><span class="line">          &quot;evictions&quot;: 0</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>分片查询缓存</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果大多数查询是聚合查询，应该看看<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/shard-request-cache.html#_cache_invalidation" target="_blank" rel="noopener">分片查询缓存</a>，它可以缓存聚合结果，以便<code>Elasticsearch</code>直接以低成本提供请求。有几件事情需要注意：</p>
<p>o 设置<code>“size”：0</code>。分片查询缓存只缓存聚合结果和建议。它不会缓存操作过程，因此如果将大小设置为非零，则无法从缓存中获益。</p>
<p>o 有效负载JSON必须相同。分片查询缓存使用JSON主体作为缓存键，因此需要确保JSON主体不会更改，并确保JSON主体中的键具有相同的顺序。</p>
<p>o Round日期时间。不要直接在查询中使用像Date.now这样的变量，Round它。否则，每个请求都会有不同的有效负载主体，从而导致缓存始终无效。建议Round日期时间为小时或天，以便更有效地利用缓存。</p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用下面的请求来检验分片查询缓存是否有效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">GET index_name/_stats?filter_path=indices.**.request_cache</span><br><span class="line">&#123;</span><br><span class="line">  &quot;indices&quot;: &#123;</span><br><span class="line">    &quot;index_name&quot;: &#123;</span><br><span class="line">      &quot;primaries&quot;: &#123;</span><br><span class="line">        &quot;request_cache&quot;: &#123;</span><br><span class="line">          &quot;memory_size_in_bytes&quot;: 0,</span><br><span class="line">          &quot;evictions&quot;: 0,</span><br><span class="line">          &quot;hit_count&quot;: 541,</span><br><span class="line">          &quot;miss_count&quot;: 514098</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;total&quot;: &#123;</span><br><span class="line">        &quot;request_cache&quot;: &#123;</span><br><span class="line">          &quot;memory_size_in_bytes&quot;: 0,</span><br><span class="line">          &quot;evictions&quot;: 0,</span><br><span class="line">          &quot;hit_count&quot;: 982,</span><br><span class="line">          &quot;miss_count&quot;: 947321</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>仅检索必要的字段**。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果文档很大，并且只需要几个字段，请使用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-stored-fields.html" target="_blank" rel="noopener">stored_fields</a> 检索所需要的字段而不是所有字段。</p>
</li>
</ul>
<ul>
<li><p><strong>避免搜索停用词</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;诸如“a”和“the”这样的停用词可能导致查询命中结果计数爆炸。设想有一百万个文件，搜索“fox”可能会返回几十个结果，但搜索<code>“the fox”</code>可能会返回索引中的所有文件，因为“the”出现在几乎所有的文件中。<code>Elasticsearch</code>需要对所有命中的结果进行评分和排序，导致像“the fox”这样的查询减慢整个系统。可以使用停止标记过滤来删除停用词，或使用“和”运算符将查询从<code>“the fox”</code>更改为<code>“the AND fox”</code>，以获得更精确的结果。</p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果某些词在索引中经常使用，但不在默认停用词列表中，则可以使用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html#query-dsl-match-query-cutoff" target="_blank" rel="noopener">截止频率</a>来动态处理它们。</p>
<ul>
<li><p><strong>如果不关心文档返回的顺序，则按_doc排序</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Elasticsearch</code>使用“_score”字段按默认分数排序。如果不关心顺序，可以使用<code>“sort”：“_doc”</code>让<code>Elasticsearch</code>按索引顺序返回。</p>
</li>
</ul>
<ul>
<li><p><strong>避免使用脚本查询来计算不固定的匹配</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在索引时存储计算的字段。例如，有一个包含大量用户信息的索引，需要查询以“1234”开头的所有用户。或许想运行一个脚本查询，如<code>“source”：“doc [‘num’].value.startsWith（’1234’）</code>。” 这个查询是非常耗费资源的，并且减慢整个系统。索引时考虑添加一个名为<code>“num_prefix”</code>的字段，然后只需要查询<code>“name_prefix”：“1234”</code>。</p>
</li>
</ul>
<ul>
<li><strong>避免通配符查询</strong>。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/63/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/63/">63</a><span class="page-number current">64</span><a class="page-number" href="/page/65/">65</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/65/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
