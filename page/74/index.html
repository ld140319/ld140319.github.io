<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/page/74/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/page/74/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/16/可视化架构设计——C4介绍/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/16/可视化架构设计——C4介绍/" itemprop="url">可视化架构设计——C4介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-16T12:12:57+08:00">
                2019-05-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/流程图/" itemprop="url" rel="index">
                    <span itemprop="name">流程图</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/流程图/架构图/" itemprop="url" rel="index">
                    <span itemprop="name">架构图</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="可视化架构设计——C4介绍"><a href="#可视化架构设计——C4介绍" class="headerlink" title="可视化架构设计——C4介绍"></a>可视化架构设计——C4介绍</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://www.jianshu.com/p/33c6a7ed126f" target="_blank" rel="noopener">https://www.jianshu.com/p/33c6a7ed126f</a></p>
</blockquote>
<p><br></p>
<h2 id="由来介绍"><a href="#由来介绍" class="headerlink" title="由来介绍"></a>由来介绍</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好多年前，同事徐昊说过的一句话给了我很大启发，他说“<strong>纸上的不是架构，每个人脑子里的才是</strong>”。这句话告诉我们，即便是天天工作在一个团队里的人，对架构的认识也可能是不一样的。每个人嘴上说的是类似的话，但心里想象的画面仍然是不一样的。在多年的工作中，我越来越认可这句话所揭示出的道理。软件开发是一个团队协作的工作，<strong>混乱的理解会造成架构的无意义腐化、技术债的无意识积累、维护成本的无价值上升</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近听到一句话，“<strong>那些精妙的方案之所以落不了地，是因为没有在设计上兼容人类的愚蠢</strong>”。话糙理不糙，虽然最终人们选择的方案的思想都是在十年前甚至几十年前就已经存在的，然而在技术升级到足以“兼容”人类的愚蠢之前，这些思想只能在学术的故纸堆里睡大觉。当然话糙确实也会有一个问题，将一个思想性问题转化成了情绪性问题。人们容易把一些糟心的事情归因到人类的愚蠢，在宣泄完不满情绪后就停止思考了。作为知识工作者，我们的思维不能停步，我们需要思考到底人类有哪些愚蠢，分别用什么方法去避免或者“兼容”。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以肯定彼此明明对自己开发的软件有不一样的认识却天天在一起讨论问题并试图把软件做好是一件愚蠢的事情，为了兼容这种愚蠢我们需要采用可视化的方法。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么需要可视化呢，主要还是语言不靠谱。人类语言真的是太随意了，只要你想，你可以说你见过一个方形的圆，并为此与别人辩论。但是无论如何你也画不出来一个方形的圆，这就是我们需要可视化的原因。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;今天我们介绍一个工具，叫做<a href="https://c4model.com/" target="_blank" rel="noopener">C4 model</a>，这是我近几年见到的一个比较难得跟我的认知有大量共鸣的工具。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该工具的作者在多年的咨询中经常发现，很多个人画出来的架构图都是不一样的，但也不是说谁画错了，而是每个人的抽象层次不一样。抽象层次这种东西，说起来好像存在，但真要说清楚还挺难，于是作者类比地图，提出了缩放的概念。（两年前我在教学生的时候提过同样的概念）如下图：</p>
<p><img src="//blog.com/2019/05/16/可视化架构设计——C4介绍/2267652-9879b37c3e31b481.webp" alt="img"></p>
<p>上面的四张地图就是想说明，当我们看待真实世界的“架构图”时候，也是要不停的缩放，<strong>在每一个层次刻意忽略一些细节才能表达好当前抽象层次的信息</strong>。所以他类比着把架构也提出了四个抽象层次：</p>
<p><img src="//blog.com/2019/05/16/可视化架构设计——C4介绍/2267652-1e23ea279479c978.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上到下依次是系统<code>System</code>、容器<code>Container</code>、组件<code>Component</code>和代码<code>Code</code>。（咦，那为什么叫<code>C4</code>呢，因为系统的图叫<code>System Context</code>，系统上下文图。为了凑四个<code>C</code>也是够拼的。）</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于这四个层次的抽象，<code>C4</code>模型由4张核心图和3张附属图组成，分别用于描述不同的场景，下面我们一一介绍一下。</p>
<h2 id="四张核心图"><a href="#四张核心图" class="headerlink" title="四张核心图"></a>四张核心图</h2><h3 id="系统上下文图"><a href="#系统上下文图" class="headerlink" title="系统上下文图"></a>系统上下文图</h3><p><img src="//blog.com/2019/05/16/可视化架构设计——C4介绍/2267652-0bcfd7966a6c9047.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上图所示，这个图表达的是<strong>你所开发的系统和它的用户以及它所依赖的系统之间的关系</strong>。从这个图上我们已经看出来<code>C4</code>图形的几个关键图形：</p>
<p><img src="//blog.com/2019/05/16/可视化架构设计——C4介绍/2267652-6dfe8618d2cede6e.webp" alt="img"></p>
<p><code>C4</code>说穿了就是几个要素：</p>
<blockquote>
<p><strong>关系——带箭头的线</strong></p>
<p><strong>元素——方块和角色</strong></p>
<p><strong>关系描述——线上的文字</strong></p>
<p><strong>元素的描述——方块和角色里的文字</strong></p>
<p><strong>元素的标记——方块和角色的颜色、虚线框</strong></p>
<p><strong>虚线框——系统和用户的边界</strong></p>
<p><strong>蓝色——需要聚焦的系统</strong> </p>
<p><strong>灰色——直接依赖的系统</strong></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过在不同的抽象层次上，重新定义方块和虚线框的含义来将我们的表达限制在一个抽象层次上，从而避免在表达的时候产生抽象层次混乱的问题。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么在系统上下文图里，<strong>方块指代的是软件系统，蓝色表示我们聚焦的系统，也就是我开发的系统</strong>（也可能是我分析的系统，取决于我是谁），<strong>灰色表示我们直接依赖的系统，虚线框表示的是企业的边界</strong>。通过这些图形化的元素表达我们可以看出来各个系统彼此之间的关系。</p>
<h3 id="容器图"><a href="#容器图" class="headerlink" title="容器图"></a>容器图</h3><p><img src="//blog.com/2019/05/16/可视化架构设计——C4介绍/2267652-85d796b76018043c.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们放大一个系统，就会看到容器，如上图所示，<strong><code>C4</code>模型认为系统是由容器组成的</strong>。我个人认为，容器是<code>C4</code>模型最大的创举，尤其是在这个单体架构快速崩塌的时代。所谓容器，既不是<code>Docker</code>的容器，也不是<code>JavaEE</code>里的容器，而是借用了进程模型，代指有自己独立进程空间的一种存在。不管是在服务器上的单独进程空间，还是在浏览器里的单独进程空间，只要是单独的进程空间就可以看作一个容器。当然如果你容器化做得好，<code>Docker</code>的<code>Container</code>和这个<code>Container</code>可以一一对应。有了这个概念的存在我们就可以更清晰的去表达我们的架构，而不是总是用一些模糊的东西。组件图</p>
<h3 id="组件图"><a href="#组件图" class="headerlink" title="组件图"></a>组件图</h3><p><img src="//blog.com/2019/05/16/可视化架构设计——C4介绍/2267652-191674381b0f4990.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们放大一个容器，我们就会看到组件，如上图所示。组件在这里面很好的把接口和它的实现类打包成一个概念来表达关系。我个人觉得有时候一些存在于代码中，但又不是接口的某些东西，比如<code>Service</code>、<code>Controller</code>、<code>Repository</code>之类也可以用组件图来表达，如果你学了一些没有明确抽象层次的架构知识或者一些单体时代的遗留经验的时候，你可以画出来一些组件图，来印证自己的理解，如下图，是我画的自己对<code>DDD</code>战术设计里面的一些概念的理解：</p>
<p><img src="//blog.com/2019/05/16/可视化架构设计——C4介绍/2267652-cf543f90cd8e15ca.webp" alt="img"></p>
<p>比起模糊的堆砌在一起的文字，这种表达要清晰的很多，哪怕我的理解是不对的，也容易指出和讨论。</p>
<h3 id="代码图"><a href="#代码图" class="headerlink" title="代码图"></a>代码图</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;代码图没什么可说的，就是<code>UML</code>里的类图之类很细节的图。一般是不画的，都是代码生成出来。除非非常重要的且还没有写出代码的组件才画代码图。</p>
<h2 id="三张扩展图"><a href="#三张扩展图" class="headerlink" title="三张扩展图"></a>三张扩展图</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;架构设计设计要考虑的维度很多，仅四张核心图是不够的，所以作者又提供了三张扩展图，可以让我们关注更多的维度。</p>
<h3 id="系统景观图"><a href="#系统景观图" class="headerlink" title="系统景观图"></a>系统景观图</h3><p><img src="//blog.com/2019/05/16/可视化架构设计——C4介绍/2267652-750f563ef80cbbf2.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看得出来，系统景观图是比上下文图更丰富的系统级别的表达。<strong>不像上下文图只关注聚焦系统和它的直接关系，连一些间接相关的系统都会标示出来，那些系统的用户以及用户之间的关系也会标示出来，只是内部的用户会用灰色标记</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个图有什么用呢？在我们分析一个企业的时候，我们需要一个工具帮助我们把一家公司给挖个底掉，做到完全穷尽，才能看到企业的全景图，从而理解局部的正确定位以做好局部设计为全局优化服务。之前我试过以四色建模的红卡、事件风暴的事件两种工具来教人掌握这种能力，一般来说，程序员学员都无法快速掌握这种顺藤摸瓜的分析技巧，毕竟跟程序员的思维还是有些差异的。但是用了系统景观图之后，学员就毫不费力的掌握了这种分析能力，所以我后来都是用这个图来教程序员探索企业的数字化全景图，效果极好，推荐给大家。</p>
<h3 id="动态图"><a href="#动态图" class="headerlink" title="动态图"></a>动态图</h3><p><img src="//blog.com/2019/05/16/可视化架构设计——C4介绍/2267652-4c725707626f1293.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;动态图不同于其他表达静态关系的图，它是用来<strong>表达动态关系的，也就是不同的元素之间是如何调用来完成一个业务的</strong>。所以<strong>动态图不仅仅适用于一个层面上，它在系统级、容器级和组件级都可以画，表达的目标是不一样的</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我之前曾经写过名为《像机器一样思考》的一系列文章，在文中也发明了类似的图，不同于本文中关系线上标注的是调用的方法、函数，我更关注的是数据，使用效果也很好。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;什么时候用动态图呢？举个小例子，我之前做一个内部的小系统，团队中只有一个有经验的工程师带着十多个毕业生，我便要求他们在开始工作之前都画出动态图来，交由有经验的工程师去评估他们的思路是否正确，如果有问题，就在开始之前就扼杀掉烂设计。不管是毕业生还是初级工程师，改代码的能力都比写代码的能力要差很多，所以将烂设计扼杀在实现之前还是有帮助的。</p>
<h3 id="部署图"><a href="#部署图" class="headerlink" title="部署图"></a>部署图</h3><p><img src="//blog.com/2019/05/16/可视化架构设计——C4介绍/2267652-6eae7365fe8aa413.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面的几张图都是站在开发的角度思考，但是一个没有充分思考过部署的架构很容易变成一个运维的灾难。所以作者提供了一个部署图。考虑到<code>DevOps</code>运动如火如荼，这个图可以变成很好的<code>Dev</code>和<code>Ops</code>之间沟通的桥梁。我们在实操中发现，<code>Dev</code>和<code>Ops</code>关注点的不同、语言的不一致，在这张图上表现得非常清楚。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;图上最大的的实线框不同于虚线框，它表达的是数据中心，当你开始考虑异地载备的时候它就有了意义。数据的同步、实例的数量都会影响部署图的内容。<strong>部署图基本都是容器级的，它能很好的表达出来容器到底部署了几个实例，部署在什么样的操作系统上，一个节点部署了几个容器之类</strong>，我们在实际使用中，发现需要考虑的信息太多，自己就抽象出了类似于亚马逊上实例规格的<code>Small、Large</code>之类的术语来表达机器配置，增进了开发和运维之间的交流准确性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/16/用于软件架构的C4模型/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/16/用于软件架构的C4模型/" itemprop="url">用于软件架构的C4模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-16T12:12:57+08:00">
                2019-05-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/流程图/" itemprop="url" rel="index">
                    <span itemprop="name">流程图</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/流程图/架构图/" itemprop="url" rel="index">
                    <span itemprop="name">架构图</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="用于软件架构的C4模型"><a href="#用于软件架构的C4模型" class="headerlink" title="用于软件架构的C4模型"></a>用于软件架构的C4模型</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://www.infoq.cn/article/C4-architecture-model" target="_blank" rel="noopener">https://www.infoq.cn/article/C4-architecture-model</a></p>
</blockquote>
<p><br></p>
<blockquote>
<h2 id="关键要点"><a href="#关键要点" class="headerlink" title="关键要点"></a>关键要点</h2><ul>
<li>由于向敏捷转型，软件架构图的使用规模已经大幅缩减。即使有在使用软件架构图，它们往往也混淆不清。</li>
<li>C4 模型由一系列分层的软件架构图组成，这些架构图用于描述上下文、容器、组件和代码。C4 图的层次结构提供了不同的抽象级别，每种抽象级别都与不同的受众有关。</li>
<li>为了避免出现含糊不清的情况，可以在图中包含足够数量的文本和关键的图例。</li>
</ul>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;软件架构图是一种非常好的表达方式，可以用它们来表达你将如何构建一个软件系统（预先设计）或者现有的软件系统是如何工作的（回顾文档、知识分享和学习）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然而，你所看到的大多数软件架构图很可能只是由混乱的框和线组成。<a href="http://agilemanifesto.org/" target="_blank" rel="noopener">敏捷软件开发宣言</a>的一个副作用就是让很多团队停止或缩减了他们的图表和文档工作，包括使用 UML。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在，这些团队倾向于依靠他们在白板上绘制的临时图表，或者使用通用的图表工具（如微软的 <code>Visio</code>）。<code>Ionut Balosin</code>在去年写了一篇叫作“<a href="http://www.infoq.com/cn/articles/crafting-architectural-diagrams" target="_blank" rel="noopener">软件架构图的艺术</a>”的文章，他在文章中描述了一些常见问题，这些问题<strong>与不可理解的符号和不明确的语义有关</strong>。</p>
<p>﻿<img src="//blog.com/2019/05/16/用于软件架构的C4模型/c77b430c1243a7c83a485b228222140b.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;含糊不清的软件架构图容易导致误解，这可能会拖慢一个优秀团队的前进步伐。在我们的行业中，我们真的应该努力创建出更好的软件架构图。多年来，我自己参与软件开发，并与世界各地的团队合作，基于这些经验，我建立了一个称之为“C4 模型”的东西。C4 代表<strong>上下文（Context）、容器（Container）、组件（Component）</strong>和<strong>代码（Code）</strong>——一系列分层的图表，可以用这些图表来描述不同缩放级别的软件架构，每种图表都适用于不同的受众。可以将其视为代码的谷歌地图。</p>
<p>﻿<img src="//blog.com/2019/05/16/用于软件架构的C4模型/a7d7cd3b84b2d5284869274e64082ffb.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要为你的代码创建地图，首先需要一组通用的抽象来创建一种无处不在的语言，用来描述软件系统的静态结构。<code>C4</code>模型使用<strong>容器</strong>（应用程序、数据存储、微服务等）、<strong>组件</strong>和<strong>代码</strong>来描述一个软件系统的静态结构。它还考虑到使用软件系统的人。</p>
<p>﻿<img src="//blog.com/2019/05/16/用于软件架构的C4模型/cddcb6fe112e169d679be355d6fb31d4.jpg" alt="img"></p>
<h2 id="第-1-层：系统上下文"><a href="#第-1-层：系统上下文" class="headerlink" title="第 1 层：系统上下文"></a>第 1 层：系统上下文</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第 1 层是系统上下文图，它显示了你正在构建的软件系统，以及系统与用户及其他软件系统之间的关系。以下是一个系统上下文图的示例，描述了一个互联网银行系统的系统上下文：</p>
<p>﻿<img src="//blog.com/2019/05/16/用于软件架构的C4模型/01cb5819b9f80163ee0de4285741fa2b.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;银行的个人客户使用互联网银行系统查看有关银行账户的信息并进行支付。互联网银行系统使用银行现有的大型机银行系统来执行此操作，并使用银行现有的电子邮件系统向客户发送电子邮件。<strong>图中的颜色表示哪些软件系统已经存在（灰色）以及待构建的系统（蓝色）</strong>。</p>
<h2 id="第-2-层：容器"><a href="#第-2-层：容器" class="headerlink" title="第 2 层：容器"></a>第 2 层：容器</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第 2 层是一个容器图，将软件系统放大，显示组成该软件系统的容器（<strong>应用程序、数据存储、微服务</strong>等）。技术决策也是该图的关键部分。以下是互联网银行系统的容器图示例。它显示了互联网银行系统（虚线框）由五个容器组成：服务器端 <code>Web</code> 应用程序、客户端单页面应用程序、移动应用程序、服务器端<code>API</code> 应用程序和数据库。</p>
<p>﻿<img src="//blog.com/2019/05/16/用于软件架构的C4模型/ff26aa85f64c7605a66798506feaf3ea.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Web</code> 应用程序是一个<code>Java/Spring MVC Web</code>应用程序，它仅提供静态内容（<code>HTML、CSS</code>和 <code>JavaScript</code>），包括组成单页应用程序的内容。单页面应用程序是一个运行在客户网络浏览器中的 <code>Angular</code>应用程序，提供所有的网上银行功能。或者，客户可以使用跨平台<code>Xamarin</code>移动应用程序访问互联网银行的部分功能。单页应用程序和移动应用程序都调用<code>JSON/HTTPS API</code>，这是由服务器端运行的另一个<code>Java/Spring MVC</code> 应用程序提供的。<code>API</code> 应用程序从数据库中获取用户信息（关系数据库模式）。<code>API</code> 应用程序还使用专有的<code>XML/HTTPS</code>接口与现有的大型机银行系统进行通信，以获取有关银行账户或交易的信息。如果需要向客户发送电子邮件，API 应用程序还会调用现有的电子邮件系统。</p>
<h2 id="第-3-层：组件"><a href="#第-3-层：组件" class="headerlink" title="第 3 层：组件"></a>第 3 层：组件</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第 3 层是组件图，<strong>将单个容器放大，以显示其中的组件。这些组件映射到代码库中的真实抽象</strong>（例如一组代码）。下面是一个虚拟的网上银行系统的组件图示例，显示了<code>API</code>应用程序中的一些组件（而不是全部）。</p>
<p>﻿<img src="//blog.com/2019/05/16/用于软件架构的C4模型/7305c5739d2caff49f5452dd040efedd.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两个 <code>Spring MVC REST</code>控制器为<code>JSON/HTTPS API</code>提供访问点，每个控制器随后使用其他组件访问数据库和大型机银行系统中的数据。</p>
<h2 id="第-4-层：代码"><a href="#第-4-层：代码" class="headerlink" title="第 4 层：代码"></a>第 4 层：代码</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，如果你确实想要，或者说有这个必要，可以<strong>放大个别组件，以显示该组件的实现方式</strong>。以下是一个虚拟的网上银行系统的 <code>UML</code> 类图示例（部分），显示了组成 <code>MainframeBankingSystemFacade</code> 组件的代码元素（接口和类）。</p>
<p>﻿<img src="//blog.com/2019/05/16/用于软件架构的C4模型/c0bba922b79ef285be48c08681047b42.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它表明该组件由很多类组成，实现细节直接反映了代码。我并不建议创建在这种详细程度的图表，有时候你可以直接从大多数 <code>IDE</code>中获取它们。</p>
<h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>C4</code>模型没有预定义任何特定的符号，你在这些示例图中看到的是一个个简单的符号，适用于白板、纸张、便签、索引卡片和各种图表工具。你也可以使用 <code>UML</code>作为符号，并适当使用包、组件和原型。无论你使用哪种符号，我都会建议<strong>让每个元素都包含名称、元素类型（即“人”、“软件系统”，“容器”或“组件”）、技术选型（如果有的话），以及一些描述性文字</strong>。在图表中包含如此多的文本可能看起来很不寻常，但这些附加文本有助于消除软件架构图中通常会出现的不明确的表示。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使符号对你来说是显而易见的，仍然要确保为这些符号提供图例。<strong>图例中应该包括颜色、形状、首字母缩略词、线条样式、边框、尺寸等</strong>。<strong>理想情况下，符号应该在每个细节层次上保持一致</strong>。下面是前面显示的容器图的图例。</p>
<p>﻿<img src="//blog.com/2019/05/16/用于软件架构的C4模型/dea25c68d4875a860b81efd1833245cc.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，<strong>不要忘记了标题，它应该出现在每个图表上，以明确地描述每个图表的类型和范围</strong>（例如，“网上银行系统的系统上下文图表”）。</p>
<h2 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>C4</code> 模型是一种在不同抽象层次上交流软件架构的简单方法，可以向不同的受众讲述不同的故事。这也是向软件开发团队介绍（通常是重新引入）严谨和轻量级建模的一种方式。有关 <code>C4</code>模型的更多信息，以及补充图（运行时和部署）的示例、符号清单、常见问题解答、会议讲座视频和工具选项，请参阅<a href="http://c4model.com/" target="_blank" rel="noopener">c4model.com</a>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/15/Golang中的三个点 '...' 的用法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/15/Golang中的三个点 '...' 的用法/" itemprop="url">Golang中的三个点 '...' 的用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-15T12:12:57+08:00">
                2019-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Golang中的三个点-‘…’-的用法"><a href="#Golang中的三个点-‘…’-的用法" class="headerlink" title="Golang中的三个点 ‘…’ 的用法"></a>Golang中的三个点 ‘…’ 的用法</h1><p><br></p>
<blockquote>
<p> 原文地址：<a href="https://blog.csdn.net/jeffrey11223/article/details/79166724" target="_blank" rel="noopener">https://blog.csdn.net/jeffrey11223/article/details/79166724</a></p>
</blockquote>
<p><br></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>‘…’</code>其实是go的一种语法糖。 它的第一个用法主要是用于函数有多个不定参数的情况，可以接受多个不确定数量的参数。 第二个用法是slice可以被打散进行传递。</p>
<h2 id="不定参数传递"><a href="#不定参数传递" class="headerlink" title="不定参数传递"></a>不定参数传递</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">(args ...<span class="keyword">string</span>)</span></span> &#123; <span class="comment">//可以接受任意个string参数</span></span><br><span class="line">	<span class="keyword">for</span> _, v:= <span class="keyword">range</span> args&#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> str_slice= []<span class="keyword">string</span>&#123;</span><br><span class="line">		<span class="string">"lzm"</span>,</span><br><span class="line">		<span class="string">"ly"</span>,</span><br><span class="line">		<span class="string">"dqq"</span>,</span><br><span class="line">		<span class="string">"lq"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	display(str_slice...) <span class="comment">//切片被打散传入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">lzm</span></span><br><span class="line"><span class="comment">ly</span></span><br><span class="line"><span class="comment">dqq</span></span><br><span class="line"><span class="comment">lq</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">liuzeming</span></span><br><span class="line"><span class="comment">dengqinqin</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<h2 id="slice被打散进行传递"><a href="#slice被打散进行传递" class="headerlink" title="slice被打散进行传递"></a>slice被打散进行传递</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> name_slice1 = []<span class="keyword">string</span>&#123;<span class="string">"liuzeming"</span>, <span class="string">"dengqinqin"</span>&#125;</span><br><span class="line">	<span class="keyword">var</span> name_slice2 = []<span class="keyword">string</span>&#123;<span class="string">"liuyan"</span>, <span class="string">"liushuang"</span>, <span class="string">"liuqian"</span>&#125;</span><br><span class="line">	name := <span class="built_in">append</span>(name_slice1, name_slice2...)</span><br><span class="line">	fmt.Println(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [liuzeming dengqinqin liuyan liushuang liuqian]</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/15/Golang设计模式——状态模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/15/Golang设计模式——状态模式/" itemprop="url">Golang设计模式——状态模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-15T12:12:57+08:00">
                2019-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/状态模式/" itemprop="url" rel="index">
                    <span itemprop="name">状态模式</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/状态模式/Golang设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">Golang设计模式</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/状态模式/Golang设计模式/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Golang设计模式——状态模式"><a href="#Golang设计模式——状态模式" class="headerlink" title="Golang设计模式——状态模式"></a>Golang设计模式——状态模式</h1><p><br></p>
<blockquote>
<p> 原文地址：<a href="https://www.jianshu.com/p/dbd7a5bc21e9" target="_blank" rel="noopener">https://www.jianshu.com/p/dbd7a5bc21e9</a></p>
</blockquote>
<p><br></p>
<h2 id="状态模式及其结构"><a href="#状态模式及其结构" class="headerlink" title="状态模式及其结构"></a>状态模式及其结构</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>状态模式(State)：</strong>当一个对象的内部状态发生改变时，会导致其行为的改变，对象看起来似乎修改了它的类。其别名为状态对象(<code>Objects for States</code>),状态模式是一种对象行为型模式。状态模式用于解决系统中<strong>复杂对象的状态转换以及不同状态下行为</strong>的封装问题。当系统中某个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可以使用状态模式。</p>
<p><strong>模式的结构</strong></p>
<p><code>UML</code></p>
<p><img src="//blog.com/2019/05/15/Golang设计模式——状态模式/3823321-7455877ce6ab096b.webp" alt="img"></p>
<p>在状态模式结构图中包含如下几个角色：</p>
<ul>
<li><strong>Context（环境类）</strong>：环境类又称为上下文类，它是拥有多种状态的对象。由于环境类的状态存在多样性且在不同状态下对象的行为有所不同，因此将状态独立出去形成单独的状态类。在环境类中维护一个抽象状态类<code>State</code>的实例，这个实例定义当前状态，在具体实现时，它是一个<code>State</code>子类的对象。</li>
<li><strong>State（抽象状态类）</strong>：它用于定义一个接口以封装与环境类的一个特定状态相关的行为，在抽象状态类中声明了各种不同状态对应的方法，而在其子类中实现类这些方法，由于不同状态下对象的行为可能不同，因此在不同子类中方法的实现可能存在不同，相同的方法可以写在抽象状态类中。</li>
<li><strong>ConcreteState（具体状态类）</strong>：它是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。</li>
</ul>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当今社会，论坛贴吧很多，我们也会加入感兴趣的论坛，偶尔进行发言，但有时却会发现不能发帖了，原来是昨天的某个帖子引发了口水战，被举报了。这里就用论坛发帖为例，简单用代码描述一下：</p>
<p><img src="//blog.com/2019/05/15/Golang设计模式——状态模式/3823321-495a74024bcb5410.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设有三种状态，<code>normal</code>(正常），<code>restricted</code>(受限)，<code>closed</code>(封号)，判断依据是一个健康值（这里只是假设）。</p>
<h3 id="2-1不用状态模式"><a href="#2-1不用状态模式" class="headerlink" title="2.1不用状态模式"></a>2.1不用状态模式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> account</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AccountState <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">   NORMAL     AccountState = <span class="literal">iota</span> <span class="comment">//正常0</span></span><br><span class="line">   RESTRICTED                     <span class="comment">//受限</span></span><br><span class="line">   CLOSED                         <span class="comment">//封号</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">   State       AccountState</span><br><span class="line">   HealthValue <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAccount</span><span class="params">(health <span class="keyword">int</span>)</span> *<span class="title">Account</span></span> &#123;</span><br><span class="line">   a := &amp;Account&#123;</span><br><span class="line">      HealthValue: health,</span><br><span class="line">   &#125;</span><br><span class="line">   a.changeState()</span><br><span class="line">   <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///看帖</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">View</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> a.State == NORMAL || a.State == RESTRICTED &#123;</span><br><span class="line">      fmt.Println(<span class="string">"正常看帖"</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> a.State == CLOSED &#123;</span><br><span class="line">      fmt.Println(<span class="string">"账号被封，无法看帖"</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///评论</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">Comment</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> a.State == NORMAL || a.State == RESTRICTED &#123;</span><br><span class="line">      fmt.Println(<span class="string">"正常评论"</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> a.State == CLOSED &#123;</span><br><span class="line">      fmt.Println(<span class="string">"抱歉，你的健康值小于-10，不能评论"</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///发帖</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">Post</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> a.State == NORMAL &#123;</span><br><span class="line">      fmt.Println(<span class="string">"正常发帖"</span>)</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> a.State == RESTRICTED || a.State == CLOSED &#123;</span><br><span class="line">      fmt.Println(<span class="string">"抱歉，你的健康值小于0，不能发帖"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">changeState</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> a.HealthValue &lt;= <span class="number">-10</span> &#123;</span><br><span class="line">      a.State = CLOSED</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> a.HealthValue &gt; <span class="number">-10</span> &amp;&amp; a.HealthValue &lt;= <span class="number">0</span> &#123;</span><br><span class="line">      a.State = RESTRICTED</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> a.HealthValue &gt; <span class="number">0</span> &#123;</span><br><span class="line">      a.State = NORMAL</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///给账户设定健康值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">SetHealth</span><span class="params">(value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   a.HealthValue = value</span><br><span class="line">   a.changeState()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码很简单，能够实现需要的功能，但是却有几个问题：</p>
<ul>
<li>看帖和发帖方法中都包含状态判断语句，以判断在该状态下是否具有该方法以及在特定状态下该方法如何实现，导致<strong>代码非常冗长，可维护性较差</strong>；</li>
<li><strong>系统扩展性较差</strong>，如果需要增加一种新的状态，如<code>hot</code>状态（活跃用户，该状态用户发帖积分增加更多），需要对原有代码进行大量修改，扩展起来非常麻烦。</li>
</ul>
<h3 id="2-2使用状态模式"><a href="#2-2使用状态模式" class="headerlink" title="2.2使用状态模式"></a>2.2使用状态模式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;状态模式可以在一定程度上解决上述问题，<strong>在状态模式中将对象在每一个状态下的行为和状态转移语句封装在一个个状态类中，通过这些状态类来分散冗长的条件转移语句，让系统具有更好的灵活性和可扩展性</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> saccount</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Account <span class="keyword">struct</span> &#123;</span><br><span class="line">   State       ActionState</span><br><span class="line">   HealthValue <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAccount</span><span class="params">(health <span class="keyword">int</span>)</span> *<span class="title">Account</span></span> &#123;</span><br><span class="line">   a := &amp;Account&#123;</span><br><span class="line">      HealthValue: health,</span><br><span class="line">   &#125;</span><br><span class="line">   a.changeState()</span><br><span class="line">   <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span><span class="title">View</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   a.State.View()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span><span class="title">Comment</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   a.State.Comment()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span><span class="title">Post</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   a.State.Post()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ActionState <span class="keyword">interface</span> &#123;</span><br><span class="line">   View()</span><br><span class="line">   Comment()</span><br><span class="line">   Post()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CloseState <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CloseState)</span><span class="title">View</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   fmt.Println(<span class="string">"账号被封，无法看帖"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CloseState)</span><span class="title">Comment</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   fmt.Println(<span class="string">"抱歉，你的健康值小于-10，不能评论"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *CloseState)</span><span class="title">Post</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   fmt.Println(<span class="string">"抱歉，你的健康值小于0，不能发帖"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RestrictedState <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RestrictedState)</span><span class="title">View</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   fmt.Println(<span class="string">"正常看帖"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RestrictedState)</span><span class="title">Comment</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   fmt.Println(<span class="string">"正常评论"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RestrictedState)</span><span class="title">Post</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   fmt.Println(<span class="string">"抱歉，你的健康值小于0，不能发帖"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NormalState <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NormalState)</span><span class="title">View</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   fmt.Println(<span class="string">"正常看帖"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NormalState)</span><span class="title">Comment</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   fmt.Println(<span class="string">"正常评论"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *NormalState)</span><span class="title">Post</span><span class="params">()</span></span>  &#123;</span><br><span class="line">   fmt.Println(<span class="string">"正常发帖"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">changeState</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> a.HealthValue &lt;= <span class="number">-10</span> &#123;</span><br><span class="line">      a.State = &amp;CloseState&#123;&#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> a.HealthValue &gt; <span class="number">-10</span> &amp;&amp; a.HealthValue &lt;= <span class="number">0</span> &#123;</span><br><span class="line">      a.State = &amp;RestrictedState&#123;&#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> a.HealthValue &gt; <span class="number">0</span> &#123;</span><br><span class="line">      a.State = &amp;NormalState&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///给账户设定健康值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *Account)</span> <span class="title">SetHealth</span><span class="params">(value <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   a.HealthValue = value</span><br><span class="line">   a.changeState()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>状态模式的主要优点如下：</p>
<ul>
<li>封装了状态的转换规则，在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中，<strong>可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中</strong>。</li>
<li><strong>将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为</strong>。</li>
<li><strong>允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起</strong>。</li>
<li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>状态模式的主要缺点如下：</p>
<ul>
<li>状态模式的使用必然会增加系统中类和对象的个数，导致系统运行开销增大。</li>
<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，增加系统设计的难度。</li>
<li><strong>状态模式对“开闭原则”的支持并不太好，增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态</strong>；<strong>而且修改某个状态类的行为也需修改对应类的源代码</strong>。</li>
</ul>
<h2 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h2><p>在以下情况下可以使用状态模式：</p>
<ul>
<li><strong>对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为</strong>。</li>
<li>代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。</li>
</ul>
<h2 id="模式应用"><a href="#模式应用" class="headerlink" title="模式应用"></a>模式应用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;状态模式在工作流或游戏等类型的软件中得以广泛使用，甚至可以用于这些系统的核心功能设计，如在政府OA办公系统中，一个批文的状态有多种：尚未办理；正在办理；正在批示；正在审核；已经完成等各种状态，而且批文状态不同时对批文的操作也有所差异。使用状态模式可以描述工作流对象（如批文）的状态转换以及不同状态下它所具有的行为。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/15/golang 并发设计模式(二)--管道模式管道和显式取消/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/15/golang 并发设计模式(二)--管道模式管道和显式取消/" itemprop="url">golang 并发设计模式(二)--管道模式管道和显式取消</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-15T12:12:57+08:00">
                2019-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/Go并发/" itemprop="url" rel="index">
                    <span itemprop="name">Go并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="golang-并发设计模式-二-–管道模式管道和显式取消"><a href="#golang-并发设计模式-二-–管道模式管道和显式取消" class="headerlink" title="golang 并发设计模式(二)–管道模式管道和显式取消"></a>golang 并发设计模式(二)–管道模式管道和显式取消</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://blog.csdn.net/hittata/article/details/51782441" target="_blank" rel="noopener">https://blog.csdn.net/hittata/article/details/51782441</a></p>
<p>英文地址：<a href="https://blog.golang.org/pipelines" target="_blank" rel="noopener">https://blog.golang.org/pipelines</a></p>
</blockquote>
<p><br></p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Go</code>并发原语使得构建流式数据管道，高效利用<code>I/O</code>和多核变得简单。这篇文章介绍了几个管道例子，重点指出在操作失败时的细微差别，并介绍了优雅处理失败的技术。</p>
<h2 id="什么是管道？"><a href="#什么是管道？" class="headerlink" title="什么是管道？"></a>什么是管道？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Go</code>没有正式的管道定义。管道只是众多并发程序的一类。一般的，一个管道就是一些列的由<code>channel</code>连接起来的阶段。每个阶段都有执行相同逻辑的<code>goroutine</code>。在每个阶段中，<code>goroutine</code></p>
<ol>
<li>从<code>channel</code>读取上游数据</li>
<li>在数据上执行一些操作，通常会产生新的数据</li>
<li>通过<code>channel</code>将数据发往下游</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个阶段都可以有任意个输入<code>channel</code>和输出<code>channel</code>，除了第一个和最有一个<code>channel</code>（只有输入<code>channel</code>或只有输出<code>channel</code>）。第一个步骤通常叫数据源或者生产者，最后一个叫做存储池或者消费者。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们先从一个简单的管道例子来解释这些概念和技术，稍后我们会介绍一个更为复杂的例子。</p>
<h2 id="数字的平方"><a href="#数字的平方" class="headerlink" title="数字的平方"></a>数字的平方</h2><p>假设管道有三个阶段。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一步，<code>gen</code>函数,是一个将数字列表转换到一个<code>channel</code>中的函数。<code>Gen</code>函数启动了一个<code>goroutine</code>，将数字发送到<code>channel</code>，并在所有数字都发送完后关闭<code>channel</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(nums ...<span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line"></span><br><span class="line">            out &lt;- n</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(out)</span><br><span class="line"></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个阶段，<code>sq</code>，从上面的<code>channel</code>接收数字，并返回一个包含所有收到数字的平方的<code>channel</code>。在上游<code>channel</code>关闭后，这个阶段已经往下游发送完所有的结果，然后关闭输出<code>channel</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sq</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> n := <span class="keyword">range</span> in &#123;</span><br><span class="line"></span><br><span class="line">            out &lt;- n * n</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(out)</span><br><span class="line"></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>main</code>函数建立这个管道，并执行第一个阶段，从第二个阶段接收结果并逐个打印，直到<code>channel</code>被关闭。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up the pipeline.</span></span><br><span class="line"></span><br><span class="line">    c := gen(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    out := sq(c)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Consume the output.</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(&lt;-out) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(&lt;-out) <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为sq对输入<code>channel</code>和输出<code>channel</code>拥有相同的类型，我们可以任意次的组合他们。我们也可以像其他阶段一样，将<code>main</code>函数重写成一个循环遍历。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up the pipeline and consume the output.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> n := <span class="keyword">range</span> sq(sq(gen(<span class="number">2</span>, <span class="number">3</span>))) &#123;</span><br><span class="line"></span><br><span class="line">        fmt.Println(n) <span class="comment">// 16 then 81</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扇出扇入（Fan-out-fan-in）"><a href="#扇出扇入（Fan-out-fan-in）" class="headerlink" title="扇出扇入（Fan-out, fan-in）"></a>扇出扇入（Fan-out, fan-in）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>多个函数可以从同一个<code>channel</code>读取数据，直到这个<code>channel</code>关闭，这叫扇出</strong>。这是一种多个工作实例分布式地协作以并行利用<code>CPU和I/O</code>的方式。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>一个函数可以从多个输入读取并处理数据，直到所有的输入<code>channel</code>都被关闭</strong>。<strong>这个函数会将所有输入channel导入一个单一的<code>channel</code>。这个单一的<code>channel</code>在所有输入<code>channel</code>都关闭后才会关闭</strong>。<strong>这叫做扇入</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以设置我们的管道执行两个<code>sq</code>实例，每一个实例都从相同的输入<code>channel</code>读取数据。我们引入了一个新的函数，<code>merge</code>，来扇入结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">    in := gen(2, 3)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    // Distribute the sq work across two goroutines that both read from in.</span><br><span class="line"></span><br><span class="line">    c1 := sq(in)</span><br><span class="line"></span><br><span class="line">    c2 := sq(in)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    // Consume the merged output from c1 and c2.</span><br><span class="line"></span><br><span class="line">    for n := range merge(c1, c2) &#123;</span><br><span class="line"></span><br><span class="line">        fmt.Println(n) // 4 then 9, or 9 then 4</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>merge</code>函数为每一个输入<code>channel</code>启动一个<code>goroutine</code>，<code>goroutine</code>将数据拷贝到同一个输出<code>channel</code>。这样就将多个<code>channel</code>转换成一个<code>channel</code>。一旦所有的<code>output goroutine</code>启动起来，<code>merge</code>就启动另一个<code>goroutine</code>，在所有输入拷贝完毕后关闭输出<code>channel</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;向一个关闭了的<code>channel</code>发送数据会触发异常，所以在调用<code>close</code>之前确认所有的发送动作都执行完毕很重要。<code>sync.WaitGroup</code>类型为这种同步提供了一种简便的方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(cs ...&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start an output goroutine for each input channel in cs.  output</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// copies values from c to out until c is closed, then calls wg.Done.</span></span><br><span class="line"></span><br><span class="line">    output := <span class="function"><span class="keyword">func</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> n := <span class="keyword">range</span> c &#123;</span><br><span class="line"></span><br><span class="line">            out &lt;- n</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wg.Done()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="built_in">len</span>(cs))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> cs &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> output(c)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a goroutine to close out once all the output goroutines are</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// done.  This must start after the wg.Add call.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        wg.Wait()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(out)</span><br><span class="line"></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="停止的艺术"><a href="#停止的艺术" class="headerlink" title="停止的艺术"></a>停止的艺术</h2><p>我们所有的管道函数都遵循一种模式：</p>
<ol>
<li><strong>发送者在发送完毕时关闭其输出<code>channel</code></strong></li>
<li><strong>接收者持续从输入管道接收数据直到输入管道关闭</strong></li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种模式使得每一个接收函数都能写成一个<code>range</code>循环，保证所有的<code>goroutine</code>在数据成功发送到下游后就关闭。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是在真实的案例中，<strong>并不是所有的输入数据都需要被接收处理</strong>。有些时候是故意这么设计的：接收者可能只需要数据的子集就够了；或者更一般的，因为输入数据有错误而导致接收函数提早退出。上面任何一种情况下，<strong>接收者都不应该继续等待后续的数据到来</strong>，并且我们<strong>希望上游函数停止生成后续步骤已经不需要的数据</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们的管道例子中，如果一个阶段无法消费所有的输入数据，那些发送这些数据的<code>goroutine</code>就会一直阻塞下去：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Consume the first value from output.</span></span><br><span class="line"></span><br><span class="line">    out := merge(c1, c2)</span><br><span class="line"></span><br><span class="line">    fmt.Println(&lt;-out) <span class="comment">// 4 or 9</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since we didn't receive the second value from out,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// one of the output goroutines is hung attempting to send it.</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一种资源泄漏：<code>goroutine</code>会占用内存和运行时资源。<strong><code>goroutine</code>栈持有的堆引用会阻止<code>GC</code>回收资源</strong>。而且<strong><code>goroutine</code>不能被垃圾回收，必须主动退出</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们必须重新设计管道中的上游函数，在下游函数无法接收所有输入数据时退出。一种方法就是<strong>让输出<code>channel</code>拥有一定的缓存</strong>。缓存可以存储一定数量的数据。如果缓存空间足够，发送操作就会马上返回:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>) <span class="comment">// buffer size 2</span></span><br><span class="line"></span><br><span class="line">c &lt;- <span class="number">1</span>  <span class="comment">// succeeds immediately</span></span><br><span class="line"></span><br><span class="line">c &lt;- <span class="number">2</span>  <span class="comment">// succeeds immediately</span></span><br><span class="line"></span><br><span class="line">c &lt;- <span class="number">3</span>  <span class="comment">// blocks until another goroutine does &lt;-c and receives 1</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果在<code>channel</code>创建时就知道需要发送数据的数量，带缓存的<code>channel</code>会简化代码。例如，我们可以重写<code>gen</code>函数，拷贝一系列的整数到一个带缓存的<code>channel</code>而不是创建一个新的<code>goroutine</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(nums ...<span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line"></span><br><span class="line">        out &lt;- n</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;反过来我们看管道中被阻塞的<code>goroutine</code>，我们可以考虑为<code>merge</code>函数返回的输出<code>channel</code>增加一个缓存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func merge(cs ...&lt;-chan int) &lt;-chan int &#123;</span><br><span class="line"></span><br><span class="line">    var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    out := make(chan int, 1) // enough space for the unread inputs</span><br><span class="line"></span><br><span class="line">    // ... the rest is unchanged ...</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然这样可以避免了程序中<code>goroutine</code>的阻塞，但这是很烂的代码。<strong>选择缓存大小为1取决于知道<code>merge</code>函数接收数字的数量和下游函数消费数字的数量</strong>（<code>merge</code>函数调用时传入了两个参数）。这是很不稳定的：如果我们向<code>gen</code>多发送了一个数据，或者下游函数少消费了数据，我们就又一次阻塞了<code>goroutine</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然而，我们需要提供一种方式，<strong>下游函数可以通知上游发送者下游要停止接收数据</strong>。</p>
<h2 id="显式取消"><a href="#显式取消" class="headerlink" title="显式取消"></a>显式取消</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当<code>main</code>函数决定在没有从<code>out</code>接收所有的数据而要退出时，它需要通知上游的<code>goroutine</code>取消即将发送的数据。可以通过向一个叫做<code>done</code>的<code>channel</code>发送数据来实现。因为有两个潜在阻塞的<code>goroutine</code>，<code>main</code>函数会发送两个数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    in := gen(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Distribute the sq work across two goroutines that both read from in.</span></span><br><span class="line"></span><br><span class="line">    c1 := sq(in)</span><br><span class="line"></span><br><span class="line">    c2 := sq(in)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Consume the first value from output.</span></span><br><span class="line"></span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    out := merge(done, c1, c2)</span><br><span class="line"></span><br><span class="line">    fmt.Println(&lt;-out) <span class="comment">// 4 or 9</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell the remaining senders we're leaving.</span></span><br><span class="line"></span><br><span class="line">    done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">    done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对发送<code>goroutine</code>而言，需要将发送操作替换为一个<code>select</code>语句，要么<code>out</code>发生发送操作，要么从<code>done</code>接收数据。<code>done</code>的数据类型是空的<code>struct</code>，因为其值无关紧要：仅仅表示<code>out</code>需要取消发送操作。<code>output</code> 继续在输入<code>channel</code>循环执行，因此上游函数是不会阻塞的。（接下来我们会讨论如何让循环提早退出）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, cs ...&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start an output goroutine for each input channel in cs.  output</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// copies values from c to out until c is closed or it receives a value</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// from done, then output calls wg.Done.</span></span><br><span class="line"></span><br><span class="line">    output := <span class="function"><span class="keyword">func</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> n := <span class="keyword">range</span> c &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> out &lt;- n:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> &lt;-done:</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wg.Done()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... the rest is unchanged ...</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方法有一个问题：每一个下游函数需要知道潜在可能阻塞的上游发送者发送报文的数量，以发送响应的信号让其提早退出。跟踪这些数量是无趣的而且很容易出错。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们需要一种能够让未知或无界数量的<code>goroutine</code>都能够停止向下游发送数据的方法。在<code>Go</code>中，我们可以通过关闭一个<code>channel</code>实现。因为从一个关闭了的<code>channel</code>执行接收操作总能马上成功，并返回相应数据类型的零值。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这意味着<code>main</code>函数仅通过关闭<code>done</code>就能实现将所有的发送者解除阻塞。<strong>关闭操作是一个高效的对发送者的广播信号</strong>。我们扩展管道中所有的函数接受<code>done</code>作为一个参数，并通过<code>defer</code>来实现相应<code>channel</code>的关闭操作。因此，无论<code>main</code>函数在哪一行退出都会通知上游退出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set up a done channel that's shared by the whole pipeline,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// and close that channel when this pipeline exits, as a signal</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// for all the goroutines we started to exit.</span></span><br><span class="line"></span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    in := gen(done, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Distribute the sq work across two goroutines that both read from in.</span></span><br><span class="line"></span><br><span class="line">    c1 := sq(done, in)</span><br><span class="line"></span><br><span class="line">    c2 := sq(done, in)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Consume the first value from output.</span></span><br><span class="line"></span><br><span class="line">    out := merge(done, c1, c2)</span><br><span class="line"></span><br><span class="line">    fmt.Println(&lt;-out) <span class="comment">// 4 or 9</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// done will be closed by the deferred call.</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在每一个管道函数在<code>done</code>被关闭后就可以马上返回了。<code>merge</code>函数中的<code>output</code>可以在接收管道的数据消费完之前返回，因为<code>output</code>函数知道上游发送者<code>sq</code>会在<code>done</code>关闭后停止产生数据。同时，<code>output</code>通过<code>defer</code>语句保证<code>wq.Done</code>会在所有退出路径上调用。</p>
<p>这里有个机制：</p>
<p>Ø 首先保证<code>sq</code>退出，<code>sq</code>退出，源头的生产者就没有了，<code>merge</code>里面的 <code>for range</code>就会退出；</p>
<p>Ø 如果恰巧阻塞到<code>merge 的select</code>里面，也由于<code>done</code>已经关闭，对导致解除阻塞而退出；</p>
<p>（原因是：一般通知生产者停止生产时，消费者已经不去消费了<code>case out &lt;- n</code>: 会阻塞，所以<code>select</code>中的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case &lt;-done:</span><br><span class="line"></span><br><span class="line">ruturn</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;能够执行<code>select</code> 多个<code>chan</code>都已经准备就绪，选择是随机的，这就说明<code>sq</code>肯定有机会退出）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, cs ...&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start an output goroutine for each input channel in cs.  output</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// copies values from c to out until c or done is closed, then calls</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wg.Done.</span></span><br><span class="line"></span><br><span class="line">    output := <span class="function"><span class="keyword">func</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>  n := <span class="keyword">range</span> c &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> out &lt;- n:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> &lt;-done:              <span class="comment">//这里使用的是闭包</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="built_in">len</span>(cs))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> cs &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">go</span> output(c)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start a goroutine to close out once all the output goroutines are</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// done.  This must start after the wg.Add call.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        wg.Wait()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(out)</span><br><span class="line"></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  out</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类似的，<code>sq</code>也可以在<code>done</code>关闭后马上返回。<code>sq</code>通过<code>defer</code>语句使得任何退出路径都能关闭其输出<code>channel out</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sq</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> &lt;-<span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>  n := <span class="keyword">range</span> in &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> out &lt;- n * n:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> &lt;-done:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="管道构建的指导思想"><a href="#管道构建的指导思想" class="headerlink" title="管道构建的指导思想"></a>管道构建的指导思想</h2><ol>
<li>每一个阶段在所有发送操作完成后关闭输出<code>channel</code></li>
<li>每一个阶段持续从输入<code>channel</code>接收数据直到输入<code>channel</code>被关闭或者生产者被解除阻塞（译者：生产者退出）</li>
</ol>
<h2 id="管道解除生产者阻塞"><a href="#管道解除生产者阻塞" class="headerlink" title="管道解除生产者阻塞"></a>管道解除生产者阻塞</h2><ol>
<li><strong>要么保证有足够的缓存空间存储将要被生产的数据</strong>;</li>
<li><strong>要么显式的通知生产者消费者要取消接收数据</strong>;</li>
</ol>
<h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><ol>
<li>一般情况下由发送者主动关闭<code>chan</code>，特殊情况下才由消费者发信号告知生产者关闭<code>chan</code>, 避免生产者的<code>goroutine</code>一直阻塞；</li>
<li>读取被关闭的channel会立马返回，是不会阻塞的，返回值是<code>chan type</code>的零值；<code>select</code> 与之结合天衣无缝的扑捉到关闭信号然后，生产者停止生产退出关闭<code>channel</code>,释放资源；</li>
</ol>
<h2 id="树形摘要"><a href="#树形摘要" class="headerlink" title="树形摘要"></a>树形摘要</h2><p>让我们来看一个更为实际的管道。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>MD5</code>是一个信息摘要算法，对于文件校验非常有用。命令行工具<code>md5 sum</code>很有用，可以打印一系列文件的摘要值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">% md5sum *.go</span><br><span class="line">d47c2bbc28298ca9befdfbc5d3aa4e65  bounded.go</span><br><span class="line">ee869afd31f83cbb2d10ee81b2b831dc  parallel.go</span><br><span class="line">b88175e65fdcbc01ac08aaf1fd9b5e96  serial.go</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们的例子程序和<code>md5sum</code>类似，但是接受一个单一的文件夹作为参数，打印该文件夹下每一个普通文件的摘要值，并按路径名称排序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">% go run serial.go .</span><br><span class="line">d47c2bbc28298ca9befdfbc5d3aa4e65  bounded.go</span><br><span class="line">ee869afd31f83cbb2d10ee81b2b831dc  parallel.go</span><br><span class="line">b88175e65fdcbc01ac08aaf1fd9b5e96  serial.go</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们程序的<code>main</code>函数调用一个工具函数<code>MD5ALL</code>，该函数返回一个从路径名称到摘要值的哈希表，然后排序并输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">    // Calculate the MD5 sum of all files under the specified directory,</span><br><span class="line">    // then print the results sorted by path name.</span><br><span class="line">    m, err := MD5All(os.Args[1])</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    var paths []string</span><br><span class="line">    for path := range m &#123;</span><br><span class="line">        paths = append(paths, path)</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Strings(paths)</span><br><span class="line">    for _, path := range paths &#123;</span><br><span class="line">        fmt.Printf(&quot;%x  %s\n&quot;, m[path], path)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>MD5ALL</code>是我们讨论的核心。在 <code>serial.go</code>中，没有采用任何并发，仅仅遍历文件夹，读取文件并求出摘要值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// MD5All reads all the files in the file tree rooted at root and returns a map</span><br><span class="line">// from file path to the MD5 sum of the file&apos;s contents.  If the directory walk</span><br><span class="line">// fails or any read operation fails, MD5All returns an error.</span><br><span class="line">func MD5All(root string) (map[string][md5.Size]byte, error) &#123;</span><br><span class="line">    m := make(map[string][md5.Size]byte)</span><br><span class="line">    err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error &#123;</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            return err</span><br><span class="line">        &#125;</span><br><span class="line">        if !info.Mode().IsRegular() &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        data, err := ioutil.ReadFile(path)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            return err</span><br><span class="line">        &#125;</span><br><span class="line">        m[path] = md5.Sum(data)</span><br><span class="line">        return nil</span><br><span class="line">    &#125;)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        return nil, err</span><br><span class="line">    &#125;</span><br><span class="line">    return m, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并行摘要求值"><a href="#并行摘要求值" class="headerlink" title="并行摘要求值"></a>并行摘要求值</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>parallel.go</code>中，我们将<code>MD5ALL</code>分成两阶段的管道。第一个阶段，<code>sumFiles</code>，遍历文件夹，每个文件一个<code>goroutine</code>进行求摘要值，然后将结果发送一个数据类型为<code>result</code>的<code>channel</code>中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type result struct &#123;</span><br><span class="line">    path string</span><br><span class="line">    sum  [md5.Size]byte</span><br><span class="line">    err  error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>sumFiles</code>返回两个<code>channel</code>：一个用于生成结果，一个用于<code>filepath.Walk</code>返回错误。<code>Walk</code>函数为每一个普通文件启动一个<code>goroutine</code>，然后检查<code>done</code>，如果<code>done</code>被关闭，<code>walk</code>马上就会退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">func sumFiles(done &lt;-chan struct&#123;&#125;, root string) (&lt;-chan result, &lt;-chan error) &#123;</span><br><span class="line">    // For each regular file, start a goroutine that sums the file and sends</span><br><span class="line">    // the result on c.  Send the result of the walk on errc.</span><br><span class="line">    c := make(chan result)</span><br><span class="line">    errc := make(chan error, 1)</span><br><span class="line">    go func() &#123;</span><br><span class="line">        var wg sync.WaitGroup</span><br><span class="line">        err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error &#123;</span><br><span class="line">            if err != nil &#123;</span><br><span class="line">                return err</span><br><span class="line">            &#125;</span><br><span class="line">            if !info.Mode().IsRegular() &#123;</span><br><span class="line">                return nil</span><br><span class="line">            &#125;</span><br><span class="line">            wg.Add(1)</span><br><span class="line">            go func() &#123;</span><br><span class="line">                data, err := ioutil.ReadFile(path)</span><br><span class="line">                select &#123;</span><br><span class="line">                    case c &lt;- result&#123;path, md5.Sum(data), err&#125;:</span><br><span class="line">                    case &lt;-done:</span><br><span class="line">                &#125;</span><br><span class="line">                wg.Done()</span><br><span class="line">            &#125;()</span><br><span class="line">            // Abort the walk if done is closed.</span><br><span class="line">            select &#123;</span><br><span class="line">                case &lt;-done:</span><br><span class="line">                    return errors.New(&quot;walk canceled&quot;)</span><br><span class="line">                default:</span><br><span class="line">                    return nil</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        // Walk has returned, so all calls to wg.Add are done.  Start a</span><br><span class="line">        // goroutine to close c once all the sends are done.</span><br><span class="line">        go func() &#123;</span><br><span class="line">            wg.Wait()</span><br><span class="line">            close(c)</span><br><span class="line">        &#125;()</span><br><span class="line">        // No select needed here, since errc is buffered.</span><br><span class="line">        errc &lt;- err</span><br><span class="line">    &#125;()</span><br><span class="line">    return c, errc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>MD5All</code> 从c中接收摘要值。<code>MD5All</code> 在遇到错误时提前退出，通过<code>defer</code>关闭<code>done</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func MD5All(root string) (map[string][md5.Size]byte, error) &#123;</span><br><span class="line">    // MD5All closes the done channel when it returns; it may do so before</span><br><span class="line">    // receiving all the values from c and errc.</span><br><span class="line">    done := make(chan struct&#123;&#125;)</span><br><span class="line">    defer close(done)</span><br><span class="line"></span><br><span class="line">    c, errc := sumFiles(done, root)</span><br><span class="line"></span><br><span class="line">    m := make(map[string][md5.Size]byte)</span><br><span class="line">    for r := range c &#123;</span><br><span class="line">        if r.err != nil &#123;</span><br><span class="line">            return nil, r.err</span><br><span class="line">        &#125;</span><br><span class="line">        m[r.path] = r.sum</span><br><span class="line">    &#125;</span><br><span class="line">    if err := &lt;-errc; err != nil &#123;</span><br><span class="line">        return nil, err</span><br><span class="line">    &#125;</span><br><span class="line">    return m, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="有界并行"><a href="#有界并行" class="headerlink" title="有界并行"></a>有界并行</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>parallel.go</code>中实现的<code>MD5ALL</code>，对每一个文件启动了一个<code>goroutine</code>。在一个包含大量大文件的文件夹中，这会导致超过机器可用内存的内存分配。（译者注：即发生<code>OOM</code>）</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以通过限制读取文件的并发度来避免这种情况发生。在bounded.go中，我们通过创建一定数量的<code>goroutine</code>读取文件。现在我们的管道现在有三个阶段：遍历文件夹，读取文件并计算摘要值，收集摘要值。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个阶段，<code>walkFiles</code>，输出文件夹中普通文件的文件路径：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkFiles</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, root <span class="keyword">string</span>)</span> <span class="params">(&lt;-<span class="keyword">chan</span> <span class="keyword">string</span>, &lt;-<span class="keyword">chan</span> error)</span></span> &#123;</span><br><span class="line">    paths := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line">    errc := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Close the paths channel after Walk returns.</span></span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(paths)</span><br><span class="line">        <span class="comment">// No select needed for this send, since errc is buffered.</span></span><br><span class="line">        errc &lt;- filepath.Walk(root, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="keyword">string</span>, info os.FileInfo, err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !info.Mode().IsRegular() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> paths &lt;- path:</span><br><span class="line">            <span class="keyword">case</span> &lt;-done:</span><br><span class="line">                <span class="keyword">return</span> errors.New(<span class="string">"walk canceled"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> paths, errc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中间的阶段启动一定数量的<code>digester goroutine</code>，从<code>paths</code>接收文件名称，并向<code>c</code>发送<code>result</code>结构:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">digester</span><span class="params">(done &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, paths &lt;-<span class="keyword">chan</span> <span class="keyword">string</span>, c <span class="keyword">chan</span>&lt;- result)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> path := <span class="keyword">range</span> paths &#123;</span><br><span class="line">        data, err := ioutil.ReadFile(path)</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> c &lt;- result&#123;path, md5.Sum(data), err&#125;:</span><br><span class="line">        <span class="keyword">case</span> &lt;-done:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;和前一个例子不同，<code>digester</code>并不关闭其输出<code>channel</code>，因为输出<code>channel</code>是共享的，多个<code>goroutine</code>会向同一个<code>channel</code>发送数据。<code>MD5All</code> 会在所有的<code>digesters</code>结束后关闭响应的<code>channel</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start a fixed number of goroutines to read and digest files.</span></span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> result)</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">const</span> numDigesters = <span class="number">20</span></span><br><span class="line">wg.Add(numDigesters)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numDigesters; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        digester(done, paths, c)</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(c)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们也可以让每一个<code>digester</code>创建并返回自己的输出<code>channel</code>，但如果这样的话，我们需要额外的<code>goroutine</code>来扇入这些结果。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后一个阶段从<code>c</code>中接收所有的<code>result</code>数据，并从<code>errc</code>中检查错误。这种检查不能在之前的阶段做，因为在这之前，<code>walkFiles</code> 可能被阻塞不能往下游发送数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>][md5.Size]<span class="keyword">byte</span>)</span><br><span class="line">    <span class="keyword">for</span> r := <span class="keyword">range</span> c &#123;</span><br><span class="line">        <span class="keyword">if</span> r.err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, r.err</span><br><span class="line">        &#125;</span><br><span class="line">        m[r.path] = r.sum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check whether the Walk failed.</span></span><br><span class="line">    <span class="keyword">if</span> err := &lt;-errc; err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>This article has presented techniques for constructing streaming data pipelines in Go. Dealing with failures in such pipelines is tricky, since each stage in the pipeline may block attempting to send values downstream, and the downstream stages may no longer care about the incoming data. We showed how closing a channel can broadcast a “done” signal to all the goroutines started by a pipeline and defined guidelines for constructing pipelines correctly.</p>
<p>Further reading:</p>
<ul>
<li><a href="https://talks.golang.org/2012/concurrency.slide#1" target="_blank" rel="noopener">Go Concurrency Patterns</a> (<a href="https://www.youtube.com/watch?v=f6kdp27TYZs" target="_blank" rel="noopener">video</a>) presents the basics of Go’s concurrency primitives and several ways to apply them.</li>
<li><a href="https://blog.golang.org/advanced-go-concurrency-patterns" target="_blank" rel="noopener">Advanced Go Concurrency Patterns</a> (<a href="http://www.youtube.com/watch?v=QDDwwePbDtw" target="_blank" rel="noopener">video</a>) covers more complex uses of Go’s primitives, especially <code>select</code>.</li>
<li>Douglas McIlroy’s paper <a href="https://swtch.com/~rsc/thread/squint.pdf" target="_blank" rel="noopener">Squinting at Power Series</a> shows how Go-like concurrency provides elegant support for complex calculations.</li>
</ul>
<p>By Sameer Ajmani</p>
<h2 id="Related-articles"><a href="#Related-articles" class="headerlink" title="Related articles"></a>Related articles</h2><ul>
<li><a href="https://blog.golang.org/context" target="_blank" rel="noopener">Go Concurrency Patterns: Context</a></li>
<li><a href="https://blog.golang.org/race-detector" target="_blank" rel="noopener">Introducing the Go Race Detector</a></li>
<li><a href="https://blog.golang.org/advanced-go-concurrency-patterns" target="_blank" rel="noopener">Advanced Go Concurrency Patterns</a></li>
<li><a href="https://blog.golang.org/concurrency-is-not-parallelism" target="_blank" rel="noopener">Concurrency is not parallelism</a></li>
<li><a href="https://blog.golang.org/go-videos-from-google-io-2012" target="_blank" rel="noopener">Go videos from Google I/O 2012</a></li>
<li><a href="https://blog.golang.org/go-concurrency-patterns-timing-out-and" target="_blank" rel="noopener">Go Concurrency Patterns: Timing out, moving on</a></li>
<li><a href="https://blog.golang.org/share-memory-by-communicating" target="_blank" rel="noopener">Share Memory By Communicating</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/73/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/73/">73</a><span class="page-number current">74</span><a class="page-number" href="/page/75/">75</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/75/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
