<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/page/130/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/page/130/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/01/29/Git版本回退/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/29/Git版本回退/" itemprop="url">Git版本回退</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-29T12:12:57+08:00">
                2019-01-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Git版本回退"><a href="#Git版本回退" class="headerlink" title="Git版本回退"></a>Git版本回退</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://blog.csdn.net/yxlshk/article/details/79944535" target="_blank" rel="noopener">https://blog.csdn.net/yxlshk/article/details/79944535</a> </p>
</blockquote>
<h2 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在利用<code>github</code>实现多人合作程序开发的过程中，我们有时会出现错误提交的情况，此时我们希望能撤销提交操作，让程序回到提交前的样子，本文总结了两种解决方法：回退（<code>reset</code>）、反做（<code>revert</code>）。</p>
<h2 id="二、背景知识"><a href="#二、背景知识" class="headerlink" title="二、背景知识"></a>二、背景知识</h2><p><strong>git的版本管理，及HEAD的理解</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用git的每次提交，Git都会自动把它们串成一条时间线，这条时间线就是一个分支。如果没有新建分支，那么只有一条时间线，即只有一个分支，在Git里，这个分支叫主分支，即master分支。有一个HEAD指针指向当前分支（只有一个分支的情况下会指向master，而master是指向最新提交）。每个版本都会有自己的版本信息，如特有的版本号、版本名等。如下图，假设只有一个分支：</p>
<p><img src="//blog.com/2019/01/29/Git版本回退/20180414200442603.png" alt=""></p>
<h2 id="三、解决方法"><a href="#三、解决方法" class="headerlink" title="三、解决方法"></a>三、解决方法</h2><h3 id="方法一：git-reset"><a href="#方法一：git-reset" class="headerlink" title="方法一：git reset"></a>方法一：git reset</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原理： git reset的作用是修改HEAD的位置，即将<strong>HEAD指向的位置改变为之前存在的某个版本</strong>，如下图所示，假设我们要回退到版本一：</p>
<p><img src="//blog.com/2019/01/29/Git版本回退/20180414212221033.png" alt=""></p>
<p>适用场景： 如果想恢复到之前某个提交的版本，且<strong>那个版本之后提交的版本我们都不要了</strong>，就可以用这种方法。</p>
<p>具体操作：</p>
<ol>
<li>查看版本号：<br>可以使用命令“git log”查看：</li>
</ol>
<p><img src="//blog.com/2019/01/29/Git版本回退/20180414203101939.png" alt=""></p>
<p>也可以在github网站上查看：</p>
<p><img src="//blog.com/2019/01/29/Git版本回退/20180414203344138.png" alt=""></p>
<ol start="2">
<li><p>使用“git reset –hard 目标版本号”命令将版本回退：</p>
<p><img src="//blog.com/2019/01/29/Git版本回退/20180414202413666.png" alt=""></p>
</li>
</ol>
<p>再用“git log”查看版本信息，此时本地的HEAD已经指向之前的版本：</p>
<p><img src="//blog.com/2019/01/29/Git版本回退/20180414202716010.png" alt=""></p>
<ol start="3">
<li><p>使用“git push -f”提交更改：<br>此时如果用“git push”会报错，因为我们本地库HEAD指向的版本比远程库的要旧：</p>
<p><img src="//blog.com/2019/01/29/Git版本回退/20180414203605797.png" alt=""></p>
</li>
</ol>
<p>所以我们要用“git push -f”强制推上去，就可以了：</p>
<p><img src="//blog.com/2019/01/29/Git版本回退/20180414203957217.png" alt=""></p>
<p>在github图形化界面上看，远程库的HEAD也已经指向目标版本：</p>
<p><img src="//blog.com/2019/01/29/Git版本回退/20180414204245891.png" alt=""></p>
<p>回退成功！</p>
<h3 id="方法二：git-revert"><a href="#方法二：git-revert" class="headerlink" title="方法二：git revert"></a>方法二：git revert</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原理： <strong>git revert的作用通过反做创建一个新的版本，这个版本的内容与我们要回退到的目标版本一样，但是HEAD指针是指向这个新生成的版本，而不是目标版本</strong>。如下图所示，假设我们要回退到版本一，版本四的内容和版本一是一样的：</p>
<p><img src="//blog.com/2019/01/29/Git版本回退/20180414205816188.png" alt=""></p>
<p>适用场景： 如果我们想恢复之前的某一版本（<strong>该版本不是merge类型</strong>），但是又想保留该目标版本后面的版本，记录下这整个版本变动流程，就可以用这种方法。</p>
<p>具体操作：</p>
<ol>
<li><p>查看版本号：<br>可以通过命令行查看：</p>
<p><img src="//blog.com/2019/01/29/Git版本回退/20181209151411417.png" alt=""></p>
</li>
</ol>
<p>也可以通过github网站图形化界面查看：</p>
<p><img src="//blog.com/2019/01/29/Git版本回退/20181209151459670.png" alt=""></p>
<p>2.使用“git revert -n 版本号”反做，并使用“git commit -m 版本名”提交：<br>（1）反做，使用“git revert -n 版本号”：</p>
<p><img src="//blog.com/2019/01/29/Git版本回退/2018120915155289.png" alt=""></p>
<p>注意： 这里可能会出现冲突，那么需要手动修改冲突的文件。而且要git add 文件名。<br>（2）提交，使用“git commit -m 版本名”：</p>
<p><img src="//blog.com/2019/01/29/Git版本回退/20181209151758404.png" alt=""></p>
<p>此时可以用“git log”查看本地的版本信息，可见多生成了一个新的版本：</p>
<p><img src="//blog.com/2019/01/29/Git版本回退/20181209151939390.png" alt=""></p>
<p>3.使用“git push”推上远程库：</p>
<p><img src="//blog.com/2019/01/29/Git版本回退/20181209152031922.png" alt=""></p>
<p>查看github上显示的远程库版本信息：</p>
<p><img src="//blog.com/2019/01/29/Git版本回退/20181209152058937.png" alt=""></p>
<h2 id="反做成功！"><a href="#反做成功！" class="headerlink" title="反做成功！"></a>反做成功！</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>git reset    –hard   要回退的commit的前一个commit</strong></p>
<p><strong>git revert   -n       “要回退的commit”</strong></p>
<blockquote>
<p>git revert 还原选中commit及其后面的修改</p>
</blockquote>
<blockquote>
<p>git reset 还原选中commit后面的修改</p>
</blockquote>
<blockquote>
<p>git reset 是向后修改</p>
</blockquote>
<blockquote>
<p>git revert 是向前修改</p>
</blockquote>
<p>git revert是个安全的方法。相比git reset他不会改变现在的提交历史，因此git revert可以用在公共分支上，而git reset最好用在私人分支上。</p>
<p><strong>git reset    –hard   保留目标commit</strong></p>
<p><strong>git revert   -n       “目标commit的后一个commit”</strong></p>
<h3 id="针对merge"><a href="#针对merge" class="headerlink" title="针对merge"></a>针对merge</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard  merge前的那一次commit</span><br><span class="line"></span><br><span class="line">git revert -n  merge的commit</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/01/27/TCP 的那些事儿（下）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/27/TCP 的那些事儿（下）/" itemprop="url">TCP 的那些事儿（下）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-27T12:12:57+08:00">
                2019-01-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/Linux/Tcp/" itemprop="url" rel="index">
                    <span itemprop="name">Tcp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="TCP-的那些事儿（下）"><a href="#TCP-的那些事儿（下）" class="headerlink" title="TCP 的那些事儿（下）"></a>TCP 的那些事儿（下）</h1><blockquote>
<p>原文地址：<a href="https://coolshell.cn/articles/11609.html" target="_blank" rel="noopener">https://coolshell.cn/articles/11609.html</a></p>
</blockquote>
<h4 id="TCP的RTT算法"><a href="#TCP的RTT算法" class="headerlink" title="TCP的RTT算法"></a>TCP的RTT算法</h4><p>从前面的TCP重传机制我们知道Timeout的设置对于重传非常重要。</p>
<ul>
<li><strong>设长了</strong>，重发就慢，丢了老半天才重发，<strong>没有效率，性能差</strong>；</li>
<li><strong>设短了</strong>，会导致可能并没有丢就重发。于是重发的就快，会<strong>增加网络拥塞</strong>，导致更多的超时，更多的超时导致更多的重发；</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;而且，这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。只能<strong>动态地设置</strong>。 为了动态地设置，<strong>TCP引入了RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间</strong>。这样发送端就大约知道需要多少的时间，从而可以方便地设置<strong>Timeout——RTO（Retransmission TimeOut）</strong>，以让我们的重传机制更高效。 听起来似乎很简单，好像就是在发送端发包时记下t0，然后接收端再把这个ack回来时再记一个t1，于是RTT = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。</p>
<h5 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h5><p><a href="http://tools.ietf.org/html/rfc793" target="_blank" rel="noopener">RFC793</a> 中定义的经典算法是这样的：</p>
<p>1）首先，先采样RTT，记下最近好几次的RTT值。</p>
<p>2）然后做平滑计算SRTT（ Smoothed RTT）。公式为：（其中的 α 取值在0.8 到 0.9之间，这个算法英文叫Exponential weighted moving average，中文叫：加权移动平均）</p>
<p><strong>SRTT = ( α * SRTT ) + ((1- α) * RTT)</strong></p>
<p>3）开始计算RTO。公式如下：</p>
<p><strong>RTO = min [ UBOUND,  max [ LBOUND,   (β * SRTT) ]  ]</strong></p>
<p>其中：</p>
<ul>
<li>UBOUND是最大的timeout时间，上限值</li>
<li>LBOUND是最小的timeout时间，下限值</li>
<li>β 值一般在1.3到2.0之间。</li>
</ul>
<h5 id="Karn-Partridge-算法"><a href="#Karn-Partridge-算法" class="headerlink" title="Karn / Partridge 算法"></a>Karn / Partridge 算法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;但是上面的这个算法在重传的时候会出有一个终极问题——<strong>你是用第一次发数据的时间和ack回来的时间做RTT样本值，还是用重传的时间和ACK回来的时间做RTT样本值</strong>？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这个问题无论你选那头都是按下葫芦起了瓢。 如下图所示：</p>
<ul>
<li>情况（a）是ack没回来，所以重传。如果你计算第一次发送和ACK的时间，那么，明显算大了。</li>
<li>情况（b）是ack回来慢了，但是导致了重传，但刚重传不一会儿，之前ACK就回来了。如果你是算重传的时间和ACK回来的时间的差，就会算短了。</li>
</ul>
<p><img src="//blog.com/2019/01/27/TCP 的那些事儿（下）/Karn-Partridge-Algorithm.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;所以1987年的时候，搞了一个叫<a href="http://en.wikipedia.org/wiki/Karn&#39;s_Algorithm" target="_blank" rel="noopener">Karn / Partridge Algorithm</a>，这个算法的最大特点是——<strong>忽略重传，不把重传的RTT做采样</strong>（你看，你不需要去解决不存在的问题）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;但是，这样一来，又会引发一个大BUG——<strong>如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重转所有的包（因为之前的RTO很小），于是，因为重转的不算，所以，RTO就不会被更新，这是一个灾难</strong>。 于是Karn算法用了一个取巧的方式——只要一发生重传，就对现有的RTO值翻倍（这就是所谓的 Exponential backoff），很明显，这种死规矩对于一个需要估计比较准确的RTT也不靠谱。</p>
<h5 id="Jacobson-Karels-算法"><a href="#Jacobson-Karels-算法" class="headerlink" title="Jacobson / Karels 算法"></a>Jacobson / Karels 算法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果RTT有一个大的波动的话，很难被发现，因为被平滑掉了。所以，1988年，又有人推出来了一个新的算法，这个算法叫Jacobson / Karels Algorithm（参看<a href="http://tools.ietf.org/html/rfc6298" target="_blank" rel="noopener">RFC6289</a>）。这个算法引入了最新的RTT的采样和平滑过的SRTT的差距做因子来计算。 公式如下：（其中的DevRTT是Deviation RTT的意思）</p>
<p><strong>SRTT</strong> = <strong>SRTT</strong> <strong>+ α</strong> <strong>(RTT</strong> <strong>– SRTT)</strong>                                                    —— 计算平滑RTT</p>
<p><strong>DevRTT</strong> <strong>= (1-β)*DevRTT</strong> <strong>+ β***</strong>(|RTT-SRTT|)**                             ——计算平滑RTT和真实的差距（加权移动平均）</p>
<p><strong>RTO= µ * SRTT + ∂ *DevRTT</strong> —— 神一样的公式</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;（其中：在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——这就是算法中的“调得一手好参数”，nobody knows why, it just works…） <strong>最后的这个算法在被用在今天的TCP协议中（Linux的源代码在：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_input.c?v=2.6.32#L609" target="_blank" rel="noopener">tcp_rtt_estimator</a>）</strong>。</p>
<h4 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;需要说明一下，如果你不了解TCP的滑动窗口这个事，你等于不了解TCP协议。我们都知道，<strong>TCP必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;所以，TCP引入了一些技术和设计来做<strong>网络流控</strong>，Sliding Window是其中一个技术。 前面我们说过，<strong>TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据</strong>。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。 为了说明滑动窗口，我们需要先看一下TCP缓冲区的一些数据结构：</p>
<p><img src="https://coolshell.cn/wp-content/uploads/2014/05/tcpswwindows.png" alt="img"></p>
<p>上图中，我们可以看到：</p>
<ul>
<li><p>接收端LastByteRead指向了TCP缓冲区中读到的位置</p>
<p>NextByteExpected指向的地方是收到的连续包的最后一个位置</p>
<p>LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。</p>
</li>
<li><p>发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认）</p>
<p>LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。</p>
</li>
</ul>
<p>于是：</p>
<ul>
<li><p>接收端在给发送端回ACK中会汇报自己的AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1;</p>
</li>
<li><p>而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。</p>
</li>
</ul>
<p>下面我们来看一下发送方的滑动窗口示意图：</p>
<p><img src="//blog.com/2019/01/27/TCP 的那些事儿（下）/tcpswwindows.png" alt="img"></p>
<p>（<a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-6.htm" target="_blank" rel="noopener">图片来源</a>）</p>
<p>上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口）</p>
<ul>
<li>#1已收到ack确认的数据。</li>
<li>#2发还没收到ack的。</li>
<li>#3在窗口中还没有发出的（接收方还有空间）。</li>
<li>#4窗口以外的数据（接收方没空间）</li>
</ul>
<p>下面是个滑动后的示意图（收到36的ack，并发出了46-51的字节）：</p>
<p><img src="//blog.com/2019/01/27/TCP 的那些事儿（下）/tcpswslide.png" alt="img"></p>
<p>下面我们来看一个接受端控制发送端的图示：</p>
<p><img src="//blog.com/2019/01/27/TCP 的那些事儿（下）/tcpswflow.png" alt="img"></p>
<p>（<a href="http://www.tcpipguide.com/free/t_TCPWindowSizeAdjustmentandFlowControl-2.htm" target="_blank" rel="noopener">图片来源</a>）</p>
<h5 id="Zero-Window"><a href="#Zero-Window" class="headerlink" title="Zero Window"></a>Zero Window</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;上图，我们可以看到一个处理缓慢的Server（接收端）是怎么把Client（发送端）的TCP Sliding Window给降成0的。此时，你一定会问，如果Window变成0了，TCP会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿Window size 可用了，怎么通知发送端呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;解决这个问题，TCP使用了Zero Window Probe技术，缩写为ZWP，也就是说，发送端在窗口变成0后，会发ZWP的包给接收方，让接收方来ack他的Window尺寸，一般这个值会设置成3次，第次大约30-60秒（不同的实现可能会不一样）。如果3次过后还是0的话，有的TCP实现就会发RST把链接断了。</p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;注意</strong>：只要有等待的地方都可能出现DDoS攻击，Zero Window也不例外，一些攻击者会在和HTTP建好链发完GET请求后，就把Window设置为0，然后服务端就只能等待进行ZWP，于是攻击者会并发大量的这样的请求，把服务器端的资源耗尽。（关于这方面的攻击，大家可以移步看一下<a href="http://en.wikipedia.org/wiki/Sockstress" target="_blank" rel="noopener">Wikipedia的SockStress词条</a>）</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;另外，Wireshark中，你可以使用tcp.analysis.zero_window来过滤包，然后使用右键菜单里的follow TCP stream，你可以看到ZeroWindowProbe及ZeroWindowProbeAck的包。</p>
<h5 id="Silly-Window-Syndrome"><a href="#Silly-Window-Syndrome" class="headerlink" title="Silly Window Syndrome"></a>Silly Window Syndrome</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;Silly Window Syndrome翻译成中文就是“糊涂窗口综合症”。正如你上面看到的一样，如果我们的接收方太忙了，来不及取走Receive Windows里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的window，而我们的发送方会义无反顾地发送这几个字节。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;要知道，我们的TCP+IP头有40个字节，为了几个字节，要达上这么大的开销，这太不经济了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;另外，你需要知道网络上有个MTU，对于以太网来说，MTU是1500字节，除去TCP+IP头的40个字节，真正的数据传输可以有1460，这就是所谓的MSS（Max Segment Size）注意，TCP的RFC定义这个MSS的默认值是536，这是因为 <a href="http://tools.ietf.org/html/rfc791" target="_blank" rel="noopener">RFC 791</a>里说了任何一个IP设备都得最少接收576尺寸的大小（实际上来说576是拨号的网络的MTU，而576减去IP头的20个字节就是536）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>如果你的网络包可以塞满MTU，那么你可以用满整个带宽，如果不能，那么你就会浪费带宽</strong>。（大于MTU的包有两种结局，一种是直接被丢了，另一种是会被重新分块打包发送） 你可以想像成一个MTU就相当于一个飞机的最多可以装的人，如果这飞机里满载的话，带宽最高，如果一个飞机只运一个人的话，无疑成本增加了，也而相当二。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;所以，<strong>Silly Windows Syndrome这个现像就像是你本来可以坐200人的飞机里只做了一两个人</strong>。 要解决这个问题也不难，就是避免对小的window size做出响应，直到有足够大的window size再响应，这个思路可以同时实现在sender和receiver两端。</p>
<ul>
<li><p>如果这个问题是由Receiver端引起的，那么就会使用 David D Clark’s 方案。在receiver端，如果收到的数据导致window size小于某个值，可以直接ack(0)回sender，这样就把window给关闭了，也阻止了sender再发数据过来，等到receiver端处理了一些数据后windows size 大于等于了MSS，或者，receiver buffer有一半为空，就可以把window打开让send 发送数据过来。</p>
</li>
<li><p>如果这个问题是由Sender端引起的，那么就会使用著名的 <a href="http://en.wikipedia.org/wiki/Nagle%27s_algorithm" target="_blank" rel="noopener">Nagle’s algorithm</a>。这个算法的思路也是延时处理，他有两个主要的条件：1）要等到 Window Size&gt;=MSS 或是 Data Size &gt;=MSS，2）收到之前发送数据的ack回包，他才会发数据，否则就是在攒数据。</p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;另外，Nagle算法默认是打开的，所以，对于一些需要小包场景的程序——<strong>比如像telnet或ssh这样的交互性比较强的程序，你需要关闭这个算法</strong>。你可以在Socket设置TCP_NODELAY选项来关闭这个算法（关闭Nagle算法没有全局参数，需要根据每个应用自己的特点来关闭）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;另外，网上有些文章说TCP_CORK的socket option是也关闭Nagle算法，这不对。<strong>TCP_CORK其实是更新激进的Nagle算汉，完全禁止小包发送，而Nagle算法没有禁止小包发送，只是禁止了大量的小包发送</strong>。最好不要两个选项都设置。</p>
<h4 id="TCP的拥塞处理-–-Congestion-Handling"><a href="#TCP的拥塞处理-–-Congestion-Handling" class="headerlink" title="TCP的拥塞处理 – Congestion Handling"></a>TCP的拥塞处理 – Congestion Handling</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;上面我们知道了，TCP通过Sliding Window来做流控（Flow Control），但是TCP觉得这还不够，因为Sliding Window需要依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。TCP的设计者觉得，一个伟大而牛逼的协议仅仅做到流控并不够，因为流控只是网络模型4层以上的事，TCP的还应该更聪明地知道整个网络上的事。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;具体一点，我们知道TCP通过一个timer采样了RTT并计算RTO，但是，<strong>如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。</strong>这是一个灾难。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;所以，TCP不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此TCP的设计理念是：<strong>TCP不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。</strong></p>
<p>关于拥塞控制的论文请参看《<a href="http://ee.lbl.gov/papers/congavoid.pdf" target="_blank" rel="noopener">Congestion Avoidance and Control</a>》(PDF)</p>
<p>拥塞控制主要是四个算法：</p>
<p><strong>1）慢启动</strong></p>
<p><strong>2）拥塞避免</strong></p>
<p><strong>3）拥塞发生</strong></p>
<p><strong>4）快速恢复</strong></p>
<p>这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。 备注:</p>
<ul>
<li>1988年，TCP-Tahoe 提出了1）慢启动，2）拥塞避免，3）拥塞发生时的快速重传</li>
<li>1990年，TCP Reno 在Tahoe的基础上增加了4）快速恢复</li>
</ul>
<h5 id="慢热启动算法-–-Slow-Start"><a href="#慢热启动算法-–-Slow-Start" class="headerlink" title="慢热启动算法 – Slow Start"></a>慢热启动算法 – Slow Start</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;首先，我们来看一下TCP的慢热启动。慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来就像那些特权车一样霸道地把路占满。新同学上高速还是要慢一点，不要把已经在高速上的秩序给搞乱了。</p>
<p>慢启动的算法如下(cwnd全称Congestion Window)：</p>
<p>1）连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。</p>
<p>2）每当收到一个ACK，cwnd++; 呈线性上升</p>
<p>3）每当过了一个RTT，cwnd = cwnd*2; 呈指数让升</p>
<p>4）还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）</p>
<p>所以，我们可以看到，如果网速很快的话，ACK也会返回得快，RTT也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程。</p>
<p><img src="https://coolshell.cn/wp-content/uploads/2014/05/tcp.slow_.start_.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这里，我需要提一下的是一篇Google的论文《<a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf" target="_blank" rel="noopener">An Argument for Increasing TCP’s Initial Congestion Window</a>》Linux 3.0后采用了这篇论文的建议——把cwnd 初始化成了 10个MSS。而Linux 3.0以前，比如2.6，Linux采用了<a href="http://www.rfc-editor.org/rfc/rfc3390.txt" target="_blank" rel="noopener">RFC3390</a>，cwnd是跟MSS的值来变的，如果MSS&lt; 1095，则cwnd = 4；如果MSS&gt;2190，则cwnd=2；其它情况下，则是3。</p>
<p><strong>MSS（最大报文段长度）</strong></p>
<h5 id="拥塞避免算法-–-Congestion-Avoidance"><a href="#拥塞避免算法-–-Congestion-Avoidance" class="headerlink" title="拥塞避免算法 – Congestion Avoidance"></a>拥塞避免算法 – Congestion Avoidance</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;前面说过，还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”。一般来说<strong>ssthresh的值是65535，单位是字节</strong>，当cwnd达到这个值时后，算法如下：</p>
<p>1）收到一个ACK时，cwnd = cwnd + 1/cwnd</p>
<p>2）当每过一个RTT时，cwnd = cwnd + 1</p>
<p>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。</p>
<h5 id="拥塞状态时的算法"><a href="#拥塞状态时的算法" class="headerlink" title="拥塞状态时的算法"></a>拥塞状态时的算法</h5><p>前面我们说过，当丢包的时候，会有两种情况：</p>
<p>1）等到RTO超时，重传数据包。TCP认为这种情况太糟糕，反应也很强烈。</p>
<ul>
<li><ul>
<li>sshthresh =  cwnd /2</li>
<li>cwnd 重置为 1</li>
<li>进入慢启动过程</li>
</ul>
</li>
</ul>
<p>2）Fast Retransmit算法，也就是在收到3个duplicate ACK时就开启重传，而不用等到RTO超时。</p>
<ul>
<li><ul>
<li>TCP Tahoe的实现和RTO超时一样。</li>
</ul>
</li>
<li><ul>
<li>TCP Reno的实现是：<ul>
<li>cwnd = cwnd /2</li>
<li>sshthresh = cwnd</li>
<li>进入快速恢复算法——Fast Recovery</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;上面我们可以看到<strong>RTO超时后，sshthresh会变成cwnd的一半，这意味着，如果cwnd&lt;=sshthresh时出现的丢包，那么TCP的sshthresh就会减了一半，然后等cwnd又很快地以指数级增涨爬到这个地方时，就会成慢慢的线性增涨</strong>。我们可以看到，TCP是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。</p>
<h5 id="快速恢复算法-–-Fast-Recovery"><a href="#快速恢复算法-–-Fast-Recovery" class="headerlink" title="快速恢复算法 – Fast Recovery"></a>快速恢复算法 – Fast Recovery</h5><p><strong>TCP Reno</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这个算法定义在<a href="http://tools.ietf.org/html/rfc5681" target="_blank" rel="noopener">RFC5681</a>。快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有3个Duplicated Acks说明网络也不那么糟糕，所以没有必要像RTO超时那么强烈。 注意，正如前面所说，进入Fast Recovery之前，cwnd 和 sshthresh已被更新：</p>
<ul>
<li>cwnd = cwnd /2</li>
<li>sshthresh = cwnd</li>
</ul>
<p>然后，真正的Fast Recovery算法如下：</p>
<ul>
<li>cwnd = sshthresh  + 3 * MSS （3的意思是确认有3个数据包被收到了）</li>
<li>重传Duplicated ACKs指定的数据包</li>
<li>如果再收到 duplicated Acks，那么cwnd = cwnd +1</li>
<li>如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果你仔细思考一下上面的这个算法，你就会知道，<strong>上面这个算法也有问题，那就是——它依赖于3个重复的Acks</strong>。注意，3个重复的Acks并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到RTO超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成TCP的传输速度呈级数下降，而且也不会触发Fast Recovery算法了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;通常来说，正如我们前面所说的，SACK或D-SACK的方法可以让Fast Recovery或Sender在做决定时更聪明一些，但是并不是所有的TCP的实现都支持SACK（SACK需要两端都支持），所以，需要一个没有SACK的解决方案。而通过SACK进行拥塞控制的算法是FACK（后面会讲）</p>
<p><strong>TCP New Reno</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;于是，1995年，TCP New Reno（参见 <a href="http://tools.ietf.org/html/rfc6582" target="_blank" rel="noopener">RFC 6582</a> ）算法提出来，主要就是在没有SACK的支持下改进Fast Recovery算法的——</p>
<ul>
<li><p>当sender这边收到了3个Duplicated Acks，进入Fast Retransimit模式，开发重传重复Acks指示的那个包。如果只有这一个包丢了，那么，重传这个包后回来的Ack会把整个已经被sender传输出去的数据ack回来。如果没有的话，说明有多个包丢了。我们叫这个ACK为Partial ACK。</p>
</li>
<li><p>一旦Sender这边发现了Partial ACK出现，那么，sender就可以推理出来有多个包被丢了，于是乎继续重传sliding window里未被ack的第一个包。直到再也收不到了Partial Ack，才真正结束Fast Recovery这个过程</p>
</li>
</ul>
<p>我们可以看到，这个“Fast Recovery的变更”是一个非常激进的玩法，他同时延长了Fast Retransmit和Fast Recovery的过程。</p>
<h5 id="算法示意图"><a href="#算法示意图" class="headerlink" title="算法示意图"></a>算法示意图</h5><p>下面我们来看一个简单的图示以同时看一下上面的各种算法的样子：</p>
<p><img src="https://coolshell.cn/wp-content/uploads/2014/05/tcp.fr_-1024x359.jpg" alt="img"></p>
<h5 id="FACK算法"><a href="#FACK算法" class="headerlink" title="FACK算法"></a>FACK算法</h5><p>FACK全称Forward Acknowledgment 算法，论文地址在这里（PDF）<a href="http://conferences.sigcomm.org/sigcomm/1996/papers/mathis.pdf" target="_blank" rel="noopener">Forward Acknowledgement: Refining TCP Congestion Control</a> 这个算法是其于SACK的，前面我们说过SACK是使用了TCP扩展字段Ack了有哪些数据收到，哪些数据没有收到，他比Fast Retransmit的3 个duplicated acks好处在于，前者只知道有包丢了，不知道是一个还是多个，而SACK可以准确的知道有哪些包丢了。 所以，SACK可以让发送端这边在重传过程中，把那些丢掉的包重传，而不是一个一个的传，但这样的一来，如果重传的包数据比较多的话，又会导致本来就很忙的网络就更忙了。所以，FACK用来做重传过程中的拥塞流控。</p>
<ul>
<li><p>这个算法会把SACK中最大的Sequence Number 保存在<strong>snd.fack</strong>这个变量中，snd.fack的更新由ack带秋，如果网络一切安好则和snd.una一样（snd.una就是还没有收到ack的地方，也就是前面sliding window里的category #2的第一个地方）</p>
</li>
<li><p>然后定义一个<strong>awnd = snd.nxt – snd.fack</strong>（snd.nxt指向发送端sliding window中正在要被发送的地方——前面sliding windows图示的category#3第一个位置），这样awnd的意思就是在网络上的数据。（所谓awnd意为：actual quantity of data outstanding in the network）</p>
</li>
<li><p>如果需要重传数据，那么，<strong>awnd = snd.nxt – snd.fack + retran_data</strong>，也就是说，awnd是传出去的数据 + 重传的数据。</p>
</li>
<li><p>然后触发Fast Recovery 的条件是： ( <strong>( snd.fack – snd.una ) &gt; (3*MSS)</strong> ) || (dupacks == 3) ) 。这样一来，就不需要等到3个duplicated acks才重传，而是只要sack中的最大的一个数据和ack的数据比较长了（3个MSS），那就触发重传。在整个重传过程中cwnd不变。直到当第一次丢包的snd.nxt&lt;=snd.una（也就是重传的数据都被确认了），然后进来拥塞避免机制——cwnd线性上涨。</p>
</li>
</ul>
<p>我们可以看到如果没有FACK在，那么在丢包比较多的情况下，原来保守的算法会低估了需要使用的window的大小，而需要几个RTT的时间才会完成恢复，而FACK会比较激进地来干这事。 但是，FACK如果在一个网络包会被 reordering的网络里会有很大的问题。</p>
<h4 id="其它拥塞控制算法简介"><a href="#其它拥塞控制算法简介" class="headerlink" title="其它拥塞控制算法简介"></a>其它拥塞控制算法简介</h4><h5 id="TCP-Vegas-拥塞控制算法"><a href="#TCP-Vegas-拥塞控制算法" class="headerlink" title="TCP Vegas 拥塞控制算法"></a><strong>TCP Vegas 拥塞控制算法</strong></h5><p>&nbsp;&nbsp;&nbsp;&nbsp;这个算法1994年被提出，它主要对TCP Reno 做了些修改。这个算法通过对RTT的非常重的监控来计算一个基准RTT。然后通过这个基准RTT来估计当前的网络实际带宽，如果实际带宽比我们的期望的带宽要小或是要多的活，那么就开始线性地减少或增加cwnd的大小。如果这个计算出来的RTT大于了Timeout后，那么，不等ack超时就直接重传。（Vegas 的核心思想是用RTT的值来影响拥塞窗口，而不是通过丢包） 这个算法的论文是《<a href="http://www.cs.cmu.edu/~srini/15-744/F02/readings/BP95.pdf" target="_blank" rel="noopener">TCP Vegas: End to End Congestion Avoidance on a Global Internet</a>》这篇论文给了Vegas和 New Reno的对比：</p>
<p><img src="https://coolshell.cn/wp-content/uploads/2014/05/tcp_vegas_newreno-1024x555.jpg" alt="img"></p>
<p>关于这个算法实现，你可以参看Linux源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.h" target="_blank" rel="noopener">/net/ipv4/tcp_vegas.h</a>， <a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.c" target="_blank" rel="noopener">/net/ipv4/tcp_vegas.c</a></p>
<p>##### </p>
<h5 id="HSTCP-High-Speed-TCP-算法"><a href="#HSTCP-High-Speed-TCP-算法" class="headerlink" title="HSTCP(High Speed TCP) 算法"></a>HSTCP(High Speed TCP) 算法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;这个算法来自<a href="http://tools.ietf.org/html/rfc3649" target="_blank" rel="noopener">RFC 3649</a>（<a href="http://en.wikipedia.org/wiki/HSTCP" target="_blank" rel="noopener">Wikipedia词条</a>）。其对最基础的算法进行了更改，他使得Congestion Window涨得快，减得慢。其中：</p>
<ul>
<li>拥塞避免时的窗口增长方式： cwnd = cwnd + α(cwnd) / cwnd</li>
<li>丢包后窗口下降方式：cwnd = (1- β(cwnd))*cwnd</li>
</ul>
<p>注：α(cwnd)和β(cwnd)都是函数，如果你要让他们和标准的TCP一样，那么让α(cwnd)=1，β(cwnd)=0.5就可以了。 对于α(cwnd)和β(cwnd)的值是个动态的变换的东西。 关于这个算法的实现，你可以参看Linux源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_highspeed.c" target="_blank" rel="noopener">/net/ipv4/tcp_highspeed.c</a></p>
<h5 id="TCP-BIC-算法"><a href="#TCP-BIC-算法" class="headerlink" title="TCP BIC 算法"></a>TCP BIC 算法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;2004年，产内出BIC算法。现在你还可以查得到相关的新闻《Google：<a href="https://www.google.com/search?lr=lang_zh-CN%7Clang_zh-TW&amp;newwindow=1&amp;biw=1366&amp;bih=597&amp;tbs=lr%3Alang_1zh-CN%7Clang_1zh-TW&amp;q=%E7%BE%8E%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%A0%94%E5%8F%91BIC-TCP%E5%8D%8F%E8%AE%AE+%E9%80%9F%E5%BA%A6%E6%98%AFDSL%E5%85%AD%E5%8D%83%E5%80%8D&amp;oq=%E7%BE%8E%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%A0%94%E5%8F%91BIC-TCP%E5%8D%8F%E8%AE%AE+%E9%80%9F%E5%BA%A6%E6%98%AFDSL%E5%85%AD%E5%8D%83%E5%80%8D" target="_blank" rel="noopener">美科学家研发BIC-TCP协议 速度是DSL六千倍</a>》 BIC全称<a href="http://research.csc.ncsu.edu/netsrv/?q=content/bic-and-cubic" target="_blank" rel="noopener">Binary Increase Congestion control</a>，在Linux 2.6.8中是默认拥塞控制算法。BIC的发明者发这么多的拥塞控制算法都在努力找一个合适的cwnd – Congestion Window，而且BIC-TCP的提出者们看穿了事情的本质，其实这就是一个搜索的过程，所以BIC这个算法主要用的是Binary Search——二分查找来干这个事。 关于这个算法实现，你可以参看Linux源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_bic.c" target="_blank" rel="noopener">/net/ipv4/tcp_bic.c</a></p>
<h5 id="TCP-WestWood算法"><a href="#TCP-WestWood算法" class="headerlink" title="TCP WestWood算法"></a>TCP WestWood算法</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;westwood采用和Reno相同的慢启动算法、拥塞避免算法。westwood的主要改进方面：在发送端做带宽估计，当探测到丢包时，根据带宽值来设置拥塞窗口、慢启动阈值。 那么，这个算法是怎么测量带宽的？每个RTT时间，会测量一次带宽，测量带宽的公式很简单，就是这段RTT内成功被ack了多少字节。因为，这个带宽和用RTT计算RTO一样，也是需要从每个样本来平滑到一个值的——也是用一个加权移平均的公式。 另外，我们知道，如果一个网络的带宽是每秒可以发送X个字节，而RTT是一个数据发出去后确认需要的时候，所以，X <em> RTT应该是我们缓冲区大小。所以，在这个算法中，ssthresh的值就是est_BD </em> min-RTT(最小的RTT值)，如果丢包是Duplicated ACKs引起的，那么如果cwnd &gt; ssthresh，则 cwin = ssthresh。如果是RTO引起的，cwnd = 1，进入慢启动。   关于这个算法实现，你可以参看Linux源码： <a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_westwood.c" target="_blank" rel="noopener">/net/ipv4/tcp_westwood.c</a></p>
<h5 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h5><p>更多的算法，你可以从Wikipedia的 <a href="http://en.wikipedia.org/wiki/TCP_congestion-avoidance_algorithm" target="_blank" rel="noopener">TCP Congestion Avoidance Algorithm</a> 词条中找到相关的线索</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/01/27/cron 秒级控制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/27/cron 秒级控制/" itemprop="url">cron 秒级控制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-27T12:12:57+08:00">
                2019-01-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/定时任务/" itemprop="url" rel="index">
                    <span itemprop="name">定时任务</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/定时任务/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/定时任务/Linux/Cron/" itemprop="url" rel="index">
                    <span itemprop="name">Cron</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="cron-秒级控制"><a href="#cron-秒级控制" class="headerlink" title="cron 秒级控制"></a>cron 秒级控制</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://laravel-china.org/articles/22826" target="_blank" rel="noopener">https://laravel-china.org/articles/22826</a></p>
</blockquote>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>使用 <code>crontab</code> 每隔5秒执行一个脚本</p>
<h3 id="纠正"><a href="#纠正" class="headerlink" title="纠正"></a>纠正</h3><p><code>crontab</code> 最小调度单位是「分钟」，没法控制到「秒」.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/<span class="number">5</span> * * * * /path/to/script</span><br></pre></td></tr></table></figure>
<p>这里的 <code>/</code> 是指「步长」，意思是每隔5分钟执行一次脚本.</p>
<p><code>crontab</code> 详细用法参考：<a href="https://github.com/codcodog/Blog/issues/92" target="_blank" rel="noopener">Crontab 用法</a></p>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>编写脚本</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat cron_seconds.sh</span><br><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">  SCRIPT <span class="comment"># 脚本的执行路径</span></span><br><span class="line">  sleep 5</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p><code>cron</code> 定时任务设置</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * /path/to/cron_seconds.sh</span><br></pre></td></tr></table></figure>
<h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ crontab -l</span><br><span class="line">* * * * * /path/to/script</span><br><span class="line">* * * * * sleep <span class="number">5</span>;/path/to/script</span><br><span class="line">* * * * * sleep <span class="number">10</span>;/path/to/script</span><br><span class="line">* * * * * sleep <span class="number">15</span>;/path/to/script</span><br><span class="line">* * * * * sleep <span class="number">20</span>;/path/to/script</span><br><span class="line">* * * * * sleep <span class="number">25</span>;/path/to/script</span><br><span class="line">* * * * * sleep <span class="number">30</span>;/path/to/script</span><br><span class="line">* * * * * sleep <span class="number">35</span>;/path/to/script</span><br><span class="line">* * * * * sleep <span class="number">40</span>;/path/to/script</span><br><span class="line">* * * * * sleep <span class="number">45</span>;/path/to/script</span><br><span class="line">* * * * * sleep <span class="number">50</span>;/path/to/script</span><br><span class="line">* * * * * sleep <span class="number">55</span>;/path/to/script</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/01/27/Lucene-全文检索的基本原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/27/Lucene-全文检索的基本原理/" itemprop="url">Lucene-全文检索的基本原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-27T12:12:57+08:00">
                2019-01-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/服务器/" itemprop="url" rel="index">
                    <span itemprop="name">服务器</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/服务器/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/服务器/架构/搜索引擎/" itemprop="url" rel="index">
                    <span itemprop="name">搜索引擎</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/服务器/架构/搜索引擎/Elasticsearch/" itemprop="url" rel="index">
                    <span itemprop="name">Elasticsearch</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/服务器/架构/搜索引擎/Elasticsearch/Lucene/" itemprop="url" rel="index">
                    <span itemprop="name">Lucene</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Lucene-全文检索的基本原理"><a href="#Lucene-全文检索的基本原理" class="headerlink" title="Lucene-全文检索的基本原理"></a>Lucene-全文检索的基本原理</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="http://www.cnblogs.com/guochunguang/articles/3641008.html" target="_blank" rel="noopener">http://www.cnblogs.com/guochunguang/articles/3641008.html</a></p>
</blockquote>
<h2 id="一、总论"><a href="#一、总论" class="headerlink" title="一、总论"></a>一、总论</h2><p>根据<a href="http://lucene.apache.org/java/docs/index.html" target="_blank" rel="noopener">http://lucene.apache.org/java/docs/index.html</a>定义：</p>
<p><strong>Lucene**</strong>是一个高效的，基于Java<strong>**的全文检索库。</strong></p>
<p>所以在了解Lucene之前要费一番工夫了解一下全文检索。</p>
<p>那么什么叫做全文检索呢？这要从我们生活中的数据说起。</p>
<p>我们生活中的数据总体分为两种：<strong>结构化数据</strong>和<strong>非结构化数据</strong>。</p>
<ul>
<li><strong>结构化数据：</strong>指具有固定格式或有限长度的数据，如数据库，元数据等。</li>
<li><strong>非结构化数据：</strong>指不定长或无固定格式的数据，如邮件，word文档等。</li>
</ul>
<p>当然有的地方还会提到第三种，半结构化数据，如XML，HTML等，当根据需要可按结构化数据来处理，也可抽取出纯文本按非结构化数据来处理。</p>
<p><strong>非结构化数据又一种叫法叫全文数据。</strong></p>
<p>按照数据的分类，搜索也分为两种：</p>
<ul>
<li><strong>对结构化数据的搜索</strong>：如对数据库的搜索，用SQL语句。再如对元数据的搜索，如利用windows搜索对文件名，类型，修改时间进行搜索等。</li>
<li><strong>对非结构化数据的搜索</strong>：如利用windows的搜索也可以搜索文件内容，Linux下的grep命令，再如用Google和百度可以搜索大量内容数据。</li>
</ul>
<p>对非结构化数据也即对全文数据的搜索主要有两种方法：</p>
<p>一种是<strong>顺序扫描法</strong>(Serial Scanning)：所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用windows的搜索也可以搜索文件内容，只是相当的慢。如果你有一个80G硬盘，如果想在上面找到一个内容包含某字符串的文件，不花他几个小时，怕是做不到。Linux下的grep命令也是这一种方式。大家可能觉得这种方法比较原始，但对于小数据量的文件，这种方法还是最直接，最方便的。但是对于大量的文件，这种方法就很慢了。</p>
<p>有人可能会说，对非结构化数据顺序扫描很慢，对结构化数据的搜索却相对较快（由于结构化数据有一定的结构可以采取一定的搜索算法加快速度），那么把我们的非结构化数据想办法弄得有一定结构不就行了吗？</p>
<p>这种想法很天然，却构成了全文检索的基本思路，也即将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。</p>
<p>这部分从非结构化数据中提取出的然后重新组织的信息，我们称之<strong>索引</strong>。</p>
<p>这种说法比较抽象，举几个例子就很容易明白，比如字典，字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。</p>
<p><strong>这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)**</strong>。**</p>
<p>下面这幅图来自《Lucene in action》，但却不仅仅描述了Lucene的检索过程，而是描述了全文检索的一般过程。</p>
<p><img src="//blog.com/2019/01/27/Lucene-全文检索的基本原理/1.png" alt="image"></p>
<p>全文检索大体分两个过程，<strong>索引创建**</strong>(Indexing)<strong>和</strong>搜索索引<strong>**(Search)</strong>。</p>
<ul>
<li>索引创建：将现实世界中所有的结构化和非结构化数据提取信息，创建索引的过程。</li>
<li>搜索索引：就是得到用户的查询请求，搜索创建的索引，然后返回结果的过程。</li>
</ul>
<p>于是全文检索就存在三个重要问题：</p>
<p><strong>1.</strong> <strong>索引里面究竟存些什么？(Index)</strong></p>
<p><strong>2.</strong> <strong>如何创建索引？(Indexing)</strong></p>
<p><strong>3.</strong> <strong>如何对索引进行搜索？(Search)</strong></p>
<p>下面我们顺序对每个个问题进行研究。</p>
<h2 id="二、索引里面究竟存些什么"><a href="#二、索引里面究竟存些什么" class="headerlink" title="二、索引里面究竟存些什么"></a>二、索引里面究竟存些什么</h2><p>索引里面究竟需要存些什么呢？</p>
<p>首先我们来看为什么顺序扫描的速度慢：</p>
<p>其实是由于我们想要搜索的信息和非结构化数据中所存储的信息不一致造成的。</p>
<p>非结构化数据中所存储的信息是每个文件包含哪些字符串，也即已知文件，欲求字符串相对容易，也即是从文件到字符串的映射。而我们想搜索的信息是哪些文件包含此字符串，也即已知字符串，欲求文件，也即从字符串到文件的映射。两者恰恰相反。于是如果索引总能够保存从字符串到文件的映射，则会大大提高搜索速度。</p>
<p>由于从字符串到文件的映射是文件到字符串映射的反向过程，于是保存这种信息的索引称为<strong>反向索引</strong>。</p>
<p>反向索引的所保存的信息一般如下：</p>
<p>假设我的文档集合里面有100篇文档，为了方便表示，我们为文档编号从1到100，得到下面的结构</p>
<p><img src="//blog.com/2019/01/27/Lucene-全文检索的基本原理/2.jpg" alt="inverted index"></p>
<p>左边保存的是一系列字符串，称为<strong>词典</strong>。</p>
<p>每个字符串都指向包含此字符串的文档(Document)链表，此文档链表称为<strong>倒排表</strong>(Posting List)。</p>
<p>有了索引，便使保存的信息和要搜索的信息一致，可以大大加快搜索的速度。</p>
<p>比如说，我们要寻找既包含字符串“lucene”又包含字符串“solr”的文档，我们只需要以下几步：</p>
<ol>
<li>取出包含字符串“lucene”的文档链表。</li>
<li>取出包含字符串“solr”的文档链表。</li>
<li>通过合并链表，找出既包含“lucene”又包含“solr”的文件。</li>
</ol>
<p><img src="//blog.com/2019/01/27/Lucene-全文检索的基本原理/3.jpg" alt="inverted index merge"></p>
<p>看到这个地方，有人可能会说，全文检索的确加快了搜索的速度，但是多了索引的过程，两者加起来不一定比顺序扫描快多少。的确，加上索引的过程，全文检索不一定比顺序扫描快，尤其是在数据量小的时候更是如此。而对一个很大量的数据创建索引也是一个很慢的过程。</p>
<p>然而两者还是有区别的，顺序扫描是每次都要扫描，而创建索引的过程仅仅需要一次，以后便是一劳永逸的了，每次搜索，创建索引的过程不必经过，仅仅搜索创建好的索引就可以了。</p>
<p><strong>这也是全文搜索相对于顺序扫描的优势之一：一次索引，多次使用。</strong></p>
<h2 id="三、如何创建索引"><a href="#三、如何创建索引" class="headerlink" title="三、如何创建索引"></a>三、如何创建索引</h2><p>全文检索的索引创建过程一般有以下几步：</p>
<h3 id="第一步：一些要索引的原文档-Document-。"><a href="#第一步：一些要索引的原文档-Document-。" class="headerlink" title="第一步：一些要索引的原文档(Document)。"></a><strong>第一步：一些要索引的原文档(Document)。</strong></h3><p>为了方便说明索引创建过程，这里特意用两个文件为例：</p>
<p>文件一：Students should be allowed to go out with their friends, but not allowed to drink beer.</p>
<p>文件二：My friend Jerry went to school to see his students but found them drunk which is not allowed.</p>
<h3 id="第二步：将原文档传给分次组件-Tokenizer-。"><a href="#第二步：将原文档传给分次组件-Tokenizer-。" class="headerlink" title="第二步：将原文档传给分次组件(Tokenizer)。"></a><strong>第二步：将原文档传给分次组件(Tokenizer)。</strong></h3><p><strong>分词组件(Tokenizer)会做以下几件事情(**</strong>此过程称为Tokenize)<strong>**：</strong></p>
<p><strong>1.</strong> <strong>将文档分成一个一个单独的单词。</strong></p>
<p><strong>2.</strong> <strong>去除标点符号。</strong></p>
<p><strong>3.</strong> <strong>去除停词(Stop word)**</strong>。**</p>
<p>所谓停词(Stop word)就是一种语言中最普通的一些单词，由于没有特别的意义，因而大多数情况下不能成为搜索的关键词，因而创建索引时，这种词会被去掉而减少索引的大小。</p>
<p>英语中挺词(Stop word)如：“the”,“a”，“this”等。</p>
<p>对于每一种语言的分词组件(Tokenizer)，都有一个停词(stop word)集合。</p>
<p><strong>经过分词(Tokenizer)**</strong>后得到的结果称为词元(Token)<strong>**。</strong></p>
<p>在我们的例子中，便得到以下词元(Token)：</p>
<p>“Students”，“allowed”，“go”，“their”，“friends”，“allowed”，“drink”，“beer”，“My”，“friend”，“Jerry”，“went”，“school”，“see”，“his”，“students”，“found”，“them”，“drunk”，“allowed”。</p>
<h3 id="第三步：将得到的词元-Token-传给语言处理组件-Linguistic-Processor-。"><a href="#第三步：将得到的词元-Token-传给语言处理组件-Linguistic-Processor-。" class="headerlink" title="第三步：将得到的词元(Token)传给语言处理组件(Linguistic Processor)。"></a><strong>第三步：将得到的词元(Token)传给语言处理组件(Linguistic Processor)。</strong></h3><p>语言处理组件(linguistic processor)主要是对得到的词元(Token)做一些同语言相关的处理。</p>
<p><strong>对于英语，语言处理组件(Linguistic Processor)**</strong>一般做以下几点：**</p>
<p><strong>1.</strong> <strong>变为小写(Lowercase)**</strong>。**</p>
<p><strong>2.</strong> <strong>将单词缩减为词根形式，如“cars**</strong>”到“car<strong><strong>”等。这种操作称为：stemming</strong></strong>。**</p>
<p><strong>3.</strong> <strong>将单词转变为词根形式，如“drove**</strong>”到“drive<strong><strong>”等。这种操作称为：lemmatization</strong></strong>。**</p>
<p><strong>Stemming 和 lemmatization的异同：</strong></p>
<ul>
<li>相同之处：Stemming和lemmatization都要使词汇成为词根形式。</li>
<li>两者的方式不同：<ul>
<li>Stemming采用的是“缩减”的方式：“cars”到“car”，“driving”到“drive”。</li>
<li>Lemmatization采用的是“转变”的方式：“drove”到“drove”，“driving”到“drive”。</li>
</ul>
</li>
<li>两者的算法不同：<ul>
<li>Stemming主要是采取某种固定的算法来做这种缩减，如去除“s”，去除“ing”加“e”，将“ational”变为“ate”，将“tional”变为“tion”。</li>
<li>Lemmatization主要是采用保存某种字典的方式做这种转变。比如字典中有“driving”到“drive”，“drove”到“drive”，“am, is, are”到“be”的映射，做转变时，只要查字典就可以了。</li>
</ul>
</li>
<li>Stemming和lemmatization不是互斥关系，是有交集的，有的词利用这两种方式都能达到相同的转换。</li>
</ul>
<p><strong>语言处理组件(linguistic processor)的结果称为词(Term)</strong>。</p>
<p>在我们的例子中，经过语言处理，得到的词(Term)如下：</p>
<p>“student”，“allow”，“go”，“their”，“friend”，“allow”，“drink”，“beer”，“my”，“friend”，“jerry”，“go”，“school”，“see”，“his”，“student”，“find”，“them”，“drink”，“allow”。</p>
<p>也正是因为有语言处理的步骤，才能使搜索drove，而drive也能被搜索出来。</p>
<h3 id="第四步：将得到的词-Term-传给索引组件-Indexer-。"><a href="#第四步：将得到的词-Term-传给索引组件-Indexer-。" class="headerlink" title="第四步：将得到的词(Term)传给索引组件(Indexer)。"></a><strong>第四步：将得到的词(Term)传给索引组件(Indexer)。</strong></h3><p><strong>索引</strong>组件(Indexer)主要做以下几件事情：</p>
<p><strong>1. 利用得到的词(Term)创建一个字典。</strong></p>
<p>在我们的例子中字典如下：</p>
<table>
<thead>
<tr>
<th>Term</th>
<th>Document ID</th>
</tr>
</thead>
<tbody>
<tr>
<td>student</td>
<td>1</td>
</tr>
<tr>
<td>allow</td>
<td>1</td>
</tr>
<tr>
<td>go</td>
<td>1</td>
</tr>
<tr>
<td>their</td>
<td>1</td>
</tr>
<tr>
<td>friend</td>
<td>1</td>
</tr>
<tr>
<td>allow</td>
<td>1</td>
</tr>
<tr>
<td>drink</td>
<td>1</td>
</tr>
<tr>
<td>beer</td>
<td>1</td>
</tr>
<tr>
<td>my</td>
<td>2</td>
</tr>
<tr>
<td>friend</td>
<td>2</td>
</tr>
<tr>
<td>jerry</td>
<td>2</td>
</tr>
<tr>
<td>go</td>
<td>2</td>
</tr>
<tr>
<td>school</td>
<td>2</td>
</tr>
<tr>
<td>see</td>
<td>2</td>
</tr>
<tr>
<td>his</td>
<td>2</td>
</tr>
<tr>
<td>student</td>
<td>2</td>
</tr>
<tr>
<td>find</td>
<td>2</td>
</tr>
<tr>
<td>them</td>
<td>2</td>
</tr>
<tr>
<td>drink</td>
<td>2</td>
</tr>
<tr>
<td>allow</td>
<td>2</td>
</tr>
</tbody>
</table>
<p><strong>2.</strong> <strong>对字典按字母顺序进行排序。</strong></p>
<table>
<thead>
<tr>
<th>Term</th>
<th>Document ID</th>
</tr>
</thead>
<tbody>
<tr>
<td>allow</td>
<td>1</td>
</tr>
<tr>
<td>allow</td>
<td>1</td>
</tr>
<tr>
<td>allow</td>
<td>2</td>
</tr>
<tr>
<td>beer</td>
<td>1</td>
</tr>
<tr>
<td>drink</td>
<td>1</td>
</tr>
<tr>
<td>drink</td>
<td>2</td>
</tr>
<tr>
<td>find</td>
<td>2</td>
</tr>
<tr>
<td>friend</td>
<td>1</td>
</tr>
<tr>
<td>friend</td>
<td>2</td>
</tr>
<tr>
<td>go</td>
<td>1</td>
</tr>
<tr>
<td>go</td>
<td>2</td>
</tr>
<tr>
<td>his</td>
<td>2</td>
</tr>
<tr>
<td>jerry</td>
<td>2</td>
</tr>
<tr>
<td>my</td>
<td>2</td>
</tr>
<tr>
<td>school</td>
<td>2</td>
</tr>
<tr>
<td>see</td>
<td>2</td>
</tr>
<tr>
<td>student</td>
<td>1</td>
</tr>
<tr>
<td>student</td>
<td>2</td>
</tr>
<tr>
<td>their</td>
<td>1</td>
</tr>
<tr>
<td>them</td>
<td>2</td>
</tr>
</tbody>
</table>
<p><strong>3.</strong> <strong>合并相同的词(Term)</strong>成为文档倒排(Posting List)<strong>链表</strong>。</p>
<p><img src="//blog.com/2019/01/27/Lucene-全文检索的基本原理/4.jpg" alt="postinglist"></p>
<p>在此表中，有几个定义：</p>
<ul>
<li>Document Frequency 即文档频次，表示总共有多少文件包含此词(Term)。</li>
<li>Frequency 即词频率，表示此文件中包含了几个此词(Term)。</li>
</ul>
<p>所以对词(Term) “allow”来讲，总共有两篇文档包含此词(Term)，从而词(Term)后面的文档链表总共有两项，第一项表示包含“allow”的第一篇文档，即1号文档，此文档中，“allow”出现了2次，第二项表示包含“allow”的第二个文档，是2号文档，此文档中，“allow”出现了1次。</p>
<p>到此为止，索引已经创建好了，我们可以通过它很快的找到我们想要的文档。</p>
<p>而且在此过程中，我们惊喜地发现，搜索“drive”，“driving”，“drove”，“driven”也能够被搜到。因为在我们的索引中，“driving”，“drove”，“driven”都会经过语言处理而变成“drive”，在搜索时，如果您输入“driving”，输入的查询语句同样经过我们这里的一到三步，从而变为查询“drive”，从而可以搜索到想要的文档。</p>
<h2 id="三、如何对索引进行搜索？"><a href="#三、如何对索引进行搜索？" class="headerlink" title="三、如何对索引进行搜索？"></a>三、如何对索引进行搜索？</h2><p>到这里似乎我们可以宣布“我们找到想要的文档了”。</p>
<p>然而事情并没有结束，找到了仅仅是全文检索的一个方面。不是吗？如果仅仅只有一个或十个文档包含我们查询的字符串，我们的确找到了。然而如果结果有一千个，甚至成千上万个呢？那个又是您最想要的文件呢？</p>
<p>打开Google吧，比如说您想在微软找份工作，于是您输入“Microsoft job”，您却发现总共有22600000个结果返回。好大的数字呀，突然发现找不到是一个问题，找到的太多也是一个问题。在如此多的结果中，如何将最相关的放在最前面呢？</p>
<p><img src="//blog.com/2019/01/27/Lucene-全文检索的基本原理/5.jpg" alt=""></p>
<p>当然Google做的很不错，您一下就找到了jobs at Microsoft。想象一下，如果前几个全部是“Microsoft does a good job at software industry…”将是多么可怕的事情呀。</p>
<p>如何像Google一样，在成千上万的搜索结果中，找到和查询语句最相关的呢？</p>
<p>如何判断搜索出的文档和查询语句的相关性呢？</p>
<p>这要回到我们第三个问题：如何对索引进行搜索？</p>
<p>搜索主要分为以下几步：</p>
<h3 id="第一步：用户输入查询语句。"><a href="#第一步：用户输入查询语句。" class="headerlink" title="第一步：用户输入查询语句。"></a><strong>第一步：用户输入查询语句。</strong></h3><p>查询语句同我们普通的语言一样，也是有一定语法的。</p>
<p>不同的查询语句有不同的语法，如SQL语句就有一定的语法。</p>
<p>查询语句的语法根据全文检索系统的实现而不同。最基本的有比如：AND, OR, NOT等。</p>
<p>举个例子，用户输入语句：lucene AND learned NOT hadoop。</p>
<p>说明用户想找一个包含lucene和learned然而不包括hadoop的文档。</p>
<h3 id="第二步：对查询语句进行词法分析，语法分析，及语言处理。"><a href="#第二步：对查询语句进行词法分析，语法分析，及语言处理。" class="headerlink" title="第二步：对查询语句进行词法分析，语法分析，及语言处理。"></a><strong>第二步：对查询语句进行词法分析，语法分析，及语言处理。</strong></h3><p>由于查询语句有语法，因而也要进行语法分析，语法分析及语言处理。</p>
<p><strong>1. 词法分析主要用来识别单词和关键字。</strong></p>
<p>如上述例子中，经过词法分析，得到单词有lucene，learned，hadoop, 关键字有AND, NOT。</p>
<p>如果在词法分析中发现不合法的关键字，则会出现错误。如lucene AMD learned，其中由于AND拼错，导致AMD作为一个普通的单词参与查询。</p>
<p><strong>2. 语法分析主要是根据查询语句的语法规则来形成一棵语法树。</strong></p>
<p>如果发现查询语句不满足语法规则，则会报错。如lucene NOT AND learned，则会出错。</p>
<p>如上述例子，lucene AND learned NOT hadoop形成的语法树如下：</p>
<p><img src="//blog.com/2019/01/27/Lucene-全文检索的基本原理/6.jpg" alt="语法树"></p>
<p><strong>3. 语言处理同索引过程中的语言处理几乎相同。</strong></p>
<p>如learned变成learn等。</p>
<p>经过第二步，我们得到一棵经过语言处理的语法树。</p>
<p><img src="//blog.com/2019/01/27/Lucene-全文检索的基本原理/7.jpg" alt="语法树1"></p>
<h3 id="第三步：搜索索引，得到符合语法树的文档。"><a href="#第三步：搜索索引，得到符合语法树的文档。" class="headerlink" title="第三步：搜索索引，得到符合语法树的文档。"></a><strong>第三步：搜索索引，得到符合语法树的文档。</strong></h3><p>此步骤有分几小步：</p>
<ol>
<li>首先，在反向索引表中，分别找出包含lucene，learn，hadoop的文档链表。</li>
<li>其次，对包含lucene，learn的链表进行合并操作，得到既包含lucene又包含learn的文档链表。</li>
<li>然后，将此链表与hadoop的文档链表进行差操作，去除包含hadoop的文档，从而得到既包含lucene又包含learn而且不包含hadoop的文档链表。</li>
<li>此文档链表就是我们要找的文档。</li>
</ol>
<h3 id="第四步：根据得到的文档和查询语句的相关性，对结果进行排序。"><a href="#第四步：根据得到的文档和查询语句的相关性，对结果进行排序。" class="headerlink" title="第四步：根据得到的文档和查询语句的相关性，对结果进行排序。"></a><strong>第四步：根据得到的文档和查询语句的相关性，对结果进行排序。</strong></h3><p>虽然在上一步，我们得到了想要的文档，然而对于查询结果应该按照与查询语句的相关性进行排序，越相关者越靠前。</p>
<p>如何计算文档和查询语句的相关性呢？</p>
<p>不如我们把查询语句看作一片短小的文档，对文档与文档之间的相关性(relevance)进行打分(scoring)，分数高的相关性好，就应该排在前面。</p>
<p>那么又怎么对文档之间的关系进行打分呢？</p>
<p><strong>这可不是一件容易的事情，首先我们看一看判断人之间的关系吧。</strong></p>
<p><strong>首先</strong>看一个人，往往有很多<strong>要素</strong>，如性格，信仰，爱好，衣着，高矮，胖瘦等等。</p>
<p><strong>其次</strong>对于人与人之间的关系，<strong>不同的要素重要性不同</strong>，性格，信仰，爱好可能重要些，衣着，高矮，胖瘦可能就不那么重要了，所以具有相同或相似性格，信仰，爱好的人比较容易成为好的朋友，然而衣着，高矮，胖瘦不同的人，也可以成为好的朋友。</p>
<p>因而判断人与人之间的关系，<strong>首先要找出哪些要素对人与人之间的关系最重要</strong>，比如性格，信仰，爱好。<strong>其次要判断两个人的这些要素之间的关系</strong>，比如一个人性格开朗，另一个人性格外向，一个人信仰佛教，另一个信仰上帝，一个人爱好打篮球，另一个爱好踢足球。我们发现，两个人在性格方面都很积极，信仰方面都很善良，爱好方面都爱运动，因而两个人关系应该会很好。</p>
<p><strong>我们再来看看公司之间的关系吧。</strong></p>
<p><strong>首先</strong>看一个公司，有很多人组成，如总经理，经理，首席技术官，普通员工，保安，门卫等。</p>
<p><strong>其次对于公司与公司之间的关系，不同的人重要性不同</strong>，总经理，经理，首席技术官可能更重要一些，普通员工，保安，门卫可能较不重要一点。所以如果两个公司总经理，经理，首席技术官之间关系比较好，两个公司容易有比较好的关系。然而一位普通员工就算与另一家公司的一位普通员工有血海深仇，怕也难影响两个公司之间的关系。</p>
<p>因而判断公司与公司之间的关系，<strong>首先要找出哪些人对公司与公司之间的关系最重要</strong>，比如总经理，经理，首席技术官。<strong>其次要判断这些人之间的关系</strong>，不如两家公司的总经理曾经是同学，经理是老乡，首席技术官曾是创业伙伴。我们发现，两家公司无论总经理，经理，首席技术官，关系都很好，因而两家公司关系应该会很好。</p>
<p>分析了两种关系，下面看一下<strong>如何判断文档之间的关系</strong>了。</p>
<p><strong>首先，一个文档有很多词(Term)组成</strong>，如search, lucene, full-text, this, a, what等。</p>
<p><strong>其次对于文档之间的关系，不同的Term重要性不同</strong>，比如对于本篇文档，search, Lucene, full-text就相对重要一些，this, a , what可能相对不重要一些。所以如果两篇文档都包含search, Lucene，fulltext，这两篇文档的相关性好一些，然而就算一篇文档包含this, a, what，另一篇文档不包含this, a, what，也不能影响两篇文档的相关性。</p>
<p>因而判断文档之间的关系，首先找出哪些词(Term)对文档之间的关系最重要，如search, Lucene, fulltext。然后判断这些词(Term)之间的关系。</p>
<p><strong>找出词(Term)**</strong>对文档的重要性的过程称为计算词的权重(Term weight)<strong>**的过程。</strong></p>
<p>计算词的权重(term weight)有两个参数，第一个是词(Term)，第二个是文档(Document)。</p>
<p>词的权重(Term weight)表示此词(Term)在此文档中的重要程度，越重要的词(Term)有越大的权重(Term weight)，因而在计算文档之间的相关性中将发挥更大的作用。</p>
<p><strong>判断词(Term)**</strong>之间的关系从而得到文档相关性的过程应用一种叫做向量空间模型的算法(Vector Space Model)<strong>**。</strong></p>
<p>下面仔细分析一下这两个过程：</p>
<h4 id="1-计算权重-Term-weight-的过程。"><a href="#1-计算权重-Term-weight-的过程。" class="headerlink" title="1. 计算权重(Term weight)的过程。"></a><strong>1. 计算权重(Term weight)的过程。</strong></h4><p>影响一个词(Term)在一篇文档中的重要性主要有两个因素：</p>
<ul>
<li>Term Frequency (tf)：即此Term在此文档中出现了多少次。tf 越大说明越重要。</li>
<li>Document Frequency (df)：即有多少文档包含次Term。df 越大说明越不重要。</li>
</ul>
<p>容易理解吗？词(Term)在文档中出现的次数越多，说明此词(Term)对该文档越重要，如“搜索”这个词，在本文档中出现的次数很多，说明本文档主要就是讲这方面的事的。然而在一篇英语文档中，this出现的次数更多，就说明越重要吗？不是的，这是由第二个因素进行调整，第二个因素说明，有越多的文档包含此词(Term), 说明此词(Term)太普通，不足以区分这些文档，因而重要性越低。</p>
<p>这也如我们程序员所学的技术，对于程序员本身来说，这项技术掌握越深越好（掌握越深说明花时间看的越多，tf越大），找工作时越有竞争力。然而对于所有程序员来说，这项技术懂得的人越少越好（懂得的人少df小），找工作越有竞争力。人的价值在于不可替代性就是这个道理。</p>
<p>道理明白了，我们来看看公式：</p>
<p><img src="//blog.com/2019/01/27/Lucene-全文检索的基本原理/13.png" alt="image"></p>
<p><img src="//blog.com/2019/01/27/Lucene-全文检索的基本原理/8.png" alt="image"></p>
<p>这仅仅只term weight计算公式的简单典型实现。实现全文检索系统的人会有自己的实现，Lucene就与此稍有不同。</p>
<h4 id="2-判断Term之间的关系从而得到文档相关性的过程，也即向量空间模型的算法-VSM-。"><a href="#2-判断Term之间的关系从而得到文档相关性的过程，也即向量空间模型的算法-VSM-。" class="headerlink" title="2. 判断Term之间的关系从而得到文档相关性的过程，也即向量空间模型的算法(VSM)。"></a><strong>2. 判断Term之间的关系从而得到文档相关性的过程，也即向量空间模型的算法(VSM)。</strong></h4><p>我们把文档看作一系列词(Term)，每一个词(Term)都有一个权重(Term weight)，不同的词(Term)根据自己在文档中的权重来影响文档相关性的打分计算。</p>
<p>于是我们把所有此文档中词(term)的权重(term weight) 看作一个向量。</p>
<p>Document = {term1, term2, …… ,term N}</p>
<p>Document Vector = {weight1, weight2, …… ,weight N}</p>
<p>同样我们把查询语句看作一个简单的文档，也用向量来表示。</p>
<p>Query = {term1, term 2, …… , term N}</p>
<p>Query Vector = {weight1, weight2, …… , weight N}</p>
<p>我们把所有搜索出的文档向量及查询向量放到一个N维空间中，每个词(term)是一维。</p>
<p>如图：</p>
<p><img src="//blog.com/2019/01/27/Lucene-全文检索的基本原理/9.jpg" alt="vsm"></p>
<p>我们认为两个向量之间的夹角越小，相关性越大。</p>
<p>所以我们计算夹角的余弦值作为相关性的打分，夹角越小，余弦值越大，打分越高，相关性越大。</p>
<p>有人可能会问，查询语句一般是很短的，包含的词(Term)是很少的，因而查询向量的维数很小，而文档很长，包含词(Term)很多，文档向量维数很大。你的图中两者维数怎么都是N呢？</p>
<p>在这里，既然要放到相同的向量空间，自然维数是相同的，不同时，取二者的并集，如果不含某个词(Term)时，则权重(Term Weight)为0。</p>
<p>相关性打分公式如下：</p>
<p>[<img src="//blog.com/2019/01/27/Lucene-全文检索的基本原理/10.png" alt="image"></p>
<p>举个例子，查询语句有11个Term，共有三篇文档搜索出来。其中各自的权重(Term weight)，如下表格。</p>
<table>
<thead>
<tr>
<th></th>
<th>t1</th>
<th>t2</th>
<th>t3</th>
<th>t4</th>
<th>t5</th>
<th>t6</th>
<th>t7</th>
<th>t8</th>
<th>t9</th>
<th>t10</th>
<th>t11</th>
</tr>
</thead>
<tbody>
<tr>
<td>D1</td>
<td>0</td>
<td>0</td>
<td>.477</td>
<td>0</td>
<td>.477</td>
<td>.176</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>.176</td>
<td>0</td>
</tr>
<tr>
<td>D2</td>
<td>0</td>
<td>.176</td>
<td>0</td>
<td>.477</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>.954</td>
<td>0</td>
<td>.176</td>
</tr>
<tr>
<td>D3</td>
<td>0</td>
<td>.176</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>.176</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>.176</td>
<td>.176</td>
</tr>
<tr>
<td>Q</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>.176</td>
<td>0</td>
<td>0</td>
<td>.477</td>
<td>0</td>
<td>.176</td>
</tr>
</tbody>
</table>
<p>于是计算，三篇文档同查询语句的相关性打分分别为：</p>
<p><img src="//blog.com/2019/01/27/Lucene-全文检索的基本原理/16.png" alt="image"></p>
<p><img src="//blog.com/2019/01/27/Lucene-全文检索的基本原理/14.png" alt="image"></p>
<p><img src="//blog.com/2019/01/27/Lucene-全文检索的基本原理/15.png" alt="image"></p>
<p>于是文档二相关性最高，先返回，其次是文档一，最后是文档三。</p>
<p>到此为止，我们可以找到我们最想要的文档了。</p>
<p>说了这么多，其实还没有进入到Lucene，而仅仅是信息检索技术(Information retrieval)中的基本理论，然而当我们看过Lucene后我们会发现，Lucene是对这种基本理论的一种基本的的实践。所以在以后分析Lucene的文章中，会常常看到以上理论在Lucene中的应用。</p>
<p>在进入Lucene之前，对上述索引创建和搜索过程所一个总结，如图：</p>
<p>此图参照<a href="http://www.lucene.com.cn/about.htm" target="_blank" rel="noopener">http://www.lucene.com.cn/about.htm</a>中文章《开放源代码的全文检索引擎Lucene》</p>
<p><img src="//blog.com/2019/01/27/Lucene-全文检索的基本原理/12.jpg" alt="clip_image016"></p>
<p><strong>1. 索引过程：</strong></p>
<p><strong>1)</strong> <strong>有一系列被索引文件</strong></p>
<p><strong>2)</strong> <strong>被索引文件经过语法分析和语言处理形成一系列词(Term)**</strong>。**</p>
<p><strong>3)</strong> <strong>经过索引创建形成词典和反向索引表。</strong></p>
<p><strong>4)</strong> <strong>通过索引存储将索引写入硬盘。</strong></p>
<p><strong>2. 搜索过程：</strong></p>
<p><strong>a)</strong> <strong>用户输入查询语句。</strong></p>
<p><strong>b)</strong> <strong>对查询语句经过语法分析和语言分析得到一系列词(Term)**</strong>。**</p>
<p><strong>c)</strong> <strong>通过语法分析得到一个查询树。</strong></p>
<p><strong>d)</strong> <strong>通过索引存储将索引读入到内存。</strong></p>
<p><strong>e)</strong> <strong>利用查询树搜索索引，从而得到每个词(Term)**</strong>的文档链表，对文档链表进行交，差，并得到结果文档。**</p>
<p><strong>f)</strong> <strong>将搜索到的结果文档对查询的相关性进行排序。</strong></p>
<p><strong>g)</strong> <strong>返回查询结果给用户。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/01/27/TCP SOCKET中backlog参数的用途是什么？/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/27/TCP SOCKET中backlog参数的用途是什么？/" itemprop="url">TCP SOCKET中backlog参数的用途是什么？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-27T12:12:57+08:00">
                2019-01-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/" itemprop="url" rel="index">
                    <span itemprop="name">网络</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/网络/Linux/Tcp/" itemprop="url" rel="index">
                    <span itemprop="name">Tcp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="TCP-SOCKET中backlog参数的用途是什么？"><a href="#TCP-SOCKET中backlog参数的用途是什么？" class="headerlink" title="TCP SOCKET中backlog参数的用途是什么？"></a>TCP SOCKET中backlog参数的用途是什么？</h1><blockquote>
<p>原文地址：<a href="https://www.cnxct.com/something-about-phpfpm-s-backlog/" target="_blank" rel="noopener">https://www.cnxct.com/something-about-phpfpm-s-backlog/</a></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在前年时，业务中遇到好多次因为PHP-FPM的backlog参数引发的性能问题，一直想去详细研究一番，还特意在2013年总结里提到这事《<a href="http://www.cnxct.com/summary-of-2013-by-cfc4n/" target="_blank" rel="noopener">为何PHP5.5.6中fpm backlog Changed default listen() backlog to 65535</a>》，然而，我稍于懒惰，一拖再拖，直至今日，才动脑去想，动笔去写。</p>
<p>2013年12月14发布的PHP5.5.6中，<a href="http://php.net/ChangeLog-5.php#5.5.6" target="_blank" rel="noopener">changelog</a>中有一条变更，</p>
<blockquote>
<p>FPM:<br>Changed default listen() backlog to 65535.</p>
</blockquote>
<p>这条改动，是在10月28日改的，见<a href="https://github.com/php/php-src/commit/9765763413526d641b98c0a1e40d57b5ba1cceb3#diff-5ac2fd3d4cd3a2c00daf25fe39aeb142" target="_blank" rel="noopener">increase backlog to the highest value everywhere</a></p>
<blockquote>
<p>It makes no sense to use -1 for *BSD (which is the highest value there)<br>and still use 128 for Linux.<br>Lets raise it right to up the limit and let the people lower it if they<br>think that 3.5Mb is too much for a process.<br>IMO this is better than silently dropping connections.</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;patch提交者认为，提高backlog数量，哪怕出现timeout之类错误，也比因为backlog满了之后，悄悄的忽略TCP SYN的请求要好。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当我最近开始想好好了解一下backlog的细节问题时，发现fpm的默认backlog已经不是65535了，现在是511了。（没写在changelog中，你没注意到，这不怪你。）我翻阅了github提交记录，找到这次改动，是在2014年7月22日，<a href="https://github.com/php/php-src/commit/ebf4ffc9354f316f19c839a114b26a564033708a" target="_blank" rel="noopener">Set FPM_BACKLOG_DEFAULT to 511</a></p>
<blockquote>
<p>It is too large for php-fpm to set the listen backlog to 65535.<br>It is realy NOT a good idea to clog the accept queue especially<br>when the client or nginx has a timeout for this connection.</p>
<p>Assume that the php-fpm qps is 5000. It will take 13s to completely<br>consume the 65535 backloged connections. The connection maybe already<br>have been closed cause of timeout of nginx or clients. So when we accept<br>the 65535th socket, we get a broken pipe.</p>
<p>Even worse, if hundreds of php-fpm processes get a closed connection<br>they are just wasting time and resouces to run a heavy task and finally<br>get error when writing to the closed connection(error: Broken Pipe).</p>
<p>The really max accept queue size will be backlog+1(ie, 512 here).<br>We take 511 which is the same as nginx and redis.</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;shafreeck其中理由是“backlog值为65535太大了。会导致前面的nginx（或者其他客户端）超时”，而且提交者举例计算了一下，假设FPM的QPS为5000，那么65535个请求全部处理完需要13s的样子。但前端的nginx（或其他客户端）已经等待超时，关闭了这个连接。当FPM处理完之后，再往这个SOCKET ID 写数据时，却发现连接已关闭，得到的是“error: Broken Pipe”，在nginx、redis、apache里，默认的backlog值兜是511。故这里也建议改为511。（后来发现，此patch提交者，是360团队「基础架构快报」中《TCP三次握手之backlog》的作者shafreeck</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;对于backlog的参数的含义，在linux kernel手册中也给了注释说明listen – listen for connections on a socket</p>
<blockquote>
<p>#include /<em> See NOTES </em>/<br>#include<br>int listen(int sockfd, int backlog);<br>Description</p>
<p>listen() marks the socket referred to by sockfd as a passive socket, that is, as a socket that will be used to accept incoming connection requests using accept(2).<br>The sockfd argument is a file descriptor that refers to a socket of type SOCK_STREAM or SOCK_SEQPACKET.</p>
<p>The backlog argument defines the maximum length to which the queue of pending connections for sockfd may grow. If a connection request arrives when the queue is full, the client may receive an error with an indication of ECONNREFUSED or, if the underlying protocol supports retransmission, the request may be ignored so that a later reattempt at connection succeeds.</p>
<p>Notes</p>
<p>The behavior of the backlog argument on TCP sockets changed with Linux 2.2. Now it specifies the queue length for completely established sockets waiting to be accepted, instead of the number of incomplete connection requests. The maximum length of the queue for incomplete sockets can be set using /proc/sys/net/ipv4/tcp_max_syn_backlog. When syncookies are enabled there is no logical maximum length and this setting is ignored. See tcp(7) for more information.</p>
<p>If the backlog argument is greater than the value in /proc/sys/net/core/somaxconn, then it is silently truncated to that value; the default value in this file is 128. In kernels before 2.4.25, this limit was a hard coded value, SOMAXCONN, with the value 128.</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>backlog的定义是已连接但未进行accept处理的SOCKET队列大小，已是（并非syn的SOCKET队列）。如果这个队列满了，将会发送一个ECONNREFUSED错误信息给到客户端</strong>,即 linux 头文件 /usr/include/asm-generic/errno.h中定义的“Connection refused”，（如果协议不支持重传，该请求会被忽略）如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENETDOWN    100 <span class="comment">/* Network is down */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENETUNREACH 101 <span class="comment">/* Network is unreachable */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENETRESET   102 <span class="comment">/* Network dropped connection because of reset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ECONNABORTED    103 <span class="comment">/* Software caused connection abort */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ECONNRESET  104 <span class="comment">/* Connection reset by peer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENOBUFS     105 <span class="comment">/* No buffer space available */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EISCONN     106 <span class="comment">/* Transport endpoint is already connected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ENOTCONN    107 <span class="comment">/* Transport endpoint is not connected */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ESHUTDOWN   108 <span class="comment">/* Cannot send after transport endpoint shutdown */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETOOMANYREFS    109 <span class="comment">/* Too many references: cannot splice */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ETIMEDOUT   110 <span class="comment">/* Connection timed out */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ECONNREFUSED    111 <span class="comment">/* Connection refused */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EHOSTDOWN   112 <span class="comment">/* Host is down */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EHOSTUNREACH    113 <span class="comment">/* No route to host */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EALREADY    114 <span class="comment">/* Operation already in progress */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EINPROGRESS 115 <span class="comment">/* Operation now in progress */</span></span></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在linux 2.2以前，backlog大小包括了半连接状态和全连接状态两种队列大小。<strong>linux 2.2以后，分离为两个backlog来分别限制半连接SYN_RCVD状态的未完成连接队列大小跟全连接ESTABLISHED状态的已完成连接队列大小</strong>。互联网上常见的TCP SYN FLOOD恶意DOS攻击方式就是用/proc/sys/net/ipv4/tcp_max_syn_backlog来控制的，可参见《<a href="http://tech.uc.cn/?p=1790" target="_blank" rel="noopener">TCP洪水攻击（SYN Flood）的诊断和处理</a>》。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>在使用listen函数时，内核会根据传入参数的backlog跟系统配置参数/proc/sys/net/core/somaxconn中，二者取最小值，作为“ESTABLISHED状态之后，完成TCP连接，等待服务程序ACCEPT”的队列大小</strong>。在kernel 2.4.25之前，是写死在代码常量SOMAXCONN，默认值是128。<strong>在kernel 2.4.25之后，在配置文件/proc/sys/net/core/somaxconn (即 /etc/sysctl.conf 之类 )中可以修改</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;我稍微整理了流程图，如下：<br><img src="//blog.com/2019/01/27/TCP SOCKET中backlog参数的用途是什么？/tcp-sync-queue-and-accept-queue-small.jpg" alt="tcp-sync-queue-and-accept-queue-small"><br>&nbsp;&nbsp;&nbsp;&nbsp;如图，<strong>服务端收到客户端的syn请求后，将这个请求放入syns queue中，然后服务器端回复syn+ack给客户端，等收到客户端的ack后，将此连接放入accept queue</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;大约了解其参数代表意义之后，我稍微测试了一番，并抓去了部分数据，首先确认系统默认参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@vmware-cnxct:/home/cfc4n# cat /proc/sys/net/core/somaxconn</span><br><span class="line">128</span><br><span class="line">root@vmware-cnxct:/home/cfc4n# ss -lt</span><br><span class="line">State      Recv-Q Send-Q         Local Address:Port                    Peer Address:Port</span><br><span class="line">LISTEN     0      128                        *:ssh                           *:*</span><br><span class="line">LISTEN     0      128                 0.0.0.0:9000                           *:*</span><br><span class="line">LISTEN     0      128                       *:http                           *:*</span><br><span class="line">LISTEN     0      128                       :::ssh                           :::*</span><br><span class="line">LISTEN     0      128                      :::http                           :::*</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在FPM的配置中，listen.backlog值默认为511，而如上结果中看到的Send-Q却是128，可见确实是<strong>以/proc/sys/net/core/somaxconn跟listen参数的最小值作为backlog的值</strong>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">cfc4n@cnxct:~$ ab -n 10000 -c 300 http://172.16.218.128/3.php</span><br><span class="line">This is ApacheBench, Version 2.3 &lt;$Revision: 1604373 $&gt;</span><br><span class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class="line"> </span><br><span class="line">Benchmarking 172.16.218.128 (be patient)</span><br><span class="line">Completed 1000 requests</span><br><span class="line">Completed 2000 requests</span><br><span class="line">Completed 3000 requests</span><br><span class="line">Completed 4000 requests</span><br><span class="line">Completed 5000 requests</span><br><span class="line">Completed 6000 requests</span><br><span class="line">Completed 7000 requests</span><br><span class="line">Completed 8000 requests</span><br><span class="line">Completed 9000 requests</span><br><span class="line">Completed 10000 requests</span><br><span class="line">Finished 10000 requests</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Server Software:        nginx/1.4.6</span><br><span class="line">Server Hostname:        172.16.218.128</span><br><span class="line">Server Port:            80</span><br><span class="line"> </span><br><span class="line">Document Path:          /3.php</span><br><span class="line">Document Length:        55757 bytes</span><br><span class="line"> </span><br><span class="line">Concurrency Level:      300</span><br><span class="line">Time taken for tests:   96.503 seconds</span><br><span class="line">Complete requests:      10000</span><br><span class="line">Failed requests:        7405</span><br><span class="line">   (Connect: 0, Receive: 0, Length: 7405, Exceptions: 0)</span><br><span class="line">Non-2xx responses:      271</span><br><span class="line">Total transferred:      544236003 bytes</span><br><span class="line">HTML transferred:       542499372 bytes</span><br><span class="line">Requests per second:    103.62 [#/sec] (mean)</span><br><span class="line">Time per request:       2895.097 [ms] (mean)</span><br><span class="line">Time per request:       9.650 [ms] (mean, across all concurrent requests)</span><br><span class="line">Transfer rate:          5507.38 [Kbytes/sec] received</span><br><span class="line"> </span><br><span class="line">Connection Times (ms)</span><br><span class="line">              min  mean[+/-sd] median   max</span><br><span class="line">Connect:        0    9  96.7      0    1147</span><br><span class="line">Processing:     8 2147 6139.2    981   60363</span><br><span class="line">Waiting:        8 2137 6140.1    970   60363</span><br><span class="line">Total:          8 2156 6162.8    981   61179</span><br><span class="line"> </span><br><span class="line">Percentage of the requests served within a certain time (ms)</span><br><span class="line"><span class="meta">  50%</span><span class="bash">    981</span></span><br><span class="line"><span class="meta">  66%</span><span class="bash">   1074</span></span><br><span class="line"><span class="meta">  75%</span><span class="bash">   1192</span></span><br><span class="line"><span class="meta">  80%</span><span class="bash">   1283</span></span><br><span class="line"><span class="meta">  90%</span><span class="bash">   2578</span></span><br><span class="line"><span class="meta">  95%</span><span class="bash">   5352</span></span><br><span class="line"><span class="meta">  98%</span><span class="bash">  13534</span></span><br><span class="line"><span class="meta">  99%</span><span class="bash">  42346</span></span><br><span class="line"><span class="meta"> 100%</span><span class="bash">  61179 (longest request)</span></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;apache ab这边的结果中，非2xx的http响应有271个，在NGINX日志数据如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@vmware-cnxct:/var/log/nginx# cat grep.error.log |wc -l</span><br><span class="line">271</span><br><span class="line">root@vmware-cnxct:/var/log/nginx# cat grep.access.log |wc -l</span><br><span class="line">10000</span><br><span class="line">root@vmware-cnxct:/var/log/nginx# cat grep.access.log |awk '&#123;print $9&#125;'|sort|uniq -c</span><br><span class="line">   9729 200</span><br><span class="line">    186 502</span><br><span class="line">     85 504</span><br><span class="line">root@vmware-cnxct:/var/log/nginx# cat grep.error.log |awk '&#123;print $8  $9  $10 $11&#125;'|sort |uniq -c</span><br><span class="line">    186 (111: Connection refused) while</span><br><span class="line">     85 out (110: Connection timed</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;从nginx结果中看出，本次压测总请求数为10000。http 200响应数量9729个；http 502 响应数量186个；http 504响应数量未85个；即非2xx响应总数为502+504总数，为271个。同时，也跟error.log中数据吻合。同时，也跟TCP数据包中的RST包数量吻合。<br><img src="//blog.com/2019/01/27/TCP SOCKET中backlog参数的用途是什么？/tcp.connection.rst-271.jpg" alt="tcp.connection.rst-271"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在nginx error中，错误号为111，错误信息为“Connection refused”的有186条，对应着所有http 502响应错误的请求；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在nginx error中，错误号为110，错误信息为“Connection timed out”的有85条,对应着所有http 504响应错误的请求。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在linux errno.h头文件定义中，错误号111对应着ECONNREFUSED；错误号110对应着ETIMEDOUT。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;linux man手册里，对listen参数的说明中，也提到，若client连不上server时，会报告ECONNREFUSED的错。</p>
<p>Nginx error日志中的详细错误如下:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//backlog  过大,fpm处理不过来，导致队列等待时间超过NGINX的proxy</span><br><span class="line">54414#0: *24135 upstream timed out (110: Connection timed out) while connecting to upstream, client: 172.16.218.1, server: localhost, request: "GET /3.php HTTP/1.0", upstream: "fastcgi://192.168.122.66:9999", host: "172.16.218.128"</span><br><span class="line"> </span><br><span class="line">//backlog 过小</span><br><span class="line">[error] 54416#0: *38728 connect() failed (111: Connection refused) while connecting to upstream, client: 172.16.218.1, server: localhost, request: "GET /3.php HTTP/1.0", upstream: "fastcgi://192.168.122.66:9999", host: "172.16.218.128"</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在压测的时候，我用tcpdump抓了通讯包，配合通信包的数据，也可以看出，当backlog为某128时，accept queue队列塞满后，TCP建立的三次握手完成，连接进入ESTABLISHED状态，客户端（nginx）发送给PHP-FPM的数据，FPM处理不过来，没有调用accept将其从accept quque队列取出时，那么就没有ACK包返回给客户端nginx，nginx那边根据TCP 重传机制会再次发从尝试…报了“111: Connection refused”错。当SYNS QUEUE满了时，TCPDUMP的结果如下，不停重传SYN包。<br><img src="//blog.com/2019/01/27/TCP SOCKET中backlog参数的用途是什么？/tcp-sync-queue-overflow.jpg" alt="tcp-sync-queue-overflow"><br>&nbsp;&nbsp;&nbsp;&nbsp;对于已经调用accept函数，从accept queue取出，读取其数据的TCP连接，由于FPM本身处理较慢，以至于NGINX等待时间过久，直接终止了该fastcgi请求，返回“110: Connection timed out”。当FPM处理完成后，往FD里写数据时，发现前端的nginx已经断开连接了，就报了“Write broken pipe”。当ACCEPT QUEUE满了时，TCPDUMP的结果如下，不停重传PSH SCK包。（别问我TCP RTO重传的机制，太复杂了，太深奥了 、<a href="http://blog.csdn.net/zhangskd/article/details/35281345" target="_blank" rel="noopener">TCP的定时器系列 — 超时重传定时器</a>）<br><img src="//blog.com/2019/01/27/TCP SOCKET中backlog参数的用途是什么？/Dev\PHP\phpStudy\WWW\Blog_ReConstruct\计算机网络\TCP SOCKET中backlog参数的用途是什么？\tcp-accept-queue-overflow-1024x638.jpg" alt="tcp-accept-queue-overflow"><br>&nbsp;&nbsp;&nbsp;&nbsp;对于这些结论，我尝试搜了很多资料，后来在360公司的「基础架构快报」中也看到了他们的研究资料《<a href="http://mp.weixin.qq.com/s?__biz=MjM5NzUwNDA5MA==&amp;mid=201005717&amp;idx=1&amp;sn=74036633114ee6212e57ee4576dbfcbc&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=6#rd" target="_blank" rel="noopener">TCP三次握手之backlog</a>》，也验证了我的结论。</p>
<p>关于ACCEPT QUEUE满了之后的表现问题，早上<a href="http://phporz.com/" target="_blank" rel="noopener">IM鑫爷</a>给我指出几个错误，感谢批评及指导，在这里，我把这个问题再详细描述一下。如上图所示</p>
<ul>
<li>NO.515 client发SYN到server，我的seq是0，消息包内容长度为0. （这里的seq并非真正的0，而是wireshark为了显示更好阅读，使用了Relative SeqNum相对序号）</li>
<li>NO.516 server回SYN ACK给client，我的seq是0，消息包内容长度是0，已经收到你发的seq 1 之前的TCP包。(请发后面的)</li>
<li>NO.641 client发ACK给server，我是seq 1 ，消息包内容长度是0，已经收到你发的seq 1 之前的TCP包。</li>
<li>NO.992 client发PSH给server，我是seq 1 ，消息包内容长度是496，已经收到你发的seq 1 之前的TCP包。</li>
<li>………..等了一段时间之后（这里约0.2s左右）</li>
<li>NO.4796 client没等到对方的ACK包，开始TCP retransmission这个包，我是seq 1，消息包长度496，已经收到你发的seq 1 之前的TCP包。</li>
<li>……….又…等了一段时间</li>
<li>NO.9669 client还是没等到对方的ACK包，又开始TCP retransmission这个包，我是seq 1，消息包长度496，已经收到你发的seq 1 之前的TCP包。</li>
<li>NO.13434 server发了SYN ACK给client，这里是tcp spurious retransmission 伪重传，我的seq是0，消息包内容长度是0，已经收到你发的seq 1 之前的TCP包。距离其上次发包给client是NO.516 已1秒左右了，因为没有收到NO.641 包ACK。这时，client收到过server的SYN,ACK包，将此TCP 连接状态改为ESTABLISHED,而server那边没有收到client的ACK包，则其TCP连接状态是SYN_RCVD状态。（感谢IM鑫爷指正）也可能是因为accept queue满了，暂时不能将此TCP连接从syns queue拉到accept queue，导致这情况，这需要翻阅内核源码才能确认。</li>
<li>NO.13467 client发TCP DUP ACK包给server，其实是重发了N0.641 ,只是seq变化了，因为要包括它之前发送过的seq的序列号总和。即..我的seq 497 ，消息包内容长度是0，已经收到你发的seq 1 之前的TCP包。</li>
<li>NO.16573 client继续重新发消息数据给server，包的内容还是NO.992的内容，因为之前发的几次，都没收到确认。</li>
<li>NO.25813 client继续重新发消息数据给server，包的内容还还是NO.992的内容，仍没收到确认。（参见下图中绿色框内标识）</li>
<li>NO.29733 server又重复了NO.13434包的流程，原因也一样，参见NO.13434包注释</li>
<li>NO.29765 client只好跟NO.13467一样，重发ACK包给server。</li>
<li>NO.44507 重复NO.16573的步骤</li>
<li>NO.79195 继续重复NO.16573的步骤</li>
<li>NO.79195 server立刻直接回了RST包，结束会话</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;详细的包内容备注在后面，需要关注的不光是包发送顺序，包的seq重传之类，还有一个重要的，TCP retransmission timeout，即TCP超时重传。对于这里已经抓到的数据包，wireshark可以看下每次超时重传的时间间隔，如下图：<br><img src="//blog.com/2019/01/27/TCP SOCKET中backlog参数的用途是什么？/tcp-ack-rto.jpg" alt="tcp ack rto 重传数据包"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;RTO的重传次数是系统可配置的，见/proc/sys/net/ipv4/tcp_retries1 ，而重传时间间隔，间隔增长频率等，是比较复杂的方式计算出来的，见《<a href="http://www.orczhou.com/index.php/2011/10/tcpip-protocol-start-rto/" target="_blank" rel="noopener">TCP/IP重传超时–RTO</a>》。</p>
<p>backlog大小设置为多少合适？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;从上面的结论中可以看出，这跟<strong>FPM的处理能力</strong>有关。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>backlog太大了，导致FPM处理不过来，nginx那边等待超时，断开连接，报504 gateway timeout错</strong>。<strong>同时FPM处理完准备write 数据给nginx时，发现TCP连接断开了，报“Broken pipe”</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>backlog太小的话，NGINX之类client，根本进入不了FPM的accept queue，报“502 Bad Gateway”错。所以，这还得去根据FPM的QPS来决定backlog的大小</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>计算方式最好为QPS=backlog</strong>。对了这里的QPS是正常业务下的QPS，千万别用echo hello world这种结果的QPS去欺骗自己。当然，<strong>backlog的数值，如果指定在FPM中的话，记得把操作系统的net.core.somaxconn设置的起码比它大</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;另外，ubuntu server 1404上/proc/sys/net/core/somaxconn 跟/proc/sys/net/ipv4/tcp_max_syn_backlog 默认值都是128，这个问题，我为了抓数据，测了好几遍才发现。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;对于测试时，<strong>TCP数据包已经drop掉的未进入syns queue，以及未进入accept queue的数据包</strong>，可以用netstat -s来查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@vmware-cnxct:/# netstat -s</span><br><span class="line">TcpExt:</span><br><span class="line">    //...</span><br><span class="line">    91855 times the listen queue of a socket overflowed</span><br><span class="line">    102324 SYNs to LISTEN sockets dropped   //未进入syns queue的数据包数量</span><br><span class="line">    444 packets directly queued to recvmsg prequeue.</span><br><span class="line">    30408 bytes directly in process context from backlog</span><br><span class="line">    //...</span><br><span class="line">    TCPSackShiftFallback: 27</span><br><span class="line">    TCPBacklogDrop: 2334    //未进入accept queue的数据包数量</span><br><span class="line">    TCPTimeWaitOverflow: 229347</span><br><span class="line">    TCPReqQFullDoCookies: 11591</span><br><span class="line">    TCPRcvCoalesce: 29062</span><br><span class="line">    //...</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 参考资料</p>
</blockquote>
<ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MjM5NzUwNDA5MA==&amp;mid=201005717&amp;idx=1&amp;sn=74036633114ee6212e57ee4576dbfcbc&amp;3rd=MzA3MDU4NTYzMw==&amp;scene=6#rd" target="_blank" rel="noopener">TCP三次握手之backlog</a></li>
<li><a href="http://blog.csdn.net/raintungli/article/details/37913765" target="_blank" rel="noopener">linux里的backlog详解</a></li>
<li><a href="http://jaseywang.me/2014/07/20/tcp-queue-%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">tcp-queue-的一些问题</a></li>
<li><a href="https://utcc.utoronto.ca/~cks/space/blog/unix/ListenBacklogMeaning" target="_blank" rel="noopener">The meaning of listen(2)’s backlog parameter</a></li>
<li><a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">TCP 的那些事儿（上）</a></li>
<li><a href="http://www.orczhou.com/index.php/2011/10/tcpip-protocol-start-rto/" target="_blank" rel="noopener">TCP/IP重传超时–RTO</a></li>
<li><a href="http://blog.csdn.net/zhangskd/article/details/35281345" target="_blank" rel="noopener">TCP的定时器系列—超时重传定时器</a></li>
<li><a href="http://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux.html" target="_blank" rel="noopener">Coping with the TCP TIME-WAIT state on busy Linux servers</a></li>
<li>2018年10月22日新增<a href="https://veithen.github.io/2014/01/01/how-tcp-backlog-works-in-linux.html" target="_blank" rel="noopener">How TCP backlog works in Linux</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/129/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/129/">129</a><span class="page-number current">130</span><a class="page-number" href="/page/131/">131</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/131/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
