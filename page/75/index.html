<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/page/75/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/page/75/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/14/golang 并发设计模式(一)--资源生成器模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/14/golang 并发设计模式(一)--资源生成器模式/" itemprop="url">golang 并发设计模式(一)--资源生成器模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-14T12:12:57+08:00">
                2019-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/" itemprop="url" rel="index">
                    <span itemprop="name">Go</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Go/Go并发/" itemprop="url" rel="index">
                    <span itemprop="name">Go并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="golang-并发设计模式-一-–资源生成器模式"><a href="#golang-并发设计模式-一-–资源生成器模式" class="headerlink" title="golang 并发设计模式(一)–资源生成器模式"></a>golang 并发设计模式(一)–资源生成器模式</h1><p><br></p>
<blockquote>
<p> 原文地址：<a href="https://blog.csdn.net/hittata/article/details/51777426" target="_blank" rel="noopener">https://blog.csdn.net/hittata/article/details/51777426</a></p>
</blockquote>
<p><br></p>
<p>在应用系统中，常见的的应用场景就是调用一个生成器：生成订单号，序列号，随机数等。</p>
<p><code>golang  goroutine</code>为这种需求提供了强大的武器。</p>
<h2 id="简单的生成器"><a href="#简单的生成器" class="headerlink" title="简单的生成器"></a>简单的生成器</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">		<span class="string">"fmt"</span></span><br><span class="line">		<span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntA</span><span class="params">()</span><span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span> ,<span class="number">10</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">				ch&lt;-rand.Int()</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">		ch := GenerateIntA()</span><br><span class="line">		fmt.Println(&lt;-ch)</span><br><span class="line">		fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="叠加增强型资源生成器"><a href="#叠加增强型资源生成器" class="headerlink" title="叠加增强型资源生成器"></a>叠加增强型资源生成器</h2><p>可以使用多路复用技术进行堆积叠加，增加服务能力<br>可以使用缓冲<code>channel</code>增加服务能力</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntA</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			ch &lt;- rand.Int()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntB</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			ch &lt;- rand.Int()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateInt</span><span class="params">()</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">20</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> ch &lt;- &lt;-GenerateIntA():</span><br><span class="line">			<span class="keyword">case</span> ch &lt;- &lt;-GenerateIntB():</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := GenerateInt()</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">		fmt.Println(&lt;-ch)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自动退出"><a href="#自动退出" class="headerlink" title="自动退出"></a>自动退出</h2><p>有时我们希望生成器能够自动的退出，这时可以使用<code>golang  channel</code>的<br><code>Close channel to broadcast</code>机制实现:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntA</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Lable:</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> ch &lt;- rand.Int():</span><br><span class="line">			<span class="keyword">case</span> &lt;-done:</span><br><span class="line">				fmt.Println(<span class="string">"GenerateIntA结束"</span>)</span><br><span class="line">				<span class="keyword">break</span> Lable</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntB</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Lable:</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> ch &lt;- rand.Int():</span><br><span class="line">			<span class="keyword">case</span> &lt;-done:</span><br><span class="line">				fmt.Println(<span class="string">"GenerateIntB结束"</span>)</span><br><span class="line">				<span class="keyword">break</span> Lable</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateInt</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	send := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Lable:</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> ch &lt;- &lt;-GenerateIntA(send):</span><br><span class="line">			<span class="keyword">case</span> ch &lt;- &lt;-GenerateIntB(send):</span><br><span class="line">			<span class="keyword">case</span> &lt;-done:</span><br><span class="line">				fmt.Println(<span class="string">"GenerateInt结束"</span>)</span><br><span class="line">				send &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">				send &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">				<span class="keyword">break</span> Lable</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	ch := GenerateInt(done)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(&lt;-ch)</span><br><span class="line">	&#125;</span><br><span class="line">	done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		v , _ok:= &lt;-ch</span><br><span class="line">		<span class="keyword">if</span> !_ok &#123;</span><br><span class="line">			<span class="comment">// 这里必须延迟才能够看到A、B退出的打印</span></span><br><span class="line">			time.Sleep(time.Millisecond * <span class="number">5</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Println(v)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更牛逼点，既要并发、缓冲，又有通知的生成器"><a href="#更牛逼点，既要并发、缓冲，又有通知的生成器" class="headerlink" title="更牛逼点，既要并发、缓冲，又有通知的生成器"></a>更牛逼点，既要并发、缓冲，又有通知的生成器</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntA</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Lable:</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> ch &lt;- rand.Int():</span><br><span class="line">			<span class="keyword">case</span> &lt;-done:</span><br><span class="line">				<span class="keyword">break</span> Lable</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateIntB</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Lable:</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> ch &lt;- rand.Int():</span><br><span class="line">			<span class="keyword">case</span> &lt;-done:</span><br><span class="line">				<span class="keyword">break</span> Lable</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateInt</span><span class="params">(done <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">chan</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	send := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Lable:</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> ch &lt;- &lt;-GenerateIntA(send):</span><br><span class="line">			<span class="keyword">case</span> ch &lt;- &lt;-GenerateIntB(send):</span><br><span class="line">			<span class="keyword">case</span> &lt;-done:</span><br><span class="line">				send &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">				send &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">				<span class="keyword">break</span> Lable</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">close</span>(ch)</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	ch := GenerateInt(done)</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		fmt.Println(&lt;-ch)</span><br><span class="line">	&#125;</span><br><span class="line">	done &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		v := &lt;-ch</span><br><span class="line">		<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(&lt;-ch)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/12/JSON Web Token入门教程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/12/JSON Web Token入门教程/" itemprop="url">JSON Web Token入门教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-12T22:12:57+08:00">
                2019-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/用户身份验证/" itemprop="url" rel="index">
                    <span itemprop="name">用户身份验证</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/用户身份验证/token认证/" itemprop="url" rel="index">
                    <span itemprop="name">token认证</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/用户身份验证/token认证/JWT/" itemprop="url" rel="index">
                    <span itemprop="name">JWT</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JSON-Web-Token入门教程"><a href="#JSON-Web-Token入门教程" class="headerlink" title="JSON Web Token入门教程"></a>JSON Web Token入门教程</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></p>
</blockquote>
<p><br></p>
<p>JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案，本文介绍它的原理和用法。</p>
<p><img src="//blog.com/2019/05/12/JSON Web Token入门教程/bg2018072301.jpg" alt="img"></p>
<h2 id="一、跨域认证的问题"><a href="#一、跨域认证的问题" class="headerlink" title="一、跨域认证的问题"></a>一、跨域认证的问题</h2><p>互联网服务离不开用户认证。一般流程是下面这样。</p>
<blockquote>
<p>1、用户向服务器发送用户名和密码。</p>
<p>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</p>
<p>3、服务器向用户返回一个 session_id，写入用户的 Cookie。</p>
<p>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</p>
<p>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</p>
</blockquote>
<p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p>
<p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p>
<p>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p>
<p>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p>
<h2 id="二、JWT-的原理"><a href="#二、JWT-的原理" class="headerlink" title="二、JWT 的原理"></a>二、JWT 的原理</h2><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123;</span><br><span class="line">&gt;   <span class="string">"姓名"</span>: <span class="string">"张三"</span>,</span><br><span class="line">&gt;   <span class="string">"角色"</span>: <span class="string">"管理员"</span>,</span><br><span class="line">&gt;   <span class="string">"到期时间"</span>: <span class="string">"2018年7月1日0点0分"</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。</p>
<p>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p>
<h2 id="三、JWT-的数据结构"><a href="#三、JWT-的数据结构" class="headerlink" title="三、JWT 的数据结构"></a>三、JWT 的数据结构</h2><p>实际的 JWT 大概就像下面这样。</p>
<p><img src="//blog.com/2019/05/12/JSON Web Token入门教程/bg2018072304.jpg" alt="img"></p>
<p>它是一个很长的字符串，中间用点（<code>.</code>）分隔成三个部分。注意，JWT 内部是没有换行的，这里只是为了便于展示，将它写成了几行。</p>
<p>JWT 的三个部分依次如下。</p>
<blockquote>
<ul>
<li>Header（头部）</li>
<li>Payload（负载）</li>
<li>Signature（签名）</li>
</ul>
</blockquote>
<p>写成一行，就是下面的样子。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Header.Payload.Signature</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="//blog.com/2019/05/12/JSON Web Token入门教程/bg2018072303.jpg" alt="img"></p>
<p>下面依次介绍这三个部分。</p>
<h3 id="3-1-Header"><a href="#3-1-Header" class="headerlink" title="3.1 Header"></a>3.1 Header</h3><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123;</span><br><span class="line">&gt;   <span class="string">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">&gt;   <span class="string">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为<code>JWT</code>。</p>
<p>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p>
<h3 id="3-2-Payload"><a href="#3-2-Payload" class="headerlink" title="3.2 Payload"></a>3.2 Payload</h3><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p>
<blockquote>
<ul>
<li>iss (issuer)：签发人</li>
<li>exp (expiration time)：过期时间</li>
<li>sub (subject)：主题</li>
<li>aud (audience)：受众</li>
<li>nbf (Not Before)：生效时间</li>
<li>iat (Issued At)：签发时间</li>
<li>jti (JWT ID)：编号</li>
</ul>
</blockquote>
<p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123;</span><br><span class="line">&gt;   <span class="string">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">&gt;   <span class="string">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">&gt;   <span class="string">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p>
<p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p>
<h3 id="3-3-Signature"><a href="#3-3-Signature" class="headerlink" title="3.3 Signature"></a>3.3 Signature</h3><p>Signature 部分是对前两部分的签名，防止数据篡改。</p>
<p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; HMACSHA256(</span><br><span class="line">&gt;   base64UrlEncode(header) + <span class="string">"."</span> +</span><br><span class="line">&gt;   base64UrlEncode(payload),</span><br><span class="line">&gt;   secret)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p>
<h3 id="3-4-Base64URL"><a href="#3-4-Base64URL" class="headerlink" title="3.4 Base64URL"></a>3.4 Base64URL</h3><p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。</p>
<p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p>
<h2 id="四、JWT-的使用方式"><a href="#四、JWT-的使用方式" class="headerlink" title="四、JWT 的使用方式"></a>四、JWT 的使用方式</h2><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p>
<p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息<code>Authorization</code>字段里面。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Authorization: Bearer &lt;token&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p>
<h2 id="五、JWT-的几个特点"><a href="#五、JWT-的几个特点" class="headerlink" title="五、JWT 的几个特点"></a>五、JWT 的几个特点</h2><p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</p>
<p>（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。</p>
<p>（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</p>
<p>（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p>
<p>（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</p>
<p>（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p>
<h2 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h2><ul>
<li><a href="https://jwt.io/introduction/" target="_blank" rel="noopener">Introduction to JSON Web Tokens</a>， by Auth0</li>
<li><a href="https://medium.com/@bryanmanuele/sessionless-authentication-withe-jwts-with-node-express-passport-js-69b059e4b22c" target="_blank" rel="noopener">Sessionless Authentication using JWTs (with Node + Express + Passport JS)</a>, by Bryan Manuele</li>
<li><a href="https://github.com/dwyl/learn-json-web-tokens/blob/master/README.md" target="_blank" rel="noopener">Learn how to use JSON Web Tokens</a>, by dwyl</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/12/细说API - 认证、授权和凭证/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/12/细说API - 认证、授权和凭证/" itemprop="url">细说API - 认证、授权和凭证</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-12T22:12:57+08:00">
                2019-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/用户身份验证/" itemprop="url" rel="index">
                    <span itemprop="name">用户身份验证</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/用户身份验证/token认证/" itemprop="url" rel="index">
                    <span itemprop="name">token认证</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/用户身份验证/token认证/OAuth-2-0/" itemprop="url" rel="index">
                    <span itemprop="name">OAuth 2.0</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="细说API-认证、授权和凭证"><a href="#细说API-认证、授权和凭证" class="headerlink" title="细说API - 认证、授权和凭证"></a>细说API - 认证、授权和凭证</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s/oOjplJXjcA3lzo65nV0aQw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/oOjplJXjcA3lzo65nV0aQw</a></p>
</blockquote>
<p><br></p>
<p>在一些互联网公司的面试中，面试官往往会问这样一个问题：</p>
<p><strong>“如果禁用浏览器 <code>cookie</code>，如何实现用户追踪和认证？”</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遗憾的是依然有大量候选人答非所问，无法搞清楚 <code>cookie</code> 和 <code>session</code>之间的区别。而在工作中也有让人惊讶的真实案例：把 <code>user ID</code> 存储到<code>local storage</code>中当做 <code>token</code>使用，原因是他们声称弃用了 <code>cookie</code> 这种落后的东西；一个移动端项目，服务器给出的 <code>API</code>中需要客户端模拟一个 <code>cookie</code>，从而像浏览器中 <code>ajax</code>那样消费 API。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;互联网是基于<code>HTTP</code>协议构建的，而 <code>HTTP</code>协议因为简单流行开来，但是<code>HTTP</code> 协议是无状态（通信层面上虚电路比数据报昂贵太多）的，为此人们为了追踪用户想出了各种办法，包括<code>cookie/session</code> 机制、<code>token、flash</code> 跨浏览器 <code>cookie</code> 甚至浏览器指纹等。</p>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/1.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把用户身份藏在每一个地方（浏览器指纹技术甚至不需要存储介质）</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;讲使用<code>spring security</code>等具体技术的资料已经很多了，这篇文章不打算写框架和代码的具体实现。我们会讨论认证和授权的区别，然后会介绍一些被业界广泛采用的技术，最后会聊聊怎么为 <code>API</code> 构建选择合适的认证方式。</p>
<hr>
<h2 id="认证、授权、凭证"><a href="#认证、授权、凭证" class="headerlink" title="认证、授权、凭证"></a><strong>认证、授权、凭证</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，认证和授权是两个不同的概念，为了让我们的 <code>API</code> 更加安全和具有清晰的设计，理解认证和授权的不同就非常有必要了，它们在英文中也是不同的单词。</p>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/2.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>认证是 <code>authentication</code>，指的是当前用户的身份，当用户登陆过后系统便能追踪到他的身份做出符合相应业务逻辑的操作</strong>。即使用户没有登录，大多数系统也会追踪他的身份，只是当做来宾或者匿名用户来处理。认证技术解决的是 <code>“我是谁？”</code>的问题。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;授权则不同，<strong>授权是 <code>authorization</code>，指的是什么样的身份被允许访问某些资源，在获取到用户身份后继续检查用户的权限</strong>。单一的系统授权往往是伴随认证来完成的，但是在开放<code>API</code>的多系统结构下，授权可以由不同的系统来完成，例如<code>OAuth</code>。授权技术是解决<code>“我能做什么？”</code>的问题。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>实现认证和授权的基础是需要一种媒介（<code>credentials</code>）来标记访问者的身份或权利</strong>，在现实生活中每个人都需要一张身份证才能访问自己的银行账户、结婚和办理养老保险等，这就是认证的凭证；在古代军事活动中，皇帝会给出战的将军颁发兵符，下级将领不关心持有兵符的人，只需要执行兵符对应的命令即可。在互联网世界中，服务器为每一个访问者颁发 <code>session ID</code> 存放到 <code>cookie</code>，这就是一种凭证技术。数字凭证还表现在方方面面，<code>SSH</code>登录的密匙、<code>JWT</code> 令牌、一次性密码等。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户账户也不一定是存放在数据库中的一张表，在一些<code>企业 IT</code>系统中，对账户管理和权限有了更多的要求。所以账户技术 （<code>accounting</code>）可以帮助我们使用不同的方式管理用户账户，同时具有不同系统之间共享账户的能力。例如微软的活动目录（<code>AD</code>），以及简单目录访问协议（<code>LDAP</code>），甚至区块链技术。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一个重要的概念是访问控制策略（<code>AC</code>）。如果我们需要把资源的权限划分到一个很细的粒度，就不得不考虑用户以何种身份来访问受限的资源，选择基于访问控制列表（<code>ACL</code>）还是基于用户角色的访问控制（<code>RBAC</code>）或者其他访问控制策略。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在流行的技术和框架中，这些概念都无法孤立的被实现，因此在现实中使用这些技术时，大家往往为一个<code>OAuth2</code>是认证还是授权这种概念争论不休。为了容易理解，我在文末附上了一份常见技术和概念的术语表。下面我会介绍在API开发中常常使用的几种认证和授权技术：<code>HTTP Basic AUthentication、HAMC、OAuth2</code>，以及凭证技术<code>JWT token</code>。</p>
<hr>
<h2 id="认证和授权技术"><a href="#认证和授权技术" class="headerlink" title="认证和授权技术"></a>认证和授权技术</h2><h3 id="HTTP-Basic-Authentication"><a href="#HTTP-Basic-Authentication" class="headerlink" title="HTTP Basic Authentication"></a><strong>HTTP Basic Authentication</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你一定用过这种方式，但不一定知道它是什么，在不久之前，当你访问一台家用路由器的管理界面，往往会看到一个浏览器弹出表单，要求你输入用户密码。</p>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/3.webp" alt="img"></p>
<p>在这背后，当用户输入完用户名密码后，浏览器帮你做了一个非常简单的操作:</p>
<ol>
<li>组合用户名和密码然后 <code>Base64</code>编码</li>
<li>给编码后的字符串添加 Basic 前缀，然后设置名称为 <code>Authorization</code>的<code>header</code>头部</li>
</ol>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/4.webp" alt="img"></p>
<p><code>API</code> 也可以非常简单的提供 <code>HTTP Basic Authentication</code>认证方式，那么客户端可以很简单通过<code>Base64</code>传输用户名和密码即可:</p>
<ol>
<li>将用户名和密码使用冒号连接，例如 <code>username:abc123456</code></li>
<li>为了防止用户名或者密码中存在超出 <code>ASCII</code>码范围的字符，推荐使用<code>UTF-8</code>编码</li>
<li>将上面的字符串使用<code>Base 64</code>编码，例如： <code>dXNlcm5hbWU6YWJjMTIzNDU2</code></li>
<li>在 <code>HTTP</code>请求头中加入 “<code>Basic</code> + 编码后的字符串”，即：<code>Authorization: Basic</code> <code>QWxhZGRpbjpPcGVuU2VzYW1l</code></li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方式实现起来非常简单，在大量场景下被采用。当然缺点也很明显，<code>Base64</code> 只能称为编码，而不是加密 (实际上无需配置密匙的客户端并没有任何可靠地加密方式，我们都依赖 <code>TSL</code> 协议)。这种方式的致命弱点是编码后的密码如果明文传输则容易在网络传输中泄露，在密码不会过期的情况下，密码一旦泄露，只能通过修改密码的方式。</p>
<hr>
<h3 id="HMAC（AK-SK）认证"><a href="#HMAC（AK-SK）认证" class="headerlink" title="HMAC（AK/SK）认证"></a>HMAC（AK/SK）认证</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们对接一些 <code>PASS</code> 平台和支付平台时，会要求我们预先生成一个 <code>access key（AK）</code>和 <code>secure key（SK）</code>，然后通过签名的方式完成认证请求，这种方式可以避免传输<code>secure key</code>，且大多数情况下签名只允许使用一次，避免了重放攻击。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种基于 <code>AK/SK</code> 的认证方式主要是利用散列的消息认证码 (<code>Hash-based MessageAuthentication Code</code>) 来实现的，因此有很多地方叫 <code>HMAC</code>认证，实际上不是非常准确。<code>HMAC</code> 只是利用带有 <code>key</code>值的哈希算法生成消息摘要，在设计 <code>API</code>时有具体不同的实现。</p>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/5.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>HMAC</code> 在作为网络通信的认证设计中作为凭证生成算法使用，避免了口令等敏感信息在网络中传输。基本过程如下：</p>
<ol>
<li>客户端需要在认证服务器中预先设置 <code>access key</code>（<code>AK 或叫 app ID</code>） 和 <code>secure key</code>（SK）</li>
<li>在调用 <code>API</code>时，客户端需要对参数和 <code>access key</code> 进行自然排序后并使用 <code>secure key</code>进行签名生成一个额外的参数 <code>digest</code></li>
<li>服务器根据预先设置的<code>secure key</code>进行同样的摘要计算，并要求结果完全一致</li>
<li><strong>注意 secure key 不能在网络中传输，以及在不受信任的位置存放（浏览器等）</strong></li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了让每一次请求的签名变得独一无二，从而实现重放攻击，我们需要在签名时放入一些干扰信息。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在业界标准中有两种典型的做法，质疑/应答算法（<code>OCRA: OATH Challenge-Response Algorithm</code>）、基于时间的一次性密码算法（<code>TOTP：Time-based One-time Password Algorithm</code>）。</p>
<h4 id="质疑-应答算法"><a href="#质疑-应答算法" class="headerlink" title="质疑/应答算法"></a>质疑/应答算法</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;质疑/应答算法需要客户端先请求一次服务器，获得一个<code>401</code>未认证的返回，并得到一个随机字符串（<code>nonce</code>）。将 <code>nonce</code> 附加到按照上面说到的方法进行<code>HMAC</code>签名，<strong>服务器使用预先分配的<code>nonce</code>同样进行签名校验，这个 <code>nonce</code>在服务器只会被使用一次，因此可以提供唯一的摘要</strong>。</p>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/6.webp" alt="img"></p>
<h4 id="基于时间的一次性密码认证"><a href="#基于时间的一次性密码认证" class="headerlink" title="基于时间的一次性密码认证"></a>基于时间的一次性密码认证</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了避免额外的请求来获取 <code>nonce</code>，还有一种算法是使用时间戳，并且<strong>通过同步时间的方式协商到一致，在一定的时间窗口内有效（1分钟左右）</strong>。</p>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/7.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的只是利用时间戳作为验证的时间窗口，并不能严格的算作基于时间的一次性密码算法。标准的基于时间的一次性密码算法在两步验证中被大量使用，例如<code>Google</code>身份验证器不需要网络通信也能实现验证（但依赖准确的授时服务）。<strong>原理是客户端服务器共享密钥然后根据时间窗口能通过 <code>HMAC</code> 算法计算出一个相同的验证码</strong>。</p>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/8.webp" alt="img"></p>
<hr>
<h3 id="OAuth2-和-Open-ID"><a href="#OAuth2-和-Open-ID" class="headerlink" title="OAuth2 和 Open ID"></a><strong>OAuth2 和 Open ID</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>OAuth</code>（开放授权）是一个<strong>开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>OAuth</code> 是一个授权标准，而不是认证标准。提供资源的服务器不需要知道确切的用户身份（<code>session</code>），只需要验证授权服务器授予的权限（<code>token</code>）即可。</p>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/9.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图只是 <code>OAuth</code> 的一个简化流程，<code>OAuth</code>的基本思路就是通过授权服务器获取 <code>access token</code> 和 <code>refresh token</code>（<code>refresh token</code> 用于重新刷新<code>access token</code>），然后通过<code>access token</code>从资源服务器获取数据 。在特定的场景下还有下面几种模式：</p>
<ol>
<li>授权码模式（<code>authorization code</code>）</li>
<li>简化模式（<code>implicit</code>）</li>
<li>密码模式（<code>resource owner password credentials</code>）</li>
<li>客户端模式（<code>client credentials</code>）</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要获取用户的认证信息，<code>OAuth</code> 本身没有定义这部分内容，如果需要识别用户信息，则需要借助另外的认证层，例如<code>OpenID Connect</code>。</p>
<h4 id="验证-access-token"><a href="#验证-access-token" class="headerlink" title="验证 access token"></a>验证 access token</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一些介绍<code>OAuth</code>的博客中很少讲到资源服务器是怎么验证 <code>access token</code> 的。<code>OAuth core</code> 标准并没有定义这部分，不过在<code>OAuth</code> 其他标准文件中提到两种验证<code>access token</code>的方式。</p>
<ol>
<li>在完成授权流程后，资源服务器可以使用 <code>OAuth</code> 服务器提供的<code>Introspection</code>接口来验证<code>access token</code>，<code>OAuth</code>服务器会返回<code>access token</code> 的状态以及过期时间。在<code>OAuth</code>标准中验证<code>token</code>的术语是 <code>Introspection</code>。同时也需要注意 <code>access token</code>是用户和资源服务器之间的凭证，不是资源服务器和授权服务器之间的凭证。资源服务器和授权服务器之间应该使用额外的认证（例如 <code>Basic</code>认证）。</li>
</ol>
<ol start="2">
<li>使用<code>JWT</code> 验证。授权服务器使用私钥签发<code>JWT</code>形式的<code>access token</code>，资源服务器需要使用预先配置的公钥校验<code>JWT token</code>，并得到<code>token</code>状态和一些被包含在<code>access token</code>中信息。因此在<code>JWT</code> 的方案下，资源服务器和授权服务器不再需要通信，在一些场景下带来巨大的优势。同时<code>JWT</code>也有一些弱点，我会在<code>JWT</code>的部分解释。</li>
</ol>
<h4 id="refresh-token-和-access-token"><a href="#refresh-token-和-access-token" class="headerlink" title="refresh token 和 access token"></a>refresh token 和 access token</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;几乎所有人刚开始了解<code>OAuth</code> 时都有一个一疑问，为什么已经有了<code>access token</code>还需要 <code>refresh token</code>呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;授权服务器会在第一次授权请求时一起返回 <code>access token</code> 和<code>refresh token</code>，在后面刷新 <code>access token</code>时只需要 <code>refresh token</code>。<strong><code>access token</code> 和 <code>refresh token</code> 的设计意图是不一样的，<code>access token</code> 被设计用来客户端和资源服务器之间交互，而 <code>refresh token</code> 是被设计用来客户端和授权服务器之间交互</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;某些授权模式下 <code>access token</code>需要暴露给浏览器，充当一个资源服务器和浏览器之间的临时会话，浏览器和资源服务器之间不存在签名机制，<code>access token</code> 成为唯一凭证，因此 <code>access token</code> 的过期时间（<code>TTL</code>）应该尽量短，从而避免用户的 <code>access token</code> 被嗅探攻击。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于要求 <code>access token</code> 时间很短，<code>refresh token</code> 可以帮助用户维护一个较长时间的状态，避免频繁重新授权。大家会觉得让 <code>access token</code>保持一个长的过期时间不就可以了吗？实际上 <code>refresh token</code> 和 <code>access token</code>的不同之处在于即使<code>refresh token</code> 被截获，系统依然是安全的，客户端拿着 <code>refresh token</code>去获取<code>access token</code>时同时需要预先配置的 <code>secure key</code>，客户端和授权服务器之前始终存在安全的认证。</p>
<hr>
<h2 id="OAuth、Open-ID、OpenID-Connect"><a href="#OAuth、Open-ID、OpenID-Connect" class="headerlink" title="OAuth、Open ID、OpenID Connect"></a><strong>OAuth、Open ID、OpenID Connect</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>OAuth</code> 负责解决分布式系统之间的授权问题，即使有时候客户端和资源服务器或者认证服务器存在同一台机器上。<code>OAuth</code> 没有解决认证的问题，但提供了良好的设计利于和现有的认证系统对接。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Open ID</code>解决的问题是分布式系统之间身份认证问题，使用<code>Open ID token</code>能在多个系统之间验证用户，以及返回用户信息，可以独立使用，与 <code>OAuth</code>没有关联。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>OpenID Connect</code> 解决的是在 <code>OAuth</code> 这套体系下的用户认证问题，实现的基本原理是将用户的认证信息（<code>ID token</code>）当做资源处理。在<code>OAuth</code> 框架下完成授权后，再通过 <code>access token</code> 获取用户的身份。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这三个概念之间的关系有点难以理解，用现实场景来说，如果系统中需要一套独立的认证系统，并不需要多系统之间的授权可以直接采用<code>Open ID</code>。如果使用了<code>OAuth</code>作为授权标准，可以再通过 <code>OpenID Connect</code>来完成用户的认证。</p>
<hr>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>OAuth</code> 等分布式的认证、授权体系下，对凭证技术有了更多的要求，比如包含用户 ID、过期等信息，不需要再外部存储中关联。因此业界对<code>token</code> 做了进一步优化，设计了一种<strong>自包含令牌，令牌签发后无需从服务器存储中检查是否合法，通过解析令牌就能获取令牌的过期、有效等信息</strong>，这就是<code>JWT （JSON Web Token）</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JWT</code>是一种包含令牌（<code>self-contained token</code>），或者叫值令牌 （<code>value token</code>），我们以前使用关联到 <code>session</code> 上的<code>hash</code> 值被叫做引用令牌（<code>reference token</code>）。</p>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/10.webp" alt="img"></p>
<p>简而言之，一个基本的JWT令牌为一段点分3段式结构。</p>
<p><em><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</code></em></p>
<p>生成JWT 令牌的流程为</p>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/11.webp" alt="img"></p>
<ol>
<li><code>header json</code> 的<code>base64</code>编码为令牌第一部分</li>
<li><code>payload json</code> 的<code>base64</code> 编码为令牌第二部分</li>
<li>拼装第一、第二部分编码后的<code>json</code>以及 <code>secret</code> 进行签名的令牌的第三部分</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此只需要签名的 <code>secret key</code> 就能校验 <code>JWT</code>令牌，如果在消息体中加入用户 ID、过期信息就可以实现验证令牌是否有效、过期了，无需从数据库/缓存中读取信息。因为使用了加密算法，所以第一、二部分即使被修改（包括过期信息）也无法通过验证。<strong><code>JWT</code>优点是不仅可以作为<code>token</code> 使用，同时也可以承载一些必要信息，省去多次查询</strong>。</p>
<p>注意：</p>
<ol>
<li><code>JWT token</code> 的第一、二部分只是 <code>base64</code>编码，肉眼不可读，不应当存放敏感信息</li>
<li><code>JWT token</code>的自包含特性，导致了无法被撤回</li>
<li><code>JWT</code>的签名算法可以自己拟定，为了便于调试，本地环境可以使用对称加密算法，生产环境建议使用非对称加密算法</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JWT token</code> 在微服务的系统中优势特别突出。多层调用的<code>API</code> 中可以直接传递<code>JWT token</code>，利用自包含的能力，可以减少用户信息查询次数；更重要的是，使用非对称的加密方式可以通过在系统中分发密匙的方式验证 <code>JWT token</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然 <code>OAuth</code> 对<code>access token</code>等凭证所选用的技术并没有做出限制，<code>OAuth</code>并不强制使用<code>JWT</code>，在使用<code>JWT</code> 自包含特性的优势时，必须考虑到<code>JWT</code>撤回困难的问题。在一些对撤回 <code>token</code>要求很高的项目中不适合使用<code>JWT</code>，即使采用了一些方案实现（<code>whitelist 和 blacklist</code>）也违背了设计<code>JWT</code> 的初衷。</p>
<hr>
<h2 id="Cookie-、Token-in-Cookie、Session-Token-依然被使用"><a href="#Cookie-、Token-in-Cookie、Session-Token-依然被使用" class="headerlink" title="Cookie 、Token in Cookie、Session Token 依然被使用"></a><strong>Cookie 、Token in Cookie、Session Token 依然被使用</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在构建<code>API</code>时，开发者会发现我们的认证方式和网页应用有一些不同，除了像<code>ajax</code> 这种典型的 <code>web</code> 技术外，如果我们希望 <code>API</code>是无状态的，不推荐使用 <code>Cookie</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>Cookie</code> 的本质是用户第一次访问时服务器会分配一个 <code>Session ID</code>，后面的请求中客户端都会带上这个 ID 作为当前用户的标志，因为 <code>HTTP</code> 本身是无状态的，<code>Cookie</code> 属于一种内建于浏览器中实现状态的方式。如果我们的 <code>API</code> 是用来给客户端使用的，强行要求 <code>API</code> 的调用者管理<code>Cookie</code> 也可以完成任务。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一些遗留或者不是标准的认证实现的项目中，我们依然可以看到这些做法，快速地实现认证。</p>
<ol>
<li>使用<code>cookie</code>，例如 <code>web</code> 项目中 <code>ajax</code> 的方式</li>
<li>使用 <code>session ID</code> 或 <code>hash</code> 作为<code>token</code>，但将<code>token</code> 放入 <code>header</code>中传递</li>
<li>将生成的<code>token</code> （可能是<code>JWT</code>）放入<code>cookie</code> 传递，利用 <code>HTTPonly</code> 和 <code>Secure</code> 标签保护 <code>token</code></li>
</ol>
<hr>
<h2 id="选择合适的认证方式"><a href="#选择合适的认证方式" class="headerlink" title="选择合适的认证方式"></a><strong>选择合适的认证方式</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随着微服务的发展，<code>API</code>的设计不仅仅是面向<code>WEB</code>或者 <code>Mobile APP</code>，还有<code>BFF（Backend for Frontend）</code>和 <code>Domain API</code>的认证，以及第三方服务的集成。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端到服务器之间认证和服务器到服务器之间认证是不同的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>我们把终端用户（<code>Human</code>）参与的通信，叫做 <code>Human-to-machine (H2M)</code>，服务器与服务器之间的通信叫做 <code>Machine-to-machine (M2M)</code></strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>H2M</code> 的通信需要更高的安全性，<code>M2M</code>的通信天然比<code>H2M</code> 安全，因此更多的强调性能，在不同的场合下选择合适的认证技术就显得特别重要。例如 <code>HTTP Basic Authentication</code>用来作为 <code>H2M</code>认证显得有些落后，但是在 <code>M2M</code> 中被大量使用。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>另外值得一提的是，H2M 这种通信方式下，客户端不受控制，由于无法自主分发密匙，认证通信的安全高度依赖 HTTPS。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从一个宏观的角度看待他们的关系，对我们技术选型非常有帮助。</p>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/13.webp" alt="img"></p>
<h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><ol>
<li><code>Browser fingerprinting</code> 通过查询浏览器的代理字符串，屏幕色深，语言等，然后这些值通过散列函数传递产生指纹，不需要通过 <code>Cookie</code> 就可以识别浏览器</li>
<li><code>MAC（Message authentication code）</code> 在密码学中，讯息鉴别码，是经过特定算法后产生的一小段资讯，检查某段讯息的完整性</li>
<li><code>HOTP（HMAC-based One-time Password algorithm）</code>基于散列消息验证码的一次性密码算法</li>
<li><code>Two-step verification</code> 是一种认证方法，使用两种不同的元素，合并在一起，来确认使用者的身份，是多因素验证中的一个特例</li>
<li><code>OTP （One time password ）</code>一次性密码，例如注册邮件和短信中的认证码</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/11/消息的顺序性保障/如何保证消费者接收消息的顺序/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/11/消息的顺序性保障/如何保证消费者接收消息的顺序/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-11T18:22:20+08:00">
                2019-05-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="如何保证消费者接收消息的顺序"><a href="#如何保证消费者接收消息的顺序" class="headerlink" title="如何保证消费者接收消息的顺序"></a>如何保证消费者接收消息的顺序</h1><p><br></p>
<blockquote>
<p>原文地址： <a href="https://www.cnblogs.com/cjsblog/p/8267892.html" target="_blank" rel="noopener">https://www.cnblogs.com/cjsblog/p/8267892.html</a></p>
</blockquote>
<p><br></p>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>假设，A和B通过消息队列通信，A发了先后发了2条消息m1和m2。A发出的顺序是m1、m2，结果m2先到达队列，m1后进的，那么在队列中m2在前m1在后，假设这两条消息是有依赖关系的，必须是先m1再m2，那么B可能先接收到m2后接收到m1，问这个时候怎么办？</p>
<h2 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h2><p>1、B接收到消息的顺序跟A发出消息的先后顺序以及消息在队列中的顺序是没有关系的。消息到达队列的先后顺序没法保证，同样，队列将消息投递出去以后接收消息的顺序也没法保证，所以，我想无论怎样作为消费者的B都必须保证业务的正确性，无论生产者怎么怎么发消息，队列怎么投递消息，作为消费者都必须意识到：接收到的消息是无序的，必须做好处理，务必保证业务正常。</p>
<p>2、我觉得这是一个通用的问题，也是作为消费者必须要考虑的问题</p>
<p>3、消息的顺序并不重要，重要的是要保证<strong>业务的最终一致性</strong></p>
<blockquote>
<p>跟消息的顺序没关系。这里面存在三个顺序：发送消息的顺序、消息在队列中的顺序、接收消息的顺序，我觉得顺序没法保证，无论顺序怎样，务必保证业务。</p>
<p>一句话：对于解决如何先消费m1再消费m2的问题？<br>在发送=&gt;m1,发送=&gt;m2队列后，让m2队列中存储能够找到关联的对应的m1的关系，比如用id，然后就可以判断消费m2的时候是否m1已经接受存在了。</p>
</blockquote>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案一：本地消息表-定时扫描"><a href="#方案一：本地消息表-定时扫描" class="headerlink" title="方案一：本地消息表+定时扫描"></a>方案一：本地消息表+定时扫描</h3><p>1、接收到消息以后，将消息保存到本地数据库的表中，标记为未处理</p>
<p>2、若满足处理条件，直接处理，成功以后，标记表中的记录为已处理，然后向队列确认消息</p>
<p>3、若不满足处理条件，则暂不处理</p>
<p>4、定时扫描本地消息表，将那些未处理的再过一遍</p>
<p>5、幂等性判断很重要</p>
<p>缺陷：<strong>需要消息生产者将消息顺序存放到一个存储载体中，用于消息消费者核对判断</strong></p>
<p>​            对于生产者生产的所有消息均要统一存储到<strong>数据库</strong>中（主键id自增，要指明<strong>消息类别</strong>，方便消费者识别处理），在发送下一条消息时要在消息体中指明<strong>消息的依赖关系（前一条消息id，消息链的第一条消息依赖为0）</strong> ，消费者每次收到一条消息时，要判断是否有依赖。如果存在依赖，则判断依赖是否已处理。若未处理，将消息入库置为待处理。若已处理，则直接进行处理。</p>
<p><img src="//blog.com/2019/05/11/消息的顺序性保障/如何保证消费者接收消息的顺序/消息顺序性保证.png" alt=""></p>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>假设，签到送积分。</p>
<p>再假设，签到和送积分是分开的，签到的逻辑是向签到表中插入一条记录，送积分的逻辑是判断积分所对应的签到记录是否存在，存在则送积分，否则不送。</p>
<p>接着假设，消息队列中有两条消息，一条是签到消息，另一条是送积分消息，这条积分消息带着签到记录的id。</p>
<p>那么，送积分的时候就要依赖是否有签到记录。按照上面的理论，将消息先保存在本地，然后定时扫描，是可以正常进行的。</p>
<h2 id="面试题剖析"><a href="#面试题剖析" class="headerlink" title="面试题剖析"></a>面试题剖析</h2><p>我举个例子，我们以前做过一个 mysql <code>binlog</code> 同步的系统，压力还是非常大的，日同步数据要达到上亿，就是说数据从一个 mysql 库原封不动地同步到另一个 mysql 库里面去（mysql -&gt; mysql）。常见的一点在于说比如大数据 team，就需要同步一个 mysql 库过来，对公司的业务系统的数据做各种复杂的操作。</p>
<p>你在 mysql 里增删改一条数据，对应出来了增删改 3 条 <code>binlog</code> 日志，接着这三条 <code>binlog</code> 发送到 MQ 里面，再消费出来依次执行，起码得保证人家是按照顺序来的吧？不然本来是：增加、修改、删除；你楞是换了顺序给执行成删除、修改、增加，不全错了么。</p>
<p>本来这个数据同步过来，应该最后这个数据被删除了；结果你搞错了这个顺序，最后这个数据保留下来了，数据同步就出错了。</p>
<p>先看看顺序会错乱的俩场景：</p>
<ul>
<li><strong>RabbitMQ</strong>：一个 queue，多个 consumer。比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1/data2/data3，压入的是 RabbitMQ 的一个内存队列。有三个消费者分别从 MQ 中消费这三条数据中的一条，结果消费者2先执行完操作，把 data2 存入数据库，然后是 data1/data3。这不明显乱了。</li>
</ul>
<p><a href="https://github.com/ld140319/advanced-java/blob/master/images/rabbitmq-order-01.png" target="_blank" rel="noopener"><img src="https://github.com/ld140319/advanced-java/raw/master/images/rabbitmq-order-01.png" alt="rabbitmq-order-01"></a></p>
<ul>
<li><strong>Kafka</strong>：比如说我们建了一个 topic，有三个 partition。生产者在写的时候，其实可以指定一个 key，比如说我们指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。<br>消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。接着，我们在消费者里可能会搞<strong>多个线程来并发处理消息</strong>。因为如果消费者是单线程消费处理，而处理比较耗时的话，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。而多个线程并发跑的话，顺序可能就乱掉了。</li>
</ul>
<p><a href="https://github.com/ld140319/advanced-java/blob/master/images/kafka-order-01.png" target="_blank" rel="noopener"><img src="https://github.com/ld140319/advanced-java/raw/master/images/kafka-order-01.png" alt="kafka-order-01"></a></p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。 <a href="https://github.com/ld140319/advanced-java/blob/master/images/rabbitmq-order-02.png" target="_blank" rel="noopener"><img src="https://github.com/ld140319/advanced-java/raw/master/images/rabbitmq-order-02.png" alt="rabbitmq-order-02"></a></p>
<h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><ul>
<li>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</li>
<li>写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</li>
</ul>
<p><a href="https://github.com/ld140319/advanced-java/blob/master/images/kafka-order-02.png" target="_blank" rel="noopener"><img src="https://github.com/ld140319/advanced-java/raw/master/images/kafka-order-02.png" alt="kafka-order-02"></a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/11/消息的顺序性保障/分布式开放消息系统(RocketMQ)的原理与实践/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/11/消息的顺序性保障/分布式开放消息系统(RocketMQ)的原理与实践/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-11T18:22:20+08:00">
                2019-05-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="分布式开放消息系统-RocketMQ-的原理与实践"><a href="#分布式开放消息系统-RocketMQ-的原理与实践" class="headerlink" title="分布式开放消息系统(RocketMQ)的原理与实践"></a>分布式开放消息系统(RocketMQ)的原理与实践</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://www.jianshu.com/p/453c6e7ff81c" target="_blank" rel="noopener">https://www.jianshu.com/p/453c6e7ff81c</a></p>
</blockquote>
<p><br></p>
<p>分布式消息系统作为实现分布式系统可扩展、可伸缩性的关键组件，需要具有高吞吐量、高可用等特点。而谈到消息系统的设计，就回避不了两个问题：</p>
<blockquote>
<ol>
<li>消息的顺序问题</li>
<li>消息的重复问题</li>
</ol>
</blockquote>
<p>RocketMQ作为阿里开源的一款高性能、高吞吐量的消息中间件，它是怎样来解决这两个问题的？RocketMQ 有哪些关键特性？其实现原理是怎样的？</p>
<h4 id="关键特性以及其实现原理"><a href="#关键特性以及其实现原理" class="headerlink" title="关键特性以及其实现原理"></a>关键特性以及其实现原理</h4><h5 id="一、顺序消息"><a href="#一、顺序消息" class="headerlink" title="一、顺序消息"></a>一、顺序消息</h5><p>消息有序指的是可以按照消息的发送顺序来消费。例如：一笔订单产生了 3 条消息，分别是订单创建、订单付款、订单完成。消费时，要按照顺序依次消费才有意义。与此同时多笔订单之间又是可以并行消费的。首先来看如下示例：</p>
<p>假如生产者产生了2条消息：M1、M2，要保证这两条消息的顺序，应该怎样做？你脑中想到的可能是这样：</p>
<p><img src="//blog.com/2019/05/11/消息的顺序性保障/分布式开放消息系统(RocketMQ)的原理与实践/分布式开放消息系统(RocketMQ" alt="img">的原理与实践/175724-303b6e1322576021.webp)</p>
<p>你可能会采用这种方式保证消息顺序</p>
<p>假定M1发送到S1，M2发送到S2，如果要保证M1先于M2被消费，那么需要M1到达消费端被消费后，通知S2，然后S2再将M2发送到消费端。</p>
<p>这个模型存在的问题是，如果M1和M2分别发送到两台Server上，就不能保证M1先达到MQ集群，也不能保证M1被先消费。换个角度看，如果M2先于M1达到MQ集群，甚至M2被消费后，M1才达到消费端，这时消息也就乱序了，说明以上模型是不能保证消息的顺序的。如何才能在MQ集群保证消息的顺序？一种简单的方式就是将M1、M2发送到同一个Server上：</p>
<p><img src="//blog.com/2019/05/11/消息的顺序性保障/分布式开放消息系统(RocketMQ)的原理与实践/分布式开放消息系统(RocketMQ" alt="img">的原理与实践/175724-886b25d2ced8e641.webp)</p>
<p>保证消息顺序，你改进后的方法</p>
<p>这样可以保证M1先于M2到达MQServer（生产者等待M1发送成功后再发送M2），根据先达到先被消费的原则，M1会先于M2被消费，这样就保证了消息的顺序。</p>
<p>这个模型也仅仅是理论上可以保证消息的顺序，在实际场景中可能会遇到下面的问题：</p>
<p><img src="//blog.com/2019/05/11/消息的顺序性保障/分布式开放消息系统(RocketMQ)的原理与实践/分布式开放消息系统(RocketMQ" alt="img">的原理与实践/175724-34c5c00c2490136b.webp)</p>
<p>网络延迟问题</p>
<p>只要将消息从一台服务器发往另一台服务器，就会存在网络延迟问题。如上图所示，如果发送M1耗时大于发送M2的耗时，那么M2就仍将被先消费，仍然不能保证消息的顺序。即使M1和M2同时到达消费端，由于不清楚消费端1和消费端2的负载情况，仍然有可能出现M2先于M1被消费的情况。</p>
<p>那如何解决这个问题？将M1和M2发往同一个消费者，且发送M1后，需要消费端响应成功后才能发送M2。</p>
<p>聪明的你可能已经想到另外的问题：如果M1被发送到消费端后，消费端1没有响应，那是继续发送M2呢，还是重新发送M1？一般为了保证消息一定被消费，肯定会选择重发M1到另外一个消费端2，就如下图所示。</p>
<p><img src="//blog.com/2019/05/11/消息的顺序性保障/分布式开放消息系统(RocketMQ)的原理与实践/分布式开放消息系统(RocketMQ" alt="img">的原理与实践/175724-78a8706b4614440e.webp)</p>
<p>保证消息顺序的正确姿势</p>
<p>这样的模型就严格保证消息的顺序，细心的你仍然会发现问题，消费端1没有响应Server时有两种情况，一种是M1确实没有到达(数据在网络传送中丢失)，另外一种消费端已经消费M1且已经发送响应消息，只是MQ Server端没有收到。如果是第二种情况，重发M1，就会造成M1被重复消费。也就引入了我们要说的第二个问题，消息重复问题，这个后文会详细讲解。</p>
<p>回过头来看消息顺序问题，严格的顺序消息非常容易理解，也可以通过文中所描述的方式来简单处理。总结起来，要实现严格的顺序消息，简单且可行的办法就是：</p>
<blockquote>
<p>保证<code>生产者 - MQServer - 消费者</code>是一对一对一的关系</p>
</blockquote>
<p>这样的设计虽然简单易行，但也会存在一些很严重的问题，比如：</p>
<blockquote>
<ol>
<li>并行度就会成为消息系统的瓶颈（吞吐量不够）</li>
<li>更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。</li>
</ol>
</blockquote>
<p>但我们的最终目标是要集群的高容错性和高吞吐量。这似乎是一对不可调和的矛盾，那么阿里是如何解决的？</p>
<blockquote>
<p>世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它！—— <a href="http://i.youku.com/u/UMTcwMTg3NDc1Mg==?from=113-2-1-2" target="_blank" rel="noopener">沈询</a></p>
</blockquote>
<p>有些问题，看起来很重要，但实际上我们可以通过<strong>合理的设计</strong>或者<strong>将问题分解</strong>来规避。如果硬要把时间花在解决问题本身，实际上不仅效率低下，而且也是一种浪费。从这个角度来看消息的顺序问题，我们可以得出两个结论：</p>
<blockquote>
<ol>
<li>不关注乱序的应用实际大量存在</li>
<li>队列无序并不意味着消息无序</li>
</ol>
</blockquote>
<p>所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是不是我们应该寻求的一种更合理的方式？</p>
<p>最后我们从源码角度分析RocketMQ怎么实现发送顺序消息。</p>
<p>RocketMQ通过轮询所有队列的方式来确定消息被发送到哪一个队列（负载均衡策略）。比如下面的示例中，订单号相同的消息会被先后发送到同一个队列中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// RocketMQ通过MessageQueueSelector中实现的算法来确定消息发送到哪一个队列上</span><br><span class="line">// RocketMQ默认提供了两种MessageQueueSelector实现：随机/Hash</span><br><span class="line">// 当然你可以根据业务实现自己的MessageQueueSelector来决定消息按照何种策略发送到消息队列中</span><br><span class="line">SendResult sendResult = producer.send(msg, new MessageQueueSelector() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) &#123;</span><br><span class="line">        Integer id = (Integer) arg;</span><br><span class="line">        int index = id % mqs.size();</span><br><span class="line">        return mqs.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, orderId);</span><br></pre></td></tr></table></figure>
<p>在获取到路由信息以后，会根据<code>MessageQueueSelector</code>实现的算法来选择一个队列，同一个OrderId获取到的肯定是同一个队列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private SendResult send()  &#123;</span><br><span class="line">    // 获取topic路由信息</span><br><span class="line">    TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">    if (topicPublishInfo != null &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">        MessageQueue mq = null;</span><br><span class="line">        // 根据我们的算法，选择一个发送队列</span><br><span class="line">        // 这里的arg = orderId</span><br><span class="line">        mq = selector.select(topicPublishInfo.getMessageQueueList(), msg, arg);</span><br><span class="line">        if (mq != null) &#123;</span><br><span class="line">            return this.sendKernelImpl(msg, mq, communicationMode, sendCallback, timeout);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="二、消息重复"><a href="#二、消息重复" class="headerlink" title="二、消息重复"></a>二、消息重复</h5><p>上面在解决消息顺序问题时，引入了一个新的问题，就是消息重复。那么RocketMQ是怎样解决消息重复的问题呢？还是“恰好”不解决。</p>
<p>造成消息重复的根本原因是：网络不可达。只要通过网络交换数据，就无法避免这个问题。所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？</p>
<blockquote>
<ol>
<li>消费端处理消息的业务逻辑保持幂等性</li>
<li>保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现</li>
</ol>
</blockquote>
<p>第1条很好理解，只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。第2条原理就是利用一张日志表来记录已经处理成功的消息的ID，如果新到的消息ID已经在日志表中，那么就不再处理这条消息。</p>
<p>第1条解决方案，很明显应该在消费端实现，不属于消息系统要实现的功能。第2条可以消息系统实现，也可以业务端实现。正常情况下出现重复消息的概率其实很小，如果由消息系统来实现的话，肯定会对消息系统的吞吐量和高可用有影响，所以最好还是由业务端自己处理消息重复的问题，这也是RocketMQ不解决消息重复的问题的原因。</p>
<p><strong>RocketMQ不保证消息不重复，如果你的业务需要保证严格的不重复消息，需要你自己在业务端去重。</strong></p>
<h5 id="三、事务消息"><a href="#三、事务消息" class="headerlink" title="三、事务消息"></a>三、事务消息</h5><p>RocketMQ除了支持普通消息，顺序消息，另外还支持事务消息。首先讨论一下什么是事务消息以及支持事务消息的必要性。我们以一个转帐的场景为例来说明这个问题：Bob向Smith转账100块。</p>
<p>在单机环境下，执行事务的情况，大概是下面这个样子：</p>
<p><img src="//blog.com/2019/05/11/消息的顺序性保障/分布式开放消息系统(RocketMQ)的原理与实践/分布式开放消息系统(RocketMQ" alt="img">的原理与实践/175724-13a6d80b21345f45.webp)</p>
<p>单机环境下转账事务示意图</p>
<p>当用户增长到一定程度，Bob和Smith的账户及余额信息已经不在同一台服务器上了，那么上面的流程就变成了这样：</p>
<p><img src="//blog.com/2019/05/11/消息的顺序性保障/分布式开放消息系统(RocketMQ)的原理与实践/分布式开放消息系统(RocketMQ" alt="img">的原理与实践/175724-69101aad0122572b.webp)</p>
<p>集群环境下转账事务示意图</p>
<p>这时候你会发现，同样是一个转账的业务，在集群环境下，耗时居然成倍的增长，这显然是不能够接受的。那如何来规避这个问题？</p>
<blockquote>
<p><strong>大事务 = 小事务 + 异步</strong></p>
</blockquote>
<p>将大事务拆分成多个小事务异步执行。这样基本上能够将跨机事务的执行效率优化到与单机一致。转账的事务就可以分解成如下两个小事务：</p>
<p><img src="//blog.com/2019/05/11/消息的顺序性保障/分布式开放消息系统(RocketMQ)的原理与实践/分布式开放消息系统(RocketMQ" alt="img">的原理与实践/175724-92abb226f288ff9c.webp)</p>
<p>小事务+异步消息</p>
<p>图中执行本地事务（Bob账户扣款）和发送异步消息应该保证同时成功或者同时失败，也就是扣款成功了，发送消息一定要成功，如果扣款失败了，就不能再发送消息。那问题是：我们是先扣款还是先发送消息呢？</p>
<p>首先看下先发送消息的情况，大致的示意图如下：</p>
<p><img src="//blog.com/2019/05/11/消息的顺序性保障/分布式开放消息系统(RocketMQ)的原理与实践/分布式开放消息系统(RocketMQ" alt="img">的原理与实践/175724-1927b8f3d14ef823.webp)</p>
<p>事务消息：先发送消息</p>
<p>存在的问题是：如果消息发送成功，但是扣款失败，消费端就会消费此消息，进而向Smith账户加钱。</p>
<p>先发消息不行，那就先扣款吧，大致的示意图如下：</p>
<p><img src="//blog.com/2019/05/11/消息的顺序性保障/分布式开放消息系统(RocketMQ)的原理与实践/分布式开放消息系统(RocketMQ" alt="img">的原理与实践/175724-367b5cf60cbdfa16.webp)</p>
<p>事务消息-先扣款</p>
<p>存在的问题跟上面类似：如果扣款成功，发送消息失败，就会出现Bob扣钱了，但是Smith账户未加钱。</p>
<p>可能大家会有很多的方法来解决这个问题，比如：直接将发消息放到Bob扣款的事务中去，如果发送失败，抛出异常，事务回滚。这样的处理方式也符合“恰好”不需要解决的原则。</p>
<blockquote>
<p>这里需要说明一下：如果使用Spring来管理事物的话，大可以将发送消息的逻辑放到本地事物中去，发送消息失败抛出异常，Spring捕捉到异常后就会回滚此事物，以此来保证本地事物与发送消息的原子性。</p>
</blockquote>
<p>RocketMQ支持事务消息，下面来看看RocketMQ是怎样来实现的。</p>
<p><img src="//blog.com/2019/05/11/消息的顺序性保障/分布式开放消息系统(RocketMQ)的原理与实践/分布式开放消息系统(RocketMQ" alt="img">的原理与实践/175724-ab0085543c6d02d6.webp)</p>
<p>RocketMQ实现发送事务消息</p>
<p>RocketMQ第一阶段发送<code>Prepared消息</code>时，会拿到消息的地址，第二阶段执行本地事物，第三阶段通过第一阶段拿到的地址去访问消息，并修改消息的状态。</p>
<p>细心的你可能又发现问题了，如果确认消息发送失败了怎么办？RocketMQ会定期扫描消息集群中的事物消息，如果发现了<code>Prepared消息</code>，它会向消息发送端(生产者)确认，Bob的钱到底是减了还是没减呢？如果减了是回滚还是继续发送确认消息呢？RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</p>
<p>那我们来看下RocketMQ源码，是如何处理事务消息的。客户端发送事务消息的部分（完整代码请查看：<code>rocketmq-example</code>工程下的<code>com.alibaba.rocketmq.example.transaction.TransactionProducer</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// =============================发送事务消息的一系列准备工作========================================</span><br><span class="line">// 未决事务，MQ服务器回查客户端</span><br><span class="line">// 也就是上文所说的，当RocketMQ发现`Prepared消息`时，会根据这个Listener实现的策略来决断事务</span><br><span class="line">TransactionCheckListener transactionCheckListener = new TransactionCheckListenerImpl();</span><br><span class="line">// 构造事务消息的生产者</span><br><span class="line">TransactionMQProducer producer = new TransactionMQProducer(&quot;groupName&quot;);</span><br><span class="line">// 设置事务决断处理类</span><br><span class="line">producer.setTransactionCheckListener(transactionCheckListener);</span><br><span class="line">// 本地事务的处理逻辑，相当于示例中检查Bob账户并扣钱的逻辑</span><br><span class="line">TransactionExecuterImpl tranExecuter = new TransactionExecuterImpl();</span><br><span class="line">producer.start()</span><br><span class="line">// 构造MSG，省略构造参数</span><br><span class="line">Message msg = new Message(......);</span><br><span class="line">// 发送消息</span><br><span class="line">SendResult sendResult = producer.sendMessageInTransaction(msg, tranExecuter, null);</span><br><span class="line">producer.shutdown();</span><br></pre></td></tr></table></figure>
<p>接着查看<code>sendMessageInTransaction</code>方法的源码，总共分为3个阶段：发送<code>Prepared消息</code>、执行本地事务、发送确认消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//  ================================事务消息的发送过程=============================================</span><br><span class="line">public TransactionSendResult sendMessageInTransaction(.....)  &#123;</span><br><span class="line">    // 逻辑代码，非实际代码</span><br><span class="line">    // 1.发送消息</span><br><span class="line">    sendResult = this.send(msg);</span><br><span class="line">    // sendResult.getSendStatus() == SEND_OK</span><br><span class="line">    // 2.如果消息发送成功，处理与消息关联的本地事务单元</span><br><span class="line">    LocalTransactionState localTransactionState = tranExecuter.executeLocalTransactionBranch(msg, arg);</span><br><span class="line">    // 3.结束事务</span><br><span class="line">    this.endTransaction(sendResult, localTransactionState, localException);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>endTransaction</code>方法会将请求发往<code>broker(mq server)</code>去更新事务消息的最终状态：</p>
<ol>
<li>根据<code>sendResult</code>找到<code>Prepared消息</code> ，<code>sendResult</code>包含事务消息的ID</li>
<li>根据<code>localTransaction</code>更新消息的最终状态</li>
</ol>
<p>如果<code>endTransaction</code>方法执行失败，数据没有发送到<code>broker</code>，导致事务消息的 状态更新失败，<code>broker</code>会有回查线程定时（默认1分钟）扫描每个存储事务状态的表格文件，如果是已经提交或者回滚的消息直接跳过，如果是<code>prepared状态</code>则会向<code>Producer</code>发起<code>CheckTransaction</code>请求，<code>Producer</code>会调用<code>DefaultMQProducerImpl.checkTransactionState()</code>方法来处理<code>broker</code>的定时回调请求，而<code>checkTransactionState</code>会调用我们的事务设置的决断方法来决定是回滚事务还是继续执行，最后调用<code>endTransactionOneway</code>让<code>broker</code>来更新消息的最终状态。</p>
<p>再回到转账的例子，如果Bob的账户的余额已经减少，且消息已经发送成功，Smith端开始消费这条消息，这个时候就会出现消费失败和消费超时两个问题，解决超时问题的思路就是一直重试，直到消费端消费消息成功，整个过程中有可能会出现消息重复的问题，按照前面的思路解决即可。</p>
<p><img src="//blog.com/2019/05/11/消息的顺序性保障/分布式开放消息系统(RocketMQ)的原理与实践/分布式开放消息系统(RocketMQ" alt="img">的原理与实践/175724-1d9ba7bcd230e0dc.webp)</p>
<p>消费事务消息</p>
<p>这样基本上可以解决消费端超时问题，但是如果消费失败怎么办？阿里提供给我们的解决方法是：<strong>人工解决</strong>。大家可以考虑一下，按照事务的流程，因为某种原因Smith加款失败，那么需要回滚整个流程。如果消息系统要实现这个回滚流程的话，系统复杂度将大大提升，且很容易出现Bug，估计出现Bug的概率会比消费失败的概率大很多。这也是RocketMQ目前暂时没有解决这个问题的原因，在设计实现消息系统时，我们需要衡量是否值得花这么大的代价来解决这样一个出现概率非常小的问题，这也是大家在解决疑难问题时需要多多思考的地方。</p>
<blockquote>
<p>20160321补充：在3.2.6版本中移除了事务消息的实现，所以此版本不支持事务消息，具体情况请参考rocketmq的issues(已失效)：<br> <del><a href="https://github.com/alibaba/RocketMQ/issues/65" target="_blank" rel="noopener">https://github.com/alibaba/RocketMQ/issues/65</a></del><br> <del><a href="https://github.com/alibaba/RocketMQ/issues/138" target="_blank" rel="noopener">https://github.com/alibaba/RocketMQ/issues/138</a></del><br> <del><a href="https://github.com/alibaba/RocketMQ/issues/156" target="_blank" rel="noopener">https://github.com/alibaba/RocketMQ/issues/156</a></del></p>
</blockquote>
<p><a href="https://github.com/ld140319/Blog_ReConstruct/blob/master/%E6%9E%B6%E6%9E%84/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A6%82%E4%BD%95%E4%BF%9D%E9%9A%9C%E5%AE%9E%E9%99%85%E7%94%9F%E4%BA%A7%E4%B8%AD99.99%25%E9%AB%98%E5%8F%AF%E7%94%A8.md" target="_blank" rel="noopener">最终一致性分布式事务如何保障实际生产中99.99%高可用？</a></p>
<h5 id="四、Producer如何发送消息"><a href="#四、Producer如何发送消息" class="headerlink" title="四、Producer如何发送消息"></a>四、Producer如何发送消息</h5><p><code>Producer</code>轮询某topic下的所有队列的方式来实现发送方的负载均衡，如下图所示：</p>
<p><img src="//blog.com/2019/05/11/消息的顺序性保障/分布式开放消息系统(RocketMQ)的原理与实践/分布式开放消息系统(RocketMQ" alt="img">的原理与实践/175724-9eac93e29d0e06ef.webp)</p>
<p>producer发送消息负载均衡</p>
<p> 首先分析一下RocketMQ的客户端发送消息的源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 构造Producer</span><br><span class="line">DefaultMQProducer producer = new DefaultMQProducer(&quot;ProducerGroupName&quot;);</span><br><span class="line">// 初始化Producer，整个应用生命周期内，只需要初始化1次</span><br><span class="line">producer.start();</span><br><span class="line">// 构造Message</span><br><span class="line">Message msg = new Message(&quot;TopicTest1&quot;,// topic</span><br><span class="line">                        &quot;TagA&quot;,// tag：给消息打标签,用于区分一类消息，可为null</span><br><span class="line">                        &quot;OrderID188&quot;,// key：自定义Key，可以用于去重，可为null</span><br><span class="line">                        (&quot;Hello MetaQ&quot;).getBytes());// body：消息内容</span><br><span class="line">// 发送消息并返回结果</span><br><span class="line">SendResult sendResult = producer.send(msg);</span><br><span class="line">// 清理资源，关闭网络连接，注销自己</span><br><span class="line">producer.shutdown();</span><br></pre></td></tr></table></figure>
<p>在整个应用生命周期内，生产者需要调用一次start方法来初始化，初始化主要完成的任务有：</p>
<blockquote>
<ol>
<li>如果没有指定<code>namesrv</code>地址，将会自动寻址</li>
<li>启动定时任务：更新namesrv地址、从namsrv更新topic路由信息、清理已经挂掉的broker、向所有broker发送心跳…</li>
<li>启动负载均衡的服务</li>
</ol>
</blockquote>
<p>初始化完成后，开始发送消息，发送消息的主要代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private SendResult sendDefaultImpl(Message msg,......) &#123;</span><br><span class="line">    // 检查Producer的状态是否是RUNNING</span><br><span class="line">    this.makeSureStateOK();</span><br><span class="line">    // 检查msg是否合法：是否为null、topic,body是否为空、body是否超长</span><br><span class="line">    Validators.checkMessage(msg, this.defaultMQProducer);</span><br><span class="line">    // 获取topic路由信息</span><br><span class="line">    TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">    // 从路由信息中选择一个消息队列</span><br><span class="line">    MessageQueue mq = topicPublishInfo.selectOneMessageQueue(lastBrokerName);</span><br><span class="line">    // 将消息发送到该队列上去</span><br><span class="line">    sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中需要关注的两个方法<code>tryToFindTopicPublishInfo</code>和<code>selectOneMessageQueue</code>。前面说过在producer初始化时，会启动定时任务获取路由信息并更新到本地缓存，所以<code>tryToFindTopicPublishInfo</code>会首先从缓存中获取topic路由信息，如果没有获取到，则会自己去<code>namesrv</code>获取路由信息。<code>selectOneMessageQueue</code>方法通过轮询的方式，返回一个队列，以达到负载均衡的目的。</p>
<p>如果Producer发送消息失败，会自动重试，重试的策略：</p>
<ol>
<li>重试次数 &lt; retryTimesWhenSendFailed（可配置）</li>
<li>总的耗时（包含重试n次的耗时） &lt; sendMsgTimeout（发送消息时传入的参数）</li>
<li>同时满足上面两个条件后，Producer会选择另外一个队列发送消息</li>
</ol>
<h5 id="五、消息存储"><a href="#五、消息存储" class="headerlink" title="五、消息存储"></a>五、消息存储</h5><p>RocketMQ的消息存储是由<code>consume queue</code>和<code>commit log</code>配合完成的。</p>
<h6 id="1、Consume-Queue"><a href="#1、Consume-Queue" class="headerlink" title="1、Consume Queue"></a>1、Consume Queue</h6><p><code>consume queue</code>是消息的逻辑队列，相当于字典的目录，用来指定消息在物理文件<code>commit log</code>上的位置。</p>
<p>我们可以在配置中指定<code>consumequeue</code>与<code>commitlog</code>存储的目录<br> 每个<code>topic</code>下的每个<code>queue</code>都有一个对应的<code>consumequeue</code>文件，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;rocketmq.home&#125;/store/consumequeue/$&#123;topicName&#125;/$&#123;queueId&#125;/$&#123;fileName&#125;</span><br></pre></td></tr></table></figure>
<p>Consume Queue文件组织，如图所示：</p>
<p><img src="//blog.com/2019/05/11/消息的顺序性保障/分布式开放消息系统(RocketMQ)的原理与实践/分布式开放消息系统(RocketMQ" alt="img">的原理与实践/175724-d1b4318d77a96950.webp)</p>
<p>Consume Queue文件组织示意图</p>
<ol>
<li>根据<code>topic</code>和<code>queueId</code>来组织文件，图中TopicA有两个队列0,1，那么TopicA和QueueId=0组成一个ConsumeQueue，TopicA和QueueId=1组成另一个ConsumeQueue。</li>
<li>按照消费端的<code>GroupName</code>来分组重试队列，如果消费端消费失败，消息将被发往重试队列中，比如图中的<code>%RETRY%ConsumerGroupA</code>。</li>
<li>按照消费端的<code>GroupName</code>来分组死信队列，如果消费端消费失败，并重试指定次数后，仍然失败，则发往死信队列，比如图中的<code>%DLQ%ConsumerGroupA</code>。</li>
</ol>
<blockquote>
<p>死信队列（Dead Letter Queue）一般用于存放由于某种原因无法传递的消息，比如处理失败或者已经过期的消息。</p>
</blockquote>
<p>Consume Queue中存储单元是一个20字节定长的二进制数据，顺序写顺序读，如下图所示：</p>
<p><img src="//blog.com/2019/05/11/消息的顺序性保障/分布式开放消息系统(RocketMQ)的原理与实践/分布式开放消息系统(RocketMQ" alt="img">的原理与实践/175724-7212acc81b91c086.webp)</p>
<p>consumequeue文件存储单元格式</p>
<ol>
<li>CommitLog Offset是指这条消息在Commit Log文件中的实际偏移量</li>
<li>Size存储中消息的大小</li>
<li>Message Tag HashCode存储消息的Tag的哈希值：主要用于订阅时消息过滤（订阅时如果指定了Tag，会根据HashCode来快速查找到订阅的消息）</li>
</ol>
<h6 id="2、Commit-Log"><a href="#2、Commit-Log" class="headerlink" title="2、Commit Log"></a>2、Commit Log</h6><p>CommitLog：消息存放的物理文件，每台<code>broker</code>上的<code>commitlog</code>被本机所有的<code>queue</code>共享，不做任何区分。<br> 文件的默认位置如下，仍然可通过配置文件修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;user.home&#125; \store\$&#123;commitlog&#125;\$&#123;fileName&#125;</span><br></pre></td></tr></table></figure>
<p>CommitLog的消息存储单元长度不固定，文件顺序写，随机读。消息的存储结构如下表所示，按照编号顺序以及编号对应的内容依次存储。</p>
<p><img src="//blog.com/2019/05/11/消息的顺序性保障/分布式开放消息系统(RocketMQ)的原理与实践/分布式开放消息系统(RocketMQ" alt="img">的原理与实践/175724-96ed677eb504abfe.webp)</p>
<p>Commit Log存储单元结构图</p>
<h6 id="3、消息存储实现"><a href="#3、消息存储实现" class="headerlink" title="3、消息存储实现"></a>3、消息存储实现</h6><p>消息存储实现，比较复杂，也值得大家深入了解，后面会单独成文来分析(目前正在收集素材)，这小节只以代码说明一下具体的流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// Set the storage time</span><br><span class="line">msg.setStoreTimestamp(System.currentTimeMillis());</span><br><span class="line">// Set the message body BODY CRC (consider the most appropriate setting</span><br><span class="line">msg.setBodyCRC(UtilAll.crc32(msg.getBody()));</span><br><span class="line">StoreStatsService storeStatsService = this.defaultMessageStore.getStoreStatsService();</span><br><span class="line">synchronized (this) &#123;</span><br><span class="line">    long beginLockTimestamp = this.defaultMessageStore.getSystemClock().now();</span><br><span class="line">    // Here settings are stored timestamp, in order to ensure an orderly global</span><br><span class="line">    msg.setStoreTimestamp(beginLockTimestamp);</span><br><span class="line">    // MapedFile：操作物理文件在内存中的映射以及将内存数据持久化到物理文件中</span><br><span class="line">    MapedFile mapedFile = this.mapedFileQueue.getLastMapedFile();</span><br><span class="line">    // 将Message追加到文件commitlog</span><br><span class="line">    result = mapedFile.appendMessage(msg, this.appendMessageCallback);</span><br><span class="line">    switch (result.getStatus()) &#123;</span><br><span class="line">    case PUT_OK:break;</span><br><span class="line">    case END_OF_FILE:</span><br><span class="line">         // Create a new file, re-write the message</span><br><span class="line">         mapedFile = this.mapedFileQueue.getLastMapedFile();</span><br><span class="line">         result = mapedFile.appendMessage(msg, this.appendMessageCallback);</span><br><span class="line">     break;</span><br><span class="line">     DispatchRequest dispatchRequest = new DispatchRequest(</span><br><span class="line">                topic,// 1</span><br><span class="line">                queueId,// 2</span><br><span class="line">                result.getWroteOffset(),// 3</span><br><span class="line">                result.getWroteBytes(),// 4</span><br><span class="line">                tagsCode,// 5</span><br><span class="line">                msg.getStoreTimestamp(),// 6</span><br><span class="line">                result.getLogicsOffset(),// 7</span><br><span class="line">                msg.getKeys(),// 8</span><br><span class="line">                /**</span><br><span class="line">                 * Transaction</span><br><span class="line">                 */</span><br><span class="line">                msg.getSysFlag(),// 9</span><br><span class="line">                msg.getPreparedTransactionOffset());// 10</span><br><span class="line">    // 1.分发消息位置到ConsumeQueue</span><br><span class="line">    // 2.分发到IndexService建立索引</span><br><span class="line">    this.defaultMessageStore.putDispatchRequest(dispatchRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4、消息的索引文件"><a href="#4、消息的索引文件" class="headerlink" title="4、消息的索引文件"></a>4、消息的索引文件</h6><p>如果一个消息包含key值的话，会使用IndexFile存储消息索引，文件的内容结构如图：</p>
<p><img src="//blog.com/2019/05/11/消息的顺序性保障/分布式开放消息系统(RocketMQ)的原理与实践/分布式开放消息系统(RocketMQ" alt="img">的原理与实践/175724-4deee0fb9d08e02d.webp)</p>
<p>消息索引</p>
<p>索引文件主要用于根据key来查询消息的，流程主要是：</p>
<ol>
<li>根据查询的 key 的 hashcode%slotNum 得到具体的槽的位置(slotNum 是一个索引文件里面包含的最大槽的数目，例如图中所示 slotNum=5000000)</li>
<li>根据 slotValue(slot 位置对应的值)查找到索引项列表的最后一项(倒序排列,slotValue 总是指向最新的一个索引项)</li>
<li>遍历索引项列表返回查询时间范围内的结果集(默认一次最大返回的 32 条记录)</li>
</ol>
<h5 id="六、消息订阅"><a href="#六、消息订阅" class="headerlink" title="六、消息订阅"></a>六、消息订阅</h5><p>RocketMQ消息订阅有两种模式，一种是Push模式，即MQServer主动向消费端推送；另外一种是Pull模式，即消费端在需要时，主动到MQServer拉取。但在具体实现时，Push和Pull模式都是采用消费端主动拉取的方式。</p>
<p>首先看下消费端的负载均衡：</p>
<p><img src="//blog.com/2019/05/11/消息的顺序性保障/分布式开放消息系统(RocketMQ)的原理与实践/分布式开放消息系统(RocketMQ" alt="img">的原理与实践/175724-fdbb184a5d9bd022.webp)</p>
<p>消费端负载均衡</p>
<p>消费端会通过RebalanceService线程，10秒钟做一次基于topic下的所有队列负载：</p>
<ol>
<li>遍历Consumer下的所有topic，然后根据topic订阅所有的消息</li>
<li>获取同一topic和Consumer Group下的所有Consumer</li>
<li>然后根据具体的分配策略来分配消费队列，分配的策略包含：平均分配、消费端配置等</li>
</ol>
<p>如同上图所示：如果有 5 个队列，2 个 consumer，那么第一个 Consumer 消费 3 个队列，第二 consumer 消费 2 个队列。这里采用的就是平均分配策略，它类似于分页的过程，TOPIC下面的所有queue就是记录，Consumer的个数就相当于总的页数，那么每页有多少条记录，就类似于某个Consumer会消费哪些队列。</p>
<p>通过这样的策略来达到大体上的平均消费，这样的设计也可以很方面的水平扩展Consumer来提高消费能力。</p>
<p>消费端的Push模式是通过长轮询的模式来实现的，就如同下图：</p>
<p><img src="//blog.com/2019/05/11/消息的顺序性保障/分布式开放消息系统(RocketMQ)的原理与实践/分布式开放消息系统(RocketMQ" alt="img">的原理与实践/175724-f2e2ee205d49a05f.webp)</p>
<p>Push模式示意图</p>
<p>Consumer端每隔一段时间主动向broker发送拉消息请求，broker在收到Pull请求后，如果有消息就立即返回数据，Consumer端收到返回的消息后，再回调消费者设置的Listener方法。如果broker在收到Pull请求时，消息队列里没有数据，broker端会阻塞请求直到有数据传递或超时才返回。</p>
<p>当然，Consumer端是通过一个线程将阻塞队列<code>LinkedBlockingQueue&lt;PullRequest&gt;</code>中的<code>PullRequest</code>发送到broker拉取消息，以防止Consumer一致被阻塞。而Broker端，在接收到Consumer的<code>PullRequest</code>时，如果发现没有消息，就会把<code>PullRequest</code>扔到ConcurrentHashMap中缓存起来。broker在启动时，会启动一个线程不停的从ConcurrentHashMap取出<code>PullRequest</code>检查，直到有数据返回。</p>
<h5 id="七、RocketMQ的其他特性"><a href="#七、RocketMQ的其他特性" class="headerlink" title="七、RocketMQ的其他特性"></a>七、RocketMQ的其他特性</h5><p>前面的6个特性都是基本上都是点到为止，想要深入了解，还需要大家多多查看源码，多多在实际中运用。当然除了已经提到的特性外，RocketMQ还支持：</p>
<ol>
<li>定时消息</li>
<li>消息的刷盘策略</li>
<li>主动同步策略：同步双写、异步复制</li>
<li>海量消息堆积能力</li>
<li>高效通信</li>
<li>…….</li>
</ol>
<p>其中涉及到的很多设计思路和解决方法都值得我们深入研究：</p>
<ol>
<li>消息的存储设计：既要满足海量消息的堆积能力，又要满足极快的查询效率，还要保证写入的效率。</li>
<li>高效的通信组件设计：高吞吐量，毫秒级的消息投递能力都离不开高效的通信。</li>
<li>…….</li>
</ol>
<h4 id="RocketMQ最佳实践"><a href="#RocketMQ最佳实践" class="headerlink" title="RocketMQ最佳实践"></a>RocketMQ最佳实践</h4><h5 id="一、Producer最佳实践"><a href="#一、Producer最佳实践" class="headerlink" title="一、Producer最佳实践"></a>一、Producer最佳实践</h5><p>1、一个应用尽可能用一个 Topic，消息子类型用 tags 来标识，tags 可以由应用自由设置。只有发送消息设置了tags，消费方在订阅消息时，才可以利用 tags 在 broker 做消息过滤。<br> 2、每个消息在业务层面的唯一标识码，要设置到 keys 字段，方便将来定位消息丢失问题。由于是哈希索引，请务必保证 key 尽可能唯一，这样可以避免潜在的哈希冲突。<br> 3、消息发送成功或者失败，要打印消息日志，务必要打印 sendresult 和 key 字段。<br> 4、对于消息不可丢失应用，务必要有消息重发机制。例如：消息发送失败，存储到数据库，能有定时程序尝试重发或者人工触发重发。<br> 5、某些应用如果不关注消息是否发送成功，请直接使用<code>sendOneWay</code>方法发送消息。</p>
<h5 id="二、Consumer最佳实践"><a href="#二、Consumer最佳实践" class="headerlink" title="二、Consumer最佳实践"></a>二、Consumer最佳实践</h5><p>1、消费过程要做到幂等（即消费端去重）<br> 2、尽量使用批量方式消费方式，可以很大程度上提高消费吞吐量。<br> 3、优化每条消息消费过程</p>
<h5 id="三、其他配置"><a href="#三、其他配置" class="headerlink" title="三、其他配置"></a>三、其他配置</h5><p>线上应该关闭<code>autoCreateTopicEnable</code>，即在配置文件中将其设置为<code>false</code>。</p>
<p>RocketMQ在发送消息时，会首先获取路由信息。如果是新的消息，由于MQServer上面还没有创建对应的<code>Topic</code>，这个时候，如果上面的配置打开的话，会返回默认TOPIC的（RocketMQ会在每台<code>broker</code>上面创建名为<code>TBW102</code>的TOPIC）路由信息，然后<code>Producer</code>会选择一台<code>Broker</code>发送消息，选中的<code>broker</code>在存储消息时，发现消息的<code>topic</code>还没有创建，就会自动创建<code>topic</code>。后果就是：以后所有该TOPIC的消息，都将发送到这台<code>broker</code>上，达不到负载均衡的目的。</p>
<p>所以基于目前RocketMQ的设计，建议关闭自动创建TOPIC的功能，然后根据消息量的大小，手动创建TOPIC。</p>
<h4 id="RocketMQ设计相关"><a href="#RocketMQ设计相关" class="headerlink" title="RocketMQ设计相关"></a>RocketMQ设计相关</h4><p>RocketMQ的设计假定：</p>
<blockquote>
<p>每台PC机器都可能宕机不可服务<br> 任意集群都有可能处理能力不足<br> 最坏的情况一定会发生<br> 内网环境需要低延迟来提供最佳用户体验</p>
</blockquote>
<p>RocketMQ的关键设计：</p>
<blockquote>
<p>分布式集群化<br> 强数据安全<br> 海量数据堆积<br> 毫秒级投递延迟（推拉模式）</p>
</blockquote>
<p>这是RocketMQ在设计时的假定前提以及需要到达的效果。我想这些假定适用于所有的系统设计。随着我们系统的服务的增多，每位开发者都要注意自己的程序是否存在单点故障，如果挂了应该怎么恢复、能不能很好的水平扩展、对外的接口是否足够高效、自己管理的数据是否足够安全…… 多多规范自己的设计，才能开发出高效健壮的程序。</p>
<h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><ol>
<li><a href="http://pan.baidu.com/s/1kTWsE8J" target="_blank" rel="noopener">RocketMQ用户指南</a></li>
<li><a href="http://pan.baidu.com/s/1bogcpgN" target="_blank" rel="noopener">RocketMQ原理简介</a></li>
<li><a href="http://pan.baidu.com/s/1kTXE4PD" target="_blank" rel="noopener">RocketMQ最佳实践</a></li>
<li><a href="http://v.youku.com/v_show/id_XODY4ODE3OTY0.html?from=s1.8-1-1.2" target="_blank" rel="noopener">阿里分布式开放消息服务(ONS)原理与实践2</a></li>
<li><a href="http://v.youku.com/v_show/id_XODY5ODcxNjI0.html?from=s1.8-1-1.2" target="_blank" rel="noopener">阿里分布式开放消息服务(ONS)原理与实践3</a></li>
<li><a href="http://blog.csdn.net/column/details/learningrocketmq.html" target="_blank" rel="noopener">RocketMQ原理解析</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/74/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/74/">74</a><span class="page-number current">75</span><a class="page-number" href="/page/76/">76</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/76/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
