<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/page/38/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/page/38/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/22/微服务化的十个设计要点/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/22/微服务化的十个设计要点/" itemprop="url">微服务化的十个设计要点</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-22T12:12:57+08:00">
                2019-06-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/微服务/" itemprop="url" rel="index">
                    <span itemprop="name">微服务</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/微服务/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="微服务化的十个设计要点"><a href="#微服务化的十个设计要点" class="headerlink" title="微服务化的十个设计要点"></a>微服务化的十个设计要点</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&amp;mid=2247484884&amp;idx=1&amp;sn=55113645acb4ce356aa0598ace9f3191&amp;chksm=fbb28c2accc5053cee90bdd08230ff9f8741caf98008d0fdbc21dfcfaf968cbb84a622a2ca87&amp;mpshare=1&amp;scene=23&amp;srcid=0620eWdLyank3hK3ZPPyovli#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzU0OTE4MzYzMw==&amp;mid=2247484884&amp;idx=1&amp;sn=55113645acb4ce356aa0598ace9f3191&amp;chksm=fbb28c2accc5053cee90bdd08230ff9f8741caf98008d0fdbc21dfcfaf968cbb84a622a2ca87&amp;mpshare=1&amp;scene=23&amp;srcid=0620eWdLyank3hK3ZPPyovli#rd</a></p>
</blockquote>
<p><br></p>
<p>微服务有哪些要点呢？先看下图是 <code>SpringCloud</code> 的整个生态。</p>
<p><img src="//blog.com/2019/06/22/微服务化的十个设计要点/fEsWkVrSk57JR01A0dpHwVZFo8xqOjtZEP5cyFrPicQ6KWibqQwmTlLTy02EpIkibJ1U2oRLgiay8iabY0zCvEH1DMQ.png" alt="img"></p>
<h2 id="设计要点一：API-网关"><a href="#设计要点一：API-网关" class="headerlink" title="设计要点一：API 网关"></a>设计要点一：API 网关</h2><p><img src="//blog.com/2019/06/22/微服务化的十个设计要点/Kp8zGHrttZao63pSfoGFPdF4aEZYibmPp0P0zH0ghlElHaVGxpIaYbZlTeFkaBvglP02RvpO5nwJNjeCWInlKJA.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实施微服务的过程中，不免要面临服务的聚合与拆分，当后端服务的拆分相对比较频繁的时候，作为手机 App 来讲，往往需要一个统一的入口，将不同的请求路由到不同的服务，无论后面如何拆分与聚合，对于手机端来讲都是透明的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有了 API 网关以后，简单的数据聚合可以在网关层完成，这样就不用在手机 App 端完成，从而手机 App 耗电量较小，用户体验较好。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有了统一的 API 网关，还可以进行<strong>统一的认证和鉴权</strong>，尽管服务之间的相互调用比较复杂，接口也会比较多，`API 网关往往只暴露必须的对外接口，并且对接口进行统一的认证和鉴权，使得内部的服务相互访问的时候，不用再进行认证和鉴权，效率会比较高。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有了统一的 API 网关，可以在这一层设定一定的策略，进行 <strong>A/B 测试，蓝绿发布，预发环境导流</strong>等等。API 网关往往是无状态的，可以横向扩展，从而不会成为性能瓶颈。</p>
<h2 id="设计要点二：无状态化，区分有状态的和无状态的应用"><a href="#设计要点二：无状态化，区分有状态的和无状态的应用" class="headerlink" title="设计要点二：无状态化，区分有状态的和无状态的应用"></a>设计要点二：无状态化，区分有状态的和无状态的应用</h2><p><img src="//blog.com/2019/06/22/微服务化的十个设计要点/Kp8zGHrttZao63pSfoGFPdF4aEZYibmPpm8MmFgw3xaegMQrfN9z0JxcJ3hYUv2dsuTwVQK3nm4rvaVic9DClpgg.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>影响应用迁移和横向扩展的重要因素就是应用的状态，无状态服务，是要把这个状态往外移，将 <code>Session</code> 数据，文件数据，结构化数据保存在后端统一的存储中，从而应用仅仅包含商务逻辑</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;状态是不可避免的，例如 <code>ZooKeeper, DB，Cache</code> 等，把这些所有有状态的东西收敛在一个非常集中的集群里面。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整个业务就分两部分，一个是无状态的部分，一个是有状态的部分。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>无状态的部分能实现两点，一是跨机房随意地部署，也即迁移性，一是弹性伸缩，很容易地进行扩容</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有状态的部分，如 <code>DB，Cache，ZooKeeper</code> 有自己的<strong>高可用机制</strong>，要利用到他们自己高可用的机制来实现这个状态的集群。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽说无状态化，但是当前处理的数据，还是会在内存里面的，当前的进程挂掉数据，肯定也是有一部分丢失的，为了实现这一点，<strong>服务要有重试的机制，接口要有幂等的机制，通过服务发现机制，重新调用一次后端服务的另一个实例就可以了</strong>。</p>
<h2 id="设计要点三：数据库的横向扩展"><a href="#设计要点三：数据库的横向扩展" class="headerlink" title="设计要点三：数据库的横向扩展"></a>设计要点三：数据库的横向扩展</h2><p><img src="//blog.com/2019/06/22/微服务化的十个设计要点/Kp8zGHrttZao63pSfoGFPdF4aEZYibmPpGmcm4WbmhpoKVMJhaVdgGllcBeUSoNjfwISsJT3kO9qj98WSakjWJw.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据库是保存状态，是最重要的也是最容易出现瓶颈的。有了分布式数据库可以使数据库的性能可以随着节点增加线性地增加。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分布式数据库最最下面是 <code>RDS</code>，是主备的，通过 <code>MySql</code>的内核开发能力，我们能够实现主备切换数据零丢失，所以数据落在这个 <code>RDS</code>里面，是非常放心的，哪怕是挂了一个节点，切换完了以后，你的数据也是不会丢的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再往上就是横向怎么承载大的吞吐量的问题，上面有一个负载均衡<code>NLB</code>，用<code>LVS，HAProxy, Keepalived</code>，下面接了一层<code>Query Server</code>。<code>Query Server</code>是可以根据监控数据进行横向扩展的，如果出现了故障，可以随时进行替换的修复，对于业务层是没有任何感知的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外一个就是双机房的部署，<code>DDB</code>开发了一个数据运河 <code>NDC</code>的组件，可以使得不同的<code>DDB</code>之间在不同的机房里面进行同步，这时候不但在一个数据中心里面是分布式的，在多个数据中心里面也会有一个类似双活的一个备份，高可用性有非常好的保证。</p>
<h2 id="设计要点四：缓存"><a href="#设计要点四：缓存" class="headerlink" title="设计要点四：缓存"></a>设计要点四：缓存</h2><p><img src="//blog.com/2019/06/22/微服务化的十个设计要点/Kp8zGHrttZao63pSfoGFPdF4aEZYibmPpCkIicc8dTjK6Nia0Kyce06nad6BhH7iax0rcb7PElJ5BW3AA43h3SIEfw.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在高并发场景下缓存是非常重要的。要有层次的缓存，使得数据尽量靠近用户。数据越靠近用户能承载的并发量也越大，响应时间越短。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在手机客户端 App 上就应该有一层缓存，不是所有的数据都每时每刻从后端拿，而是只拿重要的，关键的，时常变化的数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尤其对于静态数据，可以过一段时间去取一次，而且也没必要到数据中心去取，可以通过 <code>CDN</code>，将数据缓存在距离客户端最近的节点上，进行就近下载。</p>
<p>有&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;时候<code>CDN</code> 里面没有，还是要回到数据中心去下载，称为回源，在数据中心的最外层，我们称为接入层，可以设置一层缓存，将大部分的请求拦截，从而不会对后台的数据库造成压力。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果是动态数据，还是需要访问应用，通过应用中的商务逻辑生成，或者去数据库读取，为了减轻数据库的压力，应用可以使用本地的缓存，也可以使用分布式缓存，如 <code>Memcached</code> 或者 <code>Redis</code>，使得大部分请求读取缓存即可，不必访问数据库。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然动态数据还可以做一定的静态化，也即降级成静态数据，从而减少后端的压力。</p>
<h2 id="设计要点五：服务拆分和服务发现"><a href="#设计要点五：服务拆分和服务发现" class="headerlink" title="设计要点五：服务拆分和服务发现"></a>设计要点五：服务拆分和服务发现</h2><p><img src="//blog.com/2019/06/22/微服务化的十个设计要点/Kp8zGHrttZao63pSfoGFPdF4aEZYibmPpagNGkuj0svJIdtibo1aicMKAcDsLxavVSCKE7iasxhRbEmdADWjzykLiaA.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当系统扛不住，应用变化快的时候，往往要考虑将比较大的服务拆分为一系列小的服务。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样第一个好处就是<strong>开发比较独立</strong>，当非常多的人在维护同一个代码仓库的时候，往往对代码的修改就会相互影响，常常会出现我没改什么测试就不通过了，而且代码提交的时候，经常会出现冲突，需要进行代码合并，大大降低了开发的效率。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个好处就是<strong>上线独立</strong>，物流模块对接了一家新的快递公司，需要连同下单一起上线，这是非常不合理的行为，我没改还要我重启，我没改还让我发布，我没改还要我开会，都是应该拆分的时机。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外再就是<strong>高并发时段的扩容</strong>，往往只有最关键的下单和支付流程是核心，只要将关键的交易链路进行扩容即可，如果这时候附带很多其他的服务，扩容即是不经济的，也是很有风险的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再就是<strong>容灾和降级</strong>，在大促的时候，可能需要牺牲一部分的边角功能，但是如果所有的代码耦合在一起，很难将边角的部分功能进行降级。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然<strong>拆分完毕以后，应用之间的关系就更加复杂了，因而需要服务发现的机制，来管理应用相互的关系，实现自动的修复，自动的关联，自动的负载均衡，自动的容错切换</strong>。</p>
<h2 id="设计要点六：服务编排与弹性伸缩"><a href="#设计要点六：服务编排与弹性伸缩" class="headerlink" title="设计要点六：服务编排与弹性伸缩"></a>设计要点六：服务编排与弹性伸缩</h2><p><img src="//blog.com/2019/06/22/微服务化的十个设计要点/Kp8zGHrttZao63pSfoGFPdF4aEZYibmPpmn5ibk1QeGalzstZqdNnq7rO7MoLK4Oa8vkEt8oYnuGrrcNS0neJwLQ.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当服务拆分了，进程就会非常的多，因而需要服务编排来管理服务之间的依赖关系，以及将服务的部署代码化，也就是我们常说的基础设施即代码。这样<strong>对于服务的发布，更新，回滚，扩容，缩容，都可以通过修改编排文件来实现，从而增加了可追溯性，易管理性，和自动化的能力</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然编排文件也可以用代码仓库进行管理，就可以实现一百个服务中，更新其中五个服务，只要修改编排文件中的五个服务的配置就可以，<strong>当编排文件提交的时候，代码仓库自动触发自动部署升级脚本，从而更新线上的环境，当发现新的环境有问题时，当然希望将这五个服务原子性地回滚，如果没有编排文件，需要人工记录这次升级了哪五个服务</strong>。有了编排文件，只要在代码仓库里面 <code>revert</code>，就回滚到上一个版本了。所有的操作在代码仓库里都是可以看到的。</p>
<h2 id="设计要点七：统一配置中心"><a href="#设计要点七：统一配置中心" class="headerlink" title="设计要点七：统一配置中心"></a>设计要点七：统一配置中心</h2><p><img src="//blog.com/2019/06/22/微服务化的十个设计要点/Kp8zGHrttZao63pSfoGFPdF4aEZYibmPpcMPIFtFqWza628HKHQ0hSmXCBIOeqGskzXCicicBLwAyOIoJXZU0vUag.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;服务拆分以后，服务的数量非常多，如果所有的配置都以配置文件的方式放在应用本地的话，非常难以管理，可以想象当有几百上千个进程中有一个配置出现了问题，是很难将它找出来的，因而需要有统一的配置中心，来管理所有的配置，进行统一的配置下发。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在微服务中，配置往往分为几类，一类是几乎不变的配置，这种配置可以直接打在容器镜像里面，第二类是启动时就会确定的配置，这种配置往往通过环境变量，在容器启动的时候传进去，第三类就是<strong>统一的配置，需要通过配置中心进行下发，例如在大促的情况下，有些功能需要降级，哪些功能可以降级，哪些功能不能降级，都可以在配置文件中统一配置</strong>。</p>
<h2 id="设计要点八：统一的日志中心"><a href="#设计要点八：统一的日志中心" class="headerlink" title="设计要点八：统一的日志中心"></a>设计要点八：统一的日志中心</h2><p><img src="//blog.com/2019/06/22/微服务化的十个设计要点/Kp8zGHrttZao63pSfoGFPdF4aEZYibmPpca2emD56zpZXZKQVrmFxLc24kDqMYP1C2icK4PejeiaGLFn3NTLXc1Ag.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样是进程数目非常多的时候，很难对成千上百个容器，一个一个登录进去查看日志，所以需要统一的日志中心来收集日志，为了使收集到的日志容易分析，对于日志的规范，需要有一定的要求，当所有的服务都遵守统一的日志规范的时候，在日志中心就可以对一个交易流程进行统一的追溯。例如在最后的日志搜索引擎中，搜索交易号，就能够看到在哪个过程出现了错误或者异常。</p>
<h2 id="设计要点九：熔断，限流，降级"><a href="#设计要点九：熔断，限流，降级" class="headerlink" title="设计要点九：熔断，限流，降级"></a>设计要点九：熔断，限流，降级</h2><p><img src="//blog.com/2019/06/22/微服务化的十个设计要点/Kp8zGHrttZao63pSfoGFPdF4aEZYibmPpRPIcfqI50kjgeMJy1c2vrI1msPOQXz7kRyPRGhlKzVrOAgHRZIqCDw.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;服务要有熔断，限流，降级的能力，当一个服务调用另一个服务，出现超时的时候，应及时返回，而非阻塞在那个地方，从而影响其他用户的交易，可以返回默认的托底数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一个服务发现被调用的服务，因为过于繁忙，线程池满，连接池满，或者总是出错，则应该及时熔断，防止因为下一个服务的错误或繁忙，导致本服务的不正常，从而逐渐往前传导，导致整个应用的雪崩。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当发现整个系统的确负载过高的时候，可以选择降级某些功能或某些调用，保证最重要的交易流程的通过，以及最重要的资源全部用于保证最核心的流程。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一种手段就是限流，当既设置了熔断策略，又设置了降级策略，通过全链路的压力测试，应该能够知道整个系统的支撑能力，因而就需要制定限流策略，保证系统在测试过的支撑能力范围内进行服务，超出支撑能力范围的，可拒绝服务。当你下单的时候，系统弹出对话框说 “系统忙，请重试”，并不代表系统挂了，而是说明系统是正常工作的，只不过限流策略起到了作用。</p>
<h2 id="设计要点十：全方位的监控"><a href="#设计要点十：全方位的监控" class="headerlink" title="设计要点十：全方位的监控"></a>设计要点十：全方位的监控</h2><p><img src="//blog.com/2019/06/22/微服务化的十个设计要点/Kp8zGHrttZao63pSfoGFPdF4aEZYibmPp0JcrY9GReeUeOreECjl2vq4cs06qz8xA75hgUwX9Mv9gBo1ZOrNn5A.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当系统非常复杂的时候，要有统一的监控，主要有两个方面，一个是是否健康，一个是性能瓶颈在哪里。当系统出现异常的时候，监控系统可以配合告警系统，及时地发现，通知，干预，从而保障系统的顺利运行。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当压力测试的时候，往往会遭遇瓶颈，也需要有全方位的监控来找出瓶颈点，同时能够保留现场，从而可以追溯和分析，进行全方位的优化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/22/消息队列事务型消息原理浅析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/22/消息队列事务型消息原理浅析/" itemprop="url">消息队列事务型消息原理浅析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-22T12:12:57+08:00">
                2019-06-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/消息队列/" itemprop="url" rel="index">
                    <span itemprop="name">消息队列</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/消息队列/分布式事务/" itemprop="url" rel="index">
                    <span itemprop="name">分布式事务</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/消息队列/分布式事务/最终一致性/" itemprop="url" rel="index">
                    <span itemprop="name">最终一致性</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="消息队列事务型消息原理浅析"><a href="#消息队列事务型消息原理浅析" class="headerlink" title="消息队列事务型消息原理浅析"></a>消息队列事务型消息原理浅析</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s/ufTdKKYHENWRXlarbybgvg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ufTdKKYHENWRXlarbybgvg</a></p>
</blockquote>
<p><br></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在金融级分布式架构的领域内，消息队列是普遍被应用的异步通信产品，本文主要分为以下几个小结，循序渐进的对消息队列产品事务型消息设计原理进行分析和阐述：</p>
<ol>
<li>消息队列简介</li>
<li>消息队列应用实例</li>
<li>事务型消息设计方案</li>
<li>事务型消息总结</li>
</ol>
<h2 id="消息队列简介"><a href="#消息队列简介" class="headerlink" title="消息队列简介"></a>消息队列简介</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在分布式系统架构中，消息队列的核心职责是为不同的应用系统提供异步通信服务，通常涉及以下三个重要角色：</p>
<ul>
<li><strong>消息发布者</strong>，发送消息的应用系统，负责创建消息对象并通过网络发布到消息<code>Broker</code>，发布的过程一般是同步的。</li>
<li><strong>消息 Broker</strong>，异步消息的“代理人”，负责接收并持久化消息，保证将消息投递到指定的消息订阅者应用系统。</li>
<li><strong>消息订阅者</strong>，订阅消息的应用系统，负责消费消息 <code>Broker</code>投递过来的消息。</li>
</ul>
<p>在分布式系统架构中，引入消息队列带来的三大核心优势如下：</p>
<ul>
<li><strong>提高核心链路吞吐量</strong></li>
<li><strong>降低应用系统之间的耦合度</strong></li>
<li><strong>增强整体服务的高可用能力</strong></li>
</ul>
<h2 id="消息队列应用实例"><a href="#消息队列应用实例" class="headerlink" title="消息队列应用实例"></a>消息队列应用实例</h2><p>分析和设计一个典型的支付应用业务逻辑，以 “账单查询 Case” 为例，基本业务逻辑如下:</p>
<ol>
<li>检索数据库，获取指定账户的账单记录。</li>
<li>记录用户的检索行为，为风险控制提供数据积累。</li>
<li>发送短信到用户手机，通知用户其账单被查询事件。</li>
</ol>
<p>依赖 “同步 <code>RPC</code>” 的设计方案 A 如下所示：</p>
<p><img src="//blog.com/2019/06/22/消息队列事务型消息原理浅析/nibOZpaQKw0ickvEhp4yialO2AHU1XMmaJc4qMqGKkPBibOCdHoQ5SQaohHl4EAGlRSgXTrOibPuznQmA6iaFOicGGPJg.png" alt="img"></p>
<p><em>“账单检索 Case” 同步 RPC 设计方案 A</em></p>
<p>依赖 “异步消息队列” 的设计方案 B 如下所示：</p>
<p><img src="//blog.com/2019/06/22/消息队列事务型消息原理浅析/nibOZpaQKw0ickvEhp4yialO2AHU1XMmaJcVykEnfiaHJC8kEeiaNPUsJrcchgpibH2JrOcvKSdvL8kTOUsEozvKKhXQ.png" alt="img"></p>
<p><em>“账单检索 Case” 消息队列设计方案 B</em></p>
<p>对比以上 A, B 两个设计方案，引入消息队列的设计方案 B 具有如下优势：</p>
<ol>
<li>“账单服务” 处理 “账单查询 Case” 的耗时由 60 ms 缩减至 13 ms， 提高了服务的吞吐量。</li>
<li>“账单服务” 和 “风险控制服务”、“短信通知服务” 完全解耦，如果在业务演进过程中，增加了新的下游服务，“账单服务” 完全无需变更。</li>
<li>当 “风险控制服务” 和 “短信通知服务” 不可用时，不会导致 “账单服务” 不可用。</li>
</ol>
<p>通过以上 “账单查询 Case” 的设计方案，可以阐明引入消息队列给分布式应用架构带来的三大核心优势。</p>
<p>下面继续分析和设计 “账单变更 Case”，基本业务逻辑如下：</p>
<ol>
<li>写入数据库，变更指定账户的账单记录。</li>
<li>记录用户检索行为，为风险控制提供数据积累。</li>
<li>发送短信到用户手机，通知用户其账户变更金额。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与 “账单查询 Case” 的区别在于数据库操作是写入，而不再是检索。二者的主要区别是 “数据库检索” 不涉及数据库事务，而<strong>“数据库写入” 一定会涉及到数据库事务</strong>，按照之前的引入消息队列设计思路，“账单变更 Case” 的设计方案 C 如下：</p>
<p><img src="//blog.com/2019/06/22/消息队列事务型消息原理浅析/nibOZpaQKw0ickvEhp4yialO2AHU1XMmaJcwpXI8crOWyGBOBuY8LESGDGODGGvNWy3ibK7aKw071ye0P5MpfEEDRw.png" alt="img"></p>
<p><em>“账单变更 Case” 消息队列设计方案 C</em></p>
<p>“账单变更 Case” 消息队列设计方案 C 存在以下严重问题：</p>
<ul>
<li>“账单变更” 关联的数据库变更事务提交成功后，如果 “发布账单变更消息” 发送失败（例如网络异常或者消息队列服务不可用），则会导致 “记录用户行为” 和 “短信通知用户” 后续动作失败，无法完成风险控制数据积累，用户也无法及时获取到账户变更信息。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解决以上设计方案 C 的严重问题，初步考虑先发布 “账单变更” 消息，再做数据库变更的设计方案，但还是<strong>无法解决 “消息发布” 和 “数据库事务” 可能不一致性的严重问题</strong>，如果消息已发布成功过了，数据库变更事务回滚了，就会导致用户的账单没有变更，但用户却收到了账户变更短信，存在一致性漏洞的 “账单变更 Case” 消息队列设计方案 D 如下所示：</p>
<p><img src="//blog.com/2019/06/22/消息队列事务型消息原理浅析/nibOZpaQKw0ickvEhp4yialO2AHU1XMmaJcSiaYjEAvtu3sP7Zic8PN5ImSL4IfRfNOjjf0wFJXgG0zWPyWLA7SZ26Q.png" alt="img"></p>
<p><em>“账单变更 Case” 消息队列设计方案 D</em></p>
<p>至此，可以梳理一下完美解决 “账单变更 Case” 需要解决的关键点：</p>
<ol>
<li><strong>必须满足“一致性”要求</strong>，即账单服务数据库变更事务提交成功，风险控制服务和短信通知服务收到“账单变更”消息；账单服务数据库变更事务回滚，风险控制服务和短信通知服务不会收到“账单变更”消息。</li>
<li>“账单变更”消息发布失败，<strong>尽量避免导致数据库变更事务的回滚</strong>。</li>
</ol>
<h2 id="事务型消息设计方案"><a href="#事务型消息设计方案" class="headerlink" title="事务型消息设计方案"></a>事务型消息设计方案</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解决以上描述的两个需求，消息队列需要提供一种特殊类型的消息：<strong>消息队列收到消息后不会立刻投递消息到消息订阅者，消息订阅者暂时不可见，而是根据消息发布者应用的数据库事务状态决定消息是否投递</strong>。如果数据库事务提交，则消息投递到订阅者；反之则不投递。此类消息被命名为 “事务型消息”。具体设计方案如下：</p>
<p><img src="//blog.com/2019/06/22/消息队列事务型消息原理浅析/nibOZpaQKw0ickvEhp4yialO2AHU1XMmaJczR0nuPMvCia6s9ZjOEO4518r5iaKOhBmJ9CnNCm6Jnic1upoWxib1ahdicA.png" alt="img"></p>
<p><em>事务型消息设计方案 E</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照 “事务型消息设计方案 E” 的时序图，<strong>消息发布者和消息队列之间增加了一个 “二阶段” 消息，用来标明对应事务型消息的 “事务状态”，消息队列根据 “二阶段” 消息决定是否投递消息到下游消息订阅者</strong>。应用 “事务型消息”，“账单变更 Case” 的可行解决方案如下所示：</p>
<p><img src="//blog.com/2019/06/22/消息队列事务型消息原理浅析/nibOZpaQKw0ickvEhp4yialO2AHU1XMmaJckxO9NoX1ruT2purKOks8go4ltvhH258Z6UfT1GyaKqBHswRZQaJSMA.png" alt="img"></p>
<p><em>“账单变更 Case” 消息队列-事务型消息设计方案 F</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照 “账单变更 Case” 消息队列-事务型消息设计方案 F，可以满足“账单服务数据库变更”与“异步消息是否投递到订阅者应用”的事务一致性需求。结合 <code>Spring Framework</code> 的事务模板工具类伪代码如下：</p>
<p><img src="//blog.com/2019/06/22/消息队列事务型消息原理浅析/nibOZpaQKw0ickvEhp4yialO2AHU1XMmaJcdN780uJwzBiaulZiaX47DP29aGZFFe4zDq7yibJx9gdT3jU7k9tgl5cqw.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至于依据数据库事务提交/回滚状态决定事务型 “二阶段” 消息的发送，可以通过 <code>Spring Framework</code> 提供的事务模板同步器自动感知消息发布者本地事务状态，相关接口是：</p>
<p><img src="//blog.com/2019/06/22/消息队列事务型消息原理浅析/nibOZpaQKw0ickvEhp4yialO2AHU1XMmaJcB0HCL4eL2Xh5bOsuJ1TH5FM7oswlQ0eDIicQtic6atowGRSQEolQngicQ.png" alt="img"></p>
<p>至此，消息队列 “事务型消息” 的设计方案和实现原理基本阐明清楚了，还遗留两个可以深究的关键点：</p>
<ol>
<li><strong>为什么消息发布方法需要在本地数据库事务方法之前？</strong></li>
<li><strong>如果消息队列收不到事务型消息的二阶段“提交 or 回滚” 消息，如何处理？</strong></li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对第一个关键点，假定方法执行时序是先执行本地数据库事务方法，之后发布 “事务型” 消息，那么消息发布失败会导致消息发布者本地事务回滚，这明显是不符合预期的，因为<strong>数据库事务回滚的成本比较消息发布失败是高昂的</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对第二个关键点，在分布式网络架构中是可能出现的，比如网络异常、消息队列服务短时间不可用等。这也是消息队列提供严谨的 “事务型消息” 特性必须要解决的问题，如果消息队列没有收到 “提交 or 回滚” 回滚消息，则无法决定是否投递消息到消息订阅者，因此，严谨的 “事务型消息” 设计方案需要<strong>有一个异常场景，命名为 “事务型消息状态回查”</strong>，具体设计方案如下：</p>
<p><img src="//blog.com/2019/06/22/消息队列事务型消息原理浅析/nibOZpaQKw0ickvEhp4yialO2AHU1XMmaJcvSBuwN8eicJX0fyQge1RbBm13TUMFak9Eh2T0mCjBaYyOqH9PICy9icg.png" alt="img"></p>
<p><em>事务型消息回查设计方案G</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要明确的是，<strong>“事务型消息状态回查” 只在 “提交 or 回滚消息” 失败的场景下被触发，属于异常路径</strong>。</p>
<h2 id="事务型消息总结"><a href="#事务型消息总结" class="headerlink" title="事务型消息总结"></a>事务型消息总结</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在分布式系统架构中，尤其是金融级业务应用的解决方案设计中，消息队列提供 “事务型消息” 特性是必不可少的，“数据一致性” 是金融级分布式架构的基本要求，本文通过实例逐步说明消息队列产品支持 “事务型消息” 的必要性、设计方案和原理，定义了明确的消息队列事务型消息的核心原理：</p>
<ol>
<li><strong>消息队列事务型消息基于 “二阶段” 消息实现</strong>。</li>
<li><strong>事务型消息是否投递与消息发布者本地事务状态保持一致</strong>。</li>
<li><strong>事务型消息状态回查是保证了 “事务型消息” 的严谨性</strong>。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/22/一致性哈希算法及其在分布式系统中的应用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/22/一致性哈希算法及其在分布式系统中的应用/" itemprop="url">一致性哈希算法及其在分布式系统中的应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-22T12:12:57+08:00">
                2019-06-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/数据分片/" itemprop="url" rel="index">
                    <span itemprop="name">数据分片</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/数据分片/一致性哈希算法/" itemprop="url" rel="index">
                    <span itemprop="name">一致性哈希算法</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/数据分片/一致性哈希算法/一致性哈希算法/" itemprop="url" rel="index">
                    <span itemprop="name">一致性哈希算法</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/数据分片/一致性哈希算法/一致性哈希算法/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/数据分片/一致性哈希算法/一致性哈希算法/算法/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一致性哈希算法及其在分布式系统中的应用"><a href="#一致性哈希算法及其在分布式系统中的应用" class="headerlink" title="一致性哈希算法及其在分布式系统中的应用"></a>一致性哈希算法及其在分布式系统中的应用</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s/Sb4ksj14N4UvzkB0HN-yxw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Sb4ksj14N4UvzkB0HN-yxw</a></p>
</blockquote>
<p><br></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文将会从实际应用场景出发，介绍一致性哈希算法（<code>Consistent Hashing</code>）及其在分布式系统中的应用。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先本文会描述一个在日常开发中经常会遇到的问题场景，借此介绍一致性哈希算法以及这个算法如何解决此问题；接下来会对这个算法进行相对详细的描述，并讨论一些如虚拟节点等与此算法应用相关的话题。</p>
<h2 id="分布式缓存问题"><a href="#分布式缓存问题" class="headerlink" title="| 分布式缓存问题"></a>| 分布式缓存问题</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们有一个网站，最近发现随着流量增加，服务器压力越来越大，之前直接读写数据库的方式不太给力了，于是我们想引入<code>Memcached</code>作为缓存机制。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们一共有三台机器可以作为<code>Memcached</code>服务器，如下图所示：</p>
<p><img src="//blog.com/2019/06/22/一致性哈希算法及其在分布式系统中的应用/oP5s8EJvku6vJOBI61wVrfw7xvS1dJKTY5x8icB1CPLiaIibjr7rDm3RSlqib2msBPPrAH9Co318drlqvnuos5qs7g.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很显然，最简单的策略是将每一次<code>Memcached</code>请求<strong>随机发送</strong>到一台<code>Memcached</code>服务器，但是这种策略可能会带来两个问题：</p>
<ol>
<li><strong>同一份数据可能被存在不同的机器上而造成数据冗余</strong>，</li>
<li><strong>有可能某数据已经被缓存但是访问却没有命中，因为无法保证对相同<code>key</code>的所有访问都被发送到相同的服务器</strong>。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，<strong>随机策略无论是时间效率还是空间效率都非常不好。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要解决上述问题只需做到如下一点：<strong>保证对相同key的访问会被发送到相同的服务器。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多方法可以实现这一点，最常用的方法是计算哈希。例如对于每次访问，可以按如下算法计算其哈希值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h = Hash(key) % 3</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中<code>Hash</code>是一个从字符串到正整数的哈希映射函数。这样，如果我们将<code>Memcached Server</code>分别编号为0、1、2，那么就可以根据上式和<code>key</code>计算出服务器编号h，然后去访问。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方法虽然解决了上面提到的两个问题，但是存在一些其它的问题。如果将上述方法抽象，可以认为通过：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h = Hash(key) % N</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个算式计算每个<code>key</code>的请求应该被发送到哪台服务器，其中N为服务器的台数，并且服务器按照0 – (N-1)编号。</p>
<p><strong>这个算法的问题在于容错性和扩展性不好。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>所谓容错性是指当系统中某一个或几个服务器变得不可用时，整个系统是否可以正确高效运行；而扩展性是指当加入新的服务器后，整个系统是否可以正确高效运行</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现假设有一台服务器宕机了，那么为了填补空缺，要将宕机的服务器从编号列表中移除，后面的服务器按顺序前移一位并将其编号值减一，此时每个<code>key</code>就要按<code>h = Hash(key) % (N-1)</code>重新计算；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同样，如果新增了一台服务器，虽然原有服务器编号不用改变，但是要按<code>h = Hash(key) % (N+1)</code>重新计算哈希值。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此系统中<strong>一旦有服务器变更，大量的key会被重定位到不同的服务器从而造成大量的缓存不命中</strong>。而这种情况在分布式系统中是非常糟糕的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>一个设计良好的分布式哈希方案应该具有良好的单调性，即服务节点的增减不会造成大量哈希重定位。一致性哈希算法就是这样一种哈希方案。</strong></p>
<h2 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="| 一致性哈希算法"></a>| 一致性哈希算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单来说，一致性哈希将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数H的值空间为<code>0 - 2^32-1</code>（即哈希值是一个32位无符号整形）。</p>
<p>整个哈希空间环如下：</p>
<p><img src="//blog.com/2019/06/22/一致性哈希算法及其在分布式系统中的应用/oP5s8EJvku6vJOBI61wVrfw7xvS1dJKT6e99onuMemepldRBGR0bdIaTOp3tvJe4HGJRbQhPnia5EAUhhNgkTEA.png" alt="img"></p>
<p>整个空间<strong>按顺时针方向组织</strong>。0和<code>2^32-1</code>在零点中方向重合。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>下一步将各个服务器使用H进行一个哈希，具体可以选择服务器的ip或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里假设将上文中三台服务器使用<code>ip</code>地址哈希后在环空间的位置如下：</p>
<p><img src="//blog.com/2019/06/22/一致性哈希算法及其在分布式系统中的应用/oP5s8EJvku6vJOBI61wVrfw7xvS1dJKT1WAteMVVR76gicBwH90ga6btbbCKseiaSBib38tloOf43cGjxX3ZwEu1w.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来使用如下算法定位数据访问到相应服务器：<strong>将数据<code>key</code>使用相同的函数H计算出哈希值h，通根据h确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如我们有A、B、C、D四个数据对象，经过哈希计算后，在环空间上的位置如下：</p>
<p><img src="//blog.com/2019/06/22/一致性哈希算法及其在分布式系统中的应用/oP5s8EJvku6vJOBI61wVrfw7xvS1dJKTRJ9AhwIJkIGVDFa0sryFHSRUEGTBjnmKTuyB0z7EV8Z7sgPxP7C8pQ.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据一致性哈希算法，数据A会被定为到<code>Server 1上</code>，D被定为到<code>Server 3</code>上，而B、C分别被定为到<code>Server 2</code>上。</p>
<h2 id="容错性与可扩展性分析"><a href="#容错性与可扩展性分析" class="headerlink" title="| 容错性与可扩展性分析"></a>| 容错性与可扩展性分析</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面分析一致性哈希算法的容错性和可扩展性。现假设<code>Server 3</code>宕机了：</p>
<p><img src="//blog.com/2019/06/22/一致性哈希算法及其在分布式系统中的应用/oP5s8EJvku6vJOBI61wVrfw7xvS1dJKTOFc5NiaGwSDNvrjNU2vLHpX3BZBTTYpVWicrJ0Z2r9UZtKqibNiaPRI9ng.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到此时A、C、B不会受到影响，只有D节点被重定位到<code>Server 2</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般的，<strong>在一致性哈希算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即顺着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面考虑另外一种情况，如果我们在系统中增加一台服务器<code>Memcached Server 4</code>：</p>
<p><img src="//blog.com/2019/06/22/一致性哈希算法及其在分布式系统中的应用/oP5s8EJvku6vJOBI61wVrfw7xvS1dJKTejcteOBdO2QZpQJWOFOjW8iaSPBwp4HJHzo8sbmbicWFcgNjvEem7tyA.png" alt="img"></p>
<p>此时A、D、C不受影响，只有B需要重定位到新的<code>Server 4</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>一般的，在一致性哈希算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即顺着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>综上所述，一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</strong></p>
<h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="| 虚拟节点"></a>| 虚拟节点</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如我们的系统中有两台服务器，其环分布如下：</p>
<p><img src="//blog.com/2019/06/22/一致性哈希算法及其在分布式系统中的应用/oP5s8EJvku6vJOBI61wVrfw7xvS1dJKTpgBFsgB3SJ2as8HWycAnm5ya7H8ia05KOWGWInvvBv5a0amyRQaNUQA.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时必然造成大量数据集中到<code>Server 1</code>上，而只有极少量会定位到<code>Server 2</code>上。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点</strong>。具体做法可以<strong>在服务器ip或主机名的后面增加编号来实现</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如上面的情况，我们决定为每台服务器计算三个虚拟节点。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以分别计算下面节点的哈希值：</p>
<ul>
<li>“Memcached Server 1#1”</li>
<li>“Memcached Server 1#2”</li>
<li>“Memcached Server 1#3”</li>
<li>“Memcached Server 2#1”</li>
<li>“Memcached Server 2#2”</li>
<li>“Memcached Server 2#3”</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是形成六个虚拟节点：</p>
<p><img src="//blog.com/2019/06/22/一致性哈希算法及其在分布式系统中的应用/oP5s8EJvku6vJOBI61wVrfw7xvS1dJKTicKVELibIXDeZ1S2RqvwdTJkwLLS5MhVsRpWicT16ZHjBKdJ0HHKj3EoQ.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时数据定位算法不变，只是<strong>多了一步虚拟节点到实际节点的映射</strong>，例如定位到<code>“Memcached Server 1#1”、“Memcached Server 1#2”、“Memcached Server 1#3”</code>三个虚拟节点的数据均定位到<code>Server 1</code>上。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/22/Innodb中LRU怎么做的/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/22/Innodb中LRU怎么做的/" itemprop="url">Innodb中LRU怎么做的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-22T12:12:57+08:00">
                2019-06-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/MySql/" itemprop="url" rel="index">
                    <span itemprop="name">MySql</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/MySql/Innodb/" itemprop="url" rel="index">
                    <span itemprop="name">Innodb</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/MySql/Innodb/LRU/" itemprop="url" rel="index">
                    <span itemprop="name">LRU</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/MySql/Innodb/LRU/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/MySql/Innodb/LRU/算法/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Innodb中LRU怎么做的"><a href="#Innodb中LRU怎么做的" class="headerlink" title="Innodb中LRU怎么做的"></a>Innodb中LRU怎么做的</h1><p><br></p>
<p>原文地址：<a href="https://mp.weixin.qq.com/s/mKivy3uBzm8-4en2osiuRQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/mKivy3uBzm8-4en2osiuRQ</a></p>
<p><br></p>
<h2 id="什么是BufferPool"><a href="#什么是BufferPool" class="headerlink" title="什么是BufferPool"></a>什么是BufferPool</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Innodb</code>为了解决磁盘上磁盘速度和<code>CPU</code>速度不一致的问题，在操作磁盘上的数据时，先将数据加载至内存中，在内存中对数据页进行操作。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Mysql</code>在启动的时候，会向内存申请一块连续的空间，这块空间名为<code>Bufffer Pool</code>，也就是缓冲池，默认情况下<code>Buffer Pool</code>只有128M。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<em>那缓冲池长什么样的呢，如下图所示</em></p>
<p><img src="//blog.com/2019/06/22/Innodb中LRU怎么做的/1.webp" alt="img"></p>
<p>如图所示，有三部分组成:</p>
<ul>
<li><code>ctl</code>: 俗称控制体，里头有一个指针指向缓存页，还有一个成员变量存储着所谓的一些所谓的控制信息，例如该页所属的表空间编号、页号</li>
<li><code>page</code>:缓存页，就是磁盘上的页加载进<code>Bufffer Pool</code>后的结构体</li>
<li>碎片：每个控制体都有一个缓存页。最后内存中会有一点点的空间不足以容纳一对控制体和缓存页，于是碎片就诞生的！</li>
</ul>
<p>这个控制体<code>ctl</code>在<code>mysql</code>源码中长这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct buf_block_t&#123;</span><br><span class="line">    //省略</span><br><span class="line">    buf_page_t  page;</span><br><span class="line">    byte*       frame;</span><br><span class="line">    //省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;嗯，懂C语言的自然知道，<code>frame</code>是一个<code>指针</code>啦，指向缓存页。而<code>page</code>存储的就是该页所属的表空间编号、页号等。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>BufferPool</code>中有三大链表，需要重点关注，它们存储的元素都是<code>buf_page_t</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如，我总要知道那些页是可以用，是<strong>空闲</strong>的吧。OK,这些信息在<strong><code>free链表</code></strong>中维护。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再比如，<code>CPU</code>肯定是不会去修改磁盘上的数据。那么，CPU修改了<code>BufferPool</code>中的数据后，<code>Innodb</code>总要知道要把哪一块信息<strong>刷到磁盘</strong>上吧。OK，这些信息在<strong><code>flush链表</code></strong>中维护。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，当<code>free链表</code>里没多余的空闲页啦，<code>innodb</code>要淘汰一些缓存页啦。<strong>怎么淘汰？</strong>这还用问，一定是淘汰<strong>最近最少使用</strong>的缓存页啊。<strong>怎么知道这些页是最近最少使用的呢？</strong>嗯，那就是要借助传说中的<strong><code>LRU链表</code></strong>啦。</p>
<h2 id="简单的LRU"><a href="#简单的LRU" class="headerlink" title="简单的LRU"></a>简单的LRU</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们先来说一个简单的<code>LRU</code>算法。<code>LRU</code>嘛，全称吧啦吧啦…英文名忘了。反正就是一个淘汰<strong>最近最少使用</strong>的算法。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最常见的实现是使用一个链表保存缓存数据，详细算法实现如下：</p>
<ul>
<li><strong>新数据插入到链表头部</strong>；</li>
<li><strong>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</strong>；</li>
<li><strong>当链表满的时候，将链表尾部的数据丢弃</strong>；</li>
</ul>
<p>嗯，完美！很完美！反正<code>innodb</code>中不可能这样设计～<br>那么为什么不能这么设计呢？</p>
<p><strong><em>原因一</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设有一张表叫<code>yan_ge_hao_shuai</code>,(请将表名多看几遍)，回到正题，这张表什么索引都木有，有着几千万数据，反正就是很多很多数据页。然后，执行下面的语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from yan_ge_hao_shuai</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为没有任何索引嘛，那就进行<strong>全表扫描</strong>了。那么按照上面说的算法，这些数据页也会被全部塞入<code>LRU链表</code>，并且通通加载到<code>BufferPool</code>中，从而<strong>迅速清空其他查询语句留下来的高频的数据页</strong>。那么此时，你的<code>BufferPool</code>里全是低频的数据页，就会发现缓存命中率大大滴降低了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是你就会觉得:”我勒个去，设计这个<code>Innodb</code>的人，怕不是脑袋有问题…(以下省略一万字)”</p>
<p><strong><em>原因二</em></strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里先说以下<code>innodb</code>的<strong>预读机制</strong>，是这样子滴！这个预读细说起来可以分为线性预读和随机预读。借一张姜承尧大大的图，<code>innodb</code>的表逻辑结构如下图所示</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>从 InnoDB存储引擎的逻辑存储结构看,所有数据都被逻辑地存放在一个空间中,称之为表空间( tablespace)。表空间又由段(segment)、区( extent)、页(page)组成。页在一些文档中有时也称为块( block), InnoDB存储引擎的逻辑存储结构大致如图所示。</strong></p>
</blockquote>
<p><img src="//blog.com/2019/06/22/Innodb中LRU怎么做的/2.webp" alt="img"></p>
<p>数据页(<code>page</code>)是放在区(<code>extent</code>)里的。<br>那么</p>
<ul>
<li>线性预读:当一个区中有连续56个页面(56为默认值)被加载到<code>BufferPool</code>中，会将这个区中的所有页面都加载到<code>BufferPool</code>中。其实挺合理的，毕竟一个区最多才64个页。</li>
<li>随机预读:当一个区中随机13个页面(13为默认值)被加载到<code>BufferPool</code>中，会将这个区中所有页面都加载到<code>BufferPool</code>中。随机预读默认是<strong>关闭</strong>，由变量<code>innodb_random_read_ahead</code>控制。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好了，上面那一堆其实看不懂也没事。我只想说一件事，<strong>预读机制会预读一些额外的页到到<code>BufferPool</code>中</strong>。<br><em>那么，如果这些预读页并不是高频的页呢？</em><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OK，<strong>如果这些页并不是高频的页，按照上面的算法，也会被加入<code>LRU 链表</code>，就会将链表末端一些高频的数据页给淘汰掉，从而导致命中率下降</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是你会觉得:”唉，自己写一个都比他强…(此处略过一万字)”</p>
<h2 id="Innodb的LRU"><a href="#Innodb的LRU" class="headerlink" title="Innodb的LRU"></a>Innodb的LRU</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OK，为了解决上面的两个缺点。<code>Innodb</code>将这个链表分为两个部分，也就是所谓的<code>old区</code>和<code>young区</code>。<br><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;天啦噜，这两个区干嘛用的？</em><br>ok，<strong><code>young区</code>在链表的头部，存放经常被访问的数据页，可以理解为热数据</strong>！<br>ok，<strong><code>old区</code>在链表的尾部，存放不经常被访问的数据页，可以理解为冷数据</strong>！</p>
<p><strong>这两个部分的交汇处称为<code>midpoint</code></strong>，往下看！</p>
<p><strong><em>怎么知道两个区的比例？</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &apos;innodb_old_blocks_pct&apos;;</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">| innodb_old_blocks_pct | 37    |</span><br><span class="line">+-----------------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这说明了<code>old区</code>的比例为37%，也就是冷数据大概占<code>LRU链表</code>的3/8。剩下的就是<code>young区</code>的热数据。</p>
<p>于是可以得到一张大概的<code>LRU链表</code>图，如下所示(图片出自网络)</p>
<p><img src="//blog.com/2019/06/22/Innodb中LRU怎么做的/3.webp" alt="img"></p>
<p><code>ps：</code>一般生产的机器，内存比较大。我们会<strong>把<code>innodb_old_blocks_pct</code>值调低，防止热数据被刷出内存</strong>。</p>
<p><strong><em>数据何时在old区，何时进入young区？</em></strong></p>
<p><strong>数据页第一次被加载进<code>BufferPool</code>时在<code>old区</code>头部</strong>。</p>
<p>当这个数据页在<code>old区</code>，再次被访问到，会做如下判断</p>
<ul>
<li>如果这个数据页在LRU链表中<code>old区</code><strong>存在的时间超过了1秒，就把它移动到<code>young区</code></strong></li>
<li>这个存在时间由<code>innodb_old_blocks_time</code>控制</li>
</ul>
<p>我们来看看<code>innodb_old_blocks_time</code>的值，如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &apos;innodb_old_blocks_time&apos;;</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| Variable_name          | Value |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">| innodb_old_blocks_time | 1000  |</span><br><span class="line">+------------------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>
<p><strong><em>那怎么解决这些缺点的？</em></strong></p>
<hr>
<p><strong>针对原因一</strong></p>
<p>也就是所谓的全表扫描导致<code>Bufferpool</code>中的高频数据页快速被淘汰的问题。<br><code>Innodb</code>这么做的:<br>(1)   扫描过程中，需要新插入的数据页，都被放到<code>old区</code><br>(2)   一个数据页会有多条记录，因此一个数据页会被访问多次<br>(3)   <strong>由于是顺序扫描,数据页的第一次被访问和最后一次被访问的时间间隔不会超过1S，因此还是会留在<code>old区</code></strong><br>(4)   继续扫描，之前的数据页再也不会被访问到，因此也不会被移到<code>young区</code>，最终很快被淘汰</p>
<p><strong>针对原因二</strong></p>
<p>也就是预读到的页，可能不是高频次的页。<br>你看，你<strong>预读到的页，是存在<code>old区</code>的</strong>。<strong>如果这个页后续不会被继续访问到，是会在<code>old区</code>逐步被淘汰的</strong>。因此不会影响<code>young区</code>的热数据。</p>
<h2 id="监控冷热数据"><a href="#监控冷热数据" class="headerlink" title="监控冷热数据"></a>监控冷热数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innnodb status\G</span><br><span class="line">……</span><br><span class="line">Pages made young 0, not young 0</span><br><span class="line">0.00 youngs/s, 0.00 non-youngs/s</span><br></pre></td></tr></table></figure>
<p>1、数据页从冷到热，称为<code>young</code>；<code>not young</code>就是数据在没有成为热数据情况下就被刷走的量(累计值)。</p>
<p>2、<code>non-youngs/s</code>，这个数值如果很高，一般情况下就是系统存在严重的全表扫描，自然意味着很高的物理读。(上面分析过)</p>
<p>3、<strong><code>youngs/s</code>，如果这个值相对较高，最好增加一个<code>innodb_old_blocks_time</code>，降低<code>innodb_old_blocks_pct</code>，保护热数据</strong>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/22/注册中心 - SOFARegistr如何支持海量数据/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/22/注册中心 - SOFARegistr如何支持海量数据/" itemprop="url">注册中心 - SOFARegistr如何支持海量数据</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-22T12:12:57+08:00">
                2019-06-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/Redis/数据分片/" itemprop="url" rel="index">
                    <span itemprop="name">数据分片</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/Redis/数据分片/服务发现/" itemprop="url" rel="index">
                    <span itemprop="name">服务发现</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/Redis/数据分片/服务发现/微服务/" itemprop="url" rel="index">
                    <span itemprop="name">微服务</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/Redis/数据分片/服务发现/微服务/注册中心/" itemprop="url" rel="index">
                    <span itemprop="name">注册中心</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="注册中心-SOFARegistr如何支持海量数据"><a href="#注册中心-SOFARegistr如何支持海量数据" class="headerlink" title="注册中心 - SOFARegistr如何支持海量数据"></a>注册中心 - SOFARegistr如何支持海量数据</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;面对海量数据，想突破单机的存储瓶颈，唯一的办法是将数据分片，接下来将介绍常见的有 2 种数据分片方式。</p>
<h2 id="传统的一致性-Hash-分片"><a href="#传统的一致性-Hash-分片" class="headerlink" title="传统的一致性 Hash 分片"></a>传统的一致性 Hash 分片</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传统的一致性 Hash 算法，每台服务器被虚拟成<code>N</code>个节点，如下图所示（简单起见虚拟份数 N 设为 2 ）。每个数据根据 <code>Hash</code> 算法计算出一个值，<strong>落到环上后顺时针命中的第一个虚拟节点，即负责存储该数据</strong>。业界使用一致性 <code>Hash</code> 的代表项目有 <code>Memcached</code>、<code>Twemproxy</code>等。</p>
<p><img src="//blog.com/2019/06/22/注册中心 - SOFARegistr如何支持海量数据/1.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一致性 <code>Hash</code>分片的优点：<strong>在虚拟节点足够多的情况下，数据分片在每台节点上是非常分散均匀的，并且增加或减少节点的数量，还是能维持数据的平衡</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如当 <code>Memcached</code>单机遇到内存瓶颈时，通过扩容 <code>Memcached</code> 机器，数据将会被重新均匀地分摊到新的节点上，因此每台<code>Memcached</code> 服务器的内存就能得到降低。当某台服务器宕机时，数据会被重新均匀地分摊到剩余的节点上，如下图所示，A 机器宕机，原先在 A 机器上的数据会分别重新分摊到 B 机器和 C 机器。</p>
<p><img src="//blog.com/2019/06/22/注册中心 - SOFARegistr如何支持海量数据/2.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>一致性<code>Hash</code> 分片的缺点：分片范围不固定（一旦节点数发生变化，就会导致分片范围变化）</strong>。严格来说，这不是一致性 <code>Hash</code> 的缺点，而是它的特点，这个特点<strong>在追求数据分散的场景下是优点，但在谈及数据复制的这个场景下它是个缺点</strong>。从上面的机器宕机过程，可以看到，仅扩缩容少量节点，就会影响到其他大部分已有节点的分片范围，即<strong>每台节点的分片范围会因为节点数变化而发生变化</strong>。如下图，当 A 宕机时，分片 6 和 1 合并成 7，分片 3 和 4 合并成 8，就是说，A 宕机后，B 和 C 的分片范围都发生了变化。</p>
<p><img src="//blog.com/2019/06/22/注册中心 - SOFARegistr如何支持海量数据/3.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>“分片范围不固定”，带来的问题是：难以实现节点之间数据多副本复制</strong>。这个结论可能不太好理解，我举个例子：<strong>如果要实现节点之间数据能够复制，首先每个节点需要对数据分片保留操作日志，节点之间依靠这些操作日志进行增量的日志同步</strong>。比如上图的左半边，B 节点负责分片 1 和 5，因此 B 节点需要使用 2 个日志文件（假设叫做 data-1.log 和 data-5.log）记录这 2 个分片的所有更新操作。当 A 宕机时（上图的右半边），B 节点负责的分片变成 7 和 5，那么 data-1.log 日志文件就失效了，因为分片 1 不复存在。可见，<strong>在分片范围易变的情况下，保存数据分片的操作日志，并没有意义</strong>。这就是为什么这种情况下节点之间的日志复制不好实现的原因。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得一提的是，<code>Twemproxy</code> 也是因为<strong>“分片范围不固定（一旦节点数发生变化，就会导致分片范围变化）”这个问题，所以不支持平滑的节点动态变化</strong>。比如使用 <code>Twemproxy + Redis</code>，如果要扩容 <code>Redis</code>节点，那么需要<strong>用户自己实现数据迁移的过程</strong>，这也是后来<code>Codis</code> 出现的原因。当然，对于不需要数据多副本复制的系统，比如 <code>Memcached</code>，由于它的定位是缓存，不保证数据的高可靠，节点之间不需要做数据多副本复制，所以不存在这个顾虑。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;思考：对于那些需要基于数据多副本复制，来保证数据高可靠的 <code>kv</code>存储系统，比如 <code>Tair</code>、<code>dynamo</code> 和 <code>Cassandra</code>，它们是怎么做数据分片的呢？</p>
<h2 id="预分片机制-Pre-Sharding"><a href="#预分片机制-Pre-Sharding" class="headerlink" title="预分片机制 Pre-Sharding"></a><strong>预分片机制 Pre-Sharding</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;预分片机制，理解起来比一致性<code>Hash</code> 简单，首先需要<strong>从逻辑上将数据范围划分成 N 个大小相等的 <code>slot</code>，并且 <code>slot</code> 数量（即 N 值）后续不可再修改</strong>。然后，还需要<strong>引进“路由表”的概念，“路由表”负责存放这每个节点和 N 个slot 的映射关系</strong>，并保证尽量把所有<code>slot</code>均匀地分配给每个节点。在对数据进行路由时，根据数据的 <code>key</code> 计算出哈希值，再将<code>hash</code>值对<code>N</code>取模，这个余数就是对应<code>key</code>的<code>slot</code> 位置。比如 <code>Codis</code> 默认将数据范围分成 1024 个 <code>slots</code>，对于每个 key 来说，通过以下公式确定所属的<code>slotId：slotId = crc32（key） % 1024</code>，<strong>根据 <code>slotId</code>再从路由表里找到对应的节点</strong>。预分片机制的具体原理如下图。</p>
<p><img src="//blog.com/2019/06/22/注册中心 - SOFARegistr如何支持海量数据/4.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看出来，相对传统的一致性 <code>Hash</code>分片，<strong>预分片机制的每个<code>slot</code>的大小（代表数据分片范围）是固定的，因此解决了“分片范围不固定”的问题，现在，节点之间可以基于 <code>slot</code> 的维度做数据同步了</strong>。至于<code>slot</code>之间数据复制的方式，比如“采取异步复制还是同步复制”，“复制多少个节点成功才算成功”，不同系统的因其 <code>cap</code>定位不同，实现也大有不同，这里无法展开讲。</p>
<p>接下来，我们看看节点增删的过程。</p>
<h3 id="节点宕机"><a href="#节点宕机" class="headerlink" title="节点宕机"></a>节点宕机</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下图，副本数为 2，路由表里每个 <code>slot id</code> 需要映射到 2 个节点，1 个节点存储主副本，1 个节点存储备副本。对于 <code>S1</code> 的所有写操作，需要路由到 <code>nodeA</code>，然后 <code>nodeA</code> 会将 <code>S1</code>的操作日志同步给 <code>nodeB</code>。如果 <code>nodeA</code>发生宕机，则系统需要修改路由表，将 <code>nodeA</code>所负责的 <code>slot</code>（ 如图中的<code>S1</code>和<code>S3</code>） 重新分配给其他节点，如图，经过调整，<strong><code>S1</code> 的节点变为<code>nodeB</code> 和 <code>nodeC</code>，<code>S3</code>的节点变为 <code>nodeC</code> 和 <code>nodeE</code>。然后系统会命令<code>nodeC</code>和 <code>nodeE</code>开始做数据复制的工作，复制过程不会影响到<code>S1</code>和 <code>S3</code>对外服务，因为<code>nodeC</code>和 <code>nodeE</code> 都属于备副本（读写都访问主副本）</strong>。复制完成后方可结束。</p>
<p><img src="//blog.com/2019/06/22/注册中心 - SOFARegistr如何支持海量数据/5.webp" alt="img"></p>
<blockquote>
<p>修正一下：</p>
<p><code>nodeA</code>宕机时，<code>S1</code>的主节点由<code>nodeA</code>变成<code>nodeB</code>，<code>S3</code>的主节点由<code>nodeA</code>变成<code>nodeC</code></p>
<p><code>nodeA</code>宕机时，<code>S1</code>的备节点由<code>nodeB</code>变成<code>nodeC</code>，<code>S3</code>的主节点由<code>nodeC</code>变成<code>nodeE</code></p>
</blockquote>
<h3 id="节点扩容"><a href="#节点扩容" class="headerlink" title="节点扩容"></a>节点扩容</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;节点扩容的过程比节点宕机稍微复杂，因为<strong>新节点的加入可能导致<code>slot</code>迁移，而迁移的过程中需要保证系统仍可以对外服务</strong>。以下图为例，扩容 <code>nodeF</code>之后，系统需要对路由表的重新平衡，<code>S1</code>的主节点由 <code>nodeA</code> 变为 <code>nodeF</code>，<code>S12</code> 的备节点由 <code>nodeC</code> 变为 <code>nodeF</code>。我们讲一下<code>S1</code>的数据迁移过程：首先<strong>客户端所看到的路由表还不会发生变化，客户端对 <code>S1</code> 的读写请求仍然会路由到<code>nodeA</code></strong>。与此<strong>同时  <code>nodeA</code> 开始将 <code>S1</code>的数据复制给 <code>nodeF</code></strong>；然后，当 <code>nodeF</code> 即将完成数据的备份时，<strong>短暂地对 <code>S1</code>禁写，确保 <code>S1</code>不会再更新</strong>，然后<code>nodeF</code>完成最终的数据同步；最后，修改路由表，将 <code>S1</code>的主节点改为 <code>nodeF</code>，并将最新的路由表信息通知给<code>Client</code>，至此就完成 <code>S1</code> 的迁移过程。<code>Client</code> 后续对 <code>S1</code>的读写都会发送给 <code>nodeF</code>。</p>
<p><img src="//blog.com/2019/06/22/注册中心 - SOFARegistr如何支持海量数据/6.webp" alt="img"></p>
<p><img src="//blog.com/2019/06/22/注册中心 - SOFARegistr如何支持海量数据/7.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般来说，管<strong>理路由表、对 <code>Client</code> 和 所有<code>node</code>发号施令的功能（可以理解成是“大脑”），通常由单独的角色来承担</strong>，比如 <code>Codis</code>的大脑是 <code>codis-conf + Zookeeper/Etcd</code>，<code>Tair</code>的大脑是 <code>ConfigServer</code>。下图是 <code>Tair</code> 官方展示的部署架构图，<code>ConfigServer</code>由 2 台服务器组成，一台 <code>master</code>，一台 <code>slave</code>。</p>
<p><img src="//blog.com/2019/06/22/注册中心 - SOFARegistr如何支持海量数据/8.webp" alt="img"></p>
<p><em>Tair（Alibaba 开源的分布式 KV 存储系统）架构图</em></p>
<h2 id="SOFARegistry-的选择"><a href="#SOFARegistry-的选择" class="headerlink" title="SOFARegistry 的选择"></a>SOFARegistry 的选择</h2><p>总结一下，“一致性 <code>Hash</code> 分片机制” 和 “预分片机制” 的主要区别：</p>
<h3 id="一致性-Hash-分片机制"><a href="#一致性-Hash-分片机制" class="headerlink" title="一致性 Hash 分片机制"></a>一致性 Hash 分片机制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在虚拟节点足够多的情况下，数据分片在每台节点上是非常分散均匀的，即使增加或减少节点的数量，还是能维持数据的平衡，并且不需要额外维护路由表</strong>。但是，由于“分片范围不固定（<strong>一旦节点数发生变化，就会导致分片范围变化</strong>）”的特点，导致它<strong>不适用于需要做数据多副本复制的场景</strong>。目前业界主要代表项目有 <code>Memcached</code>、<code>Twemproxy</code> 等。</p>
<h3 id="预分片机制"><a href="#预分片机制" class="headerlink" title="预分片机制"></a>预分片机制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过事先<strong>将数据范围等分为 N 个<code>slot</code>，解决了“分片范围不固定”的问题，因此可以方便的实现数据的多副本复制</strong>。但<strong>需要引进“路由表”，并且在节点变化时可能需要做数据迁移</strong>，实现起来也不简单。目前业界主要代表项目有 <code>Dynamo</code>、<code>Casandra</code>、<code>Tair</code>、<code>Codis</code>、<code>Redis cluster</code>等。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>SOFARegistry</code> 的 <code>DataServer</code> 需要存储多个副本的服务数据，其实比较适合选择“预分片机制”，但由于历史原因，我们的分片方式选择了“一致性 <code>Hash</code>分片”。在“一致性 <code>Hash</code>分片”的基础上，当然也不意外地遇到了 “分片数据不固定”这个问题，导致 <code>DataServer</code> 之间的数据多副本复制实现难度很大。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后，我们选择在 <code>DataServer</code> 内存里以 <code>dataInfoId</code>的粒度记录操作日志，并且在 <code>DataServer</code> 之间也是以 <code>dataInfoId</code>的粒度去做数据同步。聪明的读者应该看出来了，其实思想上类似把每个<code>dataInfoId</code>当做一个 <code>slot</code>去对待。这个做法很妥协，好在，服务注册中心的场景下，<code>dataInfoId</code> 的总量是有限的（以蚂蚁的规模，每台 <code>DataServer</code>承载的<code>dataInfoId</code>数量也就在数万的级别），因此也勉强实现了<code>dataInfoId</code> 维度的数据多副本。</p>
<p><img src="//blog.com/2019/06/22/注册中心 - SOFARegistr如何支持海量数据/9.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上图，A-F 代表 6 个 <code>dataInfoId</code>数据。使用一致性 <code>Hash</code> 分片后，<code>DataServer1</code>负责 A 和 D，<code>DataServer2</code> 负责 B 和 E，<code>DataServer3</code> 负责 C 和 F。并且每个数据均有 3 个副本。对 A 的写操作是在 <code>DataServer1</code> 即主副本上进行，随后 <code>DataServer1</code>将写操作异步地复制给 <code>DataServer2</code> 和 <code>DataServer3</code>，<code>DataServer2</code>和 <code>DataServer3</code>将写操作应用到内存中的 A 备副本，这样就完成了多副本间的数据复制工作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/37/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/37/">37</a><span class="page-number current">38</span><a class="page-number" href="/page/39/">39</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/39/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
