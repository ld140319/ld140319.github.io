<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/page/132/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/page/132/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/01/25/理解分布式事务/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/25/理解分布式事务/" itemprop="url">理解分布式事务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-25T12:12:57+08:00">
                2019-01-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/服务器/" itemprop="url" rel="index">
                    <span itemprop="name">服务器</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/服务器/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/服务器/架构/分布式事务/" itemprop="url" rel="index">
                    <span itemprop="name">分布式事务</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="理解分布式事务"><a href="#理解分布式事务" class="headerlink" title="理解分布式事务"></a>理解分布式事务</h1><blockquote>
<p>原文地址：<a href="https://juejin.im/post/5c0e5bf8e51d45063322fe50" target="_blank" rel="noopener">https://juejin.im/post/5c0e5bf8e51d45063322fe50</a></p>
</blockquote>
<h1 id="1-什么是事务"><a href="#1-什么是事务" class="headerlink" title="1 什么是事务"></a>1 什么是事务</h1><p>介绍分布式事务之前，先介绍什么是事务。</p>
<h2 id="事务的具体定义"><a href="#事务的具体定义" class="headerlink" title="事务的具体定义"></a>事务的具体定义</h2><p>事务提供一种机制将一个活动涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作只有在所有操作均能正常执行的情况下方能提交，只要其中任一操作执行失败，都将导致整个事务的回滚。</p>
<p>简单地说，事务提供一种“ <strong>要么什么都不做，要么做全套（All or Nothing）</strong>”机制。</p>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817cdae1ee47.png" alt="事务"></p>
<h2 id="数据库事务的ACID属性"><a href="#数据库事务的ACID属性" class="headerlink" title="数据库事务的ACID属性"></a>数据库事务的ACID属性</h2><p>事务是基于数据进行操作，需要保证事务的数据通常存储在数据库中，所以介绍到事务，就不得不介绍数据库事务的ACID特性，指数据库事务正确执行的四个基本特性的缩写。包含：</p>
<ul>
<li><strong>原子性（Atomicity）</strong> 整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被 回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 例如：银行转账，从A账户转100元至B账户，分为两个步骤：<ul>
<li>（1）从A账户取100元</li>
<li>（2）存入100元至B账户。 这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。</li>
</ul>
</li>
<li><strong>一致性（Consistency）</strong> 在事务开始之前和事务结束以后，数据库数据的一致性约束没有被破坏。 例如：现有完整性约束A+B=100，如果一个事务改变了A，那么必须得改变B，使得事务结束后依然满足A+B=100，否则事务失败。</li>
<li><strong>隔离性（Isolation）</strong> 数据库允许多个并发事务同时对数据进行读写和修改的能力，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。 例如：现有有个交易是从A账户转100元至B账户，在这个交易事务还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。</li>
<li><strong>持久性（Durability）</strong> 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817cdb54ec09.png" alt="数据库事务的ACID特性"></p>
<p>简单而言，ACID是从不同维度描述事务的特性：</p>
<ul>
<li>原子性 —— 事务操作的整体性</li>
<li>一致性 —— 事务操作下数据的正确性</li>
<li>隔离性 —— 事务并发操作下数据的正确性</li>
<li>持久性 —— 事务对数据修改的可靠性</li>
</ul>
<p>一个支持事务（Transaction）的数据库，需要具有这4种特性，否则在事务过程当中无法保证数据的正确性，处理结果极可能达不到请求方的要求。</p>
<h2 id="什么时候使用数据库事务"><a href="#什么时候使用数据库事务" class="headerlink" title="什么时候使用数据库事务"></a>什么时候使用数据库事务</h2><p>在介绍完事务基本概念之后，什么时候该使用数据库事务？ 简单而言，就是业务上有一组数据操作，需要如果其中有任何一个操作执行失败，整组操作全部不执行并恢复到未执行状态，要么全部成功，要么全部失败。</p>
<p>在使用数据库事务时需要注意，尽可能短的保持事务，修改多个不同表的数据的冗长事务会严重妨碍系统中的所有其他用户，这很有可能导致一些性能问题。</p>
<h1 id="2-什么是分布式事务"><a href="#2-什么是分布式事务" class="headerlink" title="2 什么是分布式事务"></a>2 什么是分布式事务</h1><p>介绍完事务相关基本概念之后，下面介绍分布式事务。</p>
<h2 id="分布式产生背景与概念"><a href="#分布式产生背景与概念" class="headerlink" title="分布式产生背景与概念"></a>分布式产生背景与概念</h2><p>随着互联网快速发展，微服务，SOA等服务架构模式正在被大规模的使用，现在分布式系统一般由多个独立的子系统组成，多个子系统通过网络通信互相协作配合完成各个功能。</p>
<p>有很多用例会跨多个子系统才能完成，比较典型的是电子商务网站的下单支付流程，至少会涉及交易系统和支付系统，而且这个过程中会涉及到事务的概念，即保证交易系统和支付系统的数据一致性，此处我们称这种<strong>跨系统的事务为分布式事务</strong>，具体一点而言，分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。</p>
<p>举个互联网常用的交易业务为例：</p>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817cdb76e67e.png" alt="img"></p>
<p>上图中包含了库存和订单两个独立的微服务，每个微服务维护了自己的数据库。在交易系统的业务逻辑中，一个商品在下单之前需要先调用库存服务，进行扣除库存，再调用订单服务，创建订单记录。</p>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817cd9498402.png" alt="img"></p>
<p>可以看到，如果多个数据库之间的数据更新没有保证事务，将会导致出现子系统数据不一致，业务出现问题。</p>
<h2 id="分布式事务的难点"><a href="#分布式事务的难点" class="headerlink" title="分布式事务的难点"></a>分布式事务的难点</h2><ul>
<li><strong>事务的原子性</strong> 事务操作跨不同节点，当多个节点某一节点操作失败时，需要保证多节点操作的<strong>要么什么都不做，要么做全套（All or Nothing）</strong>的原子性。</li>
<li><strong>事务的一致性</strong> 当发生网络传输故障或者节点故障，节点间数据复制通道中断，在进行事务操作时需要保证数据一致性，保证事务的任何操作都不会使得数据违反数据库定义的约束、触发器等规则。</li>
<li><strong>事务的隔离性</strong> 事务隔离性的本质就是如何正确多个并发事务的处理的读写冲突和写写冲突，因为在分布式事务控制中，可能会出现提交不同步的现象，这个时候就有可能出现“部分已经提交”的事务。此时并发应用访问数据如果没有加以控制，有可能出现“脏读”问题。</li>
</ul>
<h1 id="3-分布式系统的一致性"><a href="#3-分布式系统的一致性" class="headerlink" title="3 分布式系统的一致性"></a>3 分布式系统的一致性</h1><p>前面介绍到的分布式事务的难点涉及的问题，最终影响是导致数据出现不一致，下面对分布式系统的一致性问题进行理论分析，后面将基于这些理论进行分布式方案的介绍。</p>
<h2 id="可用性和一致性的冲突-——-CAP理论"><a href="#可用性和一致性的冲突-——-CAP理论" class="headerlink" title="可用性和一致性的冲突 —— CAP理论"></a>可用性和一致性的冲突 —— CAP理论</h2><p><img src="//blog.com/2019/01/25/理解分布式事务/1679817cdb4305db.png" alt="CAP"></p>
<p>CAP 定理又被称作布鲁尔定理，是加州大学的计算机科学家布鲁尔在 2000 年提出的一个猜想。2002 年，麻省理工学院的赛斯·吉尔伯特和南希·林奇发表了布鲁尔猜想的证明，使之成为分布式计算领域公认的一个定理。</p>
<p>布鲁尔在提出CAP猜想时并没有具体定义 Consistency、Availability、Partition Tolerance 这3个词的含义，不同资料的具体定义也有差别，为了更好地解释，下面选择<a href="https://link.juejin.im/?target=http%3A%2F%2Frobertgreiner.com%2Fabout%2F" target="_blank" rel="noopener">Robert Greiner</a>的文章<a href="https://link.juejin.im/?target=http%3A%2F%2Frobertgreiner.com%2F2014%2F08%2Fcap-theorem-revisited%2F" target="_blank" rel="noopener">《CAP Theorem》</a>作为参考基础。</p>
<ul>
<li><strong>CAP理论的定义</strong> 在一个分布式系统（指互相连接并共享数据的节点的集合）中，当涉及读写操作时，只能保证一致性（Consistence）、可用性（Availability）、分区容错性（PartitionTolerance）三者中的两个，另外一个必须被牺牲。</li>
</ul>
<p>Consistency、Availability、Partition Tolerance具体解释如下：</p>
<ul>
<li><strong>C - Consistency 一致性</strong></li>
</ul>
<blockquote>
<p>A read is guaranteed to return the most recent write for a given client. 对某个指定的客户端来说，读操作保证能够返回最新的写操作结果。</p>
</blockquote>
<p>这里并不是强调同一时刻拥有相同的数据，对于系统执行事务来说，在事务执行过程中，系统其实处于一个不一致的状态，不同的节点的数据并不完全一致。</p>
<p>一致性强调客户端读操作能够获取最新的写操作结果，是因为事务在执行过程中，客户端是无法读取到未提交的数据的，只有等到事务提交后，客户端才能读取到事务写入的数据，而如果事务失败则会进行回滚，客户端也不会读取到事务中间写入的数据。</p>
<ul>
<li><strong>A - Availability 可用性</strong></li>
</ul>
<blockquote>
<p>A non-failing node will return a reasonable response within a reasonable amount of time (no error or timeout). 非故障的节点在合理的时间内返回合理的响应（不是错误和超时的响应）。</p>
</blockquote>
<p>这里强调的是合理的响应，不能超时，不能出错。注意并没有说“正确”的结果，例如，应该返回 100 但实际上返回了 90，肯定是不正确的结果，但可以是一个合理的结果。</p>
<ul>
<li><strong>P - Partition Tolerance 分区容忍性</strong></li>
</ul>
<blockquote>
<p>The system will continue to function when network partitions occur. 当出现<strong>网络分区</strong>后，系统能够继续“履行职责”。</p>
</blockquote>
<p>这里<strong>网络分区</strong>是指： 一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障（节点间网络连接断开、节点宕机），使得有些节点之间不连通了，整个网络就分成了几块区域，数据就散布在了这些不连通的区域中。</p>
<h3 id="一致性、可用性、分区容忍性的选择"><a href="#一致性、可用性、分区容忍性的选择" class="headerlink" title="一致性、可用性、分区容忍性的选择"></a>一致性、可用性、分区容忍性的选择</h3><p>虽然 CAP 理论定义是三个要素中只能取两个，但放到分布式环境下来思考，我们会发现<strong>必须选择 P（分区容忍）要素，因为网络本身无法做到 100% 可靠</strong>，有可能出故障，所以分区是一个必然的现象。</p>
<p>如果我们选择了 CA（一致性 + 可用性） 而放弃了 P（分区容忍性），那么<strong>当发生分区现象时，为了保证 C（一致性），系统需要禁止写入，当有写入请求时，系统返回 error（例如，当前系统不允许写入），这又和 A(可用性) 冲突了，因为 A（可用性）要求返回 no error 和 no timeout</strong>。</p>
<p>因此，分布式系统理论上不可能选择 CA （一致性 + 可用性）架构，<strong>只能选择 CP（一致性 + 分区容忍性） 或者 AP （可用性 + 分区容忍性）架构，在一致性和可用性做折中选择</strong>。</p>
<ul>
<li><p>CP - Consistency + Partition Tolerance （一致性 + 分区容忍性）</p>
<p><img src="//blog.com/2019/01/25/理解分布式事务/Dev/PHP/phpStudy/WWW/Blog_ReConstruct/%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/1679817d07dd1144.png" alt="CP模型"></p>
</li>
</ul>
<p>如上图所示，因为Node1节点和Node2节点连接中断导致分区现象，Node1节点的数据已经更新到y，但是Node1 和 Node2 之间的复制通道中断，数据 y 无法同步到 Node2，Node2 节点上的数据还是旧数据x。</p>
<p>这时<strong>客户端C 访问 Node2 时，Node2 需要返回 Error，提示客户端 “系统现在发生了错误”</strong>，这种处理方式违 背了可用性（Availability）的要求，因此 CAP 三者只能满足 CP。</p>
<ul>
<li><p>AP - Availability + Partition Tolerance （可用性 + 分区容忍性）</p>
<p><img src="//blog.com/2019/01/25/理解分布式事务/Dev/PHP/phpStudy/WWW/Blog_ReConstruct/%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/1679817d0d2bbcf1.png" alt="AP模型"></p>
</li>
</ul>
<p>同样是Node2 节点上的数据还是旧数据x，这时客户端C 访问 Node2 时，Node2 将当前自己拥有的数据 x 返回给客户端 了，而实际上当前最新的数据已经是 y 了，这就<strong>不满足一致性（Consistency）的要求</strong>了，因此 CAP 三者只能满足 AP。</p>
<p>注意：这里 Node2 节点返回 x，虽然不是一个“正确”的结果，但是一个“合理”的结果，因为<strong>x 是旧的数据</strong>，并不是一个错乱的值，只是不是最新的数据。</p>
<p>值得补充的是，CAP理论告诉我们<strong>分布式系统只能选择AP或者CP</strong>，但实际上并不是说整个系统只能选择AP或者CP，在 CAP 理论落地实践时，我们需要将系统内的数据按照不同的应用场景和要求进行分类，每类数据选择不同的策略（CP 还是 AP），而不是直接限定整个系统所有数据都是同一策略。</p>
<p>另外，只能选择CP或者AP是指系统发生分区现象时无法同时保证C（一致性）和A（可用性），但不是意味着什么都不做，<strong>当分区故障解决后，系统还是要保持保证CA</strong>。</p>
<h2 id="CAP理论的延伸——BASE理论"><a href="#CAP理论的延伸——BASE理论" class="headerlink" title="CAP理论的延伸——BASE理论"></a>CAP理论的延伸——BASE理论</h2><p><img src="//blog.com/2019/01/25/理解分布式事务/1679817d128d0b37.png" alt="BASE"></p>
<p>BASE 是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency），核心思想是即使无法做到强一致性（CAP 的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性。</p>
<ul>
<li><strong>BA - Basically Available 基本可用</strong> 分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</li>
</ul>
<p>这里的关键词是“<strong>部分</strong>”和“<strong>核心</strong>”，实际实践上，哪些是核心需要根据具体业务来权衡。例如登录功能相对注册功能更加核心，注册不了最多影响流失一部分用户，如果用户已经注册但无法登录，那就意味用户无法使用系统，造成的影响范围更大。</p>
<ul>
<li><strong>S - Soft State 软状态</strong> 允许系统存在中间状态，而该中间状态不会影响系统整体可用性。这里的中间状态就是 CAP 理论中的数据不一致。</li>
<li><strong>E - Eventual Consistency 最终一致性</strong> 系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。</li>
</ul>
<p>这里的关键词是“一定时间” 和 “最终”，“<strong>一定时间</strong>”和数据的特性是强关联的，不同业务不同数据能够容忍的不一致时间是不同的。例如支付类业务是要求秒级别内达到一致，因为用户时时关注；用户发的最新微博，可以容忍30分钟内达到一致的状态，因为用户短时间看不到明星发的微博是无感知的。而“<strong>最终</strong>”的含义就是不管多长时间，最终还是要达到一致性的状态。</p>
<p>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是<strong>对 CAP 中 AP 方案的一个补充</strong>：</p>
<ul>
<li>CAP 理论是忽略延时的，而实际应用中延时是无法避免的。 这一点就意味着<strong>完美的 CP 场景是不存在的</strong>，即使是几毫秒的数据复制延迟，在这几毫秒时间间隔内，系统是不符合 CP 要求的。因此 <strong>CAP 中的 CP 方案，实际上也是实现了最终一致性，只是“一定时间”是指几毫秒而已</strong>。</li>
<li>AP 方案中牺牲一致性只是指发生分区故障期间，而不是永远放弃一致性。 这一点其实就是 BASE 理论延伸的地方，<strong>分区期间牺牲一致性，但分区故障恢复后，系统应该达到最终一致性</strong>。</li>
</ul>
<h2 id="数据一致性模型"><a href="#数据一致性模型" class="headerlink" title="数据一致性模型"></a>数据一致性模型</h2><p>前面介绍的BASE模型提过“强一致性”和“最终一致性”，下面对这些一致性模型展开介绍。</p>
<p>分布式系统通过复制数据来提高系统的可靠性和容错性，并且将数据的不同的副本存放在不同的机器上，由于维护数据副本的一致性代价很高，因此许多系统采用弱一致性来提高性能，下面介绍常见的一致性模型：</p>
<ul>
<li><strong>强一致性</strong> 要求无论更新操作是在哪个数据副本上执行，之后所有的读操作都要能获得最新的数据。对于单副本数据来说，读写操作是在同一数据上执行的，容易保证强一致性。对多副本数据来说，则需要使用分布式事务协议。</li>
<li><strong>弱一致性</strong> 在这种一致性下，用户读到某一操作对系统特定数据的更新需要一段时间，我们将这段时间称为”不一致性窗口”。</li>
<li><strong>最终一致性</strong> 是弱一致性的一种特例，在这种一致性下系统保证用户最终能够读取到某操作对系统特定数据的更新（读取操作之前没有该数据的其他更新操作）。”不一致性窗口”的大小依赖于交互延迟、系统的负载，以及数据的副本数等。</li>
</ul>
<p>系统选择哪种一致性模型取决于应用对一致性的需求，所选取的一致性模型还会影响到系统如何处理用户的请求以及对副本维护技术的选择等。后面将基于上面介绍的一致性模型分别介绍分布式事务的解决方案。</p>
<h2 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h2><h3 id="柔性事务的概念"><a href="#柔性事务的概念" class="headerlink" title="柔性事务的概念"></a>柔性事务的概念</h3><p>在电商等互联网场景下，传统的事务在数据库性能和处理能力上都暴露出了瓶颈。在分布式领域基于CAP理论以及BASE理论，有人就提出了<strong>柔性事务</strong>的概念。</p>
<p>基于BASE理论的设计思想，柔性事务下，在不影响系统整体可用性的情况下(Basically Available 基本可用)，允许系统存在数据不一致的中间状态(Soft State 软状态)，在经过数据同步的延时之后，最终数据能够达到一致。<strong>并不是完全放弃了ACID，而是通过放宽一致性要求，借助本地事务来实现最终分布式事务一致性的同时也保证系统的吞吐</strong>。</p>
<h3 id="实现柔性事务的一些特性"><a href="#实现柔性事务的一些特性" class="headerlink" title="实现柔性事务的一些特性"></a>实现柔性事务的一些特性</h3><p>下面介绍的是实现柔性事务的一些常见特性，这些特性在具体的方案中不一定都要满足，因为不同的方案要求不一样。</p>
<p><strong>可见性(对外可查询)</strong> 在分布式事务执行过程中，如果某一个步骤执行出错，就需要明确的知道其他几个操作的处理情况，这就需要其他的服务都能够提供查询接口，保证可以通过查询来判断操作的处理情况。</p>
<p>为了保证操作的可查询，需要对于每一个服务的每一次调用都有一个全局唯一的标识，可以是业务单据号（如订单号）、也可以是系统分配的操作流水号（如支付记录流水号）。除此之外，操作的时间信息也要有完整的记录。</p>
<p><strong>操作幂等性</strong> 幂等性，其实是一个数学概念。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。也就是说，同一个方法，使用同样的参数，调用多次产生的业务结果与调用一次产生的业务结果相同。</p>
<p>之所以需要操作幂等性，是因为为了保证数据的最终一致性，很多事务协议都会有很多重试的操作，如果一个方法不保证幂等，那么将无法被重试。幂等操作的实现方式有多种，如在系统中缓存所有的请求与处理结果、检测到重复操作后，直接返回上一次的处理结果等。</p>
<h1 id="4-常见分布式事务解决方案"><a href="#4-常见分布式事务解决方案" class="headerlink" title="4 常见分布式事务解决方案"></a>4 常见分布式事务解决方案</h1><p>介绍完分布式系统的一致性相关理论，下面基于不同的一致性模型介绍分布式事务的常见解决方案，后面会再介绍各个方案的使用场景。</p>
<p>分布式事务的实现有许多种，其中较经典是由Tuxedo提出的XA分布式事务协议，XA协议包含二阶段提交（2PC）和三阶段提交（3PC）两种实现。</p>
<h2 id="4-1-2PC-二阶段提交-方案-——-强一致性"><a href="#4-1-2PC-二阶段提交-方案-——-强一致性" class="headerlink" title="4.1 2PC(二阶段提交)方案 —— 强一致性"></a>4.1 2PC(二阶段提交)方案 —— 强一致性</h2><h3 id="方案简介"><a href="#方案简介" class="headerlink" title="方案简介"></a>方案简介</h3><p>二阶段提交协议（Two-phase Commit，即2PC）是常用的分布式事务解决方案，即将事务的提交过程分为两个阶段来进行处理：准备阶段和提交阶段。事务的发起者称协调者，事务的执行者称参与者。</p>
<p>在分布式系统里，每个节点都可以知晓自己操作的成功或者失败，却无法知道其他节点操作的成功或失败。当一个事务跨多个节点时，为了保持事务的原子性与一致性，而引入一个协调者来统一掌控所有参与者的操作结果，并指示它们是否要把操作结果进行真正的提交或者回滚（rollback）。</p>
<p>二阶段提交的算法思路可以概括为：<strong>参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作</strong>。</p>
<p>核心思想就是对每一个事务都采用先尝试后提交的处理方式，处理后所有的读操作都要能获得最新的数据，因此也可以将二阶段提交看作是一个强一致性算法。</p>
<h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><p>简单一点理解，可以把协调者节点比喻为带头大哥，参与者理解比喻为跟班小弟，带头大哥统一协调跟班小弟的任务执行。</p>
<p><strong>阶段1：准备阶段</strong></p>
<blockquote>
<ul>
<li>1、协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待所有参与者答复。</li>
<li>2、各参与者执行事务操作，将undo和redo信息记入事务日志中（但不提交事务）。</li>
<li>3、如参与者执行成功，给协调者反馈yes，即可以提交；如执行失败，给协调者反馈no，即不可提交。</li>
</ul>
</blockquote>
<p><strong>阶段2：提交阶段</strong> 如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(rollback)消息；否则，发送提交(commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源) 接下来分两种情况分别讨论提交阶段的过程。</p>
<p><strong>情况1，当所有参与者均反馈yes，提交事务</strong>：</p>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817d117d6f87.png" alt="事务正常提交"></p>
<blockquote>
<ul>
<li>1、协调者向所有参与者发出正式提交事务的请求（即commit请求）。</li>
<li>2、参与者执行commit请求，并释放整个事务期间占用的资源。</li>
<li>3、各参与者向协调者反馈ack(应答)完成的消息。</li>
<li>4、协调者收到所有参与者反馈的ack消息后，即完成事务提交。</li>
</ul>
</blockquote>
<p><strong>情况2，当任何阶段1一个参与者反馈no，中断事务</strong>：</p>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817d17f9bebd.png" alt="事务中断"></p>
<blockquote>
<ul>
<li>1、协调者向所有参与者发出回滚请求（即rollback请求）。</li>
<li>2、参与者使用阶段1中的undo信息执行回滚操作，并释放整个事务期间占用的资源。</li>
<li>3、各参与者向协调者反馈ack完成的消息。</li>
<li>4、协调者收到所有参与者反馈的ack消息后，即完成事务中断。</li>
</ul>
</blockquote>
<h3 id="方案总结"><a href="#方案总结" class="headerlink" title="方案总结"></a>方案总结</h3><p>2PC方案实现起来简单，实际项目中使用比较少，主要因为以下问题：</p>
<ul>
<li>性能问题 所有参与者在事务提交阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。</li>
<li>可靠性问题 如果协调者存在单点故障问题，如果协调者出现故障，参与者将一直处于锁定状态。</li>
<li>数据一致性问题 在阶段2中，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。</li>
</ul>
<h2 id="4-2-3PC-三阶段提交-方案"><a href="#4-2-3PC-三阶段提交-方案" class="headerlink" title="4.2 3PC(三阶段提交)方案"></a>4.2 3PC(三阶段提交)方案</h2><h3 id="方案简介-1"><a href="#方案简介-1" class="headerlink" title="方案简介"></a>方案简介</h3><p>三阶段提交协议，是二阶段提交协议的改进版本，与二阶段提交不同的是，引入超时机制。同时在协调者和参与者中都引入超时机制。</p>
<p>三阶段提交将二阶段的准备阶段拆分为2个阶段，插入了一个preCommit阶段，使得原先在二阶段提交中，参与者在准备之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。</p>
<h3 id="处理流程-1"><a href="#处理流程-1" class="headerlink" title="处理流程"></a>处理流程</h3><p><strong>阶段1：canCommit</strong> 协调者向参与者发送commit请求，参与者如果可以提交就返回yes响应(参与者不执行事务操作)，否则返回no响应：</p>
<blockquote>
<ul>
<li>1、协调者向所有参与者发出包含事务内容的canCommit请求，询问是否可以提交事务，并等待所有参与者答复。</li>
<li>2、参与者收到canCommit请求后，如果认为可以执行事务操作，则反馈yes并进入预备状态，否则反馈no。</li>
</ul>
</blockquote>
<p><strong>阶段2：preCommit</strong> 协调者根据阶段1 canCommit参与者的反应情况来决定是否可以基于事务的preCommit操作。根据响应情况，有以下两种可能。</p>
<p><strong>情况1：阶段1所有参与者均反馈yes，参与者预执行事务：</strong></p>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817d3cc0fdf5.png" alt="阶段2预执行事务"></p>
<blockquote>
<ul>
<li>1、协调者向所有参与者发出preCommit请求，进入准备阶段。</li>
<li>2、参与者收到preCommit请求后，执行事务操作，将undo和redo信息记入事务日志中（但不提交事务）。</li>
<li>3、各参与者向协调者反馈ack响应或no响应，并等待最终指令。</li>
</ul>
</blockquote>
<p><strong>情况2：阶段1任何一个参与者反馈no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务:</strong></p>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817d48efd0ac.png" alt="阶段2中断事务"></p>
<blockquote>
<ul>
<li>1、协调者向所有参与者发出abort请求。</li>
<li>2、无论收到协调者发出的abort请求，或者在等待协调者请求过程中出现超时，参与者均会中断事务。</li>
</ul>
</blockquote>
<p><strong>阶段3：do Commit</strong> 该阶段进行真正的事务提交，也可以分为以下两种情况：</p>
<p><strong>情况1：阶段2所有参与者均反馈ack响应，执行真正的事务提交：</strong></p>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817d4d4ed592.png" alt="阶段3正式执行事务"></p>
<ul>
<li>1、如果协调者处于工作状态，则向所有参与者发出do Commit请求。</li>
<li>2、参与者收到do Commit请求后，会正式执行事务提交，并释放整个事务期间占用的资源。</li>
<li>3、各参与者向协调者反馈ack完成的消息。</li>
<li>4、协调者收到所有参与者反馈的ack消息后，即完成事务提交。</li>
</ul>
<p><strong>阶段2任何一个参与者反馈no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务：</strong></p>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817d4f7103dc.png" alt="中断事务"></p>
<ul>
<li>1、如果协调者处于工作状态，向所有参与者发出abort请求。</li>
<li>2、参与者使用阶段1中的undo信息执行回滚操作，并释放整个事务期间占用的资源。</li>
<li>3、各参与者向协调者反馈ack完成的消息。</li>
<li>4、协调者收到所有参与者反馈的ack消息后，即完成事务中断。</li>
</ul>
<p>注意：进入阶段3后，无论协调者出现问题，或者协调者与参与者网络出现问题，都会导致参与者无法接收到协调者发出的do Commit请求或abort请求。此时，参与者都会在等待超时之后，继续执行事务提交。</p>
<h3 id="方案总结-1"><a href="#方案总结-1" class="headerlink" title="方案总结"></a>方案总结</h3><ul>
<li>优点 相比二阶段提交，三阶段贴近降低了阻塞范围，在等待超时后协调者或参与者会中断事务。避免了协调者单点问题，阶段3中协调者出现问题时，参与者会继续提交事务。</li>
<li>缺点 数据不一致问题依然存在，当在参与者收到preCommit请求后等待do commite指令时，此时如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。</li>
</ul>
<h2 id="4-3-TCC-（Try-Confirm-Cancel）事务-——-最终一致性"><a href="#4-3-TCC-（Try-Confirm-Cancel）事务-——-最终一致性" class="headerlink" title="4.3 TCC （Try-Confirm-Cancel）事务 —— 最终一致性"></a>4.3 TCC （Try-Confirm-Cancel）事务 —— 最终一致性</h2><h3 id="方案简介-2"><a href="#方案简介-2" class="headerlink" title="方案简介"></a>方案简介</h3><p>TCC（Try-Confirm-Cancel）的概念，最早是由Pat Helland于2007年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。</p>
<p>TCC是服务化的二阶段编程模型，其Try、Confirm、Cancel 3个方法均由业务编码实现；</p>
<ul>
<li>Try操作作为一阶段，负责资源的检查和预留。</li>
<li>Confirm操作作为二阶段提交操作，执行真正的业务。</li>
<li>Cancel是预留资源的取消。</li>
</ul>
<p>TCC事务的Try、Confirm、Cancel可以理解为SQL事务中的Lock、Commit、Rollback。</p>
<h3 id="处理流程-2"><a href="#处理流程-2" class="headerlink" title="处理流程"></a>处理流程</h3><p>为了方便理解，下面以电商下单为例进行方案解析，这里把整个过程简单分为扣减库存，订单创建2个步骤，库存服务和订单服务分别在不同的服务器节点上。</p>
<p><strong>1、Try 阶段</strong> 从执行阶段来看，与传统事务机制中业务逻辑相同。但从业务角度来看，却不一样。TCC机制中的Try仅是一个初步操作，它和后续的确认一起才能真正构成一个完整的业务逻辑，这个阶段主要完成：</p>
<ul>
<li>完成所有业务检查( 一致性 )</li>
<li>预留必须业务资源( 准隔离性 )</li>
<li>Try 尝试执行业务 TCC事务机制以初步操作（Try）为中心的，确认操作（Confirm）和取消操作（Cancel）都是围绕初步操作（Try）而展开。因此，Try阶段中的操作，其保障性是最好的，即使失败，仍然有取消操作（Cancel）可以将其执行结果撤销。</li>
</ul>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817d5f39b3ed.png" alt="Try阶段"></p>
<p>假设商品库存为100，购买数量为2，这里检查和更新库存的同时，冻结用户购买数量的库存，同时创建订单，订单状态为待确认。</p>
<p><strong>2、Confirm / Cancel 阶段</strong> 根据Try阶段服务是否全部正常执行，继续执行确认操作（Confirm）或取消操作（Cancel）。 Confirm和Cancel操作满足幂等性，如果Confirm或Cancel操作执行失败，将会不断重试直到执行完成。</p>
<p><strong>Confirm：当Try阶段服务全部正常执行， 执行确认业务逻辑操作</strong></p>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817d5629680a.png" alt="Confirm"></p>
<p>这里使用的资源一定是Try阶段预留的业务资源。在TCC事务机制中认为，如果在Try阶段能正常的预留资源，那Confirm一定能完整正确的提交。Confirm阶段也可以看成是对Try阶段的一个补充，Try+Confirm一起组成了一个完整的业务逻辑。</p>
<p><strong>Cancel：当Try阶段存在服务执行失败， 进入Cancel阶段</strong></p>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817d79abebd3.png" alt="Cancel"></p>
<p>Cancel取消执行，释放Try阶段预留的业务资源，上面的例子中，Cancel操作会把冻结的库存释放，并更新订单状态为取消。</p>
<h3 id="方案总结-2"><a href="#方案总结-2" class="headerlink" title="方案总结"></a>方案总结</h3><p>TCC事务机制相对于传统事务机制（X/Open XA），TCC事务机制相比于上面介绍的XA事务机制，有以下优点:</p>
<ul>
<li>性能提升 具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。</li>
<li>数据最终一致性 基于Confirm和Cancel的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。</li>
<li>可靠性 解决了XA协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。</li>
</ul>
<p>缺点： TCC的Try、Confirm和Cancel操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。</p>
<h2 id="4-4-本地消息表-——-最终一致性"><a href="#4-4-本地消息表-——-最终一致性" class="headerlink" title="4.4 本地消息表 —— 最终一致性"></a>4.4 本地消息表 —— 最终一致性</h2><h3 id="方案简介-3"><a href="#方案简介-3" class="headerlink" title="方案简介"></a>方案简介</h3><p>本地消息表的方案最初是由ebay提出，核心思路是将分布式事务拆分成本地事务进行处理。</p>
<p>方案通过在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。</p>
<p>这样设计可以避免”<strong>业务处理成功 + 事务消息发送失败</strong>“，或”<strong>业务处理失败 + 事务消息发送成功</strong>“的棘手情况出现，保证2个系统事务的数据一致性。</p>
<h3 id="处理流程-3"><a href="#处理流程-3" class="headerlink" title="处理流程"></a>处理流程</h3><p>下面把分布式事务最先开始处理的事务方成为事务主动方，在事务主动方之后处理的业务内的其他事务成为事务被动方。</p>
<p>为了方便理解，下面继续以电商下单为例进行方案解析，这里把整个过程简单分为扣减库存，订单创建2个步骤，库存服务和订单服务分别在不同的服务器节点上，其中库存服务是事务主动方，订单服务是事务被动方。</p>
<p>事务的主动方需要额外新建事务消息表，用于记录分布式事务的消息的发生、处理状态。</p>
<p>整个业务处理流程如下：</p>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817d7dbcf5be.png" alt="本地消息表方案"></p>
<blockquote>
<ul>
<li><strong>步骤1 事务主动方处理本地事务。</strong> 事务主动发在本地事务中处理业务更新操作和写消息表操作。 上面例子中库存服务阶段再本地事务中完成扣减库存和写消息表(图中1、2)。</li>
<li><strong>步骤2 事务主动方通过消息中间件，通知事务被动方处理事务通知事务待消息</strong>。 消息中间件可以基于Kafka、RocketMQ消息队列，事务主动方法主动写消息到消息队列，事务消费方消费并处理消息队列中的消息。 上面例子中，库存服务把事务待处理消息写到消息中间件，订单服务消费消息中间件的消息，完成新增订单（图中3 - 5）。</li>
<li><strong>步骤3 事务被动方通过消息中间件，通知事务主动方事务已处理的消息。</strong> 上面例子中，订单服务把事务已处理消息写到消息中间件，库存服务消费中间件的消息，并将事务消息的状态更新为已完成(图中6 - 8)</li>
</ul>
</blockquote>
<p>为了数据的一致性，当处理错误需要重试，事务发送方和事务接收方相关业务处理需要支持幂等。具体保存一致性的容错处理如下：</p>
<blockquote>
<ul>
<li>1、当步骤1处理出错，事务回滚，相当于什么都没发生。</li>
<li>2、当步骤2、步骤3处理出错，由于未处理的事务消息还是保存在事务发送方，事务发送方可以定时轮询为超时消息数据，再次发送的消息中间件进行处理。事务被动方消费事务消息重试处理。</li>
<li>3、如果是业务上的失败，事务被动方可以发消息给事务主动方进行回滚。</li>
<li>4、如果多个事务被动方已经消费消息，事务主动方需要回滚事务时需要通知事务被动方回滚。</li>
</ul>
</blockquote>
<h3 id="方案总结-3"><a href="#方案总结-3" class="headerlink" title="方案总结"></a>方案总结</h3><p>方案的优点如下：</p>
<ul>
<li>从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对MQ中间件特性的依赖。</li>
<li>方案轻量，容易实现。</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>与具体的业务场景绑定，耦合性强，不可公用。</li>
<li>消息数据与业务数据同库，占用业务系统资源。</li>
<li>业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限。</li>
</ul>
<h2 id="4-5-MQ事务-——-最终一致性"><a href="#4-5-MQ事务-——-最终一致性" class="headerlink" title="4.5 MQ事务 —— 最终一致性"></a>4.5 MQ事务 —— 最终一致性</h2><h3 id="方案简介-4"><a href="#方案简介-4" class="headerlink" title="方案简介"></a>方案简介</h3><p>基于MQ的分布式事务方案其实是对本地消息表的封装，将本地消息表基于MQ 内部，其他方面的协议基本与本地消息表一致。</p>
<h3 id="处理流程-4"><a href="#处理流程-4" class="headerlink" title="处理流程"></a>处理流程</h3><p>下面主要基于RocketMQ4.3之后的版本介绍MQ的分布式事务方案。</p>
<p>在本地消息表方案中，保证事务主动方发写业务表数据和写消息表数据的一致性是基于数据库事务，RocketMQ的事务消息相对于普通MQ，相对于提供了2PC的提交接口，方案如下：</p>
<p><strong>正常情况——事务主动方发消息</strong> 这种情况下，事务主动方服务正常，没有发生故障，发消息流程如下：</p>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817d7e8fc6cf.png" alt="正常情况——事务主动方发消息"></p>
<blockquote>
<ul>
<li>图中1、发送方向 MQ服务端(MQ Server)发送half消息。</li>
<li>图中2、MQ Server 将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功。</li>
<li>图中3、发送方开始执行本地事务逻辑。</li>
<li>图中4、发送方根据本地事务执行结果向 MQ Server 提交二次确认（commit 或是 rollback）。</li>
<li>图中5、MQ Server 收到 commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 rollback 状态则删除半消息，订阅方将不会接受该消息。</li>
</ul>
</blockquote>
<p><strong>异常情况——事务主动方消息恢复</strong> 在断网或者应用重启等异常情况下，图中4提交的二次确认超时未到达 MQ Server，此时处理逻辑如下：</p>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817d894f37a9.png" alt="异常情况——事务主动方消息恢复"></p>
<blockquote>
<ul>
<li>图中5、MQ Server 对该消息发起消息回查。</li>
<li>图中6、发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>图中7、发送方根据检查得到的本地事务的最终状态再次提交二次确认</li>
<li>图中8、MQ Server基于commit / rollback 对消息进行投递或者删除</li>
</ul>
</blockquote>
<p>介绍完RocketMQ的事务消息方案后，由于前面已经介绍过本地消息表方案，这里就简单介绍RocketMQ分布式事务：</p>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817d8bc3189d.png" alt="MQ分布式事务"></p>
<p>事务主动方基于MQ通信通知事务被动方处理事务，事务被动方基于MQ返回处理结果。 如果事务被动方消费消息异常，需要不断重试，业务处理逻辑需要保证幂等。 如果是事务被动方业务上的处理失败，可以通过MQ通知事务主动方进行补偿或者事务回滚。</p>
<h3 id="方案总结-4"><a href="#方案总结-4" class="headerlink" title="方案总结"></a>方案总结</h3><p>相比本地消息表方案，MQ事务方案优点是：</p>
<ul>
<li>消息数据独立存储 ，降低业务系统与消息系统之间的耦合。</li>
<li>吞吐量由于使用本地消息表方案。</li>
</ul>
<p>缺点是：</p>
<ul>
<li>一次消息发送需要两次网络请求(half消息 + commit/rollback消息)</li>
<li>业务处理服务需要实现消息状态回查接口</li>
</ul>
<h2 id="4-6-Saga事务-——-最终一致性"><a href="#4-6-Saga事务-——-最终一致性" class="headerlink" title="4.6 Saga事务 —— 最终一致性"></a>4.6 Saga事务 —— 最终一致性</h2><h3 id="方案简介-5"><a href="#方案简介-5" class="headerlink" title="方案简介"></a>方案简介</h3><p>Saga事务源于1987年普林斯顿大学的Hecto和Kenneth发表的如何处理long lived transaction（长活事务）论文，Saga事务核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</p>
<h3 id="处理流程-5"><a href="#处理流程-5" class="headerlink" title="处理流程"></a>处理流程</h3><p><strong>Saga事务基本协议如下</strong>：</p>
<ul>
<li>每个Saga事务由一系列幂等的有序子事务(sub-transaction) Ti 组成。</li>
<li>每个Ti 都有对应的幂等补偿动作Ci，补偿动作用于撤销Ti造成的结果。</li>
</ul>
<p>可以看到，和TCC相比，Saga没有“预留”动作，它的Ti就是直接提交到库。</p>
<p>下面以下单流程为例，整个操作包括：创建订单、扣减库存、支付、增加积分 Saga的执行顺序有两种：</p>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817d8ce9b4b7.png" alt="Saga事务执行顺序"></p>
<ul>
<li>事务正常执行完成 T1, T2, T3, …, Tn，例如：扣减库存(T1)，创建订单(T2)，支付(T3)，依次有序完成整个事务。</li>
<li>事务回滚 T1, T2, …, Tj, Cj,…, C2, C1，其中0 &lt; j &lt; n，例如：扣减库存(T1)，创建订单(T2)，支付(T3，支付失败)，支付回滚(C3)，订单回滚(C2)，恢复库存(C1)。</li>
</ul>
<p>Saga定义了两种恢复策略：</p>
<ul>
<li>向前恢复(forward recovery)</li>
</ul>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817da631d59c.png" alt="Saga事务向前恢复"></p>
<p>对应于上面第一种执行顺序，适用于必须要成功的场景，发生失败进行重试，执行顺序是类似于这样的：T1, T2, …, Tj(失败), Tj(重试),…, Tn，其中j是发生错误的子事务(sub-transaction)。该情况下不需要Ci。</p>
<ul>
<li>向后恢复(backward recovery)</li>
</ul>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817da706b3c2.png" alt="Saga事务向后恢复"></p>
<p>对应于上面提到的第二种执行顺序，其中j是发生错误的子事务(sub-transaction)，这种做法的效果是撤销掉之前所有成功的子事务，使得整个Saga的执行结果撤销。</p>
<p>Saga事务常见的有两种不同的实现方式：</p>
<ul>
<li>1、<strong>命令协调(Order Orchestrator)：中央协调器负责集中处理事件的决策和业务逻辑排序。</strong></li>
</ul>
<p>中央协调器（Orchestrator，简称OSO）以命令/回复的方式与每项服务进行通信，全权负责告诉每个参与者该做什么以及什么时候该做什么。</p>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817daa1798dd.png" alt="命令协调模式"></p>
<p>以电商订单的例子为例：</p>
<blockquote>
<p>1、事务发起方的主业务逻辑请求OSO服务开启订单事务 2、OSO向库存服务请求扣减库存，库存服务回复处理结果。 3、OSO向订单服务请求创建订单，订单服务回复创建结果。 4、OSO向支付服务请求支付，支付服务回复处理结果。 5、主业务逻辑接收并处理OSO事务处理结果回复。</p>
</blockquote>
<p>中央协调器必须事先知道执行整个订单事务所需的流程(例如通过读取配置)。如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。基于中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。</p>
<ul>
<li>2、<strong>事件编排 (Event Choreography0：没有中央协调器（没有单点风险）时，每个服务产生并观察其他服务的事件，并决定是否应采取行动</strong>。</li>
</ul>
<p>在事件编排方法中，第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件。</p>
<p>当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何Saga参与者听到都意味着事务结束。</p>
<p>以电商订单的例子为例：</p>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817dba9b2b61.png" alt="事件编排模式"></p>
<blockquote>
<p>1、事务发起方的主业务逻辑发布开始订单事件 2、库存服务监听开始订单事件，扣减库存，并发布库存已扣减事件 2、订单服务监听库存已扣减事件，创建订单，并发布订单已创建事件 4、支付服务监听订单已创建事件，进行支付，并发布订单已支付事件 5、主业务逻辑监听订单已支付事件并处理。</p>
</blockquote>
<p>事件/编排是实现Saga模式的自然方式，它很简单，容易理解，不需要太多的代码来构建。如果事务涉及2至4个步骤，则可能是非常合适的。</p>
<h3 id="方案总结-5"><a href="#方案总结-5" class="headerlink" title="方案总结"></a>方案总结</h3><p><strong>命令协调设计的优点和缺点：</strong> 优点如下：</p>
<ul>
<li>1、服务之间关系简单，避免服务之间的循环依赖关系，因为Saga协调器会调用Saga参与者，但参与者不会调用协调器</li>
<li>2、程序开发简单，只需要执行命令/回复(其实回复消息也是一种事件消息)，降低参与者的复杂性。</li>
<li>3、易维护扩展，在添加新步骤时，事务复杂性保持线性，回滚更容易管理，更容易实施和测试</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>1、中央协调器容易处理逻辑容易过于复杂，导致难以维护。</li>
<li>2、存在协调器单点故障风险。</li>
</ul>
<p><strong>事件/编排设计的优点和缺点</strong> 优点如下：</p>
<ul>
<li>1、避免中央协调器单点故障风险。</li>
<li>2、当涉及的步骤较少服务开发简单，容易实现。</li>
</ul>
<p>缺点如下：</p>
<ul>
<li>1、服务之间存在循环依赖的风险。</li>
<li>2、当涉及的步骤较多，服务间关系混乱，难以追踪调测。</li>
</ul>
<p>值得补充的是，由于Saga模型中没有Prepare阶段，因此事务间不能保证隔离性，当多个Saga事务操作同一资源时，就会产生更新丢失、脏数据读取等问题，这时需要在业务层控制并发，例如：在应用层面加锁，或者应用层面预先冻结资源。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><h2 id="各方案使用场景"><a href="#各方案使用场景" class="headerlink" title="各方案使用场景"></a>各方案使用场景</h2><p>介绍完分布式事务相关理论和常见解决方案后，最终的目的在实际项目中运用，因此，总结一下各个方案的常见的使用场景。</p>
<p><img src="//blog.com/2019/01/25/理解分布式事务/1679817dc68ae74d.png" alt="方案比较"></p>
<ul>
<li>2PC/3PC 依赖于数据库，能够很好的提供强一致性和强事务性，但相对来说延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。</li>
<li>TCC 适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。</li>
<li>本地消息表/MQ事务 都适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账/校验系统兜底。</li>
<li>Saga事务 由于Saga事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。 Saga相比缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。Saga事务较适用于补偿动作容易处理的场景。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Faalansehaiyang%2Ftechnology-talk%2Fblob%2Fmaster%2Fdata-base%2Ftransaction.md" target="_blank" rel="noopener">technology-talk —— 事务</a></p>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fdraveness.me%2Fmysql-transaction" target="_blank" rel="noopener">MySQL 中事务的实现</a></p>
<p><a href="https://link.juejin.im/?target=http%3A%2F%2Fblog.51cto.com%2F11821908%2F2058651" target="_blank" rel="noopener">分布式一致性算法2PC和3PC</a></p>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F453c6e7ff81c" target="_blank" rel="noopener">分布式开放消息系统(RocketMQ)的原理与实践</a></p>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fblog.csdn.net%2Flirenzuo%2Farticle%2Fdetails%2F81275785" target="_blank" rel="noopener">RocketMQ事务消息入门介绍</a></p>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fservicecomb.apache.org%2Fassets%2Fslides%2F20180422%2FQConBeijing2018-Saga.pdf" target="_blank" rel="noopener">Saga分布式事务解决方案与实践 —— 姜宁</a></p>
<p><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.jdon.com%2F49338" target="_blank" rel="noopener">分布式事务Saga模式</a></p>
<p><a href="https://juejin.im/post/5baa54e1f265da0ac2566fb2" target="_blank" rel="noopener">从一笔金币充值去思考分布式事务</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/01/25/从零开始搭建监控告警平台/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/25/从零开始搭建监控告警平台/" itemprop="url">从零开始搭建监控告警平台</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-25T12:12:57+08:00">
                2019-01-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/服务器/" itemprop="url" rel="index">
                    <span itemprop="name">服务器</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/服务器/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/服务器/架构/监控/" itemprop="url" rel="index">
                    <span itemprop="name">监控</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="从零开始搭建监控告警平台"><a href="#从零开始搭建监控告警平台" class="headerlink" title="从零开始搭建监控告警平台"></a>从零开始搭建监控告警平台</h1><blockquote>
<p>转自 58沈剑  架构师之路</p>
</blockquote>
<h2 id="集群信息管理"><a href="#集群信息管理" class="headerlink" title="集群信息管理"></a>集群信息管理</h2><h3 id="一、啥是集群？"><a href="#一、啥是集群？" class="headerlink" title="一、啥是集群？"></a>一、啥是集群？</h3><p>互联网典型分层架构如下：</p>
<p><img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/1.webp" alt=""></p>
<ul>
<li>web-server层</li>
<li>service层</li>
<li>db层与cache层</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了保证高可用，每一个站点、服务、数据库、缓存都会冗余多个实例，组成一个分布式的系统，集群则是一个分布式的物理形态。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;额，好拗口，通俗的说，<strong>集群就是一堆机器，上面部署了提供相似功能的站点</strong>，服务，数据库，或者缓存。</p>
<p><img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/2.webp" alt=""></p>
<p>如上图：</p>
<ul>
<li>web集群，由web.1和web.2两个实例组成</li>
<li>service集群，由service.1/service.2/service.3三个实例组成</li>
<li>db集群，由mysql-M/mysql-S1/mysql-S2三个实例组成</li>
<li>cache集群，由cache-M/cache-S两个实例组成</li>
</ul>
<h3 id="二、集群信息"><a href="#二、集群信息" class="headerlink" title="二、集群信息"></a>二、集群信息</h3><p>什么是集群信息？</p>
<p>一个集群，会包含若干信息，例如：</p>
<ul>
<li><strong>集群名称</strong></li>
<li><strong>IP列表</strong></li>
<li><strong>二进制目录</strong></li>
<li><strong>配置目录</strong></li>
<li><strong>日志目录</strong></li>
<li><strong>负责人列表</strong></li>
</ul>
<p>画外音：<strong>集群IP列表不建议直接使用IP，而建议使用内网域名</strong></p>
<h4 id="什么时候会用到集群信息呢？"><a href="#什么时候会用到集群信息呢？" class="headerlink" title="什么时候会用到集群信息呢？"></a>什么时候会用到集群信息呢？</h4><p>很多场景，特别是线上操作，都会使用到各种集群信息，例如：</p>
<ul>
<li><strong>自动化上线</strong></li>
<li><strong>监控</strong></li>
<li><strong>日志清理</strong></li>
<li><strong>二进制与配置的备份</strong></li>
<li><strong>下游的调用</strong></li>
</ul>
<p>这些场景，分别都是如何读取集群信息的？</p>
<p>一般来说，早期会<strong>把集群信息写在配置文件</strong>件里。</p>
<p>例如，<strong>自动化上线</strong>，有一个配置文件，deploy.user.service.config，其内容是：</p>
<blockquote>
<p>name : user.service</p>
<p>ip.list : ip1, ip2, ip3</p>
<p>bin.path : /user.service/bin/</p>
<p>ftp.path : <a href="ftp://192.168.0.1/USER_2_0_1_3/user.exe" target="_blank" rel="noopener">ftp://192.168.0.1/USER_2_0_1_3/user.exe</a></p>
</blockquote>
<p> 自动化上线的过程，则是：</p>
<ol>
<li>把可执行文件从ftp拉下来</li>
<li>读取集群IP列表</li>
<li>读取二进制应该部署的目录</li>
<li>把二进制部署到线上</li>
<li>逐台重启</li>
</ol>
<p>画外音：啥，还没有实现自动化脚本部署？还处在运维ssh到线上，手动执行命令，<strong>逐台机器人肉部署</strong>的刀耕火种阶段？赶紧照着这个方案，做<strong>自动化改造</strong>吧。</p>
<p>又例如，web-X调用下游的user服务，又有一个配置文件，web-X.config，其内容配置了：</p>
<blockquote>
<p>service.name : user.service</p>
<p>service.ip.list : ip1, ip2, ip3</p>
<p>service.port : 8080</p>
</blockquote>
<p>web-X调用user服务的过程，则是：</p>
<ol>
<li>web-X启动</li>
<li>web-X读取user服务集群的IP列表与端口</li>
<li>web-X初始化user服务连接池</li>
<li>web-X拿取user服务的连接，通过RPC接口调用user服务</li>
</ol>
<p><strong>日志清理，服务监控，二进制备份</strong>的过程，也都与上述类似。</p>
<h4 id="存在什么问题？"><a href="#存在什么问题？" class="headerlink" title="存在什么问题？"></a>存在什么问题？</h4><p>上述业务场景，对于集群信息的使用，有两个最大的特点：</p>
<p><strong>每个应用场景，所需集群信息都不一样</strong>（A场景需要集群abc信息，B场景需要集群def信息）</p>
<p><strong>每个应用场景，集群信息都写在“自己”的配置文件里</strong></p>
<p>一句话总结：<strong>集群信息管理分散化</strong>。</p>
<p>这里最大的问题，是<strong>耦合，当集群的信息发生变化的时候，有非常多的配置需要修改</strong>：</p>
<blockquote>
<p>deploy.user.service.config</p>
<p>clean.log.user.service.config</p>
<p>backup.bin.user.service.config</p>
<p>monitor.config</p>
<p>web-X.config</p>
</blockquote>
<p>这些配置里，user服务集群的信息都需要修改：</p>
<p><strong>随着研发、测试、运维人员的流动，很多配置放在哪里，逐步就被遗忘了</strong></p>
<p><strong>随着时间的推移，一些配置就被改漏了</strong></p>
<p>如何解决上述耦合的问题呢？</p>
<p>一句话回答：<strong>集群信息管理集中化</strong>。</p>
<h3 id="三、如何集中化管理集群信息"><a href="#三、如何集中化管理集群信息" class="headerlink" title="三、如何集中化管理集群信息"></a>三、如何集中化管理集群信息</h3><p>如何集中化管理集群配置信息，不同发展阶段的公司，实现的方式不一样。</p>
<h4 id="早期方案-全局配置写死"><a href="#早期方案-全局配置写死" class="headerlink" title="早期方案-全局配置写死"></a>早期方案-全局配置写死</h4><p>通过<strong>全局配置文件</strong>，实现集群信息集中管理，举例global.config如下：</p>
<blockquote>
<p>[user.service]</p>
<p>ip.list : ip1, ip2, ip3</p>
<p>port : 8080</p>
<p>bin.path : /user.service/bin/</p>
<p>log.path : /user.service/log/</p>
<p>conf.path : /user.service/conf/</p>
<p>ftp.path :<a href="ftp://192.168.0.1/USER_2_0_1_3/user.exe" target="_blank" rel="noopener">ftp://192.168.0.1/USER_2_0_1_3/user.exe</a></p>
<p>owner.list : shenjian, zhangsan, lisi</p>
<p>[passport.web]</p>
<p>ip.list : ip11, ip22, ip33</p>
<p>port : 80</p>
<p>bin.path : /passport.web/bin/</p>
<p>log.path : /passport.web/log/</p>
<p>conf.path : /passport.web/conf/</p>
<p>ftp.path :<a href="ftp://192.168.0.1/PST_1_2_3_4/passport.jar" target="_blank" rel="noopener">ftp://192.168.0.1/PST_1_2_3_4/passport.jar</a></p>
<p>owner.list : shenjian, zui, shuaiqi</p>
</blockquote>
<p>集中维护集群信息之后：</p>
<ol>
<li><strong>任何需要读取集群信息的场景，都从global.config里读取</strong></li>
<li><strong>任何集群信息的修改，只需要修改global.config一处</strong></li>
<li><strong>global.config会部署到任何一台线上机器，维护和管理也很方便</strong></li>
</ol>
<p>画外音：额，当然，信息太多的话，global.config也要垂直拆分</p>
<h4 id="中期方案-接口拉取"><a href="#中期方案-接口拉取" class="headerlink" title="中期方案-接口拉取"></a>中期方案-接口拉取</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随着公司业务的发展，随着技术团队的扩充，随着技术体系的完善，通过集群信息管理服务，来维护集群信息的诉求原来越强烈。</p>
<p>画外音：慢慢的，配置太多了，通过global.config来修改配置太容易出错了</p>
<p><img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/3.webp" alt=""></p>
<p>如上图，建立集群信息管理服务：</p>
<ul>
<li>info.db ：存储集群信息</li>
<li>info.cache ：缓存集群信息</li>
<li>info.service ：提供集群信息访问的RPC接口，以及HTTP接口</li>
<li>info.web ：集群信息维护后台</li>
</ul>
<p><strong>服务的核心接口</strong>：</p>
<blockquote>
<p>Info InfoService::getInfo(String ClusterName);</p>
<p>Bool InfoService::setInfo(String ClusterName, String key, String value);</p>
</blockquote>
<p>然后，统一通过服务来获取与修改集群信息：</p>
<ol>
<li><strong>所有需要获取集群信息的场景，都通过info.service提供的接口来读取集群信息</strong></li>
<li><strong>所有需要修改集群信息的场景，都通过info.web来操作</strong></li>
</ol>
<h4 id="长期方案-推送"><a href="#长期方案-推送" class="headerlink" title="长期方案-推送"></a>长期方案-推送</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;集群信息服务可以解决大部分的耦合问题，但仍然有一个不足：<strong>集群信息变更时，无法反向实时通知关注方，集群信息发生了改变</strong>。更长远的，要引入<strong>配置中心</strong>来解决。</p>
<p><strong>可以通过zookeeper来搭建</strong></p>
<p> <img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/4.webp" alt=""></p>
<h2 id="分级告警策略"><a href="#分级告警策略" class="headerlink" title="分级告警策略"></a>分级告警策略</h2><h3 id="一、啥是告警？"><a href="#一、啥是告警？" class="headerlink" title="一、啥是告警？"></a>一、啥是告警？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;监控平台发现系统异常，向系统负责人发出<strong>文字</strong>（例如，邮件/短信），<strong>色彩</strong>（有些公司，编译不过，CI平台会亮红灯），<strong>声音</strong>（有些公司，有蜂鸣器嗡嗡响，研发压力大呀）等警示，就是告警。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绝大部分公司，<strong>主要是通过文字发出系统异常告警信息</strong>。</p>
<h4 id="文字告警有哪些常见的方法？"><a href="#文字告警有哪些常见的方法？" class="headerlink" title="文字告警有哪些常见的方法？"></a>文字告警有哪些常见的方法？</h4><p>以58到家为例，目前提供了四种文字告警的方式，其成本，到达率，实时性都不一样：</p>
<ul>
<li><strong>短信</strong>：成本高，实时性好，到达率高</li>
<li><strong>邮件</strong>：成本低，实时性差，到达率高</li>
<li><strong>钉钉/微信</strong>：成本低，实时性中，到达率中</li>
</ul>
<h3 id="二、啥是告警策略？"><a href="#二、啥是告警策略？" class="headerlink" title="二、啥是告警策略？"></a>二、啥是告警策略？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绝大部分公司，可能都没有考虑系统监控告警策略，<strong>一旦发生异常，就发邮件/短信通知系统负责人</strong>，这样可能导致这样一些问题：</p>
<ul>
<li>同一个集群的不同实例出问题，可能会造成<strong>重复告警</strong>，浪费带宽资源，升高短信成本</li>
<li>系统负责人短时间内手机被<strong>告警短信刷屏，导致产生麻木感</strong></li>
<li>系统负责人短时间内手机，邮箱，钉钉，微信同时对一个故障告警，<strong>导致产生巨大压力</strong></li>
<li>员工不重视告警，无法判断告警的优先级，leader又不知情，导致<strong>事故影响扩大</strong></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解决上述问题，针对不同的服务，在不同的时间段，不同的员工层级，应该设定不同的告警策略，<strong>有哪些常见的告警策略呢？</strong></p>
<blockquote>
<p>不能够一出现异常就报警</p>
<p>报警分级</p>
</blockquote>
<ul>
<li><strong>模块告警收敛策略</strong>：当一个模块/服务异常时，与其对应的所有接口监控，与其对应集群的多有实例，都会告警，此时，应该收敛为一个模块/服务告警，常见的实现方式是，<strong>模块/服务按照集群名称做告警去重</strong></li>
<li><strong>接口告警收敛策略</strong>：当一个模块/服务的一个接口异常，与其对应集群的多个实例，都会告警，此时，应该收敛为一个接口告警，常见的实现方式是，<strong>按照接口名称做告警去重</strong></li>
<li><strong>告警频率收敛策略</strong>：对同一个服务或者接口，应该在固定的时间内，只发送有限的告警，常见的方式是，<strong>按照1分钟1次限制告警次数</strong>，一来降低研发的紧张感与压力感，二来节省成本</li>
<li><strong>不同时段区分告警方式策略</strong>：<strong>工作日工作时段在公司时</strong>，通过邮件/钉钉/微信发送告警能更加节省成本；<strong>半夜或者周末</strong>发生故障时，通过邮件发送告警能保证实时性</li>
<li><strong>逐层上报告警策略</strong>：每个模块都应该有负责人，原则上告警会发送给模块的负责人，但如果告警连续1小时未恢复正常，告警会自动发送给系统负责人的<strong>直属leader</strong>，如果告警连续3个小时未恢复正常，告警会自动发送给系统负责人的<strong>二级leader</strong></li>
<li><strong>黑白跳动策略</strong>：当系统<strong>由正常变为异常，异常恢复正常</strong>，出现正反的变化时，都应该发出告警</li>
</ul>
<h3 id="三、监控平台，告警策略依赖的基础模块"><a href="#三、监控平台，告警策略依赖的基础模块" class="headerlink" title="三、监控平台，告警策略依赖的基础模块"></a>三、监控平台，告警策略依赖的基础模块</h3><p>要实现统一监控平台，要实现告警策略化，需要依赖<strong>两个</strong>非常重要的基础模块：</p>
<ul>
<li><strong>集群信息管理</strong></li>
<li><strong>员工信息管理</strong></li>
</ul>
<h4 id="什么是集群信息管理？"><a href="#什么是集群信息管理？" class="headerlink" title="什么是集群信息管理？"></a>什么是集群信息管理？</h4><p>额，这个架构设计中最容易忽略的部分，《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651960832&amp;idx=1&amp;sn=39fce05ae95bfff243a199d69f0fe018&amp;chksm=bd2d03dc8a5a8aca06e80f7466056beec1cdc3baa669ba1ab6419199843cab6fbe40d753ea42&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">监控平台基础服务，集群信息统一管理</a>》一文已经有过描述，文本不再展开。</p>
<p>以下是通过全局配置文件，实现集群信息集中管理，一个global.config举例：</p>
<blockquote>
<p><em>[user.service]</em></p>
<p><em>ip.list : ip1, ip2, ip3</em></p>
<p><em>port : 8080</em></p>
<p><em>bin.path : /user.service/bin/</em></p>
<p><em>log.path : /user.service/log/</em></p>
<p><em>conf.path : /user.service/conf/</em></p>
<p><em>ftp.path:<a href="ftp://192.168.0.1/USER_2_0_1_3/user.exe" target="_blank" rel="noopener">ftp://192.168.0.1/USER_2_0_1_3/user.exe</a></em></p>
<p>*owner.list : shenjian, zhangsan, lisi</p>
</blockquote>
<p>从这里，监控中心能够知道被监控的是 [user.service] <strong>集群</strong>，有<strong>三个实例</strong>部署在 ip1/ip2/ip3 上，如果发生异常，要将告警发送给 shenjian, zhangsan, lisi 三个<strong>模块直接负责人</strong>。</p>
<h4 id="什么是员工信息？"><a href="#什么是员工信息？" class="headerlink" title="什么是员工信息？"></a>什么是员工信息？</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;额，顾名思义，是员工基础信息的管理（额，这算什么解释）。和集群信息管理一样，<strong>员工信息的管理一定要集中化，不能分散在各处</strong>（分散的坏处是耦合，在《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651960832&amp;idx=1&amp;sn=39fce05ae95bfff243a199d69f0fe018&amp;chksm=bd2d03dc8a5a8aca06e80f7466056beec1cdc3baa669ba1ab6419199843cab6fbe40d753ea42&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">监控平台基础服务，集群信息统一管理</a>》一文里谈得很多了）。</p>
<p>员工信息管理的实现方式主要有两种：</p>
<ul>
<li><strong>员工信息管理服务</strong></li>
<li><strong>全局员工信息配置</strong></li>
</ul>
<p><strong>如何通过员工信息管理服务集中管理员工信息？</strong></p>
<p><img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/5.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上图，建立员工信息管理服务，绝大部分公司应该都是这么统一管理员工信息的，这个服务和HR系统结合应该是非常紧密的，即使是外采的HR系统，肯定有相关的模块管理员工信息，相关的数据库存储员工信息。</p>
<p><strong>如何通过全局配置文件集中管理员工信息？</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不考虑和HR系统的打通，而只考虑监控系统，分级告警的需求，完全可以通过配置文件来管理系统负责人信息，例如global.owner.config：</p>
<blockquote>
<p><em>[shenjian]</em></p>
<p><em>department : tech</em></p>
<p><em>leader : sandy</em></p>
<p><em>email :</em> <a href="mailto:*XX@OO.com" target="_blank" rel="noopener">*XX@OO.com</a>*</p>
<p><em>phone :15912345678</em></p>
<p><em>dingding :</em> <a href="mailto:*15912345678@dingding.com" target="_blank" rel="noopener">*15912345678@dingding.com</a>*</p>
<p><em>wechat : XXOO</em></p>
<p><em>…</em></p>
</blockquote>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>要开发统一监控平台，至少有两个基础模块：</p>
<ul>
<li>集群信息统一管理</li>
<li>员工信息统一管理</li>
</ul>
<p>统一监控平台，<strong>不能一异常就告警</strong>，太不人性化，要实现<strong>统一的分级告警策略</strong>：</p>
<ul>
<li><strong>模块告警收敛</strong>策略：按照集群名称做去重</li>
<li><strong>接口告警收敛</strong>策略：按照接口名称做去重</li>
<li><strong>告警频率收敛</strong>策略：按照M分钟N次限制告警</li>
<li><strong>不同时段区分告警</strong>方式策略：工作日/非工作日，白天/夜晚区分</li>
<li><strong>逐层上报</strong>告警策略：先模块负责人告警，n分钟未恢复升级，m分钟未恢复再升级</li>
<li><strong>黑白跳动</strong>策略：当系统由正常变为异常，异常恢复正常都通报</li>
</ul>
<p>员工信息管理，需要注意：</p>
<ul>
<li>避免分散管理，导致耦合</li>
<li>应当集中管理，有两种常见的实现方式，统一服务/统一全局配置</li>
</ul>
<h2 id="多维度立体化监控"><a href="#多维度立体化监控" class="headerlink" title="多维度立体化监控"></a>多维度立体化监控</h2><h3 id="一、什么是多维度立体化监控"><a href="#一、什么是多维度立体化监控" class="headerlink" title="一、什么是多维度立体化监控"></a>一、什么是多维度立体化监控</h3><p>监控的两个最为常见的角度：</p>
<ul>
<li>http接口监控</li>
<li>log关键字监控</li>
</ul>
<p>还有很多维度的监控：</p>
<ul>
<li><strong>操作系统，进程，端口</strong></li>
<li><strong>http状态码</strong></li>
<li><strong>服务存活性</strong></li>
<li><strong>接口处理时间</strong></li>
<li><strong>RPC接口监控</strong></li>
<li><strong>用户层面监控</strong></li>
</ul>
<p>如果只监控一个或少数几个维度：</p>
<ul>
<li><strong>监控到异常时，基本确信系统出现了问题</strong></li>
<li><strong>反过来，没有监控到异常，不能确信系统没有问题</strong></li>
</ul>
<p> <strong>系统需要监控的八个维度</strong>：</p>
<blockquote>
<ol>
<li>http接口监控</li>
<li>log关键字监控</li>
<li>操作系统，进程，端口</li>
<li>http状态码</li>
<li>服务存活性</li>
<li>接口处理时间</li>
<li>用户层面监控</li>
<li>RPC接口监控</li>
</ol>
</blockquote>
<p>例如：</p>
<ul>
<li>监控到操作系统CPU100%，系统大概率出现了问题，但CPU正常，并不能说明系统正常，例如tomcat挂了，CPU肯定是正常的，但操作系统监控却探测不到，于是需要进程，端口，存活性等其他监控予以辅助</li>
<li>进程，端口监控到异常，系统大概率出现了问题，但进程在运行，端口在监听，并不能说明系统正常，例如程序死锁，进程和端口是正常的，于是需要接口处理时间等其他监控予以辅助</li>
<li>接口处理时间监控到超时，系统大概率出现了问题，但接口处理时间不超时，并不能说明系统正常，例如数据库挂了，数据库连接拿不到，服务层每个接口都很快返回，并不超时</li>
<li>…</li>
</ul>
<p>这里的<strong>观点</strong>是：<strong>单维度监控易漏报，多维度立体化监控才是监控平台的根本之道</strong>。</p>
<p>“<strong>通用</strong>”“<strong>非侵入性</strong>”，即被监控的站点和服务无需任何埋点，无需任何修改，被监控模块的负责人无需配合做任何事情，就能全方位cover住。</p>
<h3 id="二、操作系统，进程，端口监控"><a href="#二、操作系统，进程，端口监控" class="headerlink" title="二、操作系统，进程，端口监控"></a>二、操作系统，进程，端口监控</h3><p><strong>监控需求</strong>：</p>
<ul>
<li>系统的<strong>网络</strong>是否被打满，<strong>磁盘</strong>是否有空间，<strong>CPU</strong>是否繁忙，<strong>内存</strong>是否用完，<strong>负载</strong>值是否过高，<strong>JVM</strong>是否正常</li>
<li>服务进程是否运行</li>
<li>监听端口是否正常</li>
<li>机器间是否联通</li>
</ul>
<p><img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/6.webp" alt="img"></p>
<h4 id="常见方案一：zabbix"><a href="#常见方案一：zabbix" class="headerlink" title="常见方案一：zabbix"></a>常见方案一：zabbix</h4><h4 id="常见方案二：shell"><a href="#常见方案二：shell" class="headerlink" title="常见方案二：shell"></a>常见方案二：shell</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;写一些非常简单的脚本，就能够获取到网络、磁盘、CPU、内存、load、JVM的信息，在配合一些阈值的配置，就能实现超出阈值告警的功能。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果配合集群信息管理服务，通过ps, netstat, telnet等命令，也能快速实现进程，端口，连通性的简易监控。</p>
<p><strong>实现要点</strong>：</p>
<ul>
<li>重点考虑扩展性，可配置性，非侵入性</li>
<li>集群信息管理服务（如果没有服务，有集群信息配置文件也行）</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于集群信息管理服务，详见《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651960832&amp;idx=1&amp;sn=39fce05ae95bfff243a199d69f0fe018&amp;chksm=bd2d03dc8a5a8aca06e80f7466056beec1cdc3baa669ba1ab6419199843cab6fbe40d753ea42&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">集群信息管理，架构设计中最容易遗漏的一环</a>》。</p>
<h3 id="三、404状态码监控"><a href="#三、404状态码监控" class="headerlink" title="三、404状态码监控"></a>三、404状态码监控</h3><p><strong>监控需求</strong>：监控http异常状态码。</p>
<p><strong>监控方案</strong>：<strong>nginx日志统一监控</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果实现了http接口统一监控，404监控的必要性并不是这么强，但毕竟实现简单，整一个通用的花不了多少时间。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在聊存活性监控，接口处理时间监控之前，多说几句系统架构，如果实现了框架与组件的统一，统一监控会省非常多的力气。</p>
<p><img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/7.webp" alt="img"></p>
<p>上图是一个典型的互联网分层架构图：</p>
<ul>
<li>最上游是APP和browser</li>
<li><strong>反向代理层</strong>是nginx，统一http404状态码监控就实现在这一层</li>
<li><strong>web层</strong>，假设自研了web-framework</li>
<li><strong>service层</strong>，假设自研了service-framework，web层会通过RPC-client调用service</li>
<li><strong>数据层db</strong>，假设自研了Daojia-DAO组件调用db</li>
<li><strong>缓存层cache</strong>，假设自研了Daojia-KV组件调用cache</li>
</ul>
<h3 id="四、服务存活性监控"><a href="#四、服务存活性监控" class="headerlink" title="四、服务存活性监控"></a>四、服务存活性监控</h3><p><strong>监控需求</strong>：进程和端口的监控，只能保证进程在，端口在，但并不能确定服务是否能响应请求，需要确定服务“活着”。</p>
<p><img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/8.webp" alt="img"></p>
<p><strong>监控方案</strong>：ping-pong式监控，在站点框架，服务框架层面统一实现，提供keepalive接口：</p>
<ul>
<li>在框架层面就可以实现ping-pong接口</li>
<li>监控中心通过集群信息管理服务（或者是配置文件）获取集群类型（web/service），集群IP列表</li>
<li>监控中心统一往集群发送内置的ping-pong请求</li>
</ul>
<p><strong>强调两点</strong>：</p>
<ul>
<li>如果开源框架不提供ping-pong接口，可以二次开发（要慎重，任何开源框架的二次开发，都是大坑的开始）</li>
<li>统一集群信息管理服务，或者，统一集群信息管理配置文件，真的很重要，是技术体系统一的基石</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于集群信息管理服务，详见《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651960832&amp;idx=1&amp;sn=39fce05ae95bfff243a199d69f0fe018&amp;chksm=bd2d03dc8a5a8aca06e80f7466056beec1cdc3baa669ba1ab6419199843cab6fbe40d753ea42&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">集群信息管理，架构设计中最容易遗漏的一环</a>》。</p>
<h3 id="五、接口执行时间监控"><a href="#五、接口执行时间监控" class="headerlink" title="五、接口执行时间监控"></a>五、接口执行时间监控</h3><p><strong>监控需求</strong>：</p>
<ul>
<li>http站点接口有没有超时</li>
<li>RPC服务接口有没有超时</li>
<li>db访问有没有超时</li>
<li>cache访问有没有超时</li>
<li>除了超时，还要监控同一个接口的执行时间有没有同比、环比的大幅度波动</li>
</ul>
<p>例如：一个接口平均响应时间是100ms，突然有一天增加到300ms，即使没有超时，也有理由怀疑接口出现了问题:</p>
<p><img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/9.webp" alt="img"></p>
<p><strong>监控方案</strong>：框架组件统一上报（如上图1,2,3,4）</p>
<ul>
<li>在web-framework里，对所有http接口进行数据上报，可以上报<strong>url，参数，执行时间</strong>等核心数据</li>
<li>在service-framework里，对所有RPC接口进行数据上报，可以上报<strong>接口，参数，执行时间</strong>等核心数据</li>
<li>在DAO里，对所有数据库SQL访问进行数据上报，可以上报<strong>sql，参数，执行时间</strong>等核心数据</li>
<li>早KV-client里，对所有cache访问进行数据上报，可以上报<strong>key，执行时间</strong>等核心数据</li>
</ul>
<p><strong>统一上报是思路</strong>，具体上报细节，是通过flume刷日志，还是storm/spark实时流处理，都可以。</p>
<h2 id="用户视角的监控"><a href="#用户视角的监控" class="headerlink" title="用户视角的监控"></a>用户视角的监控</h2><h3 id="一、为什么要进行用户视角的监控"><a href="#一、为什么要进行用户视角的监控" class="headerlink" title="一、为什么要进行用户视角的监控"></a>一、为什么要进行用户视角的监控</h3><h5 id="什么是用户视角的监控？"><a href="#什么是用户视角的监控？" class="headerlink" title="什么是用户视角的监控？"></a>什么是用户视角的监控？</h5><p>把系统内部当作黑盒：</p>
<ul>
<li>用户怎么访问系统，用户视角的监控就怎么访问系统</li>
<li>用户调用哪些接口，用户视角的监控就调用哪些接口</li>
</ul>
<p>此类监控的粒度较粗，并不直接监控web-server, service, db, cache…</p>
<h5 id="为什么要有用户视角的监控，非用户视角进行的监控有什么不足？"><a href="#为什么要有用户视角的监控，非用户视角进行的监控有什么不足？" class="headerlink" title="为什么要有用户视角的监控，非用户视角进行的监控有什么不足？"></a>为什么要有用户视角的监控，非用户视角进行的监控有什么不足？</h5><p><img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/10.webp" alt="img"></p>
<p>如上图所示，立体化监控的八大维度，除了用户视角的监控，另外七大维度，不管是机器监控，日志监控，接口监控，都是系统内部发起的，当系统外部与系统之间出现问题的时候，例如“某个省的光纤被挖断”或者“某条网络链路出现丢包”或者<strong>“某个地域供应商往页面里又插入小广告了”</strong>，是检测不出来的，只有站在用户视角的监控，才能检测出类似的问题。</p>
<h5 id="凌晨三点，告警短信响了，到底要不要起床检查系统？"><a href="#凌晨三点，告警短信响了，到底要不要起床检查系统？" class="headerlink" title="凌晨三点，告警短信响了，到底要不要起床检查系统？"></a>凌晨三点，告警短信响了，到底要不要起床检查系统？</h5><p>这个问题，是和技术人密切相关的问题。如何系统设计的合理，不管是任何一台 nginx, tomcat, service, cache, db 挂了，由于系统的高可用架构设计，理论上都不应该影响一线用户的访问。</p>
<p>于是乎，只要用户视角的监控不告警，是可以第二天再起床处理其他监控的告警的。</p>
<p><em>画外音：这帮不靠谱的架构师，每次都说能高可用，任何一个地方挂了，用户就受影响了。</em></p>
<h5 id="如何进行用户视角的监控？"><a href="#如何进行用户视角的监控？" class="headerlink" title="如何进行用户视角的监控？"></a>如何进行用户视角的监控？</h5><p>主要有三类方法：</p>
<ul>
<li>用户所在的地方，租机房布点监控</li>
<li>端（APP/browser）上布点监控</li>
<li>使用第三方监控平台</li>
</ul>
<h6 id="一、租机房布点监控"><a href="#一、租机房布点监控" class="headerlink" title="一、租机房布点监控"></a>一、租机房布点监控</h6><p><img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/11.webp" alt="img"></p>
<p>如上图所示，在用户所在城市租赁机房（只需要一台服务器），部署监控小程序，对系统进行外网访问监控，就能够检测网络链路，路由延时。</p>
<p><strong>缺点</strong>：额，各个城市租赁一台服务器，成本有点高（不止费用，管理成本也高）。</p>
<h6 id="二、端上布点监控"><a href="#二、端上布点监控" class="headerlink" title="二、端上布点监控"></a>二、端上布点监控</h6><p><img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/12.webp" alt="img"></p>
<p>如上图所示，假设用户使用的是APP产品，可以在APP上部署一个小的监控sdk，<strong>定期上报一些数据</strong>，根据地域IP访问的同比环比“趋势”判定某个地域用户的网络情况。</p>
<p><strong>缺点</strong>：会损耗用户一些流量。另外，既然是“趋势判定”，没有在自己机房内布点那么精确。</p>
<h6 id="三、第三方监控平台"><a href="#三、第三方监控平台" class="headerlink" title="三、第三方监控平台"></a>三、第三方监控平台</h6><p>既然是每个公司都有的痛点，实施起来又这么麻烦，自然有创业公司做这个事情。</p>
<p>可以购买第三方监控平台的服务，在配置后台配置</p>
<ul>
<li>待监控的页面，或者http接口</li>
<li>频率，阈值</li>
<li>告警接收人</li>
</ul>
<p>等信息，就能够快速实时全国各城市，甚至全世界各个国家的用户视角监控了，非常帅气。</p>
<p><strong>第三方监控平台是怎么实现全国，全世界布点监控的？</strong></p>
<p>额，他们租了机房。</p>
<p><strong>缺点</strong>：有点贵，是按照调用次数来收费的。</p>
<p><strong>五、总结</strong></p>
<p><strong>用户视角监控</strong>，把系统当作黑盒的一种粗粒度监控。</p>
<p><strong>用户视角监控</strong>，能检测出局部地域的用户访问异常。</p>
<p><strong>用户视角监控</strong>，有自主租赁机房布点，端上布点趋势检测，使用第三方服务三种方式。</p>
<h2 id="100行代码，搞定http监控框架"><a href="#100行代码，搞定http监控框架" class="headerlink" title="100行代码，搞定http监控框架"></a>100行代码，搞定http监控框架</h2><h3 id="一、常见的http监控玩法"><a href="#一、常见的http监控玩法" class="headerlink" title="一、常见的http监控玩法"></a>一、常见的http监控玩法</h3><h4 id="提问：有哪些常见http监控需求？"><a href="#提问：有哪些常见http监控需求？" class="headerlink" title="提问：有哪些常见http监控需求？"></a>提问：有哪些常见http监控需求？</h4><p><strong>回答</strong>：常见的http监控需求有两类：</p>
<ul>
<li><strong>html页面监控</strong></li>
<li><strong>返回json数据的http接口</strong></li>
</ul>
<h4 id="提问：常见的http监控怎么玩？"><a href="#提问：常见的http监控怎么玩？" class="headerlink" title="提问：常见的http监控怎么玩？"></a>提问：常见的http监控怎么玩？</h4><p><strong>回答</strong>：一般access日志，通过观测以下两个参数来实施告警：</p>
<ul>
<li><strong>http非200状态码</strong></li>
<li><strong>http请求响应时间</strong></li>
</ul>
<h3 id="二、常见的http监控存在什么问题？"><a href="#二、常见的http监控存在什么问题？" class="headerlink" title="二、常见的http监控存在什么问题？"></a>二、常见的http监控存在什么问题？</h3><p><strong>提问：常见的http非200状态码，以及响应时间监控有什么弊端？</strong></p>
<p><strong>回答</strong>：每个公司都有自己的404页面，例如58到家的404页面大概长这样：</p>
<p><img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/13.webp" alt="img"></p>
<p>这个页面的http状态码是200，且返回速度极快，根本不能代表html页面的真实运行情况，很难起到真正的监控作用。</p>
<p><em>画外音：不是说http状态码监控没用，相反，http状态码的监控是很有必要的，http状态码404说明系统一定有问题，但http状态码200不能说明系统没有问题。</em></p>
<h4 id="提问：http状态码不能说明问题，那什么才能代表http没有问题呢？"><a href="#提问：http状态码不能说明问题，那什么才能代表http没有问题呢？" class="headerlink" title="提问：http状态码不能说明问题，那什么才能代表http没有问题呢？"></a>提问：http状态码不能说明问题，那什么才能代表http没有问题呢？</h4><p><strong>回答</strong>：每个http都有自己的业务特性。</p>
<p>特性一：<strong>需要返回特定的页面内容</strong></p>
<p>例如，58到家的官网大概长成这样：</p>
<p><img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/14.webp" alt="img"></p>
<p>即，访问<a href="http://daojia.com/" target="_blank" rel="noopener">http://daojia.com/</a> ，一定要返回一个含“家政”字眼的html页面，才是正确的。</p>
<p>特性二：<strong>需要返回特定的接口内容</strong></p>
<p>例如，RESTful的获取用户信息接口，假设传入uid=123，会传回：</p>
<p>{“RET”:”SUCCESS”, “name”:”shenjian”, “uid”:”123”}</p>
<p>即，<a href="http://daojia.com/userinfo/get/?uid=123，一定要返回一个含“shenjian”的字符串，才是正确的。" target="_blank" rel="noopener">http://daojia.com/userinfo/get/?uid=123，一定要返回一个含“shenjian”的字符串，才是正确的。</a></p>
<p>于是乎，得到了可扩展通用<strong>http监控平台（框架）的思路</strong>：不仅仅要监控http状态码，更重要的是，要监控http返回内容的业务特性。</p>
<h3 id="三、可扩展通用http监控平台架构细节"><a href="#三、可扩展通用http监控平台架构细节" class="headerlink" title="三、可扩展通用http监控平台架构细节"></a>三、可扩展通用http监控平台架构细节</h3><p><img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/15.webp" alt="img"></p>
<p><img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p>
<p>整个http监控平台的架构如上，分为<strong>监控平台层，信息管理层，基础服务层</strong></p>
<h4 id="监控平台层"><a href="#监控平台层" class="headerlink" title="监控平台层"></a>监控平台层</h4><ul>
<li><strong>http监控中心：实施监控的主程序</strong></li>
<li><strong>http监控配置：可扩展的监控项信息管理</strong></li>
</ul>
<p>监控项核心信息包含：</p>
<ul>
<li><strong>被监控的html页面/RESTful接口属于哪个集群</strong></li>
<li><strong>被监控的URL</strong></li>
<li><strong>被监控的URL需要传入的数据，包含GET/POST/COOKIE等数据</strong></li>
<li><strong>被监控的http返回的数据中必须包含什么业务特性字符串</strong></li>
</ul>
<p>以58到家官网html为例，监控项核心信息为：</p>
<blockquote>
<p><em>[http.monitor.item]</em></p>
<p><em>cluster.name : daojia_main</em></p>
<p><em>url :</em> <em><a href="http://daojia.com/" target="_blank" rel="noopener">http://daojia.com/</a></em></p>
<p><em>result : 家政</em></p>
</blockquote>
<p>即，访问<a href="http://daojia.com/，返回结果必须包含“家政”。" target="_blank" rel="noopener">http://daojia.com/，返回结果必须包含“家政”。</a></p>
<p>以获取用户信息RESTful接口为例，监控项核心信息为：</p>
<blockquote>
<p><em>[http.monitor.item]</em></p>
<p><em>cluster.name : daojia_user</em></p>
<p><em>url :</em> <em><a href="http://daojia.com/userinfo/get/" target="_blank" rel="noopener">http://daojia.com/userinfo/get/</a></em></p>
<p><em>get.data : uid=123</em></p>
<p><em>post.data : NULL</em></p>
<p><em>cookie.data : NULL</em></p>
<p><em>result : shenjian</em></p>
</blockquote>
<p>即，访问<a href="http://daojia.com/userinfo/get/?uid=123，返回结果必须包含“shenjian”。" target="_blank" rel="noopener">http://daojia.com/userinfo/get/?uid=123，返回结果必须包含“shenjian”。</a></p>
<p>如果要做成<strong>平台</strong>，需要有一个<strong>监控项管理后台</strong>，来新增/修改/管理监控项。</p>
<p><strong>监控中心，会遍历所有监控项，并发对各个http监控项实施监控</strong></p>
<h4 id="信息管理层"><a href="#信息管理层" class="headerlink" title="信息管理层"></a>信息管理层</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;信息管理层又分为：<strong>集群信息管理服务，员工信息管理服务，告警策略管理服务</strong></p>
<h5 id="（1）集群信息管理服务"><a href="#（1）集群信息管理服务" class="headerlink" title="（1）集群信息管理服务"></a>（1）集群信息管理服务</h5><p>集群信息管理服务，主要提供这个接口：</p>
<blockquote>
<p> Info Service::getClusterInfo(String clusterName)</p>
</blockquote>
<p>即，<strong>通过集群名，获取集群信息</strong></p>
<p>集群信息有很多，和监控相关的主要有这么几个信息：</p>
<ul>
<li><strong>集群ip列表，每个web-server都应该被监控到</strong></li>
<li><strong>集群负责人，如果监控异常，要将告警发给谁</strong></li>
</ul>
<h5 id="（2）用户信息管理服务"><a href="#（2）用户信息管理服务" class="headerlink" title="（2）用户信息管理服务"></a>（2）用户信息管理服务</h5><p>用户信息管理服务，主要提供这个接口：</p>
<p>Info Service::getYuanGongInfo(String name)</p>
<p>即，<strong>通过员工名，获取员工信息</strong>。</p>
<p>员工信息有很多，和监控相关的主要有这么几个信息：</p>
<ul>
<li>员工手机号，邮箱，微信号，钉钉号等<strong>通讯信息</strong></li>
<li>如果要实现多级告警策略，还需要获取<strong>员工部门及leader的相关信息</strong></li>
</ul>
<h5 id="（3）告警策略管理服务"><a href="#（3）告警策略管理服务" class="headerlink" title="（3）告警策略管理服务"></a>（3）告警策略管理服务</h5><p>告警策略管理服务，主要提供这个接口：</p>
<blockquote>
<p>Bool Service::trySendAlarm(</p>
<p>​         String clusterName,</p>
<p>​         String yuangongName,</p>
<p>​         String ip,</p>
<p>​         String url,</p>
<p>​         …</p>
<p>)</p>
</blockquote>
<p>即，<strong>一旦发现接口有异常，尝试发送告警</strong>。</p>
<p>这个尝试发送告警，并不意味着一定会发送短信或者邮件，因为需要实现一系列人性化的告警策略：</p>
<ul>
<li>集群收敛策略，可以通过clusterName去重</li>
<li>接口收敛策略，可以通过url去重</li>
<li>定时定频策略，可以通过yuangongName去重</li>
<li>白天黑夜策略，可以通过告警发送时间实施</li>
<li>…</li>
</ul>
<h4 id="基础服务层"><a href="#基础服务层" class="headerlink" title="基础服务层"></a>基础服务层</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进行完<strong>告警策略过滤</strong>后，如果真实需要<strong>发送告警</strong>，调用基础服务层的服务发出。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发送邮件，发送短信这些<strong>基础服务</strong>，相信每个公司都有，这里就不展开叙述了。</p>
<h3 id="四、可扩展通用http监控框架细节"><a href="#四、可扩展通用http监控框架细节" class="headerlink" title="四、可扩展通用http监控框架细节"></a>四、可扩展通用http监控框架细节</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;楼主，你在搞笑？我在一个创业型公司，你上面说的http监控配置服务，集群信息管理服务，员工信息管理服务，告警策略管理服务，我们公司都没有！只有一个能发短信的接口，能整出个http监控框架不？还要通用可扩展哟。楼主你个骗子，说好的100行代码实现呢？</p>
<p>额，别急，上面的所有服务即使都没有，只要能发短信告警，就能整：</p>
<ul>
<li>http监控项信息：通过配置文件搞</li>
<li>集群信息：通过配置文件搞</li>
<li>员工信息：通过配置文件搞</li>
<li>告警策略信息：不搞告警策略了，异常就发短信</li>
</ul>
<p><img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/16.webp" alt="img"></p>
<p>于是乎，http监控框架变成了这个样子，服务都用配置文件代替了：</p>
<p>http监控项配置，monitor-item.config</p>
<blockquote>
<p><em>[http.monitor.item]</em></p>
<p><em>cluster.name : daojia_main</em></p>
<p><em>url :</em> <em><a href="http://daojia.com/" target="_blank" rel="noopener">http://daojia.com/</a></em></p>
<p><em>result : 家政</em></p>
</blockquote>
<blockquote>
<p><em>[http.monitor.item]</em></p>
<p><em>cluster.name : daojia_user</em></p>
<p><em>url :</em> <em><a href="http://daojia.com/userinfo/get/" target="_blank" rel="noopener">http://daojia.com/userinfo/get/</a></em></p>
<p><em>get.data : uid=123</em></p>
<p><em>post.data : NULL</em></p>
<p><em>cookie.data : NULL</em></p>
<p><em>result : shenjian</em></p>
</blockquote>
<p>集群信息配置，cluster-info.config：</p>
<blockquote>
<p><em>[daojia_main]</em></p>
<p><em>ip.list : ip1, ip2, ip3</em></p>
<p><em>port : 80</em></p>
<p><em>owner.list: shenjian, zhangsan, lisi</em></p>
</blockquote>
<blockquote>
<p><em>[daojia_user]</em></p>
<p><em>ip.list : ip11, ip22, ip33</em></p>
<p><em>port : 8080</em></p>
<p><em>owner.list: shenjian</em></p>
</blockquote>
<p>员工信息配置，owner-info.config</p>
<blockquote>
<p><em>[shenjian]</em></p>
<p><em>email :</em> <a href="mailto:*XX@XX.com" target="_blank" rel="noopener">*XX@XX.com</a>*</p>
<p><em>phone :15912345678</em></p>
</blockquote>
<blockquote>
<p><em>[zhangsan]</em></p>
<p><em>email :</em> <a href="mailto:*YY@YY.com" target="_blank" rel="noopener">*YY@YY.com</a>*</p>
<p><em>phone :18611220099</em></p>
</blockquote>
<h3 id="五、http监控框架伪代码"><a href="#五、http监控框架伪代码" class="headerlink" title="五、http监控框架伪代码"></a>五、http监控框架伪代码</h3><blockquote>
<p><em>// 解析配置文件，取出监控项、集群、员工等信息</em></p>
<p>Array[monitor-item] A1=Parse(monitor-item.config);</p>
<p>Array[cluster-info] A2= Parse(cluster-info.config);</p>
<p>Array[owner-info] A3=Parse(owner-info.config);</p>
<p><em>// 遍历所有监控项</em></p>
<p>for(each item in A1)  {</p>
<p> <em>// 取出监控项的集群名，URL，http数据，结果等信息</em></p>
<p> <em>clusterName= item.clusterName;</em></p>
<p> <em>url= item.url;</em></p>
<p> <em>getData= item.getData;</em></p>
<p> <em>postData= item.postData;</em></p>
<p> <em>cookieData= item.cookieData;</em></p>
<p> <em>result= item.result</em></p>
<p> // 由集群名，获取集群信息</p>
<p> <em>clusterInfo= A2[clusterName];</em></p>
<p> <em>// 由集群信息，获取集群ip列表，集群负责人列表</em></p>
<p> <em>List<string>ips = clusterInfo.ip;</string></em></p>
<p> <em>List<string>owners = clusterinfo.owner;</string></em></p>
<p> <em>// 集群内的每一个ip实例web-server，都需要监控</em></p>
<p> <em>for(each ip in ips){</em></p>
<p>  <em>// 根据ip，url，http数据构造请求</em></p>
<p>  <em>httpClient client = new httpClient(ip, url, getData, postData, cookieData);</em></p>
<p>  <em>// 获取http请求执行结果</em></p>
<p>  <em>httpResponse resp = client.execute();</em></p>
<p>  <em>// 如果返回为200，并且包含监控项里的业务特性结果</em></p>
<p>  <em>if(resp.code==200&amp;&amp; resp.contain(result)){</em></p>
<p>​    <em>//正常，继续监控</em></p>
<p>​    <em>continue;</em></p>
<p>  <em>}</em></p>
<p>  <em>// 否则，对所有集群负责人发送告警</em></p>
<p>  <em>for(each owner in owners){</em></p>
<p>   <em>// 取出负责人邮箱和手机号</em></p>
<p>   <em>email =A3[owner].email;</em></p>
<p>   <em>phone =A3[owner].phone;</em></p>
<p>   <em>// 发送邮件与短信告警</em></p>
<p>   <em>sendEmail(email, ip,url, owner);</em></p>
<p>   <em>snedSM(phone, ip, url,owner);</em></p>
<p>  <em>}</em></p>
<p> <em>}</em></p>
<p>}</p>
</blockquote>
<blockquote>
<p>monitor-item.config，监控项扩展性</p>
<ul>
<li>新增html页面监控，或者json的RESTful接口监控，只需要在配置中增加一个item</li>
<li>配置支持url，get，post，cookie等参数拼装任意http监控请求</li>
<li>配置支持不同业务逻辑返回不同的result的业务特性检查</li>
</ul>
<p>cluster-info.config，集群信息扩展性</p>
<ul>
<li>新增集群，只需在配置中增加一个item</li>
<li>集群加了一个实例，只需增加一个ip</li>
<li>集群加了一个负责人，只需增加一个owner</li>
</ul>
<p>owner-info.config，负责人信息扩展性</p>
<ul>
<li>新增负责人，只需要在配置中增加一个item</li>
<li>换了手机号/邮箱，只需修改相应配置</li>
</ul>
</blockquote>
<h2 id="90行代码，搞定日志监控框架"><a href="#90行代码，搞定日志监控框架" class="headerlink" title="90行代码，搞定日志监控框架"></a>90行代码，搞定日志监控框架</h2><h3 id="一、什么是日志监控"><a href="#一、什么是日志监控" class="headerlink" title="一、什么是日志监控"></a>一、什么是日志监控</h3><p>关于日志，不同公司，情况不同：</p>
<ul>
<li>A类公司：没有日志</li>
<li>B类公司：有日志，只有用户说系统挂了，或者有bug的时候，才会登录到系统看看日志，大部分日志打印得对心所欲，缺乏组织性和系统性</li>
</ul>
<p><em>画外音：额，很多时候，追查bug发现日志信息不全，要先上线一个有日志的版本，以帮助定位bug，你遇到过么？</em></p>
<ul>
<li>C类公司：有日志，有日志规范，系统性的组织和收集了日志</li>
</ul>
<p>对日志进行监控，先于用户发现系统的故障，实时告警，就是今天要讨论的日志监控问题。</p>
<h3 id="二、日志监控需求分析"><a href="#二、日志监控需求分析" class="headerlink" title="二、日志监控需求分析"></a>二、日志监控需求分析</h3><p>对于日志的监控，一般有这么几类需求：</p>
<ul>
<li><strong>某种级别的日志</strong>（例如FATAL级别，或者ERROR级别的日志）一旦出现，或者超过一定频率，就告警</li>
<li>包含某些特殊含义关键字（例如OutOfMemory，或者Exception）的<strong>异常日志</strong>，一旦出现，或者超过一定频率，就告警</li>
<li>包含某些特殊含义关键字（例如Login，或者Click）的<strong>正常日志</strong>，一旦一定时间周期没有出现，就告警</li>
</ul>
<p>其中，前两类需求，属于异常日志监控范畴，出现异常，实施告警。</p>
<p>第三类需求，属于正常日志监控范畴，一定的时间没有出现“正常”，就默认异常，实施告警。</p>
<p><strong>为什么不是一出现异常日志就告警呢？</strong></p>
<p>避免抖动引起的误报，一般到达一定频率才会告警，这属于告警策略的一部分。</p>
<h3 id="三、目录与日志的规范化"><a href="#三、目录与日志的规范化" class="headerlink" title="三、目录与日志的规范化"></a>三、目录与日志的规范化</h3><p><strong><img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/17.webp" alt="img"></strong></p>
<p>这是一个线上模块的目录示例：</p>
<ul>
<li>有<strong>源代码</strong>：hello.c</li>
<li>有<strong>可执行文件</strong>：a.out</li>
<li>有<strong>配置文件</strong>：hello.conf</li>
<li>有<strong>备份日志</strong>：hello.log.2018012812</li>
<li>有<strong>日志</strong>：hello.log</li>
<li>有<strong>临时文件</strong>：tmp</li>
</ul>
<p>体会一下，运维同学看到这样的线上文件部署，是什么感受？</p>
<p><em>画外音：没见过源代码直接部署到线上的？</em></p>
<h4 id="目录规范"><a href="#目录规范" class="headerlink" title="目录规范"></a>目录规范</h4><p>目录规范化不但对日志监控，对自动化运维都极为重要，要是线上目录都瞎搞，几乎没有办法实现自动化运维。</p>
<p>常见的目录规范有两类：<strong>模块优先类目录规范</strong>，<strong>功能优先类目录规范</strong>。</p>
<p><strong>什么是模块优先的目录规范？</strong></p>
<p><img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/18.webp" alt="img"></p>
<p>如上图，以模块名为优先组织目录：</p>
<ul>
<li>根目录下，有das，entry，logic三个模块目录</li>
<li>在模块目录下，又分别有存放可执行文件，配置文件，日志文件的bin目录，conf目录，以及log目录</li>
</ul>
<p><strong>什么是功能优先的目录规范？</strong></p>
<p><img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/19.webp" alt="img"></p>
<p>如上图，以功能为优先组织目录：</p>
<ul>
<li>根目录下，二进制目录bin，配置文件目录conf，日志目录log</li>
<li>功能目录下，有das，entry，logic等不同模块的目录</li>
</ul>
<p>建议<strong>推荐第二种</strong>，功能优先的目录规范，对二进制备份，配置备份，日志清理都非常方便。</p>
<h4 id="分级规范"><a href="#分级规范" class="headerlink" title="分级规范"></a>分级规范</h4><p>日志规范化不但对日志监控，对大数据体系建设都极为重要，需要考虑规范：</p>
<ul>
<li><strong>日志分级规范</strong>：不同级别的日志理应打到不同的文件中，例如FATAL级，ERROR级，WARM级，LOG级，INFO级，DEBUG级</li>
</ul>
<blockquote>
<p><em>fatal.log</em></p>
<p><em>error.log</em></p>
<p><em>info.log</em></p>
<p><em>debug.log</em></p>
<p><em>…</em></p>
</blockquote>
<ul>
<li><strong>日志切分规范</strong>：运维应该提供自动化的日志切分工具，支持小时级别，或者天级别的日志切分，曾经看过一个120G的access日志，从日志中grep出某个uid的日志，是极其低效的</li>
</ul>
<blockquote>
<p><em>daojia.log.2018012800</em></p>
<p><em>daojia.log.2018012801</em></p>
<p><em>…</em></p>
<p><em>daojia.log.2018012823</em></p>
</blockquote>
<h3 id="四、通用可扩展日志监控平台-框架思路"><a href="#四、通用可扩展日志监控平台-框架思路" class="headerlink" title="四、通用可扩展日志监控平台/框架思路"></a>四、通用可扩展日志监控平台/框架思路</h3><p>制订了目录规范，日志规范之后，要建立日志监控平台/框架，实施异常与正常的日志监控，就简单多了，主要有<strong>集中式监控，分散式监控</strong>两类思路。</p>
<h4 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h4><p><img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/20.webp" alt="img"></p>
<p>集中式的日志监控，最流行的莫过于<strong>ELK</strong>：</p>
<ul>
<li>各个机器节点上部署logstash，收集日志</li>
<li>收集的日志汇总到ES</li>
<li>通过Kibana做统一分析和展现</li>
</ul>
<h4 id="分散式"><a href="#分散式" class="headerlink" title="分散式"></a>分散式</h4><p>ELK有点重，三套系统搭建与运维起来比较麻烦，如果只是为了实现ERROR日志的监控，异常关键字监控，正常关键字监控，有点杀鸡用牛刀了。</p>
<p>与集中式的日志监控相比，分散式的日志监控，就显得轻量级许多，非常适用与早期的创业型公司，其思路为：</p>
<p><img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/21.webp" alt="img"></p>
<ul>
<li>通过<strong>日志监控后台</strong>，对不同集群，进行ERROR日志阈值设置，进行异常关键字设置，正常关键字设置</li>
<li><strong>日志监控中心</strong>，进行统一调度，将配置分发到不同机器的agent节点上</li>
<li><strong>agent节点</strong>，并不统一收集日志，而是接收到监控中心分发的log监控配置，在各个机器上实施日志监控，如果触发日志监控策略，立刻发起告警</li>
</ul>
<p>与ELK相比，这个日志平台会简单的多，而且扩展性非常好。</p>
<p>额，创业型公司没有时间和人员研发agent，没有资源研发日志监控中心服务，没有人力研发日志监控后台，还有没有更简洁但可扩展的方案呢？</p>
<p>和《<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651960853&amp;idx=1&amp;sn=9f6c1ff24e1770eb1ca232f45cf1c2c2&amp;chksm=bd2d03c98a5a8adf73905a0827ad970587658f0aa43aabceef7d177217c636cf526bc5ef2105&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">100行代码，搞定http监控框架</a>》的思路一样，没有服务，没有后台，没有agent，初期完全可以用配置文件来替代。</p>
<h3 id="100行搞定日志监控平台"><a href="#100行搞定日志监控平台" class="headerlink" title="100行搞定日志监控平台"></a>100行搞定日志监控平台</h3><p><img src="//blog.com/2019/01/25/从零开始搭建监控告警平台/22.webp" alt="img"></p>
<p>整个框架设计如上，大致分为三个部分：</p>
<ul>
<li><strong>被监控集群</strong></li>
<li><strong>基础信息与服务</strong></li>
</ul>
<p>​         cluster.info.xml：存储集群信息</p>
<p>​         owner.info.xml：存储集群责任人信息</p>
<p>​         mail.service/SM.service：发邮件，发短信的基础服务</p>
<ul>
<li><strong>日志监控框架</strong></li>
</ul>
<p>集群信息与负责人信息，与前文描述的一样。</p>
<p><strong>集群配置</strong>cluster.info.conf</p>
<blockquote>
<p><em>[daojia_main]</em></p>
<p><em>ip.list : ip1, ip2, ip3</em></p>
<p><em>log.path : /home/work/log/daojia_main/</em></p>
<p><em>owner.list : shenjian, zhangsan</em></p>
<p><em>[daojia_user]</em></p>
<p><em>ip.list : ip4, ip5, ip6</em></p>
<p><em>log.path : /home/work/log/daojia_user/</em></p>
<p><em>owner.list : shenjian</em></p>
</blockquote>
<p><strong>责任人配置</strong>owner.info.conf</p>
<blockquote>
<p><em>[shenjian]</em></p>
<p><em>email :</em> <a href="mailto:*XX@XX.com" target="_blank" rel="noopener">*XX@XX.com</a>*</p>
<p><em>phone :15912345678</em></p>
<p><em>[zhangsan]</em></p>
<p><em>email :</em> <a href="mailto:*YY@YY.com" target="_blank" rel="noopener">*YY@YY.com</a>*</p>
<p><em>phone :18611220099</em></p>
</blockquote>
<p>日志监控框架又分为两个模块：</p>
<ul>
<li><strong>可扩展监控配置文件</strong>log.monitor.conf</li>
</ul>
<blockquote>
<p>[log.monitor.item]</p>
<p>cluster.name : daojia_main</p>
<p><em># error日志监控，每分钟超过此阈值就告警</em></p>
<p><em>error.log. threshold : 10</em></p>
<p><em># 异常关键字监控，日志出现这些关键字就告警</em></p>
<p><em>bad.key : exeption | timeout | coredump</em></p>
<p><em># 正常关键字监控，日志每分钟不出现这些关键字就告警</em></p>
<p><em>good.key : login | user | click</em></p>
<p><em>[log.monitor.item]</em></p>
<p><em>cluster.name : daojia_user</em></p>
<p><em>error.log.threshold : 10</em></p>
</blockquote>
<p><strong>日志监控调度框架</strong>，这里需要编码啦，100行的伪代码如下：</p>
<blockquote>
<p><em>Array[log-monitor] A1= Parse(log.monitor.config);</em></p>
<p><em>Array[cluster-info] A2= Parse(cluster.info.config);</em></p>
<p><em>Array[owner-info] A3= Parse(owner.info.config);</em></p>
<p><em>// 遍历所有监控项</em></p>
<p><em>for(each item in A1){</em></p>
<p>​         <em>//取出监控项的集群名，阈值，异常/正常关键词</em></p>
<p>​         <em>clusterName= item.clusterName;</em></p>
<p>​         <em>threshold= item.threshold;</em></p>
<p>​         <em>badKey= item.badkey;</em></p>
<p>​         <em>goodKey= item.goodkey;</em></p>
<p>​         <em>//由集群名，获取集群信息</em></p>
<p>​         <em>clusterInfo= A2[clusterName];</em></p>
<p>​         <em>//获取日志目录，集群ip列表，集群负责人列表</em></p>
<p>​         <em>logPath= clusterInfo.path;</em></p>
<p>​         <em>List<string>ips = clusterInfo.ip;</string></em></p>
<p>​         <em>List<string>owners = clusterinfo.owner;</string></em></p>
<p>​        </p>
<p>​         <em>//集群内的每一个ip实例，都需要日志监控</em></p>
<p>​         <em>for(eachip in ips){</em></p>
<p>​                   <em>//登录到这一台机器</em></p>
<p>​                   <em>ssh $ip</em></p>
<p>​                   <em>//跳到相关的目录下</em></p>
<p>​                   <em>cd $logPath</em></p>
<p>​                   <em>//查看近一分钟error日志数量</em></p>
<p>​                   <em>$count= <code>grep $time error.log | wc -l</code></em></p>
<p>​                   <em>//查看badkey与goodkey</em></p>
<p>​                   <em>$boolBad= `grep $badkey \</em>`*</p>
<p>​                   <em>$boolGood= `grep $goodkey \</em>`*</p>
<p>​                   <em>if($count&lt; threshold &amp;&amp;</em> </p>
<p>​                        <em>$boolBad==NO &amp;&amp;</em></p>
<p>​                         <em>$boolGood==YES){</em></p>
<p>​                            <em>//正常，继续监控</em></p>
<p>​                            <em>continue;</em></p>
<p>​                  <em>}</em></p>
<p>​                  <em>// 否则，对所有集群负责人发送告警</em></p>
<p>​                  <em>for(each owner in owners){</em></p>
<p>​                           <em>// 略…</em></p>
<p>​                  <em>}</em></p>
<p>​         <em>}</em></p>
<p><em>}</em></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/01/24/InnoDB并发支持的原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/24/InnoDB并发支持的原理/" itemprop="url">InnoDB并发支持的原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-24T12:12:57+08:00">
                2019-01-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/MySql/" itemprop="url" rel="index">
                    <span itemprop="name">MySql</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/MySql/Innodb/" itemprop="url" rel="index">
                    <span itemprop="name">Innodb</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="InnoDB并发支持的原理"><a href="#InnoDB并发支持的原理" class="headerlink" title="InnoDB并发支持的原理"></a>InnoDB并发支持的原理</h2><h2 id="一、并发控制"><a href="#一、并发控制" class="headerlink" title="一、并发控制"></a>一、并发控制</h2><p><strong>为啥要进行并发控制？</strong></p>
<p>并发的任务对同一个临界资源进行操作，如果不采取措施，可能导致不一致，故必须进行<strong>并发控制</strong>（Concurrency Control）。</p>
<h3 id="技术上，通常如何进行并发控制？"><a href="#技术上，通常如何进行并发控制？" class="headerlink" title="技术上，通常如何进行并发控制？"></a>技术上，通常如何进行并发控制？</h3><p>通过并发控制保证数据一致性的常见手段有：</p>
<ul>
<li>锁（Locking）</li>
<li>数据多版本（Multi Versioning）</li>
</ul>
<h2 id="二、锁"><a href="#二、锁" class="headerlink" title="二、锁"></a>二、锁</h2><h3 id="如何使用普通锁保证一致性？"><a href="#如何使用普通锁保证一致性？" class="headerlink" title="如何使用普通锁保证一致性？"></a>如何使用普通锁保证一致性？</h3><p>普通锁，被使用最多：</p>
<p>(1)操作数据前，锁住，实施互斥，不允许其他的并发任务操作；</p>
<p>(2)操作完成后，释放锁，让其他任务执行；</p>
<p>如此这般，来保证一致性。</p>
<h3 id="普通锁存在什么问题？"><a href="#普通锁存在什么问题？" class="headerlink" title="普通锁存在什么问题？"></a>普通锁存在什么问题？</h3><p>简单的锁住太过粗暴，连“读任务”也无法并行，任务执行过程本质上是串行的。</p>
<p>于是出现了<strong>共享锁</strong>与<strong>排他锁</strong>：</p>
<ul>
<li>共享锁（<strong>S</strong>hare Locks，记为S锁），读取数据时加S锁</li>
<li>排他锁（e<strong>X</strong>clusive Locks，记为X锁），修改数据时加X锁</li>
</ul>
<p>共享锁与排他锁的玩法是：</p>
<ul>
<li>共享锁之间不互斥，简记为：读读可以并行</li>
<li>排他锁与任何锁互斥，简记为：写读，写写不可以并行</li>
</ul>
<p>可以看到，一旦写数据的任务没有完成，数据是不能被其他任务读取的，这对并发度有较大的影响。</p>
<p><em>画外音：对应到数据库，可以理解为，写事务没有提交，读相关数据的select也会被阻塞。</em></p>
<p><strong>有没有可能，进一步提高并发呢？</strong></p>
<p>即使写任务没有完成，其他读任务也可能并发，这就引出了数据多版本。</p>
<h2 id="三、数据多版本"><a href="#三、数据多版本" class="headerlink" title="三、数据多版本"></a>三、数据多版本</h2><p>数据多版本是一种能够进一步提高并发的方法，它的<strong>核心原理</strong>是：</p>
<p>（1）写任务发生时，将数据克隆一份，以版本号区分；</p>
<p>（2）写任务操作新克隆的数据，直至提交；</p>
<p>（3）并发读任务可以继续读取旧版本的数据，不至于阻塞；</p>
<p><img src="//blog.com/2019/01/24/InnoDB并发支持的原理/数据多版本1.webp" alt=""></p>
<p>如上图：</p>
<ol>
<li>最开始数据的版本是V0；</li>
<li>T1时刻发起了一个写任务，这是把数据clone了一份，进行修改，版本变为V1，但任务还未完成；</li>
<li>T2时刻并发了一个读任务，依然可以读V0版本的数据；</li>
<li>T3时刻又并发了一个读任务，依然不会阻塞；</li>
</ol>
<p>可以看到，数据多版本，通过“读取旧版本数据”能够极大提高任务的并发度。</p>
<p>提高并发的演进思路，就在如此：</p>
<ul>
<li><strong>普通锁</strong>，本质是串行执行</li>
<li><strong>读写锁</strong>，可以实现读读并发</li>
<li><strong>数据多版本</strong>，可以实现读写并发</li>
</ul>
<h2 id="四、redo-undo-回滚段"><a href="#四、redo-undo-回滚段" class="headerlink" title="四、redo, undo, 回滚段"></a>四、redo, undo, 回滚段</h2><h3 id="为什么要有redo日志？"><a href="#为什么要有redo日志？" class="headerlink" title="为什么要有redo日志？"></a>为什么要有redo日志？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据库事务提交后，必须将更新后的数据刷到磁盘上，以保证ACID特性。磁盘<strong>随机写</strong>性能较低，如果每次都刷盘，会极大影响数据库的吞吐量。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;优化方式是，将修改行为先写到redo日志里（此时变成了<strong>顺序写</strong>），再定期将数据刷到磁盘上，这样能极大提高性能。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>随机写优化为顺序写</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如某一时刻，数据库崩溃，还没来得及刷盘的数据，在数据库重启后，会重做redo日志里的内容，以保证已提交事务对数据产生的影响都刷到磁盘上。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>redo日志用于保障，已提交事务的ACID特性</strong></p>
<h3 id="为什么要有undo日志？"><a href="#为什么要有undo日志？" class="headerlink" title="为什么要有undo日志？"></a>为什么要有undo日志？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据库事务未提交时，会将事务修改数据的镜像（即<strong>修改前的旧版本</strong>）存放到undo日志里，当事务回滚时，或者数据库奔溃时，可以利用undo日志，即旧版本数据，撤销未提交事务对数据库产生的影响。</p>
<p>对于insert操作，undo日志记录新数据的PK(ROW_ID)，回滚时直接删除；</p>
<p>对于delete/update操作，undo日志记录旧数据row，回滚时直接恢复；</p>
<p><em>他们分别存放在不同的buffer里。</em></p>
<p>一句话，<strong>undo日志用于保障，未提交事务不会对数据库的ACID特性产生影响</strong>。</p>
<h3 id="什么是回滚段？"><a href="#什么是回滚段？" class="headerlink" title="什么是回滚段？"></a>什么是回滚段？</h3><p><strong>存储undo日志的地方，是回滚段</strong></p>
<p><strong>undo日志和回滚段和InnoDB的MVCC密切相关</strong></p>
<p><strong>例子</strong>：</p>
<p>t(id PK, name);</p>
<p> 数据为：</p>
<p>1, shenjian</p>
<p>2, zhangsan</p>
<p>3, lisi</p>
<p><img src="//blog.com/2019/01/24/InnoDB并发支持的原理/回滚段1.webp" alt="img"></p>
<p>此时没有事务未提交，故回滚段是空的。</p>
<p>接着启动了一个事务：</p>
<p>start trx;</p>
<p>delete (1, shenjian);</p>
<p>update set(3, lisi) to (3, xxx);</p>
<p>insert (4, wangwu);</p>
<p>并且事务处于未提交的状态。</p>
<p><img src="//blog.com/2019/01/24/InnoDB并发支持的原理/回滚段2.webp" alt="img"></p>
<p>可以看到：</p>
<p>(1)被删除前的(1, shenjian)作为旧版本数据，进入了回滚段；</p>
<p>(2)被修改前的(3, lisi)作为旧版本数据，进入了回滚段；</p>
<p>(3)被插入的数据，PK(4)进入了回滚段；</p>
<p>接下来，假如事务rollback，此时可以通过回滚段里的undo日志回滚。</p>
<p>假设事务提交，回滚段里的undo日志可以删除。*</p>
<p><img src="//blog.com/2019/01/24/InnoDB并发支持的原理/回滚段3.webp" alt="img"></p>
<p>可以看到：</p>
<p>(1)被删除的旧数据恢复了；</p>
<p>(2)被修改的旧数据也恢复了；</p>
<p>(3)被插入的数据，删除了；</p>
<p><img src="//blog.com/2019/01/24/InnoDB并发支持的原理/回滚段4.webp" alt="img"></p>
<p>事务回滚成功，一切如故。</p>
<h2 id="五、InnoDB是基于多版本并发控制的存储引擎"><a href="#五、InnoDB是基于多版本并发控制的存储引擎" class="headerlink" title="五、InnoDB是基于多版本并发控制的存储引擎"></a>五、InnoDB是基于多版本并发控制的存储引擎</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;InnoDB是高并发互联网场景最为推荐的存储引擎，根本原因，就是其<strong>多版本并发控制</strong>（Multi Version Concurrency Control, MVCC）。行锁，并发，事务回滚等多种特性都和MVCC相关。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MVCC就是通过“读取旧版本数据”来降低并发事务的锁冲突，提高任务的并发度。</p>
<p><strong>核心问题：</strong></p>
<p><strong>旧版本数据存储在哪里？</strong></p>
<p><strong>存储旧版本数据，对MySQL和InnoDB原有架构是否有巨大冲击？</strong></p>
<p>通过上文undo日志和回滚段的铺垫，这两个问题就非常好回答了：</p>
<p>(1)旧版本数据存储在回滚段里；</p>
<p>(2)对MySQL和InnoDB原有架构体系冲击不大；</p>
<p>InnoDB的内核，会对所有row数据增加三个内部属性：</p>
<p>(1)<strong>DB_TRX_ID</strong>，6字节，记录每一行最近一次修改它的事务ID；</p>
<p>(2)<strong>DB_ROLL_PTR</strong>，7字节，记录指向回滚段undo日志的指针；</p>
<p>(3)<strong>DB_ROW_ID</strong>，6字节，单调递增的行ID；</p>
<p><strong>InnoDB为何能够做到这么高的并发？</strong></p>
<p>回滚段里的数据，其实是历史数据的快照（snapshot），这些数据是不会被修改，select可以肆无忌惮的并发读取他们。</p>
<p><strong>快照读</strong>（Snapshot Read），这种<strong>一致性不加锁的读</strong>（Consistent Nonlocking Read），就是InnoDB并发如此之高的核心原因之一。</p>
<p>这里的<strong>一致性</strong>是指，事务读取到的数据，要么是事务开始前就已经存在的数据（当然，是其他已提交事务产生的），要么是事务自身插入或者修改的数据。</p>
<p><strong>什么样的select是快照读？</strong></p>
<p>除非显示加锁，普通的select语句都是快照读，例如：</p>
<p>select * from t where id&gt;2;</p>
<p>这里的显示加锁，非快照读是指：</p>
<p>select * from t where id&gt;2 <strong>lock in share mode</strong>;</p>
<p>select * from t where id&gt;2 <strong>for update</strong>;</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>(1)常见并发控制保证数据一致性的方法有<strong>锁</strong>，<strong>数据多版本</strong>；</p>
<p>(2)<strong>普通锁</strong>串行，<strong>读写锁</strong>读读并行，<strong>数据多版本</strong>读写并行；</p>
<p>(3)<strong>redo日志</strong>保证已提交事务的ACID特性，设计思路是，通过顺序写替代随机写，提高并发；</p>
<p>(4)<strong>undo日志</strong>用来回滚未提交的事务，它存储在回滚段里；</p>
<p>(5)InnoDB是基于<strong>MVCC</strong>的存储引擎，它利用了存储在回滚段里的undo日志，即数据的旧版本，提高并发；</p>
<p>(6)InnoDB之所以并发高，快照读不加锁；</p>
<p>(7)InnoDB所有普通select都是快照读；</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/01/24/MySQL索引背后的数据结构及算法原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/24/MySQL索引背后的数据结构及算法原理/" itemprop="url">MySQL索引背后的数据结构及算法原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-24T12:12:57+08:00">
                2019-01-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/MySql/" itemprop="url" rel="index">
                    <span itemprop="name">MySql</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/MySql/索引/" itemprop="url" rel="index">
                    <span itemprop="name">索引</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="MySQL索引背后的数据结构及算法原理"><a href="#MySQL索引背后的数据结构及算法原理" class="headerlink" title="MySQL索引背后的数据结构及算法原理"></a>MySQL索引背后的数据结构及算法原理</h1><blockquote>
<p>原文：<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p>
</blockquote>
<p>本文以 MySQL 数据库为研究对象，讨论与数据库索引相关的一些话题。特别需要说明的是， MySQL 支持诸多存储引擎，而各种存储引擎对索引的支持也各不相同，因此 MySQL 数据库支持多种索引类型，如 BTree 索引，哈希索引，全文索引等等。为了避免混乱，本文将只关注于 BTree 索引，因为这是平常使用 MySQL 时主要打交道的索引，至于哈希索引和全文索引本文暂不讨论。<br><img src="//blog.com/2019/01/24/MySQL索引背后的数据结构及算法原理/7d6b1a54-61dd-4ecb-9b84-b064ec95775a.png" alt="预览图"></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/01/24/MySQL索引背后的数据结构及算法原理/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/01/24/MySql利用function以及procedure来随机生成假数据/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/24/MySql利用function以及procedure来随机生成假数据/" itemprop="url">MySql利用function以及procedure来随机生成假数据</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-24T12:12:57+08:00">
                2019-01-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/MySql/" itemprop="url" rel="index">
                    <span itemprop="name">MySql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="MySql利用function以及procedure来随机生成假数据"><a href="#MySql利用function以及procedure来随机生成假数据" class="headerlink" title="MySql利用function以及procedure来随机生成假数据"></a>MySql利用function以及procedure来随机生成假数据</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">use test1</span><br><span class="line"></span><br><span class="line">drop table if exists device,attr,deviceattr;</span><br><span class="line">drop function if exists rand_name;</span><br><span class="line">drop function if exists rand_value;</span><br><span class="line">drop function if exists rand_num;</span><br><span class="line">drop function if exists rand_creator;</span><br><span class="line">drop procedure if exists insert_devattr;</span><br><span class="line">drop procedure if exists insert_dev;</span><br><span class="line"></span><br><span class="line">create table device    </span><br><span class="line">(</span><br><span class="line">id int primary key,</span><br><span class="line">name varchar(40),</span><br><span class="line">type varchar(40),    </span><br><span class="line">aquired int,</span><br><span class="line">groupname varchar(40),</span><br><span class="line">creator varchar(40)</span><br><span class="line">);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create table attr</span><br><span class="line">(</span><br><span class="line">id int primary key,</span><br><span class="line">name varchar(40)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create table deviceattr</span><br><span class="line">(</span><br><span class="line">id int,</span><br><span class="line">name varchar(40),</span><br><span class="line">value varchar(40)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">delimiter //</span><br><span class="line"></span><br><span class="line">create function rand_creator()</span><br><span class="line">returns varchar(20)</span><br><span class="line">begin</span><br><span class="line">declare return_str varchar(20) default &apos;aronhe&apos;;</span><br><span class="line">declare n int default 0;</span><br><span class="line">set n = floor(rand()*10);</span><br><span class="line">case n</span><br><span class="line">when 0 then set return_str = &apos;aronhe&apos;;</span><br><span class="line">when 1 then set return_str = &apos;eeelin&apos;;</span><br><span class="line">when 2 then set return_str = &apos;shadowyang&apos;;</span><br><span class="line">when 3 then set return_str = &apos;luzhao&apos;;</span><br><span class="line">when 4 then set return_str = &apos;tommyzhang&apos;;</span><br><span class="line">when 5 then set return_str = &apos;pillarzou&apos;;</span><br><span class="line">when 6 then set return_str = &apos;allenpan&apos;;</span><br><span class="line">when 7 then set return_str = &apos;beyondli&apos;;</span><br><span class="line">when 8 then set return_str = &apos;minshi&apos;;</span><br><span class="line">when 9 then set return_str = &apos;bingchen&apos;;</span><br><span class="line">else set return_str = &apos;joyhu&apos;;</span><br><span class="line">end case;</span><br><span class="line">return return_str;</span><br><span class="line">end//</span><br><span class="line"></span><br><span class="line">create function rand_num()</span><br><span class="line">returns int</span><br><span class="line">begin</span><br><span class="line">declare n int default 0;</span><br><span class="line">set n = floor(rand()*100);</span><br><span class="line">return n;</span><br><span class="line">end//</span><br><span class="line"></span><br><span class="line">create function rand_value()</span><br><span class="line">returns varchar(10)</span><br><span class="line">begin</span><br><span class="line">declare return_str varchar(10) default &apos;false&apos;;</span><br><span class="line">declare n int default 0;</span><br><span class="line">set n = floor(rand()*10);</span><br><span class="line">case</span><br><span class="line">when n&lt;5 then set return_str = &apos;false&apos;;</span><br><span class="line">when n&gt;5 then set return_str = &apos;true&apos;;</span><br><span class="line">else set return_str = &apos;true&apos;;</span><br><span class="line">end case;</span><br><span class="line">return return_str;</span><br><span class="line">end//</span><br><span class="line"></span><br><span class="line">create function rand_name()</span><br><span class="line">returns varchar(20)</span><br><span class="line">begin</span><br><span class="line">declare return_str varchar(20) default &apos;&apos;;</span><br><span class="line">set return_str = concat(&apos;attr&apos;,floor(rand()*200));</span><br><span class="line">return return_str;</span><br><span class="line">end//</span><br><span class="line"></span><br><span class="line">create procedure insert_devattr(in start int,in max int)</span><br><span class="line">begin</span><br><span class="line">declare i int default 0;</span><br><span class="line">repeat</span><br><span class="line">set i=i+1;</span><br><span class="line">insert into deviceattr values(rand_num(),rand_name(),rand_value());</span><br><span class="line">until i =max</span><br><span class="line">end repeat;</span><br><span class="line">end//</span><br><span class="line"></span><br><span class="line">create procedure insert_dev(in start int,in max int)</span><br><span class="line">begin</span><br><span class="line">declare i int default 10;</span><br><span class="line">repeat</span><br><span class="line">set i=i+1;</span><br><span class="line">insert into device values(i,concat(&apos;runner&apos;,floor(rand()*100)),&apos;pc&apos;,floor(rand()*2),&apos;PCQQ&apos;,rand_creator());</span><br><span class="line">until i =max</span><br><span class="line">end repeat;</span><br><span class="line">end//</span><br><span class="line"></span><br><span class="line">call insert_devattr(0,4000)//</span><br><span class="line">call insert_dev(11,100)//</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/131/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/131/">131</a><span class="page-number current">132</span><a class="page-number" href="/page/133/">133</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/133/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
