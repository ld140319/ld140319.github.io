<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>搬运工 + 践行者</title>
  
  <subtitle>记录学习的技能和遇到的问题</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.com/"/>
  <updated>2019-10-15T10:10:35.084Z</updated>
  <id>http://blog.com/</id>
  
  <author>
    <name>刘泽明</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数组元素差值V2</title>
    <link href="http://blog.com/2019/10/15/%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%B7%AE%E5%80%BCV2/"/>
    <id>http://blog.com/2019/10/15/数组元素差值V2/</id>
    <published>2019-10-15T04:12:57.000Z</published>
    <updated>2019-10-15T10:10:35.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组元素差值V2"><a href="#数组元素差值V2" class="headerlink" title="数组元素差值V2"></a>数组元素差值V2</h1><blockquote><p>原文地址：<a href="https://www.cnblogs.com/freedom-wangyb/p/4192611.html" target="_blank" rel="noopener">https://www.cnblogs.com/freedom-wangyb/p/4192611.html</a></p></blockquote><p><strong>对于无序数组a，求a[i]-a[j]的最大值，其中i&lt;j</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindMax</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">9</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        System.out.println(<span class="string">"a["</span> + a.length + <span class="string">"]="</span> + Arrays.toString(a));</span><br><span class="line">        System.out.println(<span class="string">"find max of a[i]-a[j],i&lt;j : "</span> + findMax(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMax</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化为最小可能的int值</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">// a[i]右边元素中的最小值</span></span><br><span class="line">        <span class="keyword">int</span> minRight = a[a.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> tempMax;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            tempMax = a[i] - minRight;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; minRight) &#123;</span><br><span class="line">                minRight = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tempMax &gt; max) &#123;</span><br><span class="line">                max = tempMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组元素差值V2&quot;&gt;&lt;a href=&quot;#数组元素差值V2&quot; class=&quot;headerlink&quot; title=&quot;数组元素差值V2&quot;&gt;&lt;/a&gt;数组元素差值V2&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://www.cnblogs
      
    
    </summary>
    
      <category term="数组" scheme="http://blog.com/categories/%E6%95%B0%E7%BB%84/"/>
    
      <category term="算法" scheme="http://blog.com/categories/%E6%95%B0%E7%BB%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://blog.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="http://blog.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>数组中两个元素的最小距离</title>
    <link href="http://blog.com/2019/10/15/%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB/"/>
    <id>http://blog.com/2019/10/15/数组中两个元素的最小距离/</id>
    <published>2019-10-15T04:12:57.000Z</published>
    <updated>2019-10-15T10:09:59.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组中两个元素的最小距离"><a href="#数组中两个元素的最小距离" class="headerlink" title="数组中两个元素的最小距离"></a>数组中两个元素的最小距离</h1><blockquote><p>原文地址：<a href="https://blog.csdn.net/luckyxiaoqiang/article/details/8985198" target="_blank" rel="noopener">https://blog.csdn.net/luckyxiaoqiang/article/details/8985198</a></p></blockquote><p>一个数组，含有重复元素，给出两个数num1和num2，求这两个数字在数组中出现的位置的最小距离</p><p><strong><code>O(n)</code>时间复杂度，<code>O(1)</code>空间复杂度</strong></p><p>给定一个数组，数组中含有重复元素，给出两个数n1和n2，求这两个数在数组中所出现位置的最小距离。例如，数组{4,5,6,4,7,4,6,4,7,8,5,6,4,3,10,8}，4和8的最小距离是2.</p><p>思路：遍历数组，会遇到两个情况：</p><p>一，当遇到n1时候，记录下n1对应的数组下标的位置n1_index，通过求n1_index与上次遍历到n2的下标值n2_index的差，可以求出最近一次遍历到n1和n2的距离。</p><p>二，当遇到n2时候，同样记录n2在数组位置下标n2_index，然后求n2_index与上次遍历到的n1的下标值n1_index的差，求出最近一次遍历到的n1和n2的距离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinDistance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? b : a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = a.length;</span><br><span class="line">        <span class="keyword">int</span> n1_index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n2_index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> min_dist = Integer.MIN_VALUE + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == n1) &#123;</span><br><span class="line">                n1_index = i;</span><br><span class="line">                <span class="keyword">if</span> (n2_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    min_dist = min(Math.abs(min_dist), Math.abs(n1_index - n2_index));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == n2) &#123;</span><br><span class="line">                n2_index = i;</span><br><span class="line">                <span class="keyword">if</span> (n1_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    min_dist = min(Math.abs(min_dist), Math.abs(n2_index - n1_index));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min_dist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        System.out.println(minDistance(a, <span class="number">5</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组中两个元素的最小距离&quot;&gt;&lt;a href=&quot;#数组中两个元素的最小距离&quot; class=&quot;headerlink&quot; title=&quot;数组中两个元素的最小距离&quot;&gt;&lt;/a&gt;数组中两个元素的最小距离&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;htt
      
    
    </summary>
    
      <category term="数组" scheme="http://blog.com/categories/%E6%95%B0%E7%BB%84/"/>
    
      <category term="算法" scheme="http://blog.com/categories/%E6%95%B0%E7%BB%84/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://blog.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数组" scheme="http://blog.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Nginx变量</title>
    <link href="http://blog.com/2019/09/19/Nginx%E5%8F%98%E9%87%8F/"/>
    <id>http://blog.com/2019/09/19/Nginx变量/</id>
    <published>2019-09-19T04:12:57.000Z</published>
    <updated>2019-09-22T04:15:03.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx变量"><a href="#Nginx变量" class="headerlink" title="Nginx变量"></a>Nginx变量</h1><blockquote><p>原文地址：<a href="http://blog.sina.com.cn/openresty" target="_blank" rel="noopener">http://blog.sina.com.cn/openresty</a></p></blockquote><h2 id="Nginx变量初识"><a href="#Nginx变量初识" class="headerlink" title="Nginx变量初识"></a>Nginx变量初识</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Nginx</code> 的配置文件使用的就是一门微型的编程语言，许多真实世界里的 <code>Nginx</code> 配置文件其实就是一个一个的小程序。当然，是不是“图灵完全的”暂且不论，至少据我观察，它在设计上受<code>Perl</code> 和 <code>Bourne Shell</code> 这两种语言的影响很大。在这一点上，相比<code>Apache</code>和 <code>Lighttpd</code>等其他 <code>Web</code>服务器的配置记法，不能不说算是 Nginx 的一大特色了。既然是编程语言，一般也就少不了“变量”这种东西（当然，<code>Haskell</code>这样奇怪的函数式语言除外了）。</p><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;熟悉 <code>Perl</code>、<code>Bourne Shell</code>、<code>C/C++</code> 等命令式编程语言的朋友肯定知道，变量说白了就是存放“值”的容器。而所谓“值”，在许多编程语言里，既可以是 <code>3.14</code> 这样的数值，也可以是 <code>hello world</code> 这样的字符串，甚至可以是像数组、哈希表这样的复杂数据结构。然而，<strong>在 Nginx 配置中，变量只能存放一种类型的值，因为也只存在一种类型的值，那就是字符串</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如我们的 <code>nginx.conf</code> 文件中有下面这一行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set $a &quot;hello world&quot;;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们使用了标准 <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank" rel="noopener">ngx_rewrite</a> 模块的 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 配置指令对变量 <code>$a</code> 进行了赋值操作。特别地，我们把字符串 <code>hello world</code> 赋给了它。</p><h2 id="变量插值"><a href="#变量插值" class="headerlink" title="变量插值"></a>变量插值</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，<code>Nginx</code>变量名前面有一个 <code>$</code> 符号，这是记法上的要求。<strong>所有的 Nginx 变量在 Nginx 配置文件中引用时都须带上 <code>$</code> 前缀</strong>。这种表示方法和 <code>Perl</code>、<code>PHP</code> 这些语言是相似的。</p><p>​    虽然 <code>$</code> 这样的变量前缀修饰会让正统的 <code>Java</code> 和 <code>C#</code> 程序员不舒服，但这种表示方法的好处也是显而易见的，那就是<strong>可以直接把变量嵌入到字符串常量中以构造出新的字符串</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set $a hello;</span><br><span class="line">set $b &quot;$a, $a&quot;;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们通过已有的 <code>Nginx</code>变量 <code>$a</code> 的值，来构造变量 <code>$b</code> 的值，于是这两条指令顺序执行完之后，<code>$a</code> 的值是 <code>hello</code>，而 <code>$b</code> 的值则是 <code>hello, hello</code>. 这种技术在 Perl 世界里被称为<strong>“变量插值”（variable interpolation）</strong>，它让专门的字符串拼接运算符变得不再那么必要。我们在这里也不妨采用此术语。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们来看一个比较完整的配置示例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">location</span> /test &#123;</span><br><span class="line">        <span class="attribute">set</span> <span class="variable">$foo</span> hello;</span><br><span class="line">        <span class="attribute">echo</span> <span class="string">"foo: <span class="variable">$foo</span>"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个例子省略了 <code>nginx.conf</code> 配置文件中最外围的 <code>http</code> 配置块以及 <code>events</code> 配置块。使用 <code>curl</code> 这个 <code>HTTP</code> 客户端在命令行上请求这个 <code>/test</code> 接口，我们可以得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">foo: hello</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们使用第三方 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 模块的 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 配置指令将 <code>$foo</code> 变量的值作为当前请求的响应体输出。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，<a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 配置指令的参数也支持“变量插值”。不过，需要说明的是，<strong>并非所有的配置指令都支持“变量插值”</strong>。事实上，<strong>指令参数是否允许“变量插值”，取决于该指令的实现模块</strong>。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出$"></a>输出$</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们想通过 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令<strong>直接输出含有“美元符”（<code>$</code>）的字符串，那么有没有办法把特殊的 <code>$</code> 字符给转义掉呢</strong>？答案是否定的（至少到目前最新的 <code>Nginx</code> 稳定版 <code>1.0.10</code>）。不过幸运的是，我们可以绕过这个限制，比如通过不支持“变量插值”的模块配置指令专门构造出取值为 <code>$</code> 的 Nginx 变量，然后再在 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 中使用这个变量。看下面这个例子：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">geo</span> <span class="variable">$dollar</span> &#123;</span><br><span class="line">    <span class="attribute">default</span> <span class="string">"$"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">location</span> /test &#123;</span><br><span class="line">        <span class="attribute">echo</span> <span class="string">"This is a dollar sign: <span class="variable">$dollar</span>"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">This is a dollar sign: $</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里用到了标准模块 <a href="http://wiki.nginx.org/HttpGeoModule" target="_blank" rel="noopener">ngx_geo</a> 提供的配置指令 <a href="http://wiki.nginx.org/HttpGeoModule#geo" target="_blank" rel="noopener">geo</a> 来为变量 <code>$dollar</code> 赋予字符串 <code>&quot;$&quot;</code>，这样我们在下面需要使用美元符的地方，就直接引用我们的 <code>$dollar</code> 变量就可以了。其实 <a href="http://wiki.nginx.org/HttpGeoModule" target="_blank" rel="noopener">ngx_geo</a> 模块最常规的用法是根据客户端的 IP 地址对指定的 <code>Nginx</code> 变量进行赋值，这里只是借用它以便“无条件地”对我们的 <code>$dollar</code> 变量赋予“美元符”这个值。</p><h2 id="符号的使用"><a href="#符号的使用" class="headerlink" title="{}符号的使用"></a>{}符号的使用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在“变量插值”的上下文中，还有一种特殊情况，即<strong>当引用的变量名之后紧跟着变量名的构成字符时（比如后跟字母、数字以及下划线），我们就需要使用特别的记法来消除歧义</strong>，例如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">location</span> /test &#123;</span><br><span class="line">        <span class="attribute">set</span> <span class="variable">$first</span> <span class="string">"hello "</span>;</span><br><span class="line">        <span class="attribute">echo</span> <span class="string">"<span class="variable">$&#123;first&#125;</span>world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里，我们在 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 配置指令的参数值中引用变量 <code>$first</code> 的时候，后面紧跟着 <code>world</code> 这个单词，所以如果直接写作 <code>&quot;$firstworld&quot;</code> 则 <code>Nginx</code> “变量插值”计算引擎会将之识别为引用了变量 <code>$firstworld</code>. <strong>为了解决这个难题，<code>Nginx</code> 的字符串记法支持使用花括号在 <code>$</code> 之后把变量名围起来</strong>，比如这里的 <code>${first}</code>. 上面这个例子的输出是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h2 id="变量与Nginx服务启动"><a href="#变量与Nginx服务启动" class="headerlink" title="变量与Nginx服务启动"></a>变量与Nginx服务启动</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令（以及前面提到的 <a href="http://wiki.nginx.org/HttpGeoModule#geo" target="_blank" rel="noopener">geo</a> 指令）不仅有赋值的功能，它还有创建 <code>Nginx</code> 变量的副作用，即<strong>当作为赋值对象的变量尚不存在时，它会自动创建该变量</strong>。比如在上面这个例子中，如果 <code>$a</code> 这个变量尚未创建，则 <code>set</code> 指令会自动创建 <code>$a</code> 这个用户变量。如果我们不创建就直接使用它的值，则会报错。例如</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> /bad &#123;</span><br><span class="line">        <span class="attribute">echo</span> <span class="variable">$foo</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时 <code>Nginx</code> 服务器会拒绝加载配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[emerg] unknown &quot;foo&quot; variable</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是的，我们甚至都无法启动服务！</p><h2 id="变量创建赋值声明、作用范围"><a href="#变量创建赋值声明、作用范围" class="headerlink" title="变量创建赋值声明、作用范围"></a>变量创建赋值声明、作用范围</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有趣的是，<strong><code>Nginx</code> 变量的创建和赋值操作发生在全然不同的时间阶段</strong>。<strong><code>Nginx</code>变量的创建只能发生在 <code>Nginx</code> 配置加载的时候，或者说 <code>Nginx</code> 启动的时候；而赋值操作则只会发生在请求实际处理的时候</strong>。这意味着不创建而直接使用变量会导致启动失败，同时也意味着我们无法在请求处理时动态地创建新的 <code>Nginx</code>变量。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Nginx</code>变量一旦创建，其变量名的可见范围就是整个<code>Nginx</code> 配置，甚至可以跨越不同虚拟主机的 <code>server</code>配置块</strong>。我们来看一个例子：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">   <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="attribute">location</span> /foo &#123;</span><br><span class="line">      <span class="attribute">echo</span> <span class="string">"foo = [<span class="variable">$foo</span>]"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="attribute">location</span> /bar &#123;</span><br><span class="line">      <span class="attribute">set</span> <span class="variable">$foo</span> <span class="number">32</span>;</span><br><span class="line">      <span class="attribute">echo</span> <span class="string">"foo = [<span class="variable">$foo</span>]"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们在 <code>location /bar</code> 中用 <code>set</code> 指令创建了变量 <code>$foo</code>，于是<strong>在整个配置文件中这个变量都是可见的</strong>，因此我们可以在 <code>location /foo</code> 中直接引用这个变量而不用担心<code>Nginx</code>会报错。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是在命令行上用 <code>curl</code> 工具访问这两个接口的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/foo&apos;</span><br><span class="line">foo = []</span><br><span class="line"> </span><br><span class="line">$ curl &apos;http://localhost:8080/bar&apos;</span><br><span class="line">foo = [32]</span><br><span class="line"> </span><br><span class="line">$ curl &apos;http://localhost:8080/foo&apos;</span><br><span class="line">foo = []</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从这个例子我们可以看到，<code>set</code> 指令因为是在 <code>location /bar</code> 中使用的，所以赋值操作只会在访问 <code>/bar</code> 的请求中执行。而请求 <code>/foo</code> 接口时，我们总是得到空的 <code>$foo</code> 值，因为<strong>用户变量未赋值就输出的话，得到的便是空字符串</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从这个例子我们可以窥见的另一个重要特性是，<strong><code>Nginx</code> 变量名的可见范围虽然是整个配置，但每个请求都有所有变量的独立副本，或者说都有各变量用来存放值的容器的独立副本，彼此互不干扰</strong>。比如前面我们请求了<code>/bar</code> 接口后，<code>$foo</code> 变量被赋予了值 <code>32</code>，但它丝毫不会影响后续对 <code>/foo</code> 接口的请求所对应的 <code>$foo</code> 值（它仍然是空的！），因为各个请求都有自己独立的 <code>$foo</code> 变量的副本。</p><p>​    对于<code>Nginx</code> 新手来说，最常见的错误之一，就是将<strong><code>Nginx</code>变量理解成某种在请求之间全局共享的东西，或者说“全局变量”</strong>。而事实上，<strong><code>Nginx</code>变量的生命期是不可能跨越请求边界的</strong>。</p><h2 id="Nginx变量容器的生命期是否与location有关"><a href="#Nginx变量容器的生命期是否与location有关" class="headerlink" title="Nginx变量容器的生命期是否与location有关"></a>Nginx变量容器的生命期是否与location有关</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于 <code>Nginx</code> 变量的另一个常见误区是认为变量容器的生命期，是与 <code>location</code> 配置块绑定的。其实不然。我们来看一个涉及“内部跳转”的例子：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">location</span> /foo &#123;</span><br><span class="line">        <span class="attribute">set</span> <span class="variable">$a</span> hello;</span><br><span class="line">        <span class="attribute">echo_exec</span> /bar;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">location</span> /bar &#123;</span><br><span class="line">        <span class="attribute">echo</span> <span class="string">"a = [<span class="variable">$a</span>]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们在 <code>location /foo</code> 中，使用第三方模块 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 提供的 <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank" rel="noopener">echo_exec</a> 配置指令，发起到 <code>location /bar</code> 的“内部跳转”。所谓<strong>“内部跳转”，就是在处理请求的过程中，于服务器内部，从一个 <code>location</code> 跳转到另一个 <code>location</code> 的过程</strong>。这不同于利用 <code>HTTP</code> 状态码 <code>301</code> 和 <code>302</code> 所进行的“外部跳转”，因为后者是由 <code>HTTP</code> 客户端配合进行跳转的，而且在客户端，用户可以通过浏览器地址栏这样的界面，看到请求的 <code>URL</code> 地址发生了变化。内部跳转和 <code>Bourne Shell</code>（或 <code>Bash</code>）中的 <code>exec</code> 命令很像，都是“有去无回”。另一个相近的例子是 <code>C</code> 语言中的 <code>goto</code> 语句。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然是<strong>内部跳转，当前正在处理的请求就还是原来那个，只是当前的 <code>location</code> 发生了变化，所以还是原来的那一套 <code>Nginx</code>变量的容器副本</strong>。对应到上例，如果我们请求的是 <code>/foo</code> 这个接口，那么整个工作流程是这样的：先在 <code>location /foo</code> 中通过 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令将 <code>$a</code> 变量的值赋为字符串 <code>hello</code>，然后通过 <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank" rel="noopener">echo_exec</a> 指令发起内部跳转，又进入到 <code>location /bar</code> 中，再输出 <code>$a</code> 变量的值。因为 <code>$a</code> 还是原来的 <code>$a</code>，所以我们可以期望得到 <code>hello</code> 这行输出。测试证实了这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8080/foo</span><br><span class="line">a = [hello]</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但如果我们从客户端直接访问 <code>/bar</code> 接口，就会得到空的 <code>$a</code> 变量的值，因为它依赖于 <code>location /foo</code> 来对 <code>$a</code>进行初始化。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面这个例子我们看到，<strong>一个请求在其处理过程中，即使经历多个不同的 <code>location</code> 配置块，它使用的还是同一套 <code>Nginx</code> 变量的副本</strong>。这里，我们也首次涉及到了“内部跳转”这个概念。值得一提的是，标准 <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank" rel="noopener">ngx_rewrite</a> 模块的 <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank" rel="noopener">rewrite</a> 配置指令其实也可以发起“内部跳转”，例如上面那个例子用 <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank" rel="noopener">rewrite</a> 配置指令可以改写成下面这样的形式：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">location</span> /foo &#123;</span><br><span class="line">        <span class="attribute">set</span> <span class="variable">$a</span> hello;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^</span> /bar;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">location</span> /bar &#123;</span><br><span class="line">        <span class="attribute">echo</span> <span class="string">"a = [<span class="variable">$a</span>]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其效果和使用 <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank" rel="noopener">echo_exec</a> 是完全相同的。后面我们还会专门介绍这个 <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank" rel="noopener">rewrite</a> 指令的更多用法，比如发起 <code>301</code>和 <code>302</code> 这样的“外部跳转”。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面这个例子我们看到，<strong><code>Nginx</code>变量值容器的生命期是与当前正在处理的请求绑定的，而与 <code>location</code>无关</strong>。</p><h2 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面我们接触到的都是通过 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令隐式创建的 <code>Nginx</code> 变量。这些变量我们一般称为“用户自定义变量”，或者更简单一些，“用户变量”。既然有“用户自定义变量”，自然也就有由<code>Nginx</code> 核心和各个 <code>Nginx</code>模块提供的“预定义变量”，或者说“内建变量”（<code>builtin variables</code>）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Nginx</code>内建变量最常见的用途就是获取关于请求或响应的各种信息。例如由 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html" target="_blank" rel="noopener">ngx_http_core</a> 模块提供的内建变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank" rel="noopener">$uri</a>，可以用来获取当前请求的 <code>URI</code>（经过解码，并且不含请求参数），而 <a href="http://wiki.nginx.org/HttpCoreModule#.24request_uri" target="_blank" rel="noopener">$request_uri</a> 则用来获取请求最原始的 <code>URI</code> （未经解码，并且包含请求参数）。请看下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    echo &quot;uri = $uri&quot;;</span><br><span class="line">    echo &quot;request_uri = $request_uri&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里为了简单起见，连 <code>server</code> 配置块也省略了，和前面所有示例一样，我们监听的依然是 <code>8080</code> 端口。在这个例子里，我们把 <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank" rel="noopener">$uri</a> 和 <a href="http://wiki.nginx.org/HttpCoreModule#.24request_uri" target="_blank" rel="noopener">$request_uri</a> 的值输出到响应体中去。下面我们用不同的请求来测试一下这个 <code>/test</code>接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">uri = /test</span><br><span class="line">request_uri = /test</span><br><span class="line"> </span><br><span class="line">$ curl &apos;http://localhost:8080/test?a=3&amp;b=4&apos;</span><br><span class="line">uri = /test</span><br><span class="line">request_uri = /test?a=3&amp;b=4</span><br><span class="line"> </span><br><span class="line">$ curl &apos;http://localhost:8080/test/hello%20world?a=3&amp;b=4&apos;</span><br><span class="line">uri = /test/hello world</span><br><span class="line">request_uri = /test/hello%20world?a=3&amp;b=4</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个特别常用的内建变量其实并不是单独一个变量，而是有无限多变种的一群变量，即名字以 <code>arg_</code> 开头的所有变量，我们估且称之为 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 变量群。一个例子是 <code>$arg_name</code>，这个变量的值是当前请求名为 <code>name</code> 的 <code>URI</code>参数的值，而且还是未解码的原始形式的值。我们来看一个比较完整的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    echo &quot;name: $arg_name&quot;;</span><br><span class="line">    echo &quot;class: $arg_class&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后在命令行上使用各种参数组合去请求这个 <code>/test</code> 接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">name: </span><br><span class="line">class: </span><br><span class="line"> </span><br><span class="line">$ curl &apos;http://localhost:8080/test?name=Tom&amp;class=3&apos;</span><br><span class="line">name: Tom</span><br><span class="line">class: 3</span><br><span class="line"> </span><br><span class="line">$ curl &apos;http://localhost:8080/test?name=hello%20world&amp;class=9&apos;</span><br><span class="line">name: hello%20world</span><br><span class="line">class: 9</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实 <code>$arg_name</code> 不仅可以匹配 <code>name</code> 参数，也可以匹配 <code>NAME</code> 参数，抑或是 <code>Name</code>，等等：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test?NAME=Marry&apos;</span><br><span class="line">name: Marry</span><br><span class="line">class: </span><br><span class="line"> </span><br><span class="line">$ curl &apos;http://localhost:8080/test?Name=Jimmy&apos;</span><br><span class="line">name: Jimmy</span><br><span class="line">class:</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Nginx</code> 会在匹配参数名之前，自动把原始请求中的参数名调整为全部小写的形式</strong>。</p><h3 id="url-decode"><a href="#url-decode" class="headerlink" title="url decode"></a>url decode</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想对 <code>URI</code> 参数值中的 <code>%XX</code> 这样的编码序列进行解码，可以使用第三方 <a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank" rel="noopener">ngx_set_misc</a> 模块提供的 <a href="http://wiki.nginx.org/HttpSetMiscModule#set_unescape_uri" target="_blank" rel="noopener">set_unescape_uri</a> 配置指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    set_unescape_uri $name $arg_name;</span><br><span class="line">    set_unescape_uri $class $arg_class;</span><br><span class="line"> </span><br><span class="line">    echo &quot;name: $name&quot;;</span><br><span class="line">    echo &quot;class: $class&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们再看一下效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test?name=hello%20world&amp;class=9&apos;</span><br><span class="line">name: hello world</span><br><span class="line">class: 9</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;空格果然被解码出来了！</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从这个例子我们同时可以看到，这个 <a href="http://wiki.nginx.org/HttpSetMiscModule#set_unescape_uri" target="_blank" rel="noopener">set_unescape_uri</a> 指令也像 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令那样，拥有自动创建 <code>Nginx</code> 变量的功能。后面我们还会专门介绍到 <a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank" rel="noopener">ngx_set_misc</a> 模块。</p><h3 id="变量群"><a href="#变量群" class="headerlink" title="变量群"></a>变量群</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;像 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 这种类型的变量拥有无穷无尽种可能的名字，所以它们并不对应任何存放值的容器。而且这种变量在 <code>Nginx</code> 核心中是经过特别处理的，第三方 <code>Nginx</code> 模块是不能提供这样充满魔法的内建变量的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类似 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 的内建变量还有不少，比如用来取 <code>cookie</code> 值的 <a href="http://wiki.nginx.org/HttpCoreModule#.24cookie_COOKIE" target="_blank" rel="noopener">$cookie_XXX</a> 变量群，用来取请求头的 <a href="http://wiki.nginx.org/HttpCoreModule#.24http_HEADER" target="_blank" rel="noopener">$http_XXX</a> 变量群，以及用来取响应头的 <a href="http://wiki.nginx.org/HttpCoreModule#.24sent_http_HEADER" target="_blank" rel="noopener">$sent_http_XXX</a> 变量群。这里就不一一介绍了，感兴趣的读者可以参考 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html" target="_blank" rel="noopener">ngx_http_core</a> 模块的官方文档。</p><h3 id="只读内建变量"><a href="#只读内建变量" class="headerlink" title="只读内建变量"></a>只读内建变量</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要指出的是，<strong>许多内建变量都是只读的</strong>，比如我们刚才介绍的 <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank" rel="noopener">$uri</a> 和 <a href="http://wiki.nginx.org/HttpCoreModule#.24request_uri" target="_blank" rel="noopener">$request_uri</a>. 对只读变量进行赋值是应当绝对避免的，因为会有意想不到的后果，比如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /bad &#123;</span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$uri</span> /blah;</span><br><span class="line">    <span class="attribute">echo</span> <span class="variable">$uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个有问题的配置会让<code>Nginx</code>在启动的时候报出一条令人匪夷所思的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[emerg] the duplicate &quot;uri&quot; variable in ...</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你尝试改写另外一些只读的内建变量，比如 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 变量，在某些 Nginx 的版本中甚至可能导致进程崩溃。</p><h3 id="改写内建变量"><a href="#改写内建变量" class="headerlink" title="改写内建变量"></a>改写内建变量</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也有一些内建变量是支持改写的，其中一个例子是 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a>. 这个变量在读取时返回当前请求的 <code>URL</code> 参数串（即请求 <code>URL</code>中问号后面的部分，如果有的话 ），而在赋值时可以直接修改参数串。我们来看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    set $orig_args $args;</span><br><span class="line">    set $args &quot;a=3&amp;b=4&quot;;</span><br><span class="line"> </span><br><span class="line">    echo &quot;original args: $orig_args&quot;;</span><br><span class="line">    echo &quot;args: $args&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们把原始的 <code>URL</code> 参数串先保存在 <code>$orig_args</code> 变量中，然后通过改写 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 变量来修改当前的 URL 参数串，最后我们用 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令分别输出 <code>$orig_args</code> 和 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 变量的值。接下来我们这样来测试这个 <code>/test</code> 接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">original args: </span><br><span class="line">args: a=3&amp;b=4</span><br><span class="line"> </span><br><span class="line">$ curl &apos;http://localhost:8080/test?a=0&amp;b=1&amp;c=2&apos;</span><br><span class="line">original args: a=0&amp;b=1&amp;c=2</span><br><span class="line">args: a=3&amp;b=4</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在第一次测试中，我们没有设置任何 <code>URL</code> 参数串，所以输出 <code>$orig_args</code> 变量的值时便得到空。而在第一次和第二次测试中，无论我们是否提供<code>URL</code> 参数串，参数串都会在 <code>location /test</code> 中被强行改写成 <code>a=3&amp;b=4</code>.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要特别指出的是，这里的 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 变量和 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 一样，也不再使用属于自己的存放值的容器。当我们读取 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 时，<code>Nginx</code> 会执行一小段代码，从 <code>Nginx</code>核心中专门存放当前 <code>URL</code> 参数串的位置去读取数据；而当我们改写 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 时，<code>Nginx</code>会执行另一小段代码，对相同位置进行改写。<code>Nginx</code> 的其他部分在需要当前 <code>URL</code>参数串的时候，都会从那个位置去读数据，所以我们对 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 的修改会影响到所有部分的功能。我们来看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    set $orig_a $arg_a;</span><br><span class="line">    set $args &quot;a=5&quot;;</span><br><span class="line">    echo &quot;original a: $orig_a&quot;;</span><br><span class="line">    echo &quot;a: $arg_a&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们先把内建变量 <code>$arg_a</code> 的值，即原始请求的 <code>URL</code> 参数 <code>a</code> 的值，保存在用户变量 <code>$orig_a</code> 中，然后通过对内建变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 进行赋值，把当前请求的参数串改写为 <code>a=5</code> ，最后再用 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令分别输出 <code>$orig_a</code> 和<code>$arg_a</code> 变量的值。因为对内建变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 的修改会直接导致当前请求的 <code>URL</code> 参数串发生变化，因此内建变量<a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 自然也会随之变化。测试的结果证实了这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test?a=3&apos;</span><br><span class="line">original a: 3</span><br><span class="line">a: 5</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，因为原始请求的 <code>URL</code> 参数串是 <code>a=3</code>, 所以 <code>$arg_a</code> 最初的值为 <code>3</code>, 但随后通过改写 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 变量，将<code>URL</code> 参数串又强行修改为 <code>a=5</code>, 所以最终 <code>$arg_a</code> 的值又自动变为了 <code>5</code>.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们再来看一个通过修改 <code>$args</code> 变量影响标准的 <code>HTTP</code> 代理模块 <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank" rel="noopener">ngx_proxy</a> 的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line"> </span><br><span class="line">    location /test &#123;</span><br><span class="line">        set $args &quot;foo=1&amp;bar=2&quot;;</span><br><span class="line">        proxy_pass http://127.0.0.1:8081/args;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">server &#123;</span><br><span class="line">    listen 8081;</span><br><span class="line"> </span><br><span class="line">    location /args &#123;</span><br><span class="line">        echo &quot;args: $args&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们在 <code>http</code> 配置块中定义了两个虚拟主机。第一个虚拟主机监听 8080 端口，其 <code>/test</code> 接口自己通过改写 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 变量，将当前请求的<code>URL</code> 参数串无条件地修改为 <code>foo=1&amp;bar=2</code>. 然后 <code>/test</code> 接口再通过 <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank" rel="noopener">ngx_proxy</a>模块的 <a href="http://wiki.nginx.org/HttpProxyModule#proxy_pass" target="_blank" rel="noopener">proxy_pass</a> 指令配置了一个反向代理，指向本机的 8081 端口上的 <code>HTTP</code> 服务 <code>/args</code>. 默认情况下，<a href="http://wiki.nginx.org/HttpProxyModule" target="_blank" rel="noopener">ngx_proxy</a> 模块在转发<code>HTTP</code>请求到远方 <code>HTTP</code>服务的时候，会自动把当前请求的 <code>URL</code> 参数串也转发到远方。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而本机的 8081 端口上的 <code>HTTP</code> 服务正是由我们定义的第二个虚拟主机来提供的。我们在第二个虚拟主机的 <code>location /args</code> 中利用 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令输出当前请求的 <code>URL</code> 参数串，以检查 <code>/test</code> 接口通过 <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank" rel="noopener">ngx_proxy</a> 模块实际转发过来的 <code>URL</code> 请求参数串。</p><p>​    我们来实际访问一下第一个虚拟主机的 <code>/test</code> 接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test?blah=7&apos;</span><br><span class="line">args: foo=1&amp;bar=2</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，虽然请求自己提供了 URL 参数串 <code>blah=7</code>，但在 <code>location /test</code> 中，参数串被强行改写成了 <code>foo=1&amp;bar=2</code>. 接着经由 <a href="http://wiki.nginx.org/HttpProxyModule#proxy_pass" target="_blank" rel="noopener">proxy_pass</a> 指令将我们被改写掉的参数串转发给了第二个虚拟主机上配置的 <code>/args</code> 接口，然后再把 <code>/args</code> 接口的 URL 参数串输出。事实证明，我们<strong>对 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 变量的赋值操作，也成功影响到了 <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank" rel="noopener">ngx_proxy</a> 模块的行为</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在读取变量时执行的这段特殊代码，在 Nginx 中被称为“取处理程序”（get handler）；而改写变量时执行的这段特殊代码，则被称为“存处理程序”（set handler）</strong>。<strong>不同的 <code>Nginx</code> 模块一般会为它们的变量准备不同的“存取处理程序”，从而让这些变量的行为充满魔法</strong>。</p><h2 id="Nginx变量读取逻辑"><a href="#Nginx变量读取逻辑" class="headerlink" title="Nginx变量读取逻辑"></a>Nginx变量读取逻辑</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实这种技巧在计算世界并不鲜见。比如在面向对象编程中，类的设计者一般不会把类的成员变量直接暴露给类的用户，而是另行提供两个方法（<code>method</code>），分别用于该成员变量的读操作和写操作，这两个方法常常被称为“存取器”（<code>accessor</code>）。下面是 C++ 语言中的一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">    const string get_name() &#123;</span><br><span class="line">        return m_name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void set_name(const string name) &#123;</span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">private:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个名叫 <code>Person</code> 的 C++ 类中，我们提供了 <code>get_name</code> 和 <code>set_name</code> 这两个公共方法，以作为私有成员变量 <code>m_name</code> 的“存取器”。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样设计的好处是显而易见的。<strong>类的设计者可以在“存取器”中执行任意代码，以实现所需的业务逻辑以及“副作用”</strong>，比如自动更新与当前成员变量存在依赖关系的其他成员变量，抑或是直接修改某个与当前对象相关联的数据库表中的对应字段。而对于后一种情况，也许“存取器”所对应的成员变量压根就不存在，或者即使存在，也顶多扮演着数据缓存的角色，以缓解被代理数据库的访问压力。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>与面向对象编程中的“存取器”概念相对应，<code>Nginx</code> 变量也是支持绑定“存取处理程序”的</strong>。<strong><code>Nginx</code>模块在创建变量时，可以选择是否为变量分配存放值的容器，以及是否自己提供与读写操作相对应的“存取处理程序”</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>不是所有的 <code>Nginx</code>变量都拥有存放值的容器</strong>。<strong>拥有值容器的变量在<code>Nginx</code>核心中被称为“被索引的”（<code>indexed</code>）；反之，则被称为“未索引的”（<code>non-indexed</code>）</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们前面在 <a href="http://blog.sina.com.cn/s/blog_6d579ff40100wk2j.html" target="_blank" rel="noopener">（二）</a> 中已经知道，像 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 这样具有无数变种的变量群，是“未索引的”。当读取这样的变量时，其实是它的<strong>“取处理程序”在起作用，即实时扫描当前请求的 <code>URL</code> 参数串，提取出变量名所指定的<code>URL</code>参数的值</strong>。很多新手都会对 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 的实现方式产生误解，以为<code>Nginx</code> 会事先解析好当前请求的所有 <code>URL</code>参数，并且把相关的 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 变量的值都事先设置好。然而事实并非如此，<code>Nginx</code>根本不会事先就解析好<code>URL</code>参数串，而是在用户读取某个 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 变量时，调用其“取处理程序”，即时去扫描<code>URL</code>参数串。类似地，内建变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24cookie_COOKIE" target="_blank" rel="noopener">$cookie_XXX</a> 也是通过它的“取处理程序”，即时去扫描 <code>Cookie</code> 请求头中的相关定义的。</p><h2 id="值容器缓存"><a href="#值容器缓存" class="headerlink" title="值容器缓存"></a>值容器缓存</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在设置了“取处理程序”的情况下，<strong><code>Nginx</code>变量也可以选择将其值容器用作缓存，这样在多次读取变量的时候，就只需要调用“取处理程序”计算一次</strong>。我们下面就来看一个这样的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">map $args $foo &#123;</span><br><span class="line">    default     0;</span><br><span class="line">    debug       1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line"> </span><br><span class="line">    location /test &#123;</span><br><span class="line">        set $orig_foo $foo;</span><br><span class="line">        set $args debug;</span><br><span class="line"> </span><br><span class="line">        echo &quot;orginal foo: $orig_foo&quot;;</span><br><span class="line">        echo &quot;foo: $foo&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里首次用到了标准 <a href="http://wiki.nginx.org/HttpMapModule" target="_blank" rel="noopener">ngx_map</a> 模块的 <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 配置指令，我们有必要在此介绍一下。<code>map</code> 在英文中除了“地图”之外，也有“映射”的意思。比方说，中学数学里讲的“函数”就是一种“映射”。而 <code>Nginx</code> 的这个 <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 指令就可以用于定义两个 <code>Nginx</code>变量之间的映射关系，或者说是函数关系。回到上面这个例子，我们用 <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 指令定义了用户变量 <code>$foo</code> 与 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 内建变量之间的映射关系。特别地，用数学上的函数记法 <code>y = f(x)</code> 来说，我们的 <code>$args</code> 就是“自变量” <code>x</code>，而 <code>$foo</code> 则是“因变量” <code>y</code>，即 <code>$foo</code> 的值是由 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 的值来决定的，或者按照书写顺序可以说，我们将 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 变量的值映射到了 <code>$foo</code> 变量上。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们再来看 <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 指令定义的映射规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map $args $foo &#123;</span><br><span class="line">    default     0;</span><br><span class="line">    debug       1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;花括号中第一行的 <code>default</code> 是一个特殊的匹配条件，即当其他条件都不匹配的时候，这个条件才匹配。当这个默认条件匹配时，就把“因变量” <code>$foo</code> 映射到值 <code>0</code>. 而花括号中第二行的意思是说，如果“自变量” <code>$args</code>精确匹配了 <code>debug</code> 这个字符串，则把“因变量” <code>$foo</code> 映射到值 <code>1</code>. 将这两行合起来，我们就得到如下完整的映射规则：<strong>当 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 的值等于 <code>debug</code> 的时候，<code>$foo</code> 变量的值就是 <code>1</code>，否则 <code>$foo</code> 的值就为 <code>0</code></strong>.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;明白了 <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 指令的含义，再来看 <code>location /test</code>. 在那里，我们先把当前 <code>$foo</code> 变量的值保存在另一个用户变量 <code>$orig_foo</code> 中，然后再强行把 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 的值改写为 <code>debug</code>，最后我们再用 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令分别输出 <code>$orig_foo</code> 和 <code>$foo</code> 的值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从逻辑上看，似乎当我们强行改写 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 的值为 <code>debug</code> 之后，根据先前的 <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 映射规则，<code>$foo</code> 变量此时的值应当自动调整为字符串 <code>1</code>, 而不论 <code>$foo</code> 原先的值是怎样的。然而测试结果并非如此：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">original foo: 0</span><br><span class="line">foo: 0</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行输出指示 <code>$orig_foo</code> 的值为 <code>0</code>，这正是我们期望的：上面这个请求并没有提供<code>URL</code> 参数串，于是 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a>最初的取值就是空，再根据我们先前定义的映射规则，<code>$foo</code> 变量在第一次被读取时的值就应当是 <code>0</code>（即匹配默认的那个 <code>default</code> 条件）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 而第二行输出显示，在强行改写 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 变量的值为字符串 <code>debug</code> 之后，<code>$foo</code> 的条件仍然是 <code>0</code> ，这显然不符合映射规则，因为当 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 为 <code>debug</code> 时，<code>$foo</code> 的值应当是 <code>1</code>. 这究竟是为什么呢？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实原因很简单，那就是 <code>$foo</code> 变量在第一次读取时，根据映射规则计算出的值被缓存住了。刚才我们说过，Nginx 模块可以为其创建的变量选择使用值容器，作为其“取处理程序”计算结果的缓存。显然，<strong><a href="http://wiki.nginx.org/HttpMapModule" target="_blank" rel="noopener">ngx_map</a>模块认为变量间的映射计算足够昂贵，需要自动将因变量的计算结果缓存下来，这样在当前请求的处理过程中如果再次读取这个因变量，<code>Nginx</code>就可以直接返回缓存住的结果，而不再调用该变量的“取处理程序”再行计算了</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了进一步验证这一点，我们不妨在请求中直接指定 <code>URL</code> 参数串为 <code>debug</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test?debug&apos;</span><br><span class="line">original foo: 1</span><br><span class="line">foo: 1</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，现在 <code>$orig_foo</code> 的值就成了 <code>1</code>，因为变量 <code>$foo</code> 在第一次被读取时，自变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 的值就是<code>debug</code>，于是按照映射规则，“取处理程序”计算返回的值便是 <code>1</code>. 而后续再读取 <code>$foo</code> 的值时，就总是得到被缓存住的 <code>1</code> 这个结果，而不论 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 后来变成什么样了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 指令其实是一个比较特殊的例子，因为它可以为用户变量注册“取处理程序”，而且用户可以自己定义这个“取处理程序”的计算规则。当然，此规则在这里被限定为与另一个变量的映射关系。同时，也并非所有使用了“取处理程序”的变量都会缓存结果，例如我们前面在 <a href="http://blog.sina.com.cn/s/blog_6d579ff40100wm63.html" target="_blank" rel="noopener">（三）</a> 中已经看到 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 并不会使用值容器进行缓存。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>类似 <a href="http://wiki.nginx.org/HttpMapModule" target="_blank" rel="noopener">ngx_map</a> 模块，标准的 <a href="http://wiki.nginx.org/HttpGeoModule" target="_blank" rel="noopener">ngx_geo</a> 等模块也一样使用了变量值的缓存机制</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的例子中，我们还应当注意到 <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 指令是在 <code>server</code> 配置块之外，也就是在最外围的 <code>http</code> 配置块中定义的。很多读者可能会对此感到奇怪，毕竟我们只是在 <code>location /test</code> 中用到了它。这倒不是因为我们不想把 <code>map</code> 语句直接挪到 <code>location</code> 配置块中，而是因为<strong><a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 指令只能在 <code>http</code> 块中使用！</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多 <code>Nginx</code> 新手都会担心如此“全局”范围的 <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 设置会让访问所有虚拟主机的所有 <code>location</code> 接口的请求都执行一遍变量值的映射计算，然而事实并非如此。前面我们已经了解到<strong><a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 配置指令的工作原理是为用户变量注册 “取处理程序”，并且实际的映射计算是在“取处理程序”中完成的，而“取处理程序”只有在该用户变量被实际读取时才会执行（当然，因为缓存的存在，只在请求生命期中的第一次读取中才被执行），所以对于那些根本没有用到相关变量的请求来说，就根本不会执行任何的无用计算</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种只在实际使用对象时才计算对象值的技术，在计算领域被称为<strong>“惰性求值”（lazy evaluation）</strong>。提供“惰性求值” 语义的编程语言并不多见，最经典的例子便是 Haskell. 与之相对的便是“主动求值” （eager evaluation）。我们有幸在 <code>Nginx</code> 中也看到了“惰性求值”的例子，但“主动求值”语义其实在 <code>Nginx</code> 里面更为常见，例如下面这行再普通不过的 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set $b &quot;$a,$a&quot;;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里会在<strong>执行 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 规定的赋值操作时，“主动”地计算出变量 <code>$b</code> 的值，而不会将该求值计算延缓到变量 <code>$b</code>实际被读取的时候</strong>。</p><h2 id="主请求与子请求"><a href="#主请求与子请求" class="headerlink" title="主请求与子请求"></a>主请求与子请求</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经了解到变量值容器的生命期是与请求绑定的，但是我当时有意避开了“请求”的正式定义。大家应当一直默认这里的“请求”都是指客户端发起的 <code>HTTP</code> 请求。其实<strong>在 Nginx 世界里有两种类型的“请求”，一种叫做“主请求”（main request），而另一种则叫做“子请求”（subrequest）</strong>。我们先来介绍一下它们。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓<strong>“主请求”，就是由 <code>HTTP</code> 客户端从 <code>Nginx</code> 外部发起的请求</strong>。我们前面见到的所有例子都只涉及到“主请求”，包括 两个使用 <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank" rel="noopener">echo_exec</a> 和 <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank" rel="noopener">rewrite</a> 指令发起“内部跳转”的例子。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而<strong>“子请求”则是由 <code>Nginx</code> 正在处理的请求在 <code>Nginx</code> 内部发起的一种级联请求</strong>。“子请求”在外观上很像 <code>HTTP</code>请求，但实现上却和 <code>HTTP</code> 协议乃至网络通信一点儿关系都没有。<strong>它是 <code>Nginx</code> 内部的一种抽象调用，目的是为了方便用户把“主请求”的任务分解为多个较小粒度的“内部请求”，并发或串行地访问多个<code>location</code> 接口，然后由这些 <code>location</code> 接口通力协作，共同完成整个“主请求”</strong>。当然，“子请求”的概念是相对的，任何一个“子请求”也可以再发起更多的“子子请求”，甚至可以玩递归调用（即自己调用自己）。当一个请求发起一个“子请求”的时候，按照 <code>Ngin</code>x 的术语，习惯把前者称为后者的“父请求”（parent request）。值得一提的是，<code>Apache</code>服务器中其实也有“子请求”的概念，所以来自<code>Apache</code>世界的读者对此应当不会感到陌生。</p><p>​    下面就来看一个使用了“子请求”的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location /main &#123;</span><br><span class="line">    echo_location /foo;</span><br><span class="line">    echo_location /bar;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /foo &#123;</span><br><span class="line">    echo foo;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /bar &#123;</span><br><span class="line">    echo bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里在 <code>location /main</code> 中，通过第三方 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 模块的 <a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank" rel="noopener">echo_location</a> 指令分别发起到 <code>/foo</code> 和 <code>/bar</code> 这两个接口的 <code>GET</code> 类型的“子请求”。由 <a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank" rel="noopener">echo_location</a> 发起的“子请求”，其执行是按照配置书写的顺序串行处理的，即只有当 <code>/foo</code> 请求处理完毕之后，才会接着处理 <code>/bar</code> 请求。这两个“子请求”的输出会按执行顺序拼接起来，作为 <code>/main</code> 接口的最终输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/main&apos;</span><br><span class="line">foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，“子请求”方式的通信是在同一个虚拟主机内部进行的，所以<strong><code>Nginx</code> 核心在实现“子请求”的时候，就只调用了若干个<code>C</code> 函数，完全不涉及任何网络或者 <code>UNIX</code>套接字（<code>socket</code>）通信</strong>。我们由此可以看出“子请求”的执行效率是极高的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回到先前对<code>Nginx</code> 变量值容器的生命期的讨论，我们现在依旧可以说，它们的<strong>生命期是与当前请求相关联的。每个请求都有所有变量值容器的独立副本，只不过当前请求既可以是“主请求”，也可以是“子请求”</strong>。即便是<strong>父子请求之间，同名变量一般也不会相互干扰</strong>。让我们来通过一个小实验证明一下这个说法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">location /main &#123;</span><br><span class="line">    set $var main;</span><br><span class="line"> </span><br><span class="line">    echo_location /foo;</span><br><span class="line">    echo_location /bar;</span><br><span class="line"> </span><br><span class="line">    echo &quot;main: $var&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /foo &#123;</span><br><span class="line">    set $var foo;</span><br><span class="line">    echo &quot;foo: $var&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /bar &#123;</span><br><span class="line">    set $var bar;</span><br><span class="line">    echo &quot;bar: $var&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个例子中，我们分别在 <code>/main</code>，<code>/foo</code> 和 <code>/bar</code> 这三个 <code>location</code> 配置块中为同一名字的变量，<code>$var</code>，分别设置了不同的值并予以输出。特别地，我们在 <code>/main</code> 接口中，故意在调用过 <code>/foo</code> 和 <code>/bar</code> 这两个“子请求”之后，再输出它自己的 <code>$var</code> 变量的值。请求 <code>/main</code> 接口的结果是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/main&apos;</span><br><span class="line">foo: foo</span><br><span class="line">bar: bar</span><br><span class="line">main: main</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，<code>/foo</code> 和 <code>/bar</code> 这两个“子请求”在处理过程中对变量 <code>$var</code> 各自所做的修改都丝毫没有影响到“主请求” <code>/main</code>. 于是这成功印证了“主请求”以及各个“子请求”都拥有不同的变量 <code>$var</code> 的值容器副本。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不幸的是，<strong>一些 <code>Nginx</code>模块发起的“子请求”却会自动共享其“父请求”的变量值容器</strong>，比如第三方模块 <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank" rel="noopener">ngx_auth_request</a>. 下面是一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">location /main &#123;</span><br><span class="line">    set $var main;</span><br><span class="line">    auth_request /sub;</span><br><span class="line">    echo &quot;main: $var&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /sub &#123;</span><br><span class="line">    set $var sub;</span><br><span class="line">    echo &quot;sub: $var&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们在 <code>/main</code> 接口中先为 <code>$var</code> 变量赋初值 <code>main</code>，然后使用 <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank" rel="noopener">ngx_auth_request</a> 模块提供的配置指令 <code>auth_request</code>，发起一个到 <code>/sub</code> 接口的“子请求”，最后利用 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令输出变量 <code>$var</code> 的值。而我们在<code>/sub</code> 接口中则故意把 <code>$var</code> 变量的值改写成 <code>sub</code>. 访问 <code>/main</code> 接口的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/main&apos;</span><br><span class="line">main: sub</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，<code>/sub</code> 接口对 <code>$var</code> 变量值的修改影响到了主请求 <code>/main</code>. 所以<strong><a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank" rel="noopener">ngx_auth_request</a> 模块发起的“子请求”确实是与其“父请求”共享一套 Nginx 变量的值容器</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于上面这个例子，相信有读者会问：“为什么‘子请求’ <code>/sub</code> 的输出没有出现在最终的输出里呢？”答案很简单，那就是因为 <code>auth_request</code> 指令会自动忽略“子请求”的响应体，而只检查“子请求”的响应状态码。当状态码是 <code>2XX</code> 的时候，<code>auth_request</code> 指令会忽略“子请求”而让 Nginx 继续处理当前的请求，否则它就会立即中断当前（主）请求的执行，返回相应的出错页。在我们的例子中，<code>/sub</code> “子请求”只是使用 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令作了一些输出，所以隐式地返回了指示正常的 <code>200</code> 状态码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如 <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank" rel="noopener">ngx_auth_request</a> 模块这样父子请求共享一套 <code>Nginx</code>变量的行为，虽然可以让父子请求之间的数据双向传递变得极为容易，但是对于足够复杂的配置，却也经常导致不少难于调试的诡异<code>bug</code>. 因为用户时常不知道“父请求”的某个 <code>Nginx</code>变量的值，其实已经在它的某个“子请求”中被意外修改了。诸如此类的因共享而导致的不好的“副作用”，让包括 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a>，<a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a>，以及 <a href="http://wiki.nginx.org/HttpSRCacheModule" target="_blank" rel="noopener">ngx_srcache</a> 在内的许多第三方模块都选择了<strong>禁用父子请求间的变量共享</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Nginx</code>内建变量用在“子请求”的上下文中时，其行为也会变得有些微妙。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经知道许多内建变量都不是简单的“存放值的容器”，它们一般会<strong>通过注册“存取处理程序”来表现得与众不同，而它们即使有存放值的容器，也只是用于缓存“存取处理程序”的计算结果</strong>。我们之前讨论过的 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 变量正是通过它的“取处理程序”来返回当前请求的 <code>URL</code> 参数串。因为当前请求也可以是“子请求”，所以在“子请求”中读取 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a>，其“取处理程序”会很自然地返回当前“子请求”的参数串。我们来看这样的一个例子：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /main &#123;</span><br><span class="line">    <span class="attribute">echo</span> <span class="string">"main args: <span class="variable">$args</span>"</span>;</span><br><span class="line">    <span class="attribute">echo_location</span> /sub <span class="string">"a=1&amp;b=2"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="attribute">location</span> /sub &#123;</span><br><span class="line">    <span class="attribute">echo</span> <span class="string">"sub args: <span class="variable">$args</span>"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里在 <code>/main</code> 接口中，先用 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令输出当前请求的 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 变量的值，接着再用 <a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank" rel="noopener">echo_location</a> 指令发起子请求 <code>/sub</code>. 这里值得注意的是，我们在 <a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank" rel="noopener">echo_location</a> 语句中除了通过第一个参数指定“子请求”的 <code>URI</code> 之外，还提供了第二个参数，用以指定该“子请求”的 URL 参数串（即 <code>a=1&amp;b=2</code>）。最后我们定义了 <code>/sub</code> 接口，在里面输出了一下 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 的值。请求 <code>/main</code> 接口的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/main?c=3&apos;</span><br><span class="line">main args: c=3</span><br><span class="line">sub args: a=1&amp;b=2</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，当 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 用在“主请求” <code>/main</code> 中时，输出的就是“主请求”的 URL 参数串，<code>c=3</code>；而当用在“子请求” <code>/sub</code> 中时，输出的则是“子请求”的参数串，<code>a=1&amp;b=2</code>。这种行为正符合我们的直觉。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 类似，内建变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank" rel="noopener">$uri</a> 用在“子请求”中时，其“取处理程序”也会正确返回当前“子请求”解析过的 URI:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /main &#123;</span><br><span class="line">    <span class="attribute">echo</span> <span class="string">"main uri: <span class="variable">$uri</span>"</span>;</span><br><span class="line">    <span class="attribute">echo_location</span> /sub;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="attribute">location</span> /sub &#123;</span><br><span class="line">    <span class="attribute">echo</span> <span class="string">"sub uri: <span class="variable">$uri</span>"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请求 <code>/main</code> 的结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/main&apos;</span><br><span class="line">main uri: /main</span><br><span class="line">sub uri: /sub</span><br></pre></td></tr></table></figure><p>这依然是我们所期望的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但不幸的是，<strong>并非所有的内建变量都作用于当前请求</strong>。<strong>少数内建变量只作用于“主请求”</strong>，比如由标准模块 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html" target="_blank" rel="noopener">ngx_http_core</a> 提供的内建变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank" rel="noopener">$request_method</a>.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank" rel="noopener">$request_method</a> 在读取时，总是会得到“主请求”的请求方法</strong>，比如 <code>GET</code>、<code>POST</code> 之类。我们来测试一下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /main &#123;</span><br><span class="line">    <span class="attribute">echo</span> <span class="string">"main method: <span class="variable">$request_method</span>"</span>;</span><br><span class="line">    <span class="attribute">echo_location</span> /sub;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="attribute">location</span> /sub &#123;</span><br><span class="line">    <span class="attribute">echo</span> <span class="string">"sub method: <span class="variable">$request_method</span>"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个例子里，<code>/main</code> 和 <code>/sub</code> 接口都会分别输出 <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank" rel="noopener">$request_method</a> 的值。同时，我们在 <code>/main</code> 接口里利用 <a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank" rel="noopener">echo_location</a> 指令发起一个到 <code>/sub</code> 接口的 <code>GET</code> “子请求”。我们现在利用 <code>curl</code> 命令行工具来发起一个到<code>/main</code> 接口的 <code>POST</code> 请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl --data hello &apos;http://localhost:8080/main&apos;</span><br><span class="line">main method: POST</span><br><span class="line">sub method: POST</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们利用 <code>curl</code> 程序的 <code>--data</code> 选项，指定 <code>hello</code> 作为我们的请求体数据，同时 <code>--data</code> 选项会自动让发送的请求使用 <code>POST</code> 请求方法。测试结果证明了我们先前的预言，<a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank" rel="noopener">$request_method</a> 变量即使在 <code>GET</code> “子请求” <code>/sub</code> 中使用，得到的值依然是“主请求” <code>/main</code> 的请求方法，<code>POST</code>.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 有的读者可能觉得我们在这里下的结论有些草率，因为上例是先在“主请求”里读取（并输出）<a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank" rel="noopener">$request_method</a> 变量，然后才发“子请求”的，所以这些读者可能认为这<strong>并不能排除 <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank" rel="noopener">$request_method</a> 在进入子请求之前就已经把第一次读到的值给缓存住，从而影响到后续子请求中的输出结果</strong>。不过，这样的顾虑是多余的，因为我们前面在也特别提到过，<strong>缓存所依赖的变量的值容器，是与当前请求绑定的，而由 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 模块发起的“子请求”都禁用了父子请求之间的变量共享</strong>，所以在上例中，<a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank" rel="noopener">$request_method</a> 内建变量即使真的使用了值容器作为缓存（事实上它也没有），它也不可能影响到 <code>/sub</code> 子请求。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了进一步消除这部分读者的疑虑，我们不妨稍微修改一下刚才那个例子，将 <code>/main</code> 接口输出 <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank" rel="noopener">$request_method</a> 变量的时间推迟到“子请求”执行完毕之后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /main &#123;</span><br><span class="line">    echo_location /sub;</span><br><span class="line">    echo &quot;main method: $request_method&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /sub &#123;</span><br><span class="line">    echo &quot;sub method: $request_method&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们重新测试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl --data hello &apos;http://localhost:8080/main&apos;</span><br><span class="line">sub method: POST</span><br><span class="line">main method: POST</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，再次以 <code>POST</code> 方法请求 <code>/main</code> 接口的结果与原先那个例子完全一致，除了父子请求的输出顺序颠倒了过来（因为我们在本例中交换了 <code>/main</code> 接口中那两条输出配置指令的先后次序）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由此可见，我们并不能通过标准的 <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank" rel="noopener">$request_method</a> 变量取得“子请求”的请求方法。为了达到我们最初的目的，我们需要求助于第三方模块 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 提供的内建变量 <a href="http://wiki.nginx.org/HttpEchoModule#.24echo_request_method" target="_blank" rel="noopener">$echo_request_method</a>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /main &#123;</span><br><span class="line">    echo &quot;main method: $echo_request_method&quot;;</span><br><span class="line">    echo_location /sub;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /sub &#123;</span><br><span class="line">    echo &quot;sub method: $echo_request_method&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时的输出终于是我们想要的了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl --data hello &apos;http://localhost:8080/main&apos;</span><br><span class="line">main method: POST</span><br><span class="line">sub method: GET</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，父子请求分别输出了它们各自不同的请求方法，<code>POST</code> 和 <code>GET</code>.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>类似 <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank" rel="noopener">$request_method</a>，内建变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24request_uri" target="_blank" rel="noopener">$request_uri</a> 一般也返回的是“主请求”未经解析过的 <code>URL</code>，毕竟“子请求”都是在 <code>Nginx</code>内部发起的，并不存在所谓的“未解析的”原始形式</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果真如前面那部分读者所担心的，内建变量的值缓存在共享变量的父子请求之间起了作用，这无疑是灾难性的。我们前面已经看到 <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank" rel="noopener">ngx_auth_request</a> 模块发起的“子请求”是与其“父请求”共享一套变量的。下面是一个这样的可怕例子：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">map</span> <span class="variable">$uri</span> <span class="variable">$tag</span> &#123;</span><br><span class="line">    <span class="attribute">default</span>     <span class="number">0</span>;</span><br><span class="line">    /main       1;</span><br><span class="line">    /sub        2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">location</span> /main &#123;</span><br><span class="line">        <span class="attribute">auth_request</span> /sub;</span><br><span class="line">        <span class="attribute">echo</span> <span class="string">"main tag: <span class="variable">$tag</span>"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">location</span> /sub &#123;</span><br><span class="line">        <span class="attribute">echo</span> <span class="string">"sub tag: <span class="variable">$tag</span>"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们使用久违了的 <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 指令来把内建变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank" rel="noopener">$uri</a> 的值映射到用户变量 <code>$tag</code> 上。当 <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank" rel="noopener">$uri</a> 的值为 <code>/main</code>时，则赋予 <code>$tag</code> 值 1，当 <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank" rel="noopener">$uri</a> 取值 <code>/sub</code> 时，则赋予 <code>$tag</code> 值 2，其他情况都赋 <code>0</code>. 接着，我们在 <code>/main</code>接口中先用 <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank" rel="noopener">ngx_auth_request</a> 模块的 <code>auth_request</code> 指令发起到 <code>/sub</code> 接口的子请求，然后再输出变量 <code>$tag</code>的值。而在 <code>/sub</code> 接口中，我们直接输出变量 <code>$tag</code>. 猜猜看，如果我们访问接口 <code>/main</code>，将会得到什么样的输出呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/main&apos;</span><br><span class="line">main tag: 2</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;咦？我们不是分明把 <code>/main</code> 这个值映射到 <code>1</code> 上的么？为什么实际输出的是 <code>/sub</code> 映射的结果 <code>2</code> 呢？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实道理很简单，因为我们的 <code>$tag</code> 变量在“子请求” <code>/sub</code> 中首先被读取，于是在那里计算出了值<code>2</code>（因为 <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank" rel="noopener">$uri</a> 在那里取值 <code>/sub</code>，而根据 <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 映射规则，<code>$tag</code> 应当取值 <code>2</code>），从此就被 <code>$tag</code> 的值容器给缓存住了。而 <strong><code>auth_request</code> 发起的“子请求”又是与“父请求”共享一套变量的，于是当 <code>Nginx</code> 的执行流回到“父请求”输出 <code>$tag</code> 变量的值时，<code>Nginx</code> 就直接返回缓存住的结果 <code>2</code> 了</strong>。这样的结果确实太意外了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从这个例子我们再次看到，父子请求间的变量共享，实在不是一个好主意。</p><h2 id="变量是否存在判断"><a href="#变量是否存在判断" class="headerlink" title="变量是否存在判断"></a>变量是否存在判断</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前面我们提到过，<code>Nginx</code> 变量的值只有一种类型，那就是字符串，但是变量也有可能压根就不存在有意义的值。<strong>没有值的变量也有两种特殊的值：一种是“不合法”（invalid），另一种是“没找到”（not found）</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举例说来，当<code>Nginx</code> 用户变量 <code>$foo</code> 创建了却未被赋值时，<code>$foo</code> 的值便是“不合法”；而如果当前请求的 URL 参数串中并没有提及 <code>XXX</code> 这个参数，则 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 内建变量的值便是“没找到”。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论是“不合法”也好，还是“没找到”也罢，这两种 <code>Nginx</code> 变量所拥有的特殊值，和空字符串（””）这种取值是完全不同的，比如<code>JavaScript</code> 语言中也有专门的 <code>undefined</code> 和 <code>null</code> 这两种特殊值，而 <code>Lua</code> 语言中也有专门的 <code>nil</code> 值: 它们既不等同于空字符串，也不等同于数字 <code>0</code>，更不是布尔值 <code>false</code>. 其实 <code>SQL</code> 语言中的 <code>NULL</code> 也是类似的一种东西。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然前面我们看到，<strong>由 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令创建的变量未初始化就用在“变量插值”中时，效果等同于空字符串，但那是因为 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令为它创建的变量自动注册了一个“取处理程序”，将“不合法”的变量值转换为空字符串</strong>。为了验证这一点，我们再重新看一下前面讨论过的那个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    echo &quot;foo = [$foo]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /bar &#123;</span><br><span class="line">    set $foo 32;</span><br><span class="line">    echo &quot;foo = [$foo]&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里为了简单起见，省略了原先写出的外围 <code>server</code> 配置块。在这个例子里，我们在 <code>/bar</code> 接口中用 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令隐式地创建了 <code>$foo</code> 变量这个名字，然后我们在 <code>/foo</code> 接口中不对 <code>$foo</code> 进行初始化就直接使用 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令输出。我们当时测试 <code>/foo</code> 接口的结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/foo&apos;</span><br><span class="line">foo = []</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从输出上看，<strong>未初始化的 <code>$foo</code> 变量确实和空字符串的效果等同</strong>。但细心的读者当时应该就已经注意到，对于上面这个请求，<strong><code>Nginx</code> 的错误日志文件（一般文件名叫做 <code>error.log</code>）中多出一行类似下面这样的警告</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[warn] 5765#0: *1 using uninitialized &quot;foo&quot; variable, ...</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一行警告是谁输出的呢？答案是 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令为 <code>$foo</code> 注册的“取处理程序”。当 <code>/foo</code> 接口中的 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令实际执行的时候，它会对它的参数 <code>&quot;foo = [$foo]&quot;</code> 进行“变量插值”计算。于是，参数串中的 <code>$foo</code> 变量会被读取，而 <code>Nginx</code> 会首先检查其值容器里的取值，结果它看到了“不合法”这个特殊值，于是它这才决定继续调用 <code>$foo</code> 变量的“取处理程序”。于是 <code>$foo</code> 变量的“取处理程序”开始运行，它向 <code>Nginx</code> 的错误日志打印出上面那条警告消息，然后返回一个空字符串作为 <code>$foo</code> 的值，并从此缓存在 <code>$foo</code> 的值容器中。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;细心的读者会注意到刚刚描述的这个过程其实就是那些支持值缓存的内建变量的工作原理，只不过 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a>指令在这里借用了这套机制来处理未正确初始化的 <code>Nginx</code> 变量。值得一提的是，<strong>只有“不合法”这个特殊值才会触发 <code>Nginx</code> 调用变量的“取处理程序”，而特殊值“没找到”却不会</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面<strong>这样的警告一般会指示出我们的 <code>Nginx</code> 配置中存在变量名拼写错误，抑或是在错误的场合使用了尚未初始化的变量</strong>。因为值缓存的存在，这条警告在一个请求的生命期中也不会打印多次。当然，<a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank" rel="noopener">ngx_rewrite</a> 模块专门提供了一条 <a href="http://wiki.nginx.org/HttpRewriteModule#uninitialized_variable_warn" target="_blank" rel="noopener">uninitialized_variable_warn</a> 配置指令可用于禁止这条警告日志。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 刚才提到，内建变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 在请求 <code>URL</code> 参数 <code>XXX</code> 并不存在时会返回特殊值“找不到”，但遗憾的是在 <code>Nginx</code> 原生配置语言（我们估且这么称呼它）中是不能很方便地把它和空字符串区分开来的，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    echo &quot;name: [$arg_name]&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们输出 <code>$arg_name</code> 变量的值同时故意在请求中不提供 <code>URL</code>参数 <code>name</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">name: []</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，<strong>输出特殊值“找不到”的效果和空字符串是相同的</strong>。因为这一回是 <strong><code>Nginx</code> 的“变量插值”引擎自动把“找不到”给忽略了</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么我们究竟应当如何捕捉到“找不到”这种特殊值的踪影呢？换句话说，我们应当如何把它和空字符串给区分开来呢？显然，下面这个请求中，<code>URL</code> 参数 <code>name</code> 是有值的，而且其值应当是空字符串：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test?name=&apos;</span><br><span class="line">name: []</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但我们却无法将之和前面完全不提供 <code>name</code> 参数的情况给区分开。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;幸运的是，通过第三方模块 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a>，我们可以轻松地在 <code>Lua</code> 代码中做到这一点。请看下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    content_by_lua &apos;</span><br><span class="line">        if ngx.var.arg_name == nil then</span><br><span class="line">            ngx.say(&quot;name: missing&quot;)</span><br><span class="line">        else</span><br><span class="line">            ngx.say(&quot;name: [&quot;, ngx.var.arg_name, &quot;]&quot;)</span><br><span class="line">        end</span><br><span class="line">    &apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个例子和前一个例子功能上非常接近，除了我们在 <code>/test</code> 接口中使用了 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 模块的 <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> 配置指令，嵌入了一小段我们自己的<code>Lua</code> 代码来对 <code>Nginx</code> 变量 <code>$arg_name</code> 的特殊值进行判断。在这个例子中，当 <code>$arg_name</code> 的值为“没找到”（或者“不合法”）时，<code>/foo</code> 接口会输出 <code>name: missing</code> 这一行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">name: missing</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为这是我们第一次接触到 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 模块，所以需要先简单介绍一下。<a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 模块将 Lua 语言解释器（或者 <a href="http://luajit.org/luajit.html" target="_blank" rel="noopener">LuaJIT</a> 即时编译器）嵌入到了 <code>Nginx</code> 核心中，从而可以让用户在<code>Nginx</code> 核心中直接运行 <code>Lua</code>语言编写的程序。我们可以选择在 <code>Nginx</code> 不同的请求处理阶段插入我们的 <code>Lua</code>代码。这些<code>Lua</code>代码既可以直接内联在 <code>Nginx</code> 配置文件中，也可以单独放置在外部 <code>.lua</code> 文件里，然后在 <code>Nginx</code> 配置文件中引用 <code>.lua</code> 文件的路径。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 回到上面这个例子，我们在 <code>Lua</code> 代码里引用 <code>Nginx</code>变量都是通过 <code>ngx.var</code> 这个由 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 模块提供的 Lua 接口。比如引用 Nginx 变量 <code>$VARIABLE</code> 时，就在 <code>Lua</code>代码里写作 <a href="http://wiki.nginx.org/HttpLuaModule#ngx.var.VARIABLE" target="_blank" rel="noopener">ngx.var.VARIABLE</a> 就可以了。当 Nginx 变量 <code>$arg_name</code> 为特殊值“没找到”（或者“不合法”）时， <code>ngx.var.arg_name</code> 在 <code>Lua</code>世界中的值就是 <code>nil</code>，即<code>Lua</code>语言里的“空”（不同于 <code>Lua</code> 空字符串）。我们在 <code>Lua</code>里输出响应体内容的时候，则使用了 <a href="http://wiki.nginx.org/HttpLuaModule#ngx.say" target="_blank" rel="noopener">ngx.say</a> 这个 <code>Lua</code>函数，也是 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 模块提供的，功能上等价于 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 模块的 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 配置指令。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 现在，如果我们提供空字符串取值的 <code>name</code> 参数，则输出就和刚才不相同了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test?name=&apos;</span><br><span class="line">name: []</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这种情况下，Nginx 变量 <code>$arg_name</code> 的取值便是空字符串，这既不是“没找到”，也不是“不合法”，因此在 <code>Lua</code>里，<code>ngx.var.arg_name</code> 就返回 <code>Lua</code>空字符串（””），和刚才的<code>Lua</code> <code>nil</code> 值就完全区分开了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种区分在有些应用场景下非常重要，比如有的 <code>web service</code> 接口会根据 <code>name</code> 这个 URL 参数是否存在来决定是否按 <code>name</code> 属性对数据集合进行过滤，而显然提供空字符串作为 <code>name</code> 参数的值，也会导致对数据集中取值为空串的记录进行筛选操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，标准的 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 变量还是有一些局限，比如我们用下面这个请求来测试刚才那个 <code>/test</code> 接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test?name&apos;</span><br><span class="line">name: missing</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时，<code>$arg_name</code> 变量仍然读出“找不到”这个特殊值，这就明显有些违反常识。此外，<a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 变量在请求 <code>URL</code> 中有多个同名 <code>XXX</code> 参数时，就只会返回最先出现的那个 <code>XXX</code> 参数的值，而默默忽略掉其他实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test?name=Tom&amp;name=Jim&amp;name=Bob&apos;</span><br><span class="line">name: [Tom]</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要解决这些局限，可以直接在<code>Lua</code>代码中使用 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 模块提供的 <a href="http://wiki.nginx.org/HttpLuaModule#ngx.req.get_uri_args" target="_blank" rel="noopener">ngx.req.get_uri_args</a> 函数。</p><h2 id="Nginx变量与Lua"><a href="#Nginx变量与Lua" class="headerlink" title="Nginx变量与Lua"></a>Nginx变量与Lua</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 类似，我们在前面提到过的内建变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24cookie_COOKIE" target="_blank" rel="noopener">$cookie_XXX</a> 变量也会在名为 <code>XXX</code> 的 <code>cookie</code>不存在时返回特殊值“没找到”：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /test &#123;</span><br><span class="line">    <span class="attribute">content_by_lua</span> <span class="string">'</span></span><br><span class="line"><span class="string">        if ngx.var.cookie_user == nil then</span></span><br><span class="line"><span class="string">            ngx.say("cookie user: missing")</span></span><br><span class="line"><span class="string">        else</span></span><br><span class="line"><span class="string">            ngx.say("cookie user: [", ngx.var.cookie_user, "]")</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string">    '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用 <code>curl</code> 命令行工具的 <code>--cookie name=value</code> 选项可以指定 <code>name=value</code> 为当前请求携带的 <code>cookie</code>（通过添加相应的 <code>Cookie</code> 请求头）。下面是若干次测试结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl --cookie user=agentzh &apos;http://localhost:8080/test&apos;</span><br><span class="line">cookie user: [agentzh]</span><br><span class="line"> </span><br><span class="line">$ curl --cookie user= &apos;http://localhost:8080/test&apos;</span><br><span class="line">cookie user: []</span><br><span class="line"> </span><br><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">cookie user: missing</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，<code>cookie user</code> 不存在以及取值为空字符串这两种情况被很好地区分开了：当 <code>cookie user</code> 不存在时，<code>Lua</code> 代码中的 <code>ngx.var.cookie_user</code> 返回了期望的<code>Lua nil</code> 值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Lua</code> 里访问未创建的 <code>Nginx</code> 用户变量时，在 <code>Lua</code> 里也会得到 <code>nil</code> 值，而不会像先前的例子那样直接让 <code>Nginx</code> 拒绝加载配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /test &#123;</span><br><span class="line">    <span class="attribute">content_by_lua</span> <span class="string">'</span></span><br><span class="line"><span class="string">        ngx.say("<span class="variable">$blah</span> = ", ngx.var.blah)</span></span><br><span class="line"><span class="string">    '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里<strong>假设我们并没有在当前的 <code>nginx.conf</code> 配置文件中创建过用户变量 <code>$blah</code>，然后我们在<code>Lua</code>代码中通过 <code>ngx.var.blah</code> 直接引用它</strong>。<strong>上面这个配置可以顺利启动，因为 <code>Nginx</code>在加载配置时只会编译 <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank" rel="noopener">content_by_lua</a>配置指令指定的 <code>Lua</code>代码而不会实际执行它，所以 <code>Nginx</code> 并不知道 <code>Lua</code>代码里面引用了 <code>$blah</code> 这个变量</strong>。于是我们在运行时也会得到 <code>nil</code> 值。而 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 提供的 <a href="http://wiki.nginx.org/HttpLuaModule#ngx.say" target="_blank" rel="noopener">ngx.say</a> 函数会自动把 <code>Lua</code> 的 <code>nil</code> 值格式化为字符串<code>&quot;nil&quot;</code> 输出，于是访问 <code>/test</code> 接口的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">$blah = nil</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这正是我们所期望的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面这个例子中另一个值得注意的地方是，我们在 <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> 配置指令的参数中提及了 <code>$bar</code> 符号，但却并没有触发“变量插值”（否则 <code>Nginx</code> 会在启动时抱怨 <code>$blah</code> 未创建）。这是因为 <strong><a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank" rel="noopener">content_by_lua</a>配置指令并不支持参数的“变量插值”功能</strong>。我们在前面中提到过，<strong>配置指令的参数是否允许“变量插值”，其实取决于该指令的实现模块</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设计返回“不合法”这一特殊值的例子是困难的，因为我们 在前面已经看到，<strong>由 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令创建的变量在未初始化时确实是“不合法”，但一旦尝试读取它们时，<code>Nginx</code> 就会自动调用其“取处理程序”，而它们的“取处理程序”会自动返回空字符串并将之缓存住</strong>。于是我们最终得到的是完全合法的空字符串。下面这个使用了 Lua 代码的例子证明了这一点：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /foo &#123;</span><br><span class="line">    <span class="attribute">content_by_lua</span> <span class="string">'</span></span><br><span class="line"><span class="string">        if ngx.var.foo == nil then</span></span><br><span class="line"><span class="string">            ngx.say("<span class="variable">$foo</span> is nil")</span></span><br><span class="line"><span class="string">        else</span></span><br><span class="line"><span class="string">            ngx.say("<span class="variable">$foo</span> = [", ngx.var.foo, "]")</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string">    '</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="attribute">location</span> /bar &#123;</span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$foo</span> <span class="number">32</span>;</span><br><span class="line">    <span class="attribute">echo</span> <span class="string">"foo = [<span class="variable">$foo</span>]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请求 <code>/foo</code> 接口的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/foo&apos;</span><br><span class="line">$foo = []</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到<strong>在 <code>Lua</code>里面读取未初始化的 <code>Nginx</code> 变量 <code>$foo</code> 时得到的是空字符串</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后值得一提的是，虽然前面反复指出<code>Nginx</code> 变量只有字符串这一种数据类型，但这并不能阻止像 <a href="http://wiki.nginx.org/HttpArrayVarModule" target="_blank" rel="noopener">ngx_array_var</a> 这样的第三方模块让 <code>Nginx</code>变量也能存放数组类型的值。下面就是这样的一个例子：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /test &#123;</span><br><span class="line">    <span class="attribute">array_split</span> <span class="string">","</span> <span class="variable">$arg_names</span> to=<span class="variable">$array</span>;</span><br><span class="line">    <span class="attribute">array_map</span> <span class="string">"[<span class="variable">$array_it</span>]"</span> <span class="variable">$array</span>;</span><br><span class="line">    <span class="attribute">array_join</span> <span class="string">" "</span> <span class="variable">$array</span> to=<span class="variable">$res</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">echo</span> <span class="variable">$res</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个例子中使用了 <a href="http://wiki.nginx.org/HttpArrayVarModule" target="_blank" rel="noopener">ngx_array_var</a> 模块的 <code>array_split</code>、 <code>array_map</code> 和 <code>array_join</code> 这三条配置指令，其含义很接近<code>Perl</code>语言中的内建函数 <code>split</code>、<code>map</code> 和 <code>join</code>（当然，其他脚本语言也有类似的等价物）。我们来看看访问 <code>/test</code> 接口的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test?names=Tom,Jim,Bob</span><br><span class="line">[Tom] [Jim] [Bob]</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，使用 <a href="http://wiki.nginx.org/HttpArrayVarModule" target="_blank" rel="noopener">ngx_array_var</a> 模块可以很方便地处理这样具有不定个数的组成元素的输入数据，例如此例中的 <code>names URL</code> 参数值就是由不定个数的逗号分隔的名字所组成。不过，这种类型的复杂任务通过 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 来做通常会更灵活而且更容易维护。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx变量&quot;&gt;&lt;a href=&quot;#Nginx变量&quot; class=&quot;headerlink&quot; title=&quot;Nginx变量&quot;&gt;&lt;/a&gt;Nginx变量&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://blog.sina.com.cn
      
    
    </summary>
    
      <category term="Nginx" scheme="http://blog.com/categories/Nginx/"/>
    
      <category term="OpenResty" scheme="http://blog.com/categories/Nginx/OpenResty/"/>
    
      <category term="Lua" scheme="http://blog.com/categories/Nginx/OpenResty/Lua/"/>
    
    
      <category term="Nginx" scheme="http://blog.com/tags/Nginx/"/>
    
      <category term="Lua" scheme="http://blog.com/tags/Lua/"/>
    
      <category term="OpenResty" scheme="http://blog.com/tags/OpenResty/"/>
    
  </entry>
  
  <entry>
    <title>mysql自定义排序规则函数——field()</title>
    <link href="http://blog.com/2019/09/19/mysql%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94field()/"/>
    <id>http://blog.com/2019/09/19/mysql自定义排序规则函数——field()/</id>
    <published>2019-09-19T04:12:57.000Z</published>
    <updated>2019-09-21T10:17:02.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql自定义排序规则函数——field"><a href="#mysql自定义排序规则函数——field" class="headerlink" title="mysql自定义排序规则函数——field()"></a>mysql自定义排序规则函数——field()</h1><blockquote><p>原文地址：<a href="https://blog.csdn.net/u011193276/article/details/52531439" target="_blank" rel="noopener">https://blog.csdn.net/u011193276/article/details/52531439</a></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>mysql order by</code>排序中，大多数情况下仅使用默认排序规则就够了：字符串按字典顺序，数字按大小等等。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可有时候，某个<strong>字段是有自身业务含义的</strong>，比如 有个字段<code>type</code>，<strong>值1、2、3可能分别表示早/中/晚，如果我想把中午信息靠前，这时候普通的升降序排列就不好办了</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>field(column,value1,value2,value3,……)</code>是解决这种问题的利器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中<code>column</code>代表要排序的列，<code>value1……</code>代表自定义的顺序： </p><blockquote><p> <code>order by field(type,2,3,1)</code>就是按2在前，3次之，1最后的顺序来排。</p></blockquote><p><strong>缺陷：在排序时，使用不了索引</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `test_order` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `cur_date` date DEFAULT &apos;2018-09-21&apos; COMMENT &apos;日期&apos;,</span><br><span class="line">  `type` tinyint(3) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;阶段  1=早上 2=中午 3=下午&apos;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `type-idx` (`type`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `cur_date`, `type`) VALUES (1, &apos;2018-09-21&apos;, 1);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `cur_date`, `type`) VALUES (2, &apos;2018-09-21&apos;, 2);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `cur_date`, `type`) VALUES (3, &apos;2018-09-21&apos;, 3);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `cur_date`, `type`) VALUES (4, &apos;2018-09-22&apos;, 1);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `cur_date`, `type`) VALUES (5, &apos;2018-09-22&apos;, 2);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `cur_date`, `type`) VALUES (6, &apos;2018-09-22&apos;, 3);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `test_order` order by field(type, 2, 3, 1)</span><br><span class="line">+----+------------+------+</span><br><span class="line">| id | cur_date   | type |</span><br><span class="line">+----+------------+------+</span><br><span class="line">|  2 | 2018-09-21 |    2 |</span><br><span class="line">|  5 | 2018-09-22 |    2 |</span><br><span class="line">|  3 | 2018-09-21 |    3 |</span><br><span class="line">|  6 | 2018-09-22 |    3 |</span><br><span class="line">|  1 | 2018-09-21 |    1 |</span><br><span class="line">|  4 | 2018-09-22 |    1 |</span><br><span class="line">+----+------------+------+</span><br></pre></td></tr></table></figure><p><strong>使用order by field</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">explain SELECT * FROM `test_order` order by field(type, 2, 3, 1);</span><br><span class="line">+----+------------+--------------+------+--------------+------+---------+------+-------+-------------+</span><br><span class="line">| id | select_type | table         | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+------------+--------------+------+--------------+------+---------+------+-------+-------------+</span><br><span class="line">|  1 | SIMPLE     | test_order_v1 | ALL | NULL         | NULL | NULL    | NULL |     6 | Using filesort |</span><br><span class="line">+----+------------+--------------+------+--------------+------+---------+------+-------+-------------+</span><br></pre></td></tr></table></figure><p><strong>未能够使用索引</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">explain SELECT type FROM `test_order` order by field(type, 2, 3, 1);</span><br><span class="line">+----+------------+--------------+-------+--------------+---------+---------+------+-------+-----------------------+</span><br><span class="line">| id | select_type | table         | type  | possible_keys | key     | key_len | ref  | rows | Extra                 |</span><br><span class="line">+----+------------+--------------+-------+--------------+---------+---------+------+-------+-----------------------+</span><br><span class="line">|  1 | SIMPLE     | test_order_v1 | index | NULL         | type-idx | 1       | NULL |     6 | Using index; Using filesort |</span><br><span class="line">+----+------------+--------------+-------+--------------+---------+---------+------+-------+-----------------------+</span><br></pre></td></tr></table></figure><p><strong>在排序时未能够使用索引，Using filesort</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">explain SELECT type FROM `test_order` where type in (1,2) order by field(type, 2, 3, 1);</span><br><span class="line">+----+------------+--------------+-------+--------------+---------+---------+------+-------+-----------------------------------+</span><br><span class="line">| id | select_type | table         | type  | possible_keys | key     | key_len | ref  | rows | Extra                             |</span><br><span class="line">+----+------------+--------------+-------+--------------+---------+---------+------+-------+-----------------------------------+</span><br><span class="line">|  1 | SIMPLE     | test_order_v1 | range | type-idx      | type-idx | 1       | NULL |     4 | Using where; Using index; Using filesort |</span><br><span class="line">+----+------------+--------------+-------+--------------+---------+---------+------+-------+-----------------------------------+</span><br></pre></td></tr></table></figure><p><strong>在索引覆盖时，取数据可以用到索引，但是排序仍然不能，Using filesort</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">explain SELECT * FROM `test_order` where type in (1,2) order by field(type, 2, 3, 1);</span><br><span class="line">+----+------------+--------------+------+--------------+------+---------+------+-------+------------------------+</span><br><span class="line">| id | select_type | table         | type | possible_keys | key  | key_len | ref  | rows | Extra                  |</span><br><span class="line">+----+------------+--------------+------+--------------+------+---------+------+-------+------------------------+</span><br><span class="line">|  1 | SIMPLE     | test_order_v1 | ALL | type-idx      | NULL | NULL    | NULL |     6 | Using where; Using filesort |</span><br><span class="line">+----+------------+--------------+------+--------------+------+---------+------+-------+------------------------+</span><br></pre></td></tr></table></figure><p><strong>select * 时，不能够使用索引</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `test_order` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(255) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;系统名称&apos;,</span><br><span class="line">  `version` tinyint(3) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;系统版本&apos;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `name_idx` (`name`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `name`, `version`) VALUES (1, &apos;ios&apos;, 2);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `name`, `version`) VALUES (2, &apos;ios&apos;, 3);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `name`, `version`) VALUES (3, &apos;android&apos;, 1);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `name`, `version`) VALUES (4, &apos;android&apos;, 4);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `name`, `version`) VALUES (5, &apos;other&apos;, 5);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `name`, `version`) VALUES (6, &apos;other&apos;, 0);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `name`, `version`) VALUES (7, &apos;鸿蒙&apos;, 1);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `name`, `version`) VALUES (8, &apos;阿里云&apos;, 2);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `test_order`;</span><br><span class="line">+----+--------+--------+</span><br><span class="line">| id | name  | version |</span><br><span class="line">+----+--------+--------+</span><br><span class="line">|  1 | ios    |      2 |</span><br><span class="line">|  2 | ios    |      3 |</span><br><span class="line">|  3 | android |      1 |</span><br><span class="line">|  4 | android |      4 |</span><br><span class="line">|  5 | other  |      5 |</span><br><span class="line">|  6 | other  |      0 |</span><br><span class="line">|  7 | 鸿蒙   |      1 |</span><br><span class="line">|  8 | 阿里云 |      2 |</span><br><span class="line">+----+--------+--------+</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `test_order` order by field(version, 2, 3, 1);</span><br><span class="line">+----+--------+--------+</span><br><span class="line">| id | name  | version |</span><br><span class="line">+----+--------+--------+</span><br><span class="line">|  4 | android |      4 |</span><br><span class="line">|  5 | other  |      5 |</span><br><span class="line">|  6 | other  |      0 |</span><br><span class="line">|  1 | ios    |      2 |</span><br><span class="line">|  8 | 阿里云 |      2 |</span><br><span class="line">|  2 | ios    |      3 |</span><br><span class="line">|  3 | android |      1 |</span><br><span class="line">|  7 | 鸿蒙   |      1 |</span><br><span class="line">+----+--------+--------+</span><br></pre></td></tr></table></figure><p><strong>默认升序时，未指定在排序列表里面的，排在最前面</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `test_order` order by field(version, 2, 3, 1) desc;</span><br><span class="line">+----+--------+--------+</span><br><span class="line">| id | name  | version |</span><br><span class="line">+----+--------+--------+</span><br><span class="line">|  3 | android |      1 |</span><br><span class="line">|  7 | 鸿蒙   |      1 |</span><br><span class="line">|  2 | ios    |      3 |</span><br><span class="line">|  1 | ios    |      2 |</span><br><span class="line">|  8 | 阿里云 |      2 |</span><br><span class="line">|  4 | android |      4 |</span><br><span class="line">|  5 | other  |      5 |</span><br><span class="line">|  6 | other  |      0 |</span><br><span class="line">+----+--------+--------+</span><br></pre></td></tr></table></figure><p><strong>降序时，未指定在排序列表里面的，排在最后面</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mysql自定义排序规则函数——field&quot;&gt;&lt;a href=&quot;#mysql自定义排序规则函数——field&quot; class=&quot;headerlink&quot; title=&quot;mysql自定义排序规则函数——field()&quot;&gt;&lt;/a&gt;mysql自定义排序规则函数——field
      
    
    </summary>
    
      <category term="Mysql" scheme="http://blog.com/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://blog.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Lua查找表元素过程</title>
    <link href="http://blog.com/2019/09/19/Lua%E6%9F%A5%E6%89%BE%E8%A1%A8%E5%85%83%E7%B4%A0%E8%BF%87%E7%A8%8B/"/>
    <id>http://blog.com/2019/09/19/Lua查找表元素过程/</id>
    <published>2019-09-19T04:12:57.000Z</published>
    <updated>2019-09-19T15:51:37.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lua查找表元素过程"><a href="#Lua查找表元素过程" class="headerlink" title="Lua查找表元素过程"></a>Lua查找表元素过程</h1><blockquote><p>原文地址：<a href="https://blog.csdn.net/xocoder/article/details/9028347" target="_blank" rel="noopener">https://blog.csdn.net/xocoder/article/details/9028347</a></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Lua</code>的表本质其实是个类似<code>HashMap</code>的东西，其元素是很多的<code>Key-Value</code>对，如果尝试访问了一个表中并不存在的元素时，就会<strong>触发Lua的一套查找机制，也是凭借这个机制来模拟了类似“继承”的行为</strong></p><p>举例说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tempTable = &#123;&#125;</span><br><span class="line">print(tempTable.memberA) --这里试图打印tempTable并不存在的成员memberA</span><br></pre></td></tr></table></figure><p>执行结果：<code>nil</code></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出为<code>nil</code>的原因很简单，<code>tempTable</code>中并没有<code>memberA</code>这个成员，这符合我们平时对<code>HashMap</code>的认知。但对于<code>Lua</code>表，如果<code>tempTable</code>有元表，情况就不同了。</p><p><strong>什么是元表：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>元表像是一个“操作指南”，里面包含了一系列操作的解决方案</strong>，例如：<code>__index</code>方法就是定义了这个表在索引失败的情况下该怎么办。</p><p><strong>__index元方法：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多人对此都有误解，这个<strong>误解是：如果A的元表是B，那么如果访问了一个A中不存在的成员，就会访问查找B中有没有这个成员</strong>。而这个理解是完全错误的，实际上，即使将A的元表设置为B，而且B中也确实有这个成员，返回结果仍然会是<code>nil</code>，原因就是B的<code>index</code>元方法没有赋值。别忘了我们之前说过的：“元表是一个操作指南”，定义了元表，只是有了操作指南，但不应该在操作指南里面去查找元素，而<strong><code>index</code>方法则是“操作指南”的“索引失败时该怎么办”</strong>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">father = &#123;</span><br><span class="line">house=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">son = &#123;</span><br><span class="line">car=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(son, father) <span class="comment">--把son的metatable设置为father</span></span><br><span class="line"><span class="built_in">print</span>(son.house)</span><br></pre></td></tr></table></figure><p>输出的结果是<code>nil</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">father = &#123;</span><br><span class="line">house=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">father.<span class="built_in">__index</span> = father <span class="comment">-- 把father的__index方法指向自己</span></span><br><span class="line">son = &#123;</span><br><span class="line">car=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(son, father)</span><br><span class="line"><span class="built_in">print</span>(son.house)</span><br></pre></td></tr></table></figure><p>输出的结果为1，符合预期</p><p>这样一来，结合上例，来解释<code>__index</code>元方法的含义：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上述例子中，访问son.house时，son中没有house这个成员，但Lua接着发现son有元表father，注意：此时，<code>Lua</code>并不是直接在father中找名为house的成员，而是调用father的<code>__index</code>方法，<strong>如果<code>__index</code>方法为<code>nil</code>，则返回<code>nil</code></strong>，如果是一个表（上例中father的<code>__index</code>方法等于自己，就是这种情况），那么就到__index方法所指的这个表中查找名为house的成员，于是，最终找到了house成员。</p><p>注：<code>__index</code>方法除了<strong>可以是一个表，还可以是一个函数</strong>，如果是一个函数，<code>__index</code>方法被调用时将返回该函数的返回值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这里，总结一下<code>Lua</code>查找一个表元素时的规则，其实就是如下3个步骤:</p><p>1.在表中查找，如果找到，返回该元素，找不到则继续</p><p>2.判断该表是否有元表（操作指南），如果没有元表，返回<code>nil</code>，有元表则继续</p><p>3.判断元表（操作指南）中<strong>有没有关于索引失败的指南（即__index方法）</strong>，如果没有（即__index方法为nil），则返回nil；如果__index方法是一个表，则重复1、2、3；如果__index方法是一个函数，则返回该函数的返回值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lua查找表元素过程&quot;&gt;&lt;a href=&quot;#Lua查找表元素过程&quot; class=&quot;headerlink&quot; title=&quot;Lua查找表元素过程&quot;&gt;&lt;/a&gt;Lua查找表元素过程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://blo
      
    
    </summary>
    
      <category term="Lua" scheme="http://blog.com/categories/Lua/"/>
    
    
      <category term="Lua" scheme="http://blog.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>lua中的self</title>
    <link href="http://blog.com/2019/09/19/lua%E4%B8%AD%E7%9A%84self/"/>
    <id>http://blog.com/2019/09/19/lua中的self/</id>
    <published>2019-09-19T04:12:57.000Z</published>
    <updated>2019-09-19T15:07:59.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lua中的self"><a href="#lua中的self" class="headerlink" title="lua中的self"></a>lua中的self</h1><blockquote><p>原文地址：<a href="https://www.jianshu.com/p/8245b1e7c487" target="_blank" rel="noopener">https://www.jianshu.com/p/8245b1e7c487</a></p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>lua</code>编程中，经常遇到函数的定义和调用。我们有两种函数定义和调用的方法。一种是用属性的方式，另外一种是通过冒号的形式（其实也是属性）。只不过<strong>用冒号形式申明的函数默认会有一个参数<code>self</code></strong>。<strong><code>self</code>指向本身（表）</strong>。下面举例说明：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">shape = &#123;side = <span class="number">4</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shape.set_side</span><span class="params">(shape, side)</span></span></span><br><span class="line">    shape.side = side</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shape.print_area</span><span class="params">(shape)</span></span></span><br><span class="line">    <span class="built_in">print</span>(shape.side * shape.side)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(shape.side)</span><br><span class="line">shape.set_side(shape, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(shape.side)</span><br><span class="line">shape.print_area(shape)</span><br></pre></td></tr></table></figure><p>上述运行结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br><span class="line">25</span><br></pre></td></tr></table></figure><p>上面是用“ . ”来定义和访问函数的方法。下面同样用“ ：”来实现同样功能的改写如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">shape = &#123;side = <span class="number">4</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shape:set_side</span><span class="params">(side)</span></span></span><br><span class="line">    self.side = side</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shape:print_area</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(self.side * self.side)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(shape.side)</span><br><span class="line">shape:set_side(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(shape.side)</span><br><span class="line">shape:print_area()</span><br></pre></td></tr></table></figure><p>运行结果和上面例子一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br><span class="line">25</span><br></pre></td></tr></table></figure><p>从上面两个例子我们可以看出<strong>：冒号定义和冒号调用其实跟上面的效果一样，只是把第一个隐藏参数省略了</strong>。而<strong>self则是指向调用者自身</strong>。<br>当然，我们也<strong>可以用点号“ . ”来定义函数，冒号“ ：”来调用函数</strong>。或者<strong>冒号定义点号调用</strong>。如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">shape = &#123;side = <span class="number">4</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shape.set_side</span><span class="params">(shape, side)</span></span></span><br><span class="line">    shape.side = side</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shape.print_area</span><span class="params">(shape)</span></span></span><br><span class="line">    <span class="built_in">print</span>(shape.side * shape.side)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(shape.side)</span><br><span class="line">shape:set_side(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(shape.side)</span><br><span class="line">shape:print_area()</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">shape = &#123;side = <span class="number">4</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shape:set_side</span><span class="params">(side)</span></span></span><br><span class="line">    self.side = side</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shape:print_area</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(self.side * self.side)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(shape.side)</span><br><span class="line">shape.set_side(shape, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(shape.side)</span><br><span class="line">shape.print_area(shape)</span><br></pre></td></tr></table></figure><p>上述运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">5</span><br><span class="line">25</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;lua中的self&quot;&gt;&lt;a href=&quot;#lua中的self&quot; class=&quot;headerlink&quot; title=&quot;lua中的self&quot;&gt;&lt;/a&gt;lua中的self&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://www.jia
      
    
    </summary>
    
      <category term="Lua" scheme="http://blog.com/categories/Lua/"/>
    
    
      <category term="Lua" scheme="http://blog.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>Lua在Redis的应用</title>
    <link href="http://blog.com/2019/09/19/Lua%E5%9C%A8Redis%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.com/2019/09/19/Lua在Redis的应用/</id>
    <published>2019-09-19T04:12:57.000Z</published>
    <updated>2019-09-19T14:57:40.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lua在Redis的应用"><a href="#Lua在Redis的应用" class="headerlink" title="Lua在Redis的应用"></a>Lua在Redis的应用</h1><p>Redis 从 2.6 版本起，也已开始支持 <a href="https://redis.io/commands/eval" target="_blank" rel="noopener">Lua 脚本</a>，我们可以更加得心应手地使用或扩展 Redis，特别是在高并发场景下 Lua 脚本提供了更高效、可靠的解决方案。</p><p><img src="//blog.com/2019/09/19/Lua在Redis的应用/3916d13312c22d84d29d3860b59544a9.png" alt=""><a id="more"></a></p><h2 id="为什么要使用Lua"><a href="#为什么要使用Lua" class="headerlink" title="为什么要使用Lua"></a>为什么要使用Lua</h2><p>我们先看一个抢购场景下 <a href="">商品库存</a> 的问题，用 PHP 可简单实现为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$key = <span class="string">'number:string'</span>;</span><br><span class="line">$redis = <span class="keyword">new</span> Redis();</span><br><span class="line">$number = $redis-&gt;get($key);</span><br><span class="line"><span class="keyword">if</span> ($number &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">$redis-&gt;decr($key);</span><br><span class="line"><span class="keyword">return</span> $number--;</span><br></pre></td></tr></table></figure><p>这段代码其实存在问题，高并发时会出现库存超卖的情况，因为上述操作在 Redis 中不是原子操作，会导致库存逻辑的判断失效。尽管可以通过优化代码来解决问题，比如使用 <a href="">Decr</a> 原子操作命令、或者使用 <a href="">锁</a> 的方式，但这里使用 Lua 脚本来解决。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = <span class="string">'number:string'</span></span><br><span class="line"><span class="keyword">local</span> number = <span class="built_in">tonumber</span>(redis.call(<span class="string">"GET"</span>, key))</span><br><span class="line"><span class="keyword">if</span> number &lt;= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">redis.call(<span class="string">"DECR"</span>, key)</span><br><span class="line"><span class="keyword">return</span> number<span class="comment">--</span></span><br></pre></td></tr></table></figure><p>这段脚本代码虽然是 Lua 语言编写（ <a href="https://www.fanhaobai.com/2017/09/lua.html" target="_blank" rel="noopener">进入Lua的世界</a>），但是其实就是 PHP 版本的翻译版。那为什么这样，Lua 脚本就能解决库存问题了呢？</p><p>Redis 中嵌入 Lua 脚本，所具有的几个特性为：</p><ul><li><a href="">原子操作</a>：Redis 将整个 Lua 脚本作为一个原子执行，无需考虑并发，无需使用事务来保证数据一致性；</li><li><a href="">高性能</a>：嵌入 Lua 脚本后，可以减少多个命令执行的网络开销，进而间接提高 Redis 性能；</li><li><a href="">可复用</a>：Lua 脚本会保存于 Redis 中，客户端都可以使用这些脚本；</li></ul><h2 id="在Redis中嵌入Lua"><a href="#在Redis中嵌入Lua" class="headerlink" title="在Redis中嵌入Lua"></a>在Redis中嵌入Lua</h2><p><img src="//blog.com/2019/09/19/Lua在Redis的应用/3916d13312c22d84d29d3860b59544a9.png" alt=""></p><h3 id="使用Lua解析器"><a href="#使用Lua解析器" class="headerlink" title="使用Lua解析器"></a>使用Lua解析器</h3><p>Redis 提供了 EVAL（直接执行脚本） 和 EVALSHA（执行 SHA1 值的脚本） 这两个命令，可以使用内置的 Lua 解析器执行 Lua 脚本。语法格式为：</p><ul><li><a href="">EVAL</a>  script  numkeys  key [key …]  arg [arg …] </li><li><a href="">EVALSHA</a>  sha1  numkeys  key [key …]  arg [arg …] </li></ul><p>参数说明：</p><ul><li>script / sha1：EVAL 命令的第一个参数为需要执行的 Lua 脚本字符，EVALSHA 命令的一个参数为 Lua 脚本的 <a href="https://redis.io/commands/eval#bandwidth-and-evalsha" target="_blank" rel="noopener">SHA1 值</a></li><li>numkeys：表示 key 的个数</li><li>key [key …]：从第三个参数开始算起，表示在脚本中所用到的那些 Redis 键（key），这些键名参数可以在 Lua 中通过全局数组 KYES[i] 访问</li><li>arg [arg …]：附加参数，在 Lua 中通过全局数组 ARGV[i] 访问</li></ul><p>EVAL 命令的使用示例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; EVAL <span class="string">"return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;"</span> <span class="number">2</span> key1 key2 first second</span><br><span class="line"><span class="number">1</span>) <span class="string">"key1"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"key2"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"first"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"second"</span></span><br></pre></td></tr></table></figure><p>每次使用 EVAL 命令都会传递需执行的 Lua 脚本内容，这样增加了宽带的浪费。Redis 内部会永久保存被运行在脚本缓存中，所以使用 EVALSHA（建议使用） 命令就可以根据脚本 SHA1 值执行对应的 Lua 脚本。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; SCRIPT LOAD <span class="string">"return 'hello'"</span></span><br><span class="line"><span class="string">"1b936e3fe509bcbc9cd0664897bbe8fd0cac101b"</span></span><br><span class="line">&gt; EVALSHA <span class="number">1</span>b936e3fe509bcbc9cd0664897bbe8fd0cac101b <span class="number">0</span></span><br><span class="line"><span class="string">"hello"</span></span><br></pre></td></tr></table></figure><blockquote><p>Redis 中执行 Lua 脚本都是以原子方式执行，所以是原子操作。另外，redis-cli 命令行客户端支持直接使用<code>--eval lua_file</code>参数执行 Lua 脚本。</p></blockquote><p>Redis 中有关脚本的命令除了 EVAL 和 EVALSHA 外，<a href="">其他常用命令</a> 如下：</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>SCRIPT EXISTS script [script …]</td><td>查看脚本是是否保存在缓存中</td></tr><tr><td>SCRIPT FLUSH</td><td>从缓存中移除所有脚本</td></tr><tr><td>SCRIPT KILL</td><td>杀死当前运行的脚本</td></tr><tr><td>SCRIPT LOAD script</td><td>将脚本添加到缓存中,不立即执行<br>返回脚本SHA1值</td></tr></tbody></table><h3 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h3><p>由于 Redis 和 Lua 都有各自定义的数据类型，所以在使用执行完 Lua 脚本后，会存在一个数据类型转换的过程。</p><p>Lua 到 Redis 类型转换与 Redis 到 Lua 类型转换相同部分关系：</p><table><thead><tr><th><a href="https://www.fanhaobai.com/2017/09/lua.html#数据类型" target="_blank" rel="noopener">Lua 类型</a></th><th><a href="http://www.redis.cn/topics/protocol.html" target="_blank" rel="noopener">Redis 返回类型</a></th><th>说明</th></tr></thead><tbody><tr><td>number</td><td>integer</td><td>浮点数会转换为整数<br>3.333–&gt;3</td></tr><tr><td>string</td><td>bulk</td><td></td></tr><tr><td>table（array）</td><td>multi bulk</td><td></td></tr><tr><td>boolean false</td><td>nil</td></tr></tbody></table><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; EVAL <span class="string">"return 3.333"</span> <span class="number">0</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line">&gt; EVAL <span class="string">"return 'fhb'"</span> <span class="number">0</span></span><br><span class="line"><span class="string">"fhb"</span></span><br><span class="line">&gt; EVAL <span class="string">"return &#123;'fhb', 'lw', 'lbf'&#125;"</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"fhb"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"lw"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"lbf"</span></span><br><span class="line">&gt; EVAL <span class="string">"return false"</span> <span class="number">0</span></span><br><span class="line">(<span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>需要注意的是，从 Lua 转化为 Redis 类型比 Redis 转化为 Lua 类型多了一条 <a href="">额外</a> 规则：</p><table><thead><tr><th>Lua 类型</th><th>Redis 返回类型</th><th>说明</th></tr></thead><tbody><tr><td>boolean true</td><td>integer</td><td>返回整型 1</td></tr></tbody></table><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; EVAL <span class="string">"return true"</span> <span class="number">0</span></span><br><span class="line">(integer) <span class="number">1</span></span><br></pre></td></tr></table></figure><p>总而言之，<a href="">类型转换的原则</a> 是将一个 Redis 值转换成 Lua 值，之后再将转换所得的 Lua 值转换回 Redis 值，那么这个转换所得的 Redis 值应该和最初时的 Redis 值一样。</p><h3 id="全局变量保护"><a href="#全局变量保护" class="headerlink" title="全局变量保护"></a>全局变量保护</h3><p>为了防止不必要的数据泄漏进 Lua 环境， Redis 脚本不允许创建全局变量。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义全局函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">return</span> n * <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> f(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>执行<code>redis-cli --eval function.lua</code>命令，会抛出尝试定义全局变量的错误：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(error) ERR Error running script (<span class="keyword">call</span> to f_0a602c93c4a2064f8dc648c402aa27d68b69514f): @enable_strict_lua:<span class="number">8</span>: user_script:<span class="number">1</span>: Script attempted to create global variable 'f'</span><br></pre></td></tr></table></figure><h2 id="Lua脚本调用Redis命令"><a href="#Lua脚本调用Redis命令" class="headerlink" title="Lua脚本调用Redis命令"></a>Lua脚本调用Redis命令</h2><p>Redis 创建了用于与 Lua 环境协作的组件—— 伪客户端，它负责执行 Lua 脚本中的 Redis 命令。</p><p><img src="//blog.com/2019/09/19/Lua在Redis的应用/ae7223b50754e37b7cd89cfe24fc13dd.png" alt=""></p><h3 id="调用Redis命令"><a href="#调用Redis命令" class="headerlink" title="调用Redis命令"></a>调用Redis命令</h3><p>在 Redis 内置的 Lua 解析器中，调用 redis.call() 和 redis.pcall() 函数执行 Redis 的命令。它们除了处理错误的行为不一样外，其他行为都保持一致。调用 格式：</p><ul><li>redis.call(command, [key …], arg [arg …] )</li><li>redis.pcall(command, [key …], arg [arg …] )</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; EVAL <span class="string">"return redis.call('SET', 'name', 'fhb')"</span> <span class="number">0</span></span><br><span class="line">&gt; EVAL <span class="string">"return redis.pcall('GET', 'name')"</span> <span class="number">0</span></span><br><span class="line"><span class="string">"fhb"</span></span><br></pre></td></tr></table></figure><h3 id="Redis日志"><a href="#Redis日志" class="headerlink" title="Redis日志"></a>Redis日志</h3><p>在 Lua 脚本中，可以通过调用 redis.log()  函数来写 Redis 日志。格式为：</p><p>redis.log(loglevel, message)</p><p>loglevel 参数可以是 redis.LOG_DEBUG、redis.LOG_VERBOSE、redis.LOG_NOTICE、redis.LOG_WARNING 的任意值。</p><p>查看<code>redis.conf</code>日志配置信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> logleval必须一致才会记录</span><br><span class="line">loglevel notice</span><br><span class="line">logfile "/home/logs/redis.log"</span><br></pre></td></tr></table></figure><p>Lua 写 Redis 日志示例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; EVAL <span class="string">"redis.log(redis.LOG_NOTICE, 'I am fhb')"</span> <span class="number">0</span></span><br><span class="line"><span class="number">113</span>:M <span class="number">04</span> Sep <span class="number">13</span>:<span class="number">12</span>:<span class="number">36.229</span> * I am fhb</span><br></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="API-访问速率控制"><a href="#API-访问速率控制" class="headerlink" title="API 访问速率控制"></a>API 访问速率控制</h3><p>通过 Lua 实现一个针对用户的 API 访问速率控制，Lua 代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = <span class="string">"rate.limit:string:"</span> .. KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> expire_time = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">local</span> times = redis.call(<span class="string">"INCR"</span>, key)</span><br><span class="line"><span class="keyword">if</span> times == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">"EXPIRE"</span>, key, expire_time)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> times &gt; limit <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>KEYS[1] 可以用 API 的 URI + 用户 uid 组成，ARGV[1] 为单位时间限制访问的次数，ARGV[2] 为限制的单位时间。</p><h3 id="批量HGETTALL"><a href="#批量HGETTALL" class="headerlink" title="批量HGETTALL"></a>批量HGETTALL</h3><p>这个例子演示通过 Lua 实现批量 HGETALL，当然也可以使用 <a href="https://www.fanhaobai.com/2017/08/redis-pipelining.html" target="_blank" rel="noopener">管道</a> 实现。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- KEYS为uid数组</span></span><br><span class="line"><span class="keyword">local</span> users = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i,uid <span class="keyword">in</span> <span class="built_in">ipairs</span>(KEYS) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> user = redis.call(<span class="string">'hgetall'</span>, uid)</span><br><span class="line">    <span class="keyword">if</span> user ~= <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">table</span>.<span class="built_in">insert</span>(users, i, user)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> users</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Lua在Redis的应用&quot;&gt;&lt;a href=&quot;#Lua在Redis的应用&quot; class=&quot;headerlink&quot; title=&quot;Lua在Redis的应用&quot;&gt;&lt;/a&gt;Lua在Redis的应用&lt;/h1&gt;&lt;p&gt;Redis 从 2.6 版本起，也已开始支持 &lt;a href=&quot;https://redis.io/commands/eval&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lua 脚本&lt;/a&gt;，我们可以更加得心应手地使用或扩展 Redis，特别是在高并发场景下 Lua 脚本提供了更高效、可靠的解决方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//blog.com/2019/09/19/Lua在Redis的应用/3916d13312c22d84d29d3860b59544a9.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Redis" scheme="http://blog.com/categories/Redis/"/>
    
      <category term="Lua" scheme="http://blog.com/categories/Redis/Lua/"/>
    
    
      <category term="Redis" scheme="http://blog.com/tags/Redis/"/>
    
      <category term="Lua" scheme="http://blog.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>Lua收集Nginx请求参数</title>
    <link href="http://blog.com/2019/09/19/Lua%E6%94%B6%E9%9B%86Nginx%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0/"/>
    <id>http://blog.com/2019/09/19/Lua收集Nginx请求参数/</id>
    <published>2019-09-19T04:12:57.000Z</published>
    <updated>2019-09-19T15:01:32.279Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lua收集Nginx请求参数"><a href="#Lua收集Nginx请求参数" class="headerlink" title="Lua收集Nginx请求参数"></a>Lua收集Nginx请求参数</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">-- http请求写入Redis</span><br><span class="line">local cjson = require(&quot;cjson&quot;)</span><br><span class="line">local mapping = require(&quot;collect.uriMapping&quot;)</span><br><span class="line">local redis = require(&quot;resty.redis&quot;)</span><br><span class="line">local crc = require(&apos;collect.crc32&apos;)</span><br><span class="line">local Main = &#123;&#125;</span><br><span class="line"></span><br><span class="line">-- 定义写入redis队列方法</span><br><span class="line">function Main.pushInRedis(uri, args)</span><br><span class="line">-- 读取映射文件获取redis队列信息表</span><br><span class="line">local data = mapping.redisInfo</span><br><span class="line">local host = nil</span><br><span class="line">local port = nil</span><br><span class="line">local auth = nil</span><br><span class="line">local queue = nil</span><br><span class="line">for index,value in pairs(data) do</span><br><span class="line">    if value[&apos;name&apos;] == uri then</span><br><span class="line">    host = value[&apos;host&apos;]</span><br><span class="line">    port = value[&apos;port&apos;]</span><br><span class="line">    auth = value[&apos;auth&apos;]</span><br><span class="line">    queue = value[&apos;queue&apos;]</span><br><span class="line">    section = value[&apos;section&apos;]</span><br><span class="line">    num = value[&apos;num&apos;]</span><br><span class="line">    break</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 队列名为空则返回</span><br><span class="line">if queue == nil then</span><br><span class="line">Main.exit(0,&quot;No redis info can find,please contact the administrator!&quot;)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">--查看数据是否需要切片</span><br><span class="line">if section ~= nil and num &gt; 2 and args[section] ~= nil then </span><br><span class="line">local i = crc.Hash(args[section]) % num</span><br><span class="line">queue = queue .. &quot;_&quot; .. i</span><br><span class="line">end</span><br><span class="line">-- 初始化redis </span><br><span class="line">local red = redis:new()</span><br><span class="line">    -- 设置超时连接时间3 sec</span><br><span class="line">red:set_timeout(3000) </span><br><span class="line">    --连接redis</span><br><span class="line">local ok, err = red:connect(host, port) </span><br><span class="line">if not ok then</span><br><span class="line">    Main.exit(0,&quot;failed to connect to Redis&quot;)</span><br><span class="line">end</span><br><span class="line">    --输入密码</span><br><span class="line">    if auth ~= nil and auth ~= &quot;&quot; then</span><br><span class="line">local res, err = red:auth(auth)   </span><br><span class="line">if not res then</span><br><span class="line"> Main.exit(0,&quot;failed to auth Redis&quot;)</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local pool_max_idle_time = 10000 --毫秒  </span><br><span class="line">local pool_size = 100 --连接池大小  </span><br><span class="line"></span><br><span class="line">--lpush进队列</span><br><span class="line">--将参数转换为JSON格式</span><br><span class="line">local json = cjson.encode(args)</span><br><span class="line">ok, err = red:lpush(queue, json)  </span><br><span class="line">if not ok then</span><br><span class="line">    Main.exit(0,&quot;failed to lpush&quot;)</span><br><span class="line">end</span><br><span class="line">local res = &#123;code = 1,msg = &quot;success!&quot;&#125;;</span><br><span class="line">ngx.say(cjson.encode(res))</span><br><span class="line">    ok, err = red:set_keepalive(10000, 100)</span><br><span class="line">    if not ok then</span><br><span class="line">        Main.exit(0,&quot;failed to set Redis keepalive&quot;)</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function Main.exit(sendcode,sendmsg)</span><br><span class="line">local res = &#123;code = sendcode, msg = sendmsg&#125;;</span><br><span class="line">ngx.say(cjson.encode(res))</span><br><span class="line">    ngx.log(ngx.ERR, sendmsg, err)</span><br><span class="line">    return ngx.exit(ngx.HTTP_OK)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function Main.main()</span><br><span class="line">--获取参数的值</span><br><span class="line">--POST 提交数据类型支持：application/x-www-form-urlencoded &amp; application/json</span><br><span class="line">local request_method = ngx.var.request_method</span><br><span class="line">local args = nil</span><br><span class="line">if &quot;GET&quot; == request_method then</span><br><span class="line">    args = ngx.req.get_uri_args()</span><br><span class="line">    -- 统计args 参数个数</span><br><span class="line">local count = 0</span><br><span class="line">for index,value in pairs(args) do</span><br><span class="line">   count = count + 1</span><br><span class="line">end</span><br><span class="line">--判断是否没有有效数据传输进来</span><br><span class="line">if count == 1 and args[&apos;apikey&apos;] ~= nil then</span><br><span class="line">Main.exit(0,&quot;exit,no useful data!&quot;)</span><br><span class="line">elseif count == 2 and  args[&apos;apikey&apos;] ~= nil and args[&apos;id&apos;] ~= nil then </span><br><span class="line">Main.exit(0,&quot;exit,no useful data!&quot;)</span><br><span class="line">end</span><br><span class="line">elseif &quot;POST&quot; == request_method then</span><br><span class="line">ngx.req.read_body()</span><br><span class="line">    str = ngx.req.get_body_data()</span><br><span class="line">ok,err = pcall(function(str) return cjson.decode(str) end, str)</span><br><span class="line">if not ok then</span><br><span class="line">args = ngx.req.get_post_args()</span><br><span class="line">else</span><br><span class="line">args = cjson.decode(ngx.req.get_body_data())</span><br><span class="line">end </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">--若没有传IP，则获取客户端的ip,如果有代理的，也获取的是客户端真实ip</span><br><span class="line">if args[&apos;ip&apos;] == nil and args[&apos;IP&apos;] == nil  then</span><br><span class="line">local myIP = ngx.req.get_headers()[&quot;X-Real-IP&quot;]</span><br><span class="line">if myIP == nil then</span><br><span class="line">    myIP = ngx.req.get_headers()[&quot;x_forwarded_for&quot;]</span><br><span class="line">end</span><br><span class="line">if myIP == nil then</span><br><span class="line">    myIP = ngx.var.remote_addr</span><br><span class="line">end</span><br><span class="line">args[&apos;ip&apos;] = myIP</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">--若没有请求时间，则写入接口访问时间</span><br><span class="line">if args[&apos;request_time&apos;] == nil and args[&apos;REQUEST_TIME&apos;] == nil  then</span><br><span class="line">date = os.date(&quot;%Y-%m-%d %H:%M:%S&quot;)</span><br><span class="line">args[&apos;request_time&apos;] =date</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">if args[&apos;time_stamp&apos;] == nil and args[&apos;TIME_STAMP&apos;] == nil  then</span><br><span class="line">args[&apos;time_stamp&apos;] =date</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local uri = ngx.var.uri </span><br><span class="line">Main.pushInRedis(uri, args)</span><br><span class="line">ngx.exit(ngx.HTTP_OK)</span><br><span class="line">--  --------------------end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">Main.main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lua收集Nginx请求参数&quot;&gt;&lt;a href=&quot;#Lua收集Nginx请求参数&quot; class=&quot;headerlink&quot; title=&quot;Lua收集Nginx请求参数&quot;&gt;&lt;/a&gt;Lua收集Nginx请求参数&lt;/h1&gt;&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="Nginx" scheme="http://blog.com/categories/Nginx/"/>
    
      <category term="OpenResty" scheme="http://blog.com/categories/Nginx/OpenResty/"/>
    
      <category term="Lua" scheme="http://blog.com/categories/Nginx/OpenResty/Lua/"/>
    
    
      <category term="Nginx" scheme="http://blog.com/tags/Nginx/"/>
    
      <category term="Lua" scheme="http://blog.com/tags/Lua/"/>
    
      <category term="OpenResty" scheme="http://blog.com/tags/OpenResty/"/>
    
  </entry>
  
  <entry>
    <title>Lua函数传递self的深入理解</title>
    <link href="http://blog.com/2019/09/19/Lua%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92self%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>http://blog.com/2019/09/19/Lua函数传递self的深入理解/</id>
    <published>2019-09-19T04:12:57.000Z</published>
    <updated>2019-09-19T15:35:56.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lua函数传递self的深入理解"><a href="#Lua函数传递self的深入理解" class="headerlink" title="Lua函数传递self的深入理解"></a>Lua函数传递self的深入理解</h1><blockquote><p>原文地址：<a href="https://blog.csdn.net/Qinhaifu/article/details/87721170" target="_blank" rel="noopener">https://blog.csdn.net/Qinhaifu/article/details/87721170</a></p></blockquote><p>现在假设我有一个模块</p><p><code>second.lua</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> second = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">second:funcA</span><span class="params">()</span></span></span><br><span class="line">    self.secondNum = <span class="number">5</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> second</span><br></pre></td></tr></table></figure><p>然后再写一个模块引用<code>second.lua</code></p><p><code>first.lua</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> second = <span class="built_in">require</span>(<span class="string">"second"</span>)</span><br><span class="line"><span class="keyword">local</span> first=&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first:funcB</span><span class="params">()</span></span></span><br><span class="line">second:funcA()</span><br><span class="line"><span class="built_in">print</span>(self.firstNum)</span><br><span class="line"><span class="built_in">print</span>(self.secondNum)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(first.firstNum)</span><br><span class="line">    <span class="built_in">print</span>(first.secondNum)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(second.firstNum)</span><br><span class="line"><span class="built_in">print</span>(second.secondNum)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">first.firstNum = <span class="number">5</span></span><br><span class="line">first:funcB()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> q</span><br></pre></td></tr></table></figure><p>第一次我们调用模块<code>second.lua</code>中的<code>funcA</code>使用<code>second:funcA()</code>的方式</p><p>此时三个打印结果如下图</p><p><img src="//blog.com/2019/09/19/Lua函数传递self的深入理解/1.png" alt=""></p><p>由打印结果：</p><p>1、此时函数<strong><code>first:funcB()</code>中的<code>self</code>是指对象<code>first</code></strong>，因为<code>first</code>有<code>firstNum</code>这个变量，所以<code>self.firstNum</code>打印出5。<br>但是因为没有<code>secondNum</code>这个变量，所以<code>self.secondNum</code>打印出<code>nil</code>；<br>即<code>first.secondNum</code>也打印出<code>nil</code></p><p>2、执行<strong><code>second:funcA()</code>这段代码时传递的<code>self</code>却是<code>second</code></strong>（意思在模块<code>second.lua</code>中函数<code>funcA ( )</code>中的<code>self</code>是<code>second</code>），生成了<code>self.secondNum</code>（就是<code>second.secondNum</code>）这个数据，所以<code>second.secondNum</code>打印出5。</p><p>因为<code>second</code>没有<code>firstNum</code>这个变量，所以<code>second.firstNum</code>打印出<code>nil</code>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> second = <span class="built_in">require</span>(<span class="string">"second"</span>)</span><br><span class="line"><span class="keyword">local</span> first=&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first:funcB</span><span class="params">()</span></span></span><br><span class="line">second.funcA(self)</span><br><span class="line"><span class="built_in">print</span>(self.firstNum)</span><br><span class="line"><span class="built_in">print</span>(self.secondNum)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(first.firstNum)</span><br><span class="line">    <span class="built_in">print</span>(first.secondNum)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(second.firstNum)</span><br><span class="line"><span class="built_in">print</span>(second.secondNum)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">first.firstNum = <span class="number">5</span></span><br><span class="line">first:funcB()</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> first</span><br></pre></td></tr></table></figure><p>稍微修改一下，此时通过<code>second.funcA(self)</code>这样手动传递<code>self</code>的方式调用。</p><p>打印结果如下</p><p><img src="//blog.com/2019/09/19/Lua函数传递self的深入理解/2.png" alt=""></p><p>此时可以看出<code>self.firstNum</code>和<code>self.secondNum</code>打印结果是5</p><p><code>first.firstNum</code>和<code>first.secondNum</code>都能打印结果都是5，</p><p>而<code>second.firstNum</code>和<code>second.secondNum</code>打印结果都是<code>nil</code>；</p><p>得出结论此时函数<code>first:funcB()</code>中的<code>self</code>依旧是<code>first</code>，所以<code>self.firstNum</code>结果是5</p><p>同时因为<code>second.funcA(self)</code>手动传递的是<code>self</code>（就是<code>first</code>）所以<code>first.secondNum</code>的结果也是5，同样<code>self.secondNum</code>也能打印出5；</p><p>而<code>second.firstNum</code>和<code>second.secondNum</code>都是<code>nil</code>值；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lua函数传递self的深入理解&quot;&gt;&lt;a href=&quot;#Lua函数传递self的深入理解&quot; class=&quot;headerlink&quot; title=&quot;Lua函数传递self的深入理解&quot;&gt;&lt;/a&gt;Lua函数传递self的深入理解&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;原
      
    
    </summary>
    
      <category term="Lua" scheme="http://blog.com/categories/Lua/"/>
    
    
      <category term="Lua" scheme="http://blog.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>Lua在Nginx的应用</title>
    <link href="http://blog.com/2019/09/19/Lua%E5%9C%A8Nginx%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://blog.com/2019/09/19/Lua在Nginx的应用/</id>
    <published>2019-09-19T04:12:57.000Z</published>
    <updated>2019-09-19T14:55:52.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lua在Nginx的应用"><a href="#Lua在Nginx的应用" class="headerlink" title="Lua在Nginx的应用"></a>Lua在Nginx的应用</h1><p>当 Nginx 标准模块和配置不能灵活地适应系统要求时，就可以考虑使用 Lua 扩展和定制 Nginx 服务。<a href="http://openresty.org/en/" target="_blank" rel="noopener">OpenResty</a> 集成了大量精良的 Lua 库、第三方模块，可以方便地搭建能够处理超高并发、扩展性极高的 Web 服务，所以这里选择 OpenResty 提供的 <a href="https://github.com/openresty/lua-nginx-module" target="_blank" rel="noopener">lua-nginx-module</a> 方案。</p><p><img src="//blog.com/2019/09/19/Lua在Nginx的应用/63113174-45d7-4a27-8472-d037675c2cbd.jpg" alt=""><a id="more"></a></p><h2 id="安装Lua环境"><a href="#安装Lua环境" class="headerlink" title="安装Lua环境"></a>安装Lua环境</h2><p>lua-nginx-module 依赖于 LuaJIT 和 ngx_devel_kit。LuaJIT 需要安装，ngx_devel_kit 只需下载源码包，在 Nginx 编译时指定 ngx_devel_kit 目录。</p><h3 id="系统依赖库"><a href="#系统依赖库" class="headerlink" title="系统依赖库"></a>系统依赖库</h3><p>首先确保系统已安装如下依赖库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> yum install readline-devel pcre-devel openssl-devel gcc</span><br></pre></td></tr></table></figure><h3 id="安装LuaJIT"><a href="#安装LuaJIT" class="headerlink" title="安装LuaJIT"></a>安装LuaJIT</h3><p>首先，安装 <a href="http://luajit.org/index.html" target="_blank" rel="noopener">LuaJIT</a> 环境，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wget http://luajit.org/download/LuaJIT-2.0.5.tar.gz</span><br><span class="line"><span class="meta">$</span> tar zxvf LuaJIT-2.0.5.tar.gz</span><br><span class="line"><span class="meta">$</span> cd LuaJIT-2.0.5</span><br><span class="line"><span class="meta">$</span> make install</span><br><span class="line"><span class="meta">#</span> 安装成功</span><br><span class="line">==== Successfully installed LuaJIT 2.0.5 to /usr/local ====</span><br></pre></td></tr></table></figure><p>设置 LuaJIT 有关的环境变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> export LUAJIT_LIB=/usr/local/lib</span><br><span class="line"><span class="meta">$</span> export LUAJIT_INC=/usr/local/include/luajit-2.0</span><br><span class="line"><span class="meta">$</span> echo "/usr/local/lib" &gt; /etc/ld.so.conf.d/usr_local_lib.conf</span><br><span class="line"><span class="meta">$</span> ldconfig</span><br></pre></td></tr></table></figure><h3 id="下载相关模块"><a href="#下载相关模块" class="headerlink" title="下载相关模块"></a>下载相关模块</h3><p>下载 <a href="https://github.com/simpl/ngx_devel_kit/tags" target="_blank" rel="noopener">ngx_devel_kit</a> 源码包，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wget https://github.com/simpl/ngx_devel_kit/archive/v0.3.0.tar.gz</span><br><span class="line"><span class="meta">$</span> tar zxvf v0.3.0.tar.gz</span><br><span class="line"><span class="meta">#</span> 解压缩后目录名</span><br><span class="line">ngx_devel_kit-0.3.0</span><br></pre></td></tr></table></figure><p><strong>接下来</strong>，下载 Lua 模块  <a href="https://github.com/openresty/lua-nginx-module" target="_blank" rel="noopener">lua-nginx-module</a> 源码包，为 Nginx 编译作准备。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wget https://github.com/openresty/lua-nginx-module/archive/v0.10.10.tar.gz</span><br><span class="line"><span class="meta">$</span> tar zxvf v0.10.10.tar.gz</span><br><span class="line"><span class="meta">#</span> 解压缩后目录名</span><br><span class="line">lua-nginx-module-0.10.10</span><br></pre></td></tr></table></figure><h3 id="加载Lua模块"><a href="#加载Lua模块" class="headerlink" title="加载Lua模块"></a>加载Lua模块</h3><p>Nginx 1.9 版本后可以动态加载模块，但这里由于版本太低只能重新编译安装 Nginx。下载 Nginx 源码包并解压：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wget http://nginx.org/download/nginx-1.13.5.tar.gz</span><br><span class="line"><span class="meta">$</span> tar zxvf nginx-1.13.5.tar.gz</span><br></pre></td></tr></table></figure><p>编译并重新安装 Nginx：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd nginx-1.13.5</span><br><span class="line"><span class="meta">#</span> 增加--add-module=/usr/src/lua-nginx-module-0.10.10 --add-module=/usr/src/ngx_devel_kit-0.3.0</span><br><span class="line"><span class="meta">$</span> ./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-http_v2_module --with-http_stub_status_module --with-pcre --add-module=/usr/src/lua-nginx-module-0.10.10 --add-module=/usr/src/ngx_devel_kit-0.3.0</span><br><span class="line"><span class="meta">$</span> make</span><br><span class="line"><span class="meta">$</span> make install</span><br><span class="line"><span class="meta">#</span> 查看是否安装成功</span><br><span class="line"><span class="meta">$</span> nginx -v</span><br></pre></td></tr></table></figure><h3 id="配置Nginx环境"><a href="#配置Nginx环境" class="headerlink" title="配置Nginx环境"></a>配置Nginx环境</h3><p>现在只需配置 Nginx，即可嵌入 Lua 脚本。首先，在 http 部分配置 Lua 模块和第三方库路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 第三方库（cjson）地址luajit-2.0/lib</span><br><span class="line">lua_package_path &apos;/home/www/lua/?.lua;;&apos;;</span><br><span class="line">lua_package_cpath &apos;/usr/local/include/luajit-2.0/lib/?.so;;&apos;;</span><br></pre></td></tr></table></figure><p>接着，配置一个 Lua 脚本服务：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hello world测试</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">location</span> /lua_content &#123;</span><br><span class="line">        <span class="comment"># 定义MIME类型</span></span><br><span class="line">        <span class="attribute">default_type</span> <span class="string">'text/plain'</span>;</span><br><span class="line">        <span class="section">content_by_lua_block</span> &#123;</span><br><span class="line">            ngx.say('Hello,world!')</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试安装和配置是否正常：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> service nginx test</span><br><span class="line"><span class="meta">$</span> service nginx reload</span><br><span class="line"><span class="meta">#</span> 访问地址/lua_content输出</span><br><span class="line">Hello,world!</span><br></pre></td></tr></table></figure><h2 id="Lua调用Nginx"><a href="#Lua调用Nginx" class="headerlink" title="Lua调用Nginx"></a>Lua调用Nginx</h2><p>lua-nginx-module 模块中已经为 Lua 提供了丰富的 Nginx 调用 API，每个 API 都有各自的作用环境，详细描述见 <a href="https://github.com/openresty/lua-nginx-module#nginx-api-for-lua" target="_blank" rel="noopener">Nginx API for Lua</a>。这里只列举基本 API 的使用 。</p><p>先配一个 Lua 脚本服务，配置文件如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ /lua_api</span> &#123;  </span><br><span class="line">    <span class="comment"># 示例用的Nginx变量  </span></span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$name</span> <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">default_type</span> <span class="string">"text/html"</span>;  </span><br><span class="line">    <span class="comment"># 通过Lua文件进行内容处理</span></span><br><span class="line">    <span class="attribute">content_by_lua_file</span> /home/www/nginx-api.lua;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="请求部分"><a href="#请求部分" class="headerlink" title="请求部分"></a>请求部分</h3><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxvarvariable" target="_blank" rel="noopener">ngx.var</a></li></ul><p>可以通过<code>ngx.var.var_name</code>形式获取或设置 Nginx 变量值，例如 request_uri、host、request 等。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ngx.say打印内容</span></span><br><span class="line">ngx.say(ngx.var.request_uri)</span><br><span class="line">ngx.var.name = <span class="string">'www.fanhaobai.com'</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxreqget_headers" target="_blank" rel="noopener">ngx.req.get_headers()</a></li></ul><p>该方法会以表的形式返回当前请求的头信息。查看请求的头信息：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(<span class="string">'Host : '</span>, ngx.req.get_headers().host, <span class="string">'&lt;br&gt;'</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(ngx.req.get_headers()) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(v) == <span class="string">"table"</span> <span class="keyword">then</span></span><br><span class="line">        ngx.say(k, <span class="string">" : "</span>, <span class="built_in">table</span>.<span class="built_in">concat</span>(v, <span class="string">","</span>), <span class="string">'&lt;br&gt;'</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ngx.say(k,<span class="string">" : "</span>, v, <span class="string">'&lt;br&gt;'</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>当然，通过 <a href="https://github.com/openresty/lua-nginx-module#ngxreqset_header" target="_blank" rel="noopener">ngx.req.set_header()</a> 也可以设置头信息。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_header(<span class="string">"Content-Type"</span>, <span class="string">"text/html"</span>)</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxreqget_uri_args" target="_blank" rel="noopener">ngx.req.get_uri_args()</a></li></ul><p>该方法以表形式返回当前请求的所有 GET 参数。查看请求 query 为<code>?name=fhb</code>的 GET 参数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(<span class="string">'name : '</span>, ngx.req.get_uri_args().name, <span class="string">'&lt;br&gt;'</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(ngx.req.get_uri_args()) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(v) == <span class="string">"table"</span> <span class="keyword">then</span></span><br><span class="line">        ngx.say(k, <span class="string">" : "</span>, <span class="built_in">table</span>.<span class="built_in">concat</span>(v, <span class="string">","</span>), <span class="string">'&lt;br&gt;'</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ngx.say(k,<span class="string">" : "</span>, v, <span class="string">'&lt;br&gt;'</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>同样，可以通过 <a href="https://github.com/openresty/lua-nginx-module#ngxreqset_uri_args" target="_blank" rel="noopener">ngx.req.set_uri_args()</a> 设置请求的所有 GET 参数。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.req.set_uri_args(&#123;name=<span class="string">'fhb'</span>&#125;) <span class="comment">--&#123;name='fhb'&#125;可以为query形式name=fhb</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxreqget_post_args" target="_blank" rel="noopener">get_post_args()</a></li></ul><p>该方法以表形式返回当前请求的所有 POST 参数，POST 数据必须是 application/x-www-form-urlencoded 类型。查看请求<code>curl --data &#39;name=fhb&#39; localhost/lua_api</code>的 POST 参数：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--必须先读取body体</span></span><br><span class="line">ngx.req.read_body()</span><br><span class="line">ngx.say(<span class="string">'name : '</span>, ngx.req.get_post_args().name, <span class="string">'&lt;br&gt;'</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(ngx.req.get_post_args()) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span>(v) == <span class="string">"table"</span> <span class="keyword">then</span></span><br><span class="line">        ngx.say(k, <span class="string">" : "</span>, <span class="built_in">table</span>.<span class="built_in">concat</span>(v, <span class="string">","</span>), <span class="string">'&lt;br&gt;'</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ngx.say(k,<span class="string">" : "</span>, v, <span class="string">'&lt;br&gt;'</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>通过 <a href="https://github.com/openresty/lua-nginx-module#ngxreqget_body_data" target="_blank" rel="noopener">ngx.req.get_body_data()</a> 方法可以获取未解析的请求 body 体内容字符串。</p><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxreqget_method" target="_blank" rel="noopener">ngx.req.get_method()</a></li></ul><p>获取请求的大写字母形式的请求方式，通过 <a href="https://github.com/openresty/lua-nginx-module#ngxreqset_method" target="_blank" rel="noopener">ngx.req.set_method()</a> 可以设置请求方式。例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(ngx.req.get_method())</span><br></pre></td></tr></table></figure><h3 id="响应部分"><a href="#响应部分" class="headerlink" title="响应部分"></a>响应部分</h3><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxheaderheader" target="_blank" rel="noopener">ngx.header</a></li></ul><p>通过<code>ngx.header.header_name</code>的形式获取或设置响应头信息。如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ngx.say(ngx.header.content_type)</span><br><span class="line">ngx.header.content_type = <span class="string">'text/plain'</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/openresty/lua-nginx-module#print" target="_blank" rel="noopener">ngx.print()</a></li></ul><p>ngx.print() 方法会填充指定内容到响应 body 中。如下所示：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.<span class="built_in">print</span>(ngx.header.content_type)</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxsay" target="_blank" rel="noopener">ngx.say()</a></li></ul><p>如上述使用，ngx.say() 方法同 ngx.print() 方法，只是会在后追加一个换行符。</p><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxexit" target="_blank" rel="noopener">ngx.exit()</a></li></ul><p>以某个状态码返回响应内容，状态码常量对应关系见 <a href="https://github.com/openresty/lua-nginx-module#http-status-constants" target="_blank" rel="noopener">HTTP status constants</a> 部分，也支持数字形式的状态码。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.<span class="built_in">exit</span>(<span class="number">403</span>)</span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxredirect" target="_blank" rel="noopener">ngx.redirect()</a></li></ul><p>重定向当前请求到新的 url，响应状态码可选列表为 301、302（默认）、303、307。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ngx.redirect(<span class="string">'http://www.fanhaobai.com'</span>)</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxrematch" target="_blank" rel="noopener">ngx.re.match</a></li></ul><p>该方法提供了正则表达式匹配方法。请求<code>?name=fhb&amp;age=24</code>匹配 GET 参数中的数字：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> m, err = ngx.re.<span class="built_in">match</span>(ngx.req.set_uri_args, <span class="string">"[0-9]+"</span>)</span><br><span class="line"><span class="keyword">if</span> m <span class="keyword">then</span></span><br><span class="line">    ngx.say(m[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ngx.say(<span class="string">"match not found"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxlog" target="_blank" rel="noopener">ngx.log()</a></li></ul><p>通过该方法可以将内容写入 Nginx 日志文件，日志文件级别需同 log 级别一致。</p><ul><li><a href="https://github.com/openresty/lua-nginx-module#ngxmd5" target="_blank" rel="noopener">ngx.md5()</a> | <a href="https://github.com/openresty/lua-nginx-module#ngxencode_base64" target="_blank" rel="noopener">ngx.encode_base64()</a> | ngx.decode_base64()</li></ul><p>它们都是字符串编码方式。ngx.md5() 可以对字符串进行 md5 加密处理，而 ngx.encode_base64() 是对字符串 base64 编码， ngx.decode_base64() 为 base64 解码。</p><h2 id="Nginx中嵌入Lua"><a href="#Nginx中嵌入Lua" class="headerlink" title="Nginx中嵌入Lua"></a>Nginx中嵌入Lua</h2><p>上面讲述了怎么在 Lua 中调用 Nginx 的 API 来扩展或定制 Nginx 的功能，那么编写好的 Lua 脚本怎么在 Nginx 中得到执行呢？其实，Nginx 是通过模块指令形式在其 11 个处理阶段做插入式处理，指令覆盖 http、server、server if、location、location if 这几个范围。</p><h3 id="模块指令列表"><a href="#模块指令列表" class="headerlink" title="模块指令列表"></a>模块指令列表</h3><p>这里只列举基本的 Lua 模块指令，更多信息参考 <a href="https://www.nginx.com/resources/wiki/modules/lua/#directives" target="_blank" rel="noopener">Directives</a> 部分。</p><table><thead><tr><th>指令</th><th>所在阶段</th><th>使用范围</th><th>说明</th></tr></thead><tbody><tr><td>init_by_lua<br>init_by_lua_file</td><td>加载配置文件</td><td>http</td><td>可以用于初始化全局配置</td></tr><tr><td>set_by_lua<br>set_by_lua_file</td><td>rewrite</td><td>server<br>location<br>location if</td><td>复杂逻辑的变量赋值，注意是阻塞的</td></tr><tr><td>rewrite_by_lua<br>rewrite_by_lua_file</td><td>rewrite</td><td>http<br>server<br>location<br>location if</td><td>实现复杂逻辑的转发或重定向</td></tr><tr><td>content_by_lua<br>content_by_lua_file</td><td>content</td><td>location<br>location if</td><td>处理请求并输出响应</td></tr><tr><td>header_filter_by_lua<br>header_filter_by_lua_file</td><td>响应头信息过滤</td><td>http<br>server<br>location<br>location if</td><td>设置响应头信息</td></tr><tr><td>body_filter_by_lua<br>body_filter_by_lua_file</td><td>输出过滤</td><td>http<br>server<br>location<br>location if</td><td>对输出进行过滤或修改</td></tr></tbody></table><h3 id="使用指令"><a href="#使用指令" class="headerlink" title="使用指令"></a>使用指令</h3><p>注意到，每个指令都会有<code>*_lua</code>和<code>*_lua_file</code>两个指令，<code>*_lua</code>指令后为 Lua 代码块，而<code>*_lua_file</code>指令后为 Lua 脚本文件路径。下面将只对<code>*_lua</code>指令进行说明。</p><ul><li>init_by_lua</li></ul><p>该指令会在 Nginx 的 Master 进程加载配置时执行，所以可以完成 Lua 模块初始化工作，Worker 进程同样会继承这些。</p><p><code>nginx.conf</code>配置文件中的 http 部分添加如下代码：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 所有worker共享的全局变量</span><br><span class="line"><span class="attribute">lua_shared_dict</span> shared_data <span class="number">1m</span>;  </span><br><span class="line"><span class="attribute">init_by_lua_file</span> /usr/example/lua/init.lua;</span><br></pre></td></tr></table></figure><p><code>init.lua</code>初始化脚本为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> cjson = <span class="built_in">require</span> <span class="string">'cjson'</span></span><br><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span> <span class="string">'resty.redis'</span></span><br><span class="line"><span class="keyword">local</span> shared_data = ngx.shared.shared_data</span><br></pre></td></tr></table></figure><ul><li>set_by_lua</li></ul><p>我们直接使用 set 指令很难实现很复杂的变量赋值逻辑，而 set_by_lua 模块指令就可以解决这个问题。</p><p><code>nginx.conf</code>配置文件 location 部分内容为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /lua &#123;</span><br><span class="line">    <span class="attribute">set_by_lua_file</span> <span class="variable">$num</span> /home/www/set.lua;</span><br><span class="line">    <span class="attribute">default_type</span> <span class="string">'text/html'</span>;</span><br><span class="line">    <span class="attribute">echo</span> <span class="variable">$num</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>set.lua</code>脚本内容为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> uri_args = ngx.req.get_uri_args()</span><br><span class="line"><span class="keyword">local</span> i = uri_args.a <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">local</span> j = uri_args.b <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> i + j</span><br></pre></td></tr></table></figure><p>上述赋值逻辑，请求 query 为<code>?a=10&amp;b=2</code>时响应内容为 12。</p><ul><li>rewrite_by_lua</li></ul><p>可以实现内部 URL 重写或者外部重定向。<code>nginx.conf</code>配置如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /lua &#123;</span><br><span class="line">    <span class="attribute">default_type</span> <span class="string">"text/html"</span>;</span><br><span class="line">    <span class="attribute">rewrite_by_lua_file</span> /home/www/rewrite.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rewrite.lua</code>脚本内容：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ngx.req.get_uri_args()[<span class="string">"type"</span>] == <span class="string">"app"</span> <span class="keyword">then</span></span><br><span class="line">    ngx.req.set_uri(<span class="string">"/m_h5"</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>access_by_lua</li></ul><p>用于访问权限控制。例如，只允许带有身份标识用户访问，<code>nginx.conf</code>配置为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /lua &#123;  </span><br><span class="line">    <span class="attribute">default_type</span> <span class="string">"text/html"</span>;</span><br><span class="line">    <span class="attribute">access_by_lua_file</span> /home/www/access.lua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>access.lua</code>脚本内容为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ngx.req.get_uri_args()[<span class="string">"token"</span>] == <span class="string">"fanhb"</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> ngx.<span class="built_in">exit</span>(<span class="number">403</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>content_by_lua</li></ul><p>该指令在 <a href="#Lua调用Nginx">Lua 调用 Nginx</a> 部分已经使用过了，用于输出响应内容。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="访问权限控制"><a href="#访问权限控制" class="headerlink" title="访问权限控制"></a>访问权限控制</h3><p>使用 Lua 模块对本站的 ES 服务做受信操作控制，即非受信 IP 只能查询操作。<code>nginx.conf</code>配置如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    set $allowed <span class="string">'115.171.226.212'</span>;</span><br><span class="line">    access_by_lua_block &#123;</span><br><span class="line">        <span class="keyword">if</span> ngx.re.<span class="built_in">match</span>(ngx.req.get_method(), <span class="string">"PUT|POST|DELETE"</span>) <span class="keyword">and</span> <span class="keyword">not</span> ngx.re.<span class="built_in">match</span>(ngx.var.request_uri, <span class="string">"_search"</span>) <span class="keyword">then</span></span><br><span class="line">    start, _ = <span class="built_in">string</span>.<span class="built_in">find</span>(ngx.var.allowed, ngx.var.remote_addr)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> start <span class="keyword">then</span></span><br><span class="line">ngx.<span class="built_in">exit</span>(<span class="number">403</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proxy_pass http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9200</span>$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问频率控制"><a href="#访问频率控制" class="headerlink" title="访问频率控制"></a>访问频率控制</h3><p>在 Nginx 配置文件的 location 部分配置 Lua 脚本基本参数，并配置 Lua 模块指令：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">default_type</span> <span class="string">"text/html"</span>;</span><br><span class="line"><span class="attribute">set</span> rate_per <span class="number">300</span></span><br><span class="line">access_by_lua_file /home/www/access.lua;</span><br></pre></td></tr></table></figure><p>Lua 脚本实现频率控制逻辑，使用 Redis 对单位时间内的访问次数做缓存，key 为访问 uri 拼接 token 后的 md5 值。具体内容如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> redis = <span class="built_in">require</span> <span class="string">"resty.redis"</span></span><br><span class="line"><span class="keyword">local</span> red = redis:new()</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ngx.var.rate_per) <span class="keyword">or</span> <span class="number">200</span></span><br><span class="line"><span class="keyword">local</span> expire_time = <span class="built_in">tonumber</span>(ngx.var.rate_expire) <span class="keyword">or</span> <span class="number">1000</span></span><br><span class="line"><span class="keyword">local</span> key = <span class="string">"rate.limit:string:"</span></span><br><span class="line"></span><br><span class="line">red:set_timeout(<span class="number">500</span>)</span><br><span class="line"><span class="keyword">local</span> ok, err = red:connect(<span class="string">"www.fanhaobai.com"</span>, <span class="number">6379</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">    ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">"failed to connect redis: "</span> .. err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">key = key .. ngx.md5(ngx.var.request_uri .. (ngx.req.get_uri_args()[<span class="string">'token'</span>] <span class="keyword">or</span> ngx.req.get_post_args()[<span class="string">'token'</span>]))</span><br><span class="line"><span class="keyword">local</span> times, err = red:incr(key)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> times <span class="keyword">then</span></span><br><span class="line">    ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">"failed to exec incr: "</span> .. err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"><span class="keyword">elseif</span> times == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    ok, err = red:expire(key, expire_time)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">        ngx.<span class="built_in">log</span>(ngx.ERR, <span class="string">"failed to exec expire: "</span> .. err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> times &gt; limit <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> ngx.<span class="built_in">exit</span>(<span class="number">403</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Lua在Nginx的应用&quot;&gt;&lt;a href=&quot;#Lua在Nginx的应用&quot; class=&quot;headerlink&quot; title=&quot;Lua在Nginx的应用&quot;&gt;&lt;/a&gt;Lua在Nginx的应用&lt;/h1&gt;&lt;p&gt;当 Nginx 标准模块和配置不能灵活地适应系统要求时，就可以考虑使用 Lua 扩展和定制 Nginx 服务。&lt;a href=&quot;http://openresty.org/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenResty&lt;/a&gt; 集成了大量精良的 Lua 库、第三方模块，可以方便地搭建能够处理超高并发、扩展性极高的 Web 服务，所以这里选择 OpenResty 提供的 &lt;a href=&quot;https://github.com/openresty/lua-nginx-module&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lua-nginx-module&lt;/a&gt; 方案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//blog.com/2019/09/19/Lua在Nginx的应用/63113174-45d7-4a27-8472-d037675c2cbd.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Nginx" scheme="http://blog.com/categories/Nginx/"/>
    
      <category term="OpenResty" scheme="http://blog.com/categories/Nginx/OpenResty/"/>
    
      <category term="Lua" scheme="http://blog.com/categories/Nginx/OpenResty/Lua/"/>
    
    
      <category term="Nginx" scheme="http://blog.com/tags/Nginx/"/>
    
      <category term="Lua" scheme="http://blog.com/tags/Lua/"/>
    
      <category term="OpenResty" scheme="http://blog.com/tags/OpenResty/"/>
    
  </entry>
  
  <entry>
    <title>错误处理</title>
    <link href="http://blog.com/2019/09/19/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <id>http://blog.com/2019/09/19/错误处理/</id>
    <published>2019-09-19T04:12:57.000Z</published>
    <updated>2019-09-19T14:53:07.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;程序运行中错误处理是必要的，在我们进行文件操作，数据转移及web service 调用过程中都会出现不可预期的错误。如果不注重错误信息的处理，就会造成信息泄露，程序无法运行等情况。</p><p>任何程序语言中，都需要错误处理。错误类型有：</p><ul><li>语法错误</li><li>运行错误</li></ul><hr><h2 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h2><p>语法错误通常是由于对程序的组件（如运算符、表达式）使用不当引起的。一个简单的实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- test.lua 文件</span><br><span class="line">a == 2</span><br></pre></td></tr></table></figure><p>以上代码执行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua: test.lua:2: syntax error near &apos;==&apos;</span><br></pre></td></tr></table></figure><p>正如你所看到的，以上出现了语法错误，一个 “=” 号跟两个 “=” 号是有区别的。一个 “=” 是赋值表达式两个 “=” 是比较运算。</p><p>另外一个实例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for a= 1,10</span><br><span class="line">   print(a)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>执行以上程序会出现如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lua: test2.lua:2: &apos;do&apos; expected near &apos;print&apos;</span><br></pre></td></tr></table></figure><p>语法错误比程序运行错误更简单，运行错误无法定位具体错误，而语法错误我们可以很快的解决，如以上实例我们只要在for语句下添加 do 即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for a= 1,10</span><br><span class="line">do</span><br><span class="line">   print(a)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><hr><p><strong>语法错误无法被捕获</strong></p><h2 id="运行错误"><a href="#运行错误" class="headerlink" title="运行错误"></a>运行错误</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>运行错误是程序可以正常执行，但是会输出报错信息</strong>。如下实例由于参数输入错误，程序执行时报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(a,b)</span><br><span class="line">   return a+b</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">add(10)</span><br></pre></td></tr></table></figure><p>当我们编译运行以下代码时，编译是可以成功的，但在运行的时候会产生如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lua: test2.lua:2: attempt to perform arithmetic on local &apos;b&apos; (a nil value)</span><br><span class="line">stack traceback:</span><br><span class="line">    test2.lua:2: in function &apos;add&apos;</span><br><span class="line">    test2.lua:5: in main chunk</span><br><span class="line">    [C]: ?</span><br></pre></td></tr></table></figure><p>以下报错信息是由于程序缺少 b 参数引起的。</p><h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><h4 id="error函数"><a href="#error函数" class="headerlink" title="error函数"></a>error函数</h4><p>语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error (message [, level])</span><br></pre></td></tr></table></figure><p>功能：终止正在执行的函数，并返回message的内容作为错误信息(error函数永远都不会返回)</p><p>通常情况下，error会附加一些错误位置的信息到message头部。</p><p>Level参数指示获得错误的位置:</p><ul><li>Level=1[默认]：为调用error位置(文件+行号)</li><li>Level=2：指出哪个调用error的函数的函数</li><li>Level=0:不添加错误位置信息</li></ul><hr><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span><span class="params">(a, b)</span></span></span><br><span class="line">    <span class="keyword">if</span> (a&lt;<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">       <span class="built_in">error</span>(<span class="string">"a的值必须大于10"</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> (b&lt;<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">       <span class="built_in">error</span>(<span class="string">"b的值必须大于10"</span>)</span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func1(<span class="number">5</span>, <span class="number">10</span>))</span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">lua: hello.lua:17: a的值必须大于10</span></span><br><span class="line"><span class="comment">    stack traceback:</span></span><br><span class="line"><span class="comment">        [C]: in function 'error'</span></span><br><span class="line"><span class="comment">        hello.lua:17: in function 'func1'</span></span><br><span class="line"><span class="comment">        hello.lua:25: in main chunk</span></span><br><span class="line"><span class="comment">        [C]: ?</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func1(<span class="number">10</span>, <span class="number">9</span>))</span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">lua: hello.lua:21: b的值必须大于10</span></span><br><span class="line"><span class="comment">    stack traceback:</span></span><br><span class="line"><span class="comment">        [C]: in function 'error'</span></span><br><span class="line"><span class="comment">        hello.lua:21: in function 'func1'</span></span><br><span class="line"><span class="comment">        hello.lua:25: in main chunk</span></span><br><span class="line"><span class="comment">        [C]: ?</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func1(<span class="number">10</span>, <span class="number">10</span>)) <span class="comment">-- 20</span></span><br></pre></td></tr></table></figure><h4 id="assert函数"><a href="#assert函数" class="headerlink" title="assert函数"></a>assert函数</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>assert首先检查第一个参数，若没问题，assert不做任何事情；否则，assert以第二个参数作为错误信息抛出</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(a,b)</span></span></span><br><span class="line">   <span class="built_in">assert</span>(<span class="built_in">type</span>(a) == <span class="string">"number"</span>, <span class="string">"a 不是一个数字"</span>)</span><br><span class="line">   <span class="built_in">assert</span>(<span class="built_in">type</span>(b) == <span class="string">"number"</span>, <span class="string">"b 不是一个数字"</span>)</span><br><span class="line">   <span class="keyword">return</span> a+b</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">add(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>执行以上程序会出现如下错误：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lua: test.lua:<span class="number">3</span>: b 不是一个数字</span><br><span class="line">stack <span class="built_in">traceback</span>:</span><br><span class="line">    [C]: <span class="keyword">in</span> <span class="function"><span class="keyword">function</span> '<span class="title">assert</span>'</span></span><br><span class="line"><span class="function">    <span class="title">test.lua</span>:3: <span class="title">in</span> <span class="title">local</span> '<span class="title">add</span>'</span></span><br><span class="line"><span class="function">    <span class="title">test.lua</span>:6: <span class="title">in</span> <span class="title">main</span> <span class="title">chunk</span></span></span><br><span class="line"><span class="function">    [<span class="title">C</span>]: <span class="title">in</span> ?</span></span><br></pre></td></tr></table></figure><h3 id="错误捕获-pcall-和-xpcall、debug"><a href="#错误捕获-pcall-和-xpcall、debug" class="headerlink" title="错误捕获(pcall 和 xpcall、debug)"></a>错误捕获(pcall 和 xpcall、debug)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lua中处理错误，可以使用函数pcall（protected call）来包装需要执行的代码。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pcall接收一个函数和要传递给后者的参数，并执行，执行结果：有错误、无错误；<strong>返回值true或者或false, errorinfo</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;语法格式如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">pcall</span>(function_name, ….) <span class="keyword">then</span></span><br><span class="line"><span class="comment">-- 没有错误</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">-- 一些错误</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>简单实例</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">print</span>(a[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">status</span>, err = <span class="built_in">pcall</span>(test);</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">status</span> <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"正常，呵呵"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"哎，函数出错了，我正在帮你处理，放心吧，等我睡醒就...不是，等你睡醒就没事了~"</span>);</span><br><span class="line">   <span class="built_in">print</span>(err);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    哎，函数出错了，我正在帮你处理，放心吧，等我睡醒就...不是，等你睡醒就没事了~</span></span><br><span class="line"><span class="comment">    hello.lua:3: attempt to index global 'a' (a nil value)</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><p>pcall以一种”保护模式”来调用第一个参数，因此pcall可以捕获函数执行中的任何错误。</p><p>通常在错误发生时，希望落得更多的调试信息，而不只是发生错误的位置。但pcall返回时，它已经销毁了调用桟的部分内容。</p><p>Lua提供了xpcall函数，xpcall接收第二个参数——一个错误处理函数，当错误发生时，Lua会在调用桟展开（unwind）前调用错误处理函数，于是就可以在这个函数中使用debug库来获取关于错误的额外信息了。</p><p>debug库提供了两个通用的错误处理函数:</p><ul><li>debug.debug：提供一个Lua提示符，让用户来检查错误的原因</li><li>debug.traceback：根据调用桟来构建一个扩展的错误消息</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;=<span class="built_in">xpcall</span>(<span class="function"><span class="keyword">function</span><span class="params">(i)</span></span> <span class="built_in">print</span>(i) <span class="built_in">error</span>(<span class="string">'error..'</span>) <span class="keyword">end</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="built_in">print</span>(<span class="built_in">debug</span>.<span class="built_in">traceback</span>()) <span class="keyword">end</span>, <span class="number">33</span>)</span><br><span class="line"><span class="number">33</span></span><br><span class="line">stack <span class="built_in">traceback</span>:</span><br><span class="line"><span class="built_in">stdin</span>:<span class="number">1</span>: <span class="keyword">in</span> <span class="function"><span class="keyword">function</span> &lt;<span class="title">stdin</span>:1&gt;</span></span><br><span class="line"><span class="function">[<span class="title">C</span>]: <span class="title">in</span> <span class="title">function</span> '<span class="title">error</span>'</span></span><br><span class="line"><span class="function"><span class="title">stdin</span>:1: <span class="title">in</span> <span class="title">function</span> &lt;<span class="title">stdin</span>:1&gt;</span></span><br><span class="line"><span class="function">[<span class="title">C</span>]: <span class="title">in</span> <span class="title">function</span> '<span class="title">xpcall</span>'</span></span><br><span class="line"><span class="function"><span class="title">stdin</span>:1: <span class="title">in</span> <span class="title">main</span> <span class="title">chunk</span></span></span><br><span class="line"><span class="function">[<span class="title">C</span>]: <span class="title">in</span> ?</span></span><br><span class="line"><span class="function"><span class="title">false</span>        <span class="title">nil</span></span></span><br></pre></td></tr></table></figure><p>xpcall 使用实例 2:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myfunction</span> <span class="params">()</span></span></span><br><span class="line">   n = n/<span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myerrorhandler</span><span class="params">( err )</span></span></span><br><span class="line">   <span class="built_in">print</span>( <span class="string">"ERROR:"</span>, err )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">status</span> = <span class="built_in">xpcall</span>( myfunction, myerrorhandler )</span><br><span class="line"><span class="built_in">print</span>( <span class="built_in">status</span>)</span><br></pre></td></tr></table></figure><p>执行以上程序会出现如下错误：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR:    test2.lua:<span class="number">2</span>: attempt to perform arithmetic on global <span class="string">'n'</span> (a <span class="literal">nil</span> value)</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;错误处理&quot;&gt;&lt;a href=&quot;#错误处理&quot; class=&quot;headerlink&quot; title=&quot;错误处理&quot;&gt;&lt;/a&gt;错误处理&lt;/h1&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;程序运行中错误处理是必要的，在我们进行文件操作，数据
      
    
    </summary>
    
      <category term="Lua" scheme="http://blog.com/categories/Lua/"/>
    
    
      <category term="Lua" scheme="http://blog.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>进入Lua的世界</title>
    <link href="http://blog.com/2019/09/19/%E8%BF%9B%E5%85%A5Lua%E7%9A%84%E4%B8%96%E7%95%8C/"/>
    <id>http://blog.com/2019/09/19/进入Lua的世界/</id>
    <published>2019-09-19T04:12:57.000Z</published>
    <updated>2019-09-19T14:45:45.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进入Lua的世界"><a href="#进入Lua的世界" class="headerlink" title="进入Lua的世界"></a>进入Lua的世界</h1><p>Lua 是一个扩展式程序设计语言，作为一个强大、轻量的脚本语言，可以嵌入任何需要的程序中使用。Lua 被设计成一种动态类型语言，且它的语法相对较简单，这里只介绍其基本语法和使用方法，更多信息见 <a href="http://cloudwu.github.io/lua53doc/manual.html" target="_blank" rel="noopener">Lua 5.3 参考手册</a>。</p><p><img src="//blog.com/2019/09/19/进入Lua的世界/c391629e-be21-4038-ab25-b47fe368daeb.jpg" alt=""><a id="more"></a></p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Lua 作为通用型脚本语言，有 8 种基本数据类型：</p><table><thead><tr><th>类型</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>nil</td><td>只有一种值 nil<br>标识和别的任何值的差异</td><td>nil</td></tr><tr><td>boolean</td><td>两种值 false 和 true</td><td>false</td></tr><tr><td>number</td><td>实数（双精度浮点数）</td><td>520</td></tr><tr><td>string</td><td>字符串，不区分单双引号</td><td>“fhb”<br>‘fhb’</td></tr><tr><td>function</td><td>函数</td><td>function haha() <br>   return 1<br>end</td></tr><tr><td>userdata</td><td>将任意 C 数据保存在 Lua 变量</td><td></td></tr><tr><td>thread</td><td>区别独立的执行线程<br>用来实现协程</td><td></td></tr><tr><td>table</td><td>表，实现了一个关联数组<br>唯一一种数据结构</td><td>{1, 2, 3}</td></tr></tbody></table><p>使用库函数 <a href="https://www.codingnow.com/2000/download/lua_manual.html#pdf-type" target="_blank" rel="noopener">type()</a> 可以返回一个变量或标量的类型。有关数据类型需要说明的是：</p><ul><li><strong>nil</strong> 和 <strong>false</strong> 都能导致条件为假，而另外所有的值都被当作真</li><li>在 number 和 string 类型参与比较或者运算时，会存在隐式类型转化，当然也可以显示转化（tonumber()）</li><li>由于 table、 function、thread、userdata 的值是所谓的对象，变量本身只是一个对对象的引用，所以赋值、参数传递、函数返回，都是对这些对象的引用传递</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Lua 中有三类变量：全局变量、局部变量、还有 table 的域。<a href="">任何变量除非显式的以 local 修饰词定义为局部变量，否则都被定义为全局变量</a>，局部变量作用范围为函数或者代码块内。说明，在变量的首次赋值之前，变量的值均为 nil。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 行注释</span></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">块注释</span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line">globalVar = <span class="string">'is global'</span></span><br><span class="line"><span class="comment">-- if代码块</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">1</span> &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">   <span class="keyword">local</span> localVar = <span class="string">'is local'</span></span><br><span class="line">   <span class="built_in">print</span>(localVar)    <span class="comment">-- 可以访问局部变量</span></span><br><span class="line">   <span class="built_in">print</span>(globalVar)   <span class="comment">-- 可以访问全局变量</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(localVar)       <span class="comment">-- 不能访问局部变量</span></span><br><span class="line"><span class="built_in">print</span>(globalVar)      <span class="comment">-- 可以访问全局变量</span></span><br></pre></td></tr></table></figure><h2 id="标识符约定"><a href="#标识符约定" class="headerlink" title="标识符约定"></a>标识符约定</h2><p>Lua 中用到的名字（标识符）可以是任何非数字开头的字母、数字、下划线组成的字符串，同大多数语言保持一致。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>下面这些是保留的关键字，不能用作名字：</p><p><img src="//blog.com/2019/09/19/进入Lua的世界/fe33e61ca081f36909b9f2d16b5c9d4b.png" alt=""></p><p>大部分的流程控制关键字将在 <a href="#流程控制">流程控制</a> 部分说明。</p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p><img src="//blog.com/2019/09/19/进入Lua的世界/84414e900ee77fc8fd1baf9fc9c7a7d7.png" alt=""></p><p>大部分运算操作符将在 <a href="#表达式">表达式</a>  部分进行说明。</p><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>Lua 的一个执行单元叫做 chunk（语句组），一个语句组就是一串语句段，而 block（语句块）是一列语句段。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> block <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>下面将介绍 Lua 的主要流程控制语句。</p><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>Lua 中同样是用 if 语句作为条件流程控制语句，else if 或者 else 子句可以省略。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- exp为条件表达式，block为条件语句</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">exp</span> <span class="keyword">then</span></span><br><span class="line">   block</span><br><span class="line"><span class="keyword">elseif</span> <span class="built_in">exp</span> <span class="keyword">then</span></span><br><span class="line">   block</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   block</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>控制结构中的条件表达式可以返回任何值。 false 和 nil 都被认为是假，所有其它值都被认为是真。另外 Lua 中并没有提供 switch 子句，我们除了使用冗长的 if 子句外，怎么实现其他语言中的 <a href="">switch</a> 功能呢？</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 利用表实现</span></span><br><span class="line"><span class="keyword">local</span> switch = &#123;</span><br><span class="line">   [<span class="number">1</span>] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>    <span class="comment">-- 索引对应的域为匿名函数</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Case 1."</span></span><br><span class="line">   <span class="keyword">end</span>,</span><br><span class="line">   [<span class="number">2</span>] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Case 2."</span></span><br><span class="line">   <span class="keyword">end</span>,</span><br><span class="line">   [<span class="number">3</span>] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">"Case 3."</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">local</span> <span class="built_in">exp</span> = <span class="number">4</span>         <span class="comment">-- exp为条件表达式</span></span><br><span class="line"><span class="keyword">local</span> func = switch[<span class="built_in">exp</span>]</span><br><span class="line"><span class="comment">-- 实现switch-default功能</span></span><br><span class="line"><span class="keyword">if</span> (func) <span class="keyword">then</span></span><br><span class="line">   <span class="keyword">return</span> func()</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">return</span> <span class="string">"Case default."</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>Lua 支持 for、while、repeat 这三种循环子句。</p><p><a href="">while</a> 子句结构定义为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 结束条件为：循环条件==false</span></span><br><span class="line"><span class="keyword">while</span> 循环条件 <span class="keyword">do</span></span><br><span class="line">    代码块</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1+...+10的和</span></span><br><span class="line"><span class="keyword">local</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">local</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">   i = i + <span class="number">1</span></span><br><span class="line">   sum = sum + i</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><p><a href="">for</a> 子句结构定义为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">-- 结束条件为：变量&lt;=循环结束值  </span></span><br><span class="line"><span class="keyword">for</span> 变量=初值, 循环结束值, 步长 <span class="keyword">do</span></span><br><span class="line">   代码块</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1+...+10的和</span></span><br><span class="line"><span class="keyword">local</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">   sum = sum + i</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><p>另外，for 结合 in 关键字可以遍历 table 类型的数据，如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> names = &#123;<span class="string">'fhb'</span>, <span class="string">'lw'</span>, <span class="string">'lbf'</span>&#125;</span><br><span class="line"><span class="keyword">local</span> name;</span><br><span class="line"><span class="keyword">for</span> i,value <span class="keyword">in</span> <span class="built_in">ipairs</span>(names) <span class="keyword">do</span></span><br><span class="line">   <span class="keyword">if</span> i == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">      name = value</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> name</span><br></pre></td></tr></table></figure><p><a href="">repeat</a> 子句只有循环条件为 true 时，才退出循环。跟通常使用习惯相反，因此使用较少。其结构定义为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 结束条件为：循环条件==true</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">   代码块</span><br><span class="line"><span class="keyword">until</span> 循环条件</span><br><span class="line"><span class="comment">-- 1+...+10的和</span></span><br><span class="line"><span class="keyword">local</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">local</span> i = <span class="number">1</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">   i = i + <span class="number">1</span></span><br><span class="line">   sum = sum + i</span><br><span class="line"><span class="keyword">until</span> i &gt; <span class="number">10</span></span><br><span class="line"><span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure><h3 id="语句的退出"><a href="#语句的退出" class="headerlink" title="语句的退出"></a>语句的退出</h3><p>return 和 break 关键字都可以用来退出语句组，但 return 关键字可以用来退出函数和代码块，包括循环语句，而 break 关键字只能退出循环语句。</p><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>在 Lua 中由多个操作符和操作数组成一个表达式。</p><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>Lua 允许多重赋值。 因此，赋值的语法定义是等号左边是一系列变量， 而等号右边是一系列的表达式。 两边的元素都用逗号间。如果右值比需要的更多，多余的值就被忽略，如果右值的数量不够， 将会被扩展若干个 nil。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 变量简单赋值</span></span><br><span class="line">x = <span class="number">10</span></span><br><span class="line">y = <span class="number">20</span></span><br><span class="line"><span class="comment">-- 交换x和y的值</span></span><br><span class="line">x, y = y, x</span><br></pre></td></tr></table></figure><h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><p>Lua 支持常见的数学运算操作符，见下表：</p><table><thead><tr><th>操作符</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>+<br>-</td><td>加减运算</td><td>10 - 5</td></tr><tr><td>*<br>/</td><td>乘除运算</td><td>10 * 5</td></tr><tr><td>%</td><td>取模运算</td><td>10 % 5</td></tr><tr><td>^</td><td>求幂运算</td><td>4^(-0.5)</td></tr><tr><td>-</td><td>取负运算</td><td>-0.5</td></tr></tbody></table><p>需要指出的是，string 类型进行数学运算操作时，会隐式转化为 number 类型。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">'12'</span> / <span class="number">6</span>    <span class="comment">-- 返回2</span></span><br></pre></td></tr></table></figure><h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h3><p>Lua 中的比较操作符有见下表：</p><table><thead><tr><th>操作符</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>==</td><td>等于，为严格判断</td><td>“1” == 1 结果为 false</td></tr><tr><td>~=</td><td>不等于<br>等价于==操作的反值</td><td>“1”~=1 结果为 true</td></tr><tr><td>&lt;<br>&lt;=</td><td>小于或小于等于</td><td>1&lt;=2</td></tr><tr><td>&gt;<br>&gt;=</td><td>大于或大于等于</td><td>2&gt;=1</td></tr></tbody></table><p>比较运算的结果一定是 boolean 类型。<a href="">如果操作数都是数字，那么就直接做数字比较，如果操作数都是字符串，就用字符串比较的方式进行，否则，无法进行比较运算</a>。</p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>Lua 中的逻辑操作符有 and、or 以及 not，一样把 false 和 nil 都作为假， 而其它值都当作真。</p><table><thead><tr><th>操作符</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>and</td><td>与</td><td>10 and 20</td></tr><tr><td>or</td><td>或</td><td>10 or 20</td></tr><tr><td>not</td><td>取非</td><td>not false</td></tr></tbody></table><p>取反操作 not 总是返回 false 或 true 中的一个。 and 和 or 都遵循短路规则，也就是说 and 操作符在第一个操作数为 false 或 nil 时，返回这第一个操作数， 否则，and 返回第二个参数； or 操作符在第一个操作数不为 nil 和 false 时，返回这第一个操作数，否则返回第二个操作数。 </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span>           <span class="comment">--&gt; 20</span></span><br><span class="line"><span class="literal">nil</span> <span class="keyword">and</span> <span class="number">10</span>          <span class="comment">--&gt; nil</span></span><br><span class="line"><span class="number">10</span> <span class="keyword">or</span> <span class="number">20</span>            <span class="comment">--&gt; 10</span></span><br><span class="line"><span class="literal">nil</span> <span class="keyword">or</span> <span class="string">"a"</span>          <span class="comment">--&gt; "a"</span></span><br><span class="line"><span class="keyword">not</span> <span class="literal">false</span>           <span class="comment">--&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="其他运算"><a href="#其他运算" class="headerlink" title="其他运算"></a>其他运算</h3><p>Lua 中还有两种特别的操作符，分别为字符串连接操作符（..）和取长度操作符（#）。</p><p>特别说明： </p><ul><li>如果字符串连接操作符的操作数存在 number 类型，则会隐式转化为 string 类型</li><li>取长度操作符获取字符串的长度是它的字节数，table 的长度被定义成一个整数下标 n</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'1'</span> .. <span class="number">2</span>           <span class="comment">--&gt; '12'</span></span><br><span class="line">#<span class="string">'123'</span>             <span class="comment">--&gt; 3</span></span><br><span class="line">#&#123;<span class="number">1</span>, <span class="number">2</span>&#125;            <span class="comment">--&gt; 2</span></span><br></pre></td></tr></table></figure><h3 id="操作符优先级"><a href="#操作符优先级" class="headerlink" title="操作符优先级"></a>操作符优先级</h3><p>Lua 中操作符的优先级见下表，从低到高优先级顺序： </p><p><img src="//blog.com/2019/09/19/进入Lua的世界/fc34646b-5eaf-45ba-b89a-0d8fc3f1b71d.png" alt=""></p><p>运算符优先级通常是这样，但是可以用括号来改变运算次序。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在 Lua 中，函数是和字符串、数值和表并列的基本数据结构， 属于第一类对象( first-class-object)，可以和数值等其他类型一样赋给变量以及作为参数传递，同样可以作为返回值接收（闭包）。</p><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>函数在 Lua 中定义也很简单，基本结构为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- arg为参数列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">function_name</span><span class="params">(arg)</span></span></span><br><span class="line">　　body</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 阶乘函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fact</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 调用函数</span></span><br><span class="line"><span class="keyword">return</span> fact(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>可以用 local 关键字来修饰函数，表示局部函数。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">return</span> n * <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在 Lua 中有一个概念，函数与所有类型值一样都是匿名的，即它们都没有名称。当讨论一个函数名时，实际上是在讨论一个持有某函数的变量：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span> <span class="keyword">return</span> -x <span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 上述写法只是一种语法糖，是下述代码的简写形式</span></span><br><span class="line">f = <span class="function"><span class="keyword">function</span><span class="params">(x)</span></span> <span class="keyword">return</span> -x <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>Lua 中函数实参有两种传递方式，但大部分情况会进行值传递。</p><h4 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h4><p>当实参值为非 table 类型时，会采用值传递。几个传参规则如下：</p><ul><li>若实参个数大于形参个数，从左向右，多余的实参被忽略</li><li>若实参个数小于形参个数，从左向右，没有被初始化的形参被初始化为 nil</li><li>支持边长参数，用<code>...</code>表示</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义两个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(a, b)</span></span> <span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span><span class="params">(a, ...)</span></span> <span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 调用参数情况</span></span><br><span class="line">f(<span class="number">3</span>)             a=<span class="number">3</span>, b=<span class="literal">nil</span></span><br><span class="line">f(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)       a=<span class="number">3</span>, b=<span class="number">4</span></span><br><span class="line">g(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)       a=<span class="number">3</span>, ...  <span class="comment">--&gt; 4 5</span></span><br></pre></td></tr></table></figure><p>当函数为变长参数时，函数内使用<code>...</code>来获取变长参数，Lua 5.0 后<code>...</code>替换为名 arg 的隐含局部变量。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(...)</span></span></span><br><span class="line">   <span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(&#123;...&#125;) <span class="keyword">do</span></span><br><span class="line">      <span class="built_in">print</span>(k, v)</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">f(<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h4 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h4><p>当实参为 table 类型时，传递的只是实参的引用而已。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(arg)</span></span></span><br><span class="line">   <span class="built_in">arg</span>[<span class="number">3</span>] = <span class="string">'new'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> a = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">f(a)</span><br><span class="line"><span class="keyword">return</span> a[<span class="number">3</span>]        <span class="comment">--&gt; "new"</span></span><br></pre></td></tr></table></figure><h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>Lua 函数允许返回多个值，中间用逗号隔开。函数返回值接收规则：</p><ul><li>若返回值个数大于接收变量的个数，多余的返回值会被忽略</li><li>若返回值个数小于参数个数，从左向右，没有被返回值初始化的变量会被初始化为 nil</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span><span class="params">()</span></span> <span class="keyword">return</span> <span class="string">"a"</span> <span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span><span class="params">()</span></span> <span class="keyword">return</span> <span class="string">"a"</span>, <span class="string">"b"</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">x, y = f1()         <span class="comment">--&gt; x="a", y=nil</span></span><br><span class="line">x = f2()            <span class="comment">--&gt; x="a", "b"被丢弃</span></span><br><span class="line"><span class="comment">-- table构造式可以接受函数所有返回值</span></span><br><span class="line"><span class="keyword">local</span> tab = &#123;f2()&#125;  <span class="comment">--&gt; t=&#123;"a", "b"&#125;</span></span><br><span class="line"><span class="comment">-- ()会迫使函数返回一个结果</span></span><br><span class="line">printf((f2()))      <span class="comment">--&gt; "a"</span></span><br></pre></td></tr></table></figure><p>Lua 中除了我们自定义函数外，已经实现了部分功能函数，见 <a href="http://cloudwu.github.io/lua53doc/manual.html#6" target="_blank" rel="noopener">标准函数库</a>。</p><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><h3 id="定义和使用"><a href="#定义和使用" class="headerlink" title="定义和使用"></a>定义和使用</h3><p>Lua 中最特别的数据类型就是表（table），可以用来实现数组、Hash、对象，全局变量也使用表来管理。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- array</span></span><br><span class="line"><span class="keyword">local</span> array = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(array[<span class="number">1</span>], #array)          <span class="comment">--&gt; 1, 3</span></span><br><span class="line"><span class="comment">-- hash</span></span><br><span class="line"><span class="keyword">local</span> hash = &#123; a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(hash.a, hash[<span class="string">'b'</span>], #hash)  <span class="comment">--&gt; 1, 2, 0</span></span><br><span class="line"><span class="comment">-- array和hash</span></span><br><span class="line"><span class="keyword">local</span> tab = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">tab[<span class="string">'x'</span>] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">return</span> <span class="string">'hash'</span> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> &#123;tab.x, #tab&#125;             <span class="comment">--&gt; 2, 3</span></span><br></pre></td></tr></table></figure><p>说明：当表表示数组时，索引从 1 开始。</p><h3 id="元表"><a href="#元表" class="headerlink" title="元表"></a>元表</h3><p>元表（metatable）中的键名称为事件，值称为元方法，它用来定义原始值在特定操作下的行为。可通过 <a href="">getmetatable()</a> 来获取任一事件的元方法，同样可以通过 <a href="">setmetatable()</a> 覆盖任一事件的元方法。Lua 支持的表事件：</p><table><thead><tr><th>元方法</th><th>事件</th></tr></thead><tbody><tr><td>__add(table, value)<br>__sub(table, value)</td><td>+ 和 - 操作</td></tr><tr><td>__mul(table, value)<br>__div(table, value)</td><td>* 和 / 操作</td></tr><tr><td>__mod(table, value)<br>__pow(table, value)</td><td>% 和 ^ 操作</td></tr><tr><td>__concat(table, value)</td><td>.. 操作</td></tr><tr><td>__len(table)</td><td># 操作</td></tr><tr><td>__eq(table, value)<br>__lt(table, value)<br>__le(table, value)</td><td>== 、&lt;、&lt;= 操作</td></tr><tr><td>__index(table, index)<br>__newindex(table, index)</td><td>取和赋值下标操作</td></tr><tr><td>__call(table, …)</td><td>调用一个值</td></tr><tr><td>__tostring(table)</td><td>调用 tostring() 时</td></tr></tbody></table><p>覆盖这些元方法，即可实现重载运算符操作。例如重载 tostring 事件：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> hash = &#123; x = <span class="number">2</span>, y = <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">local</span> operator = &#123;</span><br><span class="line">    <span class="built_in">__tostring</span> = <span class="function"><span class="keyword">function</span><span class="params">(self)</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123; "</span> .. self.x .. <span class="string">", "</span> .. self.y .. <span class="string">" &#125;"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(hash, operator)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tostring</span>(hash))             <span class="comment">--&gt; "&#123; 2, 3 &#125;"</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Lua 是面向过程语言，使得可以简单易学。轻量级的特性，使得以脚本方式轻易地嵌入别的程序中，例如 <a href="https://pecl.php.net/package/lua" target="_blank" rel="noopener">PHP</a>、JAVA、<a href="https://redis.io/commands/eval" target="_blank" rel="noopener">Redis</a>、Nginx 等语言或应用。当然，Lua 也可以通过表实现面向对象编程。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进入Lua的世界&quot;&gt;&lt;a href=&quot;#进入Lua的世界&quot; class=&quot;headerlink&quot; title=&quot;进入Lua的世界&quot;&gt;&lt;/a&gt;进入Lua的世界&lt;/h1&gt;&lt;p&gt;Lua 是一个扩展式程序设计语言，作为一个强大、轻量的脚本语言，可以嵌入任何需要的程序中使用。Lua 被设计成一种动态类型语言，且它的语法相对较简单，这里只介绍其基本语法和使用方法，更多信息见 &lt;a href=&quot;http://cloudwu.github.io/lua53doc/manual.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Lua 5.3 参考手册&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//blog.com/2019/09/19/进入Lua的世界/c391629e-be21-4038-ab25-b47fe368daeb.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Lua" scheme="http://blog.com/categories/Lua/"/>
    
    
      <category term="Lua" scheme="http://blog.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>理解lua 语言中的点、冒号与self</title>
    <link href="http://blog.com/2019/09/19/%E7%90%86%E8%A7%A3lua%20%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%82%B9%E3%80%81%E5%86%92%E5%8F%B7%E4%B8%8Eself/"/>
    <id>http://blog.com/2019/09/19/理解lua 语言中的点、冒号与self/</id>
    <published>2019-09-19T04:12:57.000Z</published>
    <updated>2019-09-19T14:41:33.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="理解lua-语言中的点、冒号与self"><a href="#理解lua-语言中的点、冒号与self" class="headerlink" title="理解lua 语言中的点、冒号与self"></a>理解lua 语言中的点、冒号与self</h1><p>lua编程中，经常遇到函数的定义和调用，有时候用点号调用，有时候用冒号调用，这里简单的说明一下原理。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">girl = &#123;money = <span class="number">200</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">girl.goToMarket</span><span class="params">(girl ,someMoney)</span></span></span><br><span class="line">girl.money = girl.money - someMoney</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">girl.goToMarket(girl ,<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(girl.money)</span><br></pre></td></tr></table></figure><p>可以看出，这里进行了方法的点号定义和点号调用。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boy = &#123;money = <span class="number">200</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boy:goToMarket</span><span class="params">(someMoney)</span></span></span><br><span class="line">self.money = self.money - someMoney</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">boy:goToMarket(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(boy.money)</span><br></pre></td></tr></table></figure><p>这里进行了冒号定义和冒号调用。<br>以上的打印结果都是100。</p><p>可以看出，冒号定义和冒号调用其实跟上面的效果一样，<strong>只是把第一个隐藏参数省略了，而该参数self指向调用者自身</strong></p><p>当然了，我们也可以点号定义冒号调用，或者冒号定义点号调用<br>如:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boy = &#123;money = <span class="number">200</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boy.goToMarket</span><span class="params">(self ,someMoney)</span></span></span><br><span class="line">self.money = self.money - someMoney</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">boy:goToMarket(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(boy.money)</span><br></pre></td></tr></table></figure><p>总结:<strong>冒号只是起了省略第一个参数self的作用，该self指向调用者本身</strong>，并没有其他特殊的地方。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;理解lua-语言中的点、冒号与self&quot;&gt;&lt;a href=&quot;#理解lua-语言中的点、冒号与self&quot; class=&quot;headerlink&quot; title=&quot;理解lua 语言中的点、冒号与self&quot;&gt;&lt;/a&gt;理解lua 语言中的点、冒号与self&lt;/h1&gt;&lt;p&gt;lu
      
    
    </summary>
    
      <category term="Lua" scheme="http://blog.com/categories/Lua/"/>
    
    
      <category term="Lua" scheme="http://blog.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>文件 IO</title>
    <link href="http://blog.com/2019/09/19/%E6%96%87%E4%BB%B6%20IO/"/>
    <id>http://blog.com/2019/09/19/文件 IO/</id>
    <published>2019-09-19T04:12:57.000Z</published>
    <updated>2019-09-19T14:51:25.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件-IO"><a href="#文件-IO" class="headerlink" title="文件 IO"></a>文件 IO</h1><p>Lua I/O 库用于读取和处理文件。分为简单模式（和C一样）、完全模式。</p><ul><li>简单模式（simple model）拥有一个当前输入文件和一个当前输出文件，并且提供针对这些文件相关的操作。</li><li>完全模式（complete model） 使用外部的文件句柄来实现。它以一种面对对象的形式，将所有的文件操作定义为文件句柄的方法</li></ul><p>简单模式在做一些简单的文件操作时较为合适。但是在进行一些高级的文件操作的时候，简单模式就显得力不从心。例如同时读取多个文件这样的操作，使用完全模式则较为合适。</p><p>打开文件操作语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file = io.open (filename [, mode])</span><br></pre></td></tr></table></figure><p>mode 的值有：</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>r</td><td>以只读方式打开文件，该文件必须存在。</td></tr><tr><td>w</td><td>打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。</td></tr><tr><td>a</td><td>以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）</td></tr><tr><td>r+</td><td>以可读写方式打开文件，该文件必须存在。</td></tr><tr><td>w+</td><td>打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。</td></tr><tr><td>a+</td><td>与a类似，但此文件可读可写</td></tr><tr><td>b</td><td>二进制模式，如果文件是二进制文件，可以加上b</td></tr><tr><td>+</td><td>号表示对文件既可以读也可以写</td></tr></tbody></table><h2 id="简单模式"><a href="#简单模式" class="headerlink" title="简单模式"></a>简单模式</h2><p>简单模式使用标准的 I/O 或使用一个当前输入文件和一个当前输出文件。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 以只读方式打开文件</span></span><br><span class="line">file = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">"test.lua"</span>, <span class="string">"r"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置默认输入文件为 test.lua</span></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">input</span>(file)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 输出文件第一行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">io</span>.<span class="built_in">read</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭打开的文件</span></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">close</span>(file)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 以附加的方式打开只写文件</span></span><br><span class="line">file = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">"test.lua"</span>, <span class="string">"a"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置默认输出文件为 test.lua</span></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">output</span>(file)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在文件最后一行添加 Lua 注释</span></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">"--  test.lua 文件末尾注释"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭打开的文件</span></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">close</span>(file)</span><br></pre></td></tr></table></figure><h3 id="读取整个文件"><a href="#读取整个文件" class="headerlink" title="读取整个文件"></a>读取整个文件</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">"test.lua"</span>, <span class="string">"r"</span>)</span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">input</span>(file)</span><br><span class="line">line=<span class="built_in">io</span>.<span class="built_in">read</span>()</span><br><span class="line"><span class="keyword">while</span> (line)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line">    line=<span class="built_in">io</span>.<span class="built_in">read</span>()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">close</span>(file)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">content=<span class="built_in">io</span>.<span class="built_in">lines</span>(<span class="string">"test.lua"</span>);</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> content</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">print</span>(line)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p> io.read() 中我们没有带参数，参数可以是下表中的一个：</p><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>“*n”</td><td>读取一个数字并返回它。例：file.read(“*n”)</td></tr><tr><td>“*a”</td><td>从当前位置读取整个文件。例：file.read(“*a”)</td></tr><tr><td>“*l”（默认）</td><td>读取下一行，在文件尾 (EOF) 处返回 nil。例：file.read(“*l”)</td></tr><tr><td>number</td><td>返回一个指定字符个数的字符串，或在 EOF 时返回 nil。例：file.read(5)</td></tr></tbody></table><p>其他的 io 方法有：</p><ul><li><strong>io.tmpfile():</strong>返回一个临时文件句柄，该文件以更新模式打开，程序结束时自动删除</li><li><strong>io.type(file):</strong> 检测obj是否一个可用的文件句柄</li><li><strong>io.flush():</strong> 向文件写入缓冲中的所有数据</li><li><strong>io.lines(optional file name):</strong> 返回一个迭代函数,每次调用将获得文件中的一行内容,当到文件尾时，将返回nil,但不关闭文件</li></ul><h2 id="完全模式"><a href="#完全模式" class="headerlink" title="完全模式"></a>完全模式</h2><p>通常我们需要在同一时间处理多个文件。我们需要使用 file:function_name 来代替 io.function_name 方法。以下实例演示了如何同时处理同一个文件:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 以只读方式打开文件</span></span><br><span class="line">file = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">"test.lua"</span>, <span class="string">"r"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 输出文件第一行</span></span><br><span class="line"><span class="built_in">print</span>(file:<span class="built_in">read</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭打开的文件</span></span><br><span class="line">file:<span class="built_in">close</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 以附加的方式打开只写文件</span></span><br><span class="line">file = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">"test.lua"</span>, <span class="string">"a"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在文件最后一行添加 Lua 注释</span></span><br><span class="line">file:<span class="built_in">write</span>(<span class="string">"--test"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭打开的文件</span></span><br><span class="line">file:<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><p>执行以上代码，你会发现，输出了 test.ua 文件的第一行信息，并在该文件最后一行添加了 lua 的注释。如我这边输出的是：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- test.lua 文件</span></span><br></pre></td></tr></table></figure><p>read 的参数与简单模式一致。</p><p>其他方法:</p><ul><li><p><strong>file:seek(optional whence, optional offset):</strong> 设置和获取当前文件位置,成功则返回最终的文件位置(按字节),失败则返回nil加错误信息。参数 whence 值可以是:</p><ul><li>“set”: 从文件头开始</li><li>“cur”: 从当前位置开始[默认]</li><li>“end”: 从文件尾开始</li><li>offset:默认为0</li></ul><p>不带参数file:seek()则返回当前位置,file:seek(“set”)则定位到文件头,file:seek(“end”)则定位到文件尾并返回文件大小</p></li><li><p><strong>file:flush():</strong> 向文件写入缓冲中的所有数据</p></li><li><p><strong>io.lines(optional file name):</strong> 打开指定的文件filename为读模式并返回一个迭代函数,每次调用将获得文件中的一行内容,当到文件尾时，将返回nil,并自动关闭文件。<br>若不带参数时io.lines() &lt;=&gt; io.input():lines(); 读取默认输入设备的内容，但结束时不关闭文件,如</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>(<span class="string">"main.lua"</span>) <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">　　<span class="built_in">print</span>(line)</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul><p>以下实例使用了 seek 方法，定位到文件倒数第 25 个位置并使用 read 方法的 *a 参数，即从当期位置(倒数第 25 个位置)读取整个文件。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 以只读方式打开文件</span></span><br><span class="line">file = <span class="built_in">io</span>.<span class="built_in">open</span>(<span class="string">"test.lua"</span>, <span class="string">"r"</span>)</span><br><span class="line"></span><br><span class="line">file:seek(<span class="string">"end"</span>,<span class="number">-25</span>)</span><br><span class="line"><span class="built_in">print</span>(file:<span class="built_in">read</span>(<span class="string">"*a"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭打开的文件</span></span><br><span class="line">file:<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure><p>我这边输出的结果是：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">st.lua 文件末尾<span class="comment">--test</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件-IO&quot;&gt;&lt;a href=&quot;#文件-IO&quot; class=&quot;headerlink&quot; title=&quot;文件 IO&quot;&gt;&lt;/a&gt;文件 IO&lt;/h1&gt;&lt;p&gt;Lua I/O 库用于读取和处理文件。分为简单模式（和C一样）、完全模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单模式（si
      
    
    </summary>
    
      <category term="Lua" scheme="http://blog.com/categories/Lua/"/>
    
    
      <category term="Lua" scheme="http://blog.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://blog.com/2019/09/19/%E6%95%B0%E7%BB%84/"/>
    <id>http://blog.com/2019/09/19/数组/</id>
    <published>2019-09-19T04:12:57.000Z</published>
    <updated>2019-09-19T14:49:59.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组，就是相同数据类型的元素按一定顺序排列的集合，可以是一维数组和多维数组。</p><p>Lua 数组的索引键值可以使用整数表示，数组的大小不是固定的。</p><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">array = &#123;<span class="string">"Lua"</span>, <span class="string">"Tutorial"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i= <span class="number">0</span>, <span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(array[i])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">nil</span></span><br><span class="line"><span class="comment">    Lua</span></span><br><span class="line"><span class="comment">    Tutorial</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><p><strong>使用整数索引来访问数组元素，如果知道的索引没有值则返回nil</strong></p><p><strong>在 Lua 索引值是以 1 为起始，但你也可以指定 0 开始</strong></p><p>除此外我们还<strong>可以以负数为数组索引值    </strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">array = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i= <span class="number">-2</span>, <span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">   array[i] = i *<span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">-2</span>,<span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(array[i])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    -4</span></span><br><span class="line"><span class="comment">    -2</span></span><br><span class="line"><span class="comment">    0</span></span><br><span class="line"><span class="comment">    2</span></span><br><span class="line"><span class="comment">    4  </span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p><strong>多维数组即数组中包含数组或一维数组的索引键对应一个数组</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 初始化数组</span></span><br><span class="line">array = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">   array[i] = &#123;&#125;</span><br><span class="line">      <span class="keyword">for</span> j=<span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">         array[i][j] = i*j</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 访问数组</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">   <span class="keyword">for</span> j=<span class="number">1</span>,<span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">      <span class="built_in">print</span>(array[i][j])</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">    2</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">    2</span></span><br><span class="line"><span class="comment">    4</span></span><br><span class="line"><span class="comment">    6</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">    6</span></span><br><span class="line"><span class="comment">    9</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h1&gt;&lt;p&gt;数组，就是相同数据类型的元素按一定顺序排列的集合，可以是一维数组和多维数组。&lt;/p&gt;
&lt;p&gt;Lua 数组的索引键值可以使用整数表示，数组的大
      
    
    </summary>
    
      <category term="Lua" scheme="http://blog.com/categories/Lua/"/>
    
    
      <category term="Lua" scheme="http://blog.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>table(表)</title>
    <link href="http://blog.com/2019/09/19/table(%E8%A1%A8)/"/>
    <id>http://blog.com/2019/09/19/table(表)/</id>
    <published>2019-09-19T04:12:57.000Z</published>
    <updated>2019-09-19T14:49:01.129Z</updated>
    
    <content type="html"><![CDATA[<h1 id="table-表"><a href="#table-表" class="headerlink" title="table(表)"></a>table(表)</h1><p>table 是 Lua 的一种数据结构用来帮助我们创建不同的数据类型，如：数组、字典等。</p><p><strong>Lua table 使用关联型数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil</strong>。</p><p>Lua table 是不固定大小的，你可以根据自己需要进行扩容。</p><p>Lua也是通过table来解决模块（module）、包（package）和对象（Object）的。 例如string.format表示使用”format”来索引table string。</p><h2 id="table-表-的构造"><a href="#table-表-的构造" class="headerlink" title="table(表)的构造"></a>table(表)的构造</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>构造器是创建和初始化表的表达式</strong>。表是Lua特有的功能强大的东西。<strong>最简单的构造函数是{}，用来创建一个空表。可以直接初始化数组</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们为 table a 并设置元素，然后将 a 赋值给 b，则 a 与 b 都指向同一个内存。如果 a 设置为 nil ，则 b 同样能访问 table 的元素。如果没有指定的变量指向a，Lua的垃圾回收机制会清理相对应的内存。<strong>(引用传值，指向同一个内存地址)</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 简单的 table</span></span><br><span class="line">mytable = &#123;&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"mytable 的类型是 "</span>,<span class="built_in">type</span>(mytable))</span><br><span class="line"></span><br><span class="line">mytable[<span class="number">1</span>]= <span class="string">"Lua"</span></span><br><span class="line">mytable[<span class="string">"wow"</span>] = <span class="string">"修改前"</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"mytable 索引为 1 的元素是 "</span>, mytable[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"mytable 索引为 wow 的元素是 "</span>, mytable[<span class="string">"wow"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- alternatetable和mytable的是指同一个 table</span></span><br><span class="line">alternatetable = mytable</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"alternatetable 索引为 1 的元素是 "</span>, alternatetable[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"mytable 索引为 wow 的元素是 "</span>, alternatetable[<span class="string">"wow"</span>])</span><br><span class="line"></span><br><span class="line">alternatetable[<span class="string">"wow"</span>] = <span class="string">"修改后"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"mytable 索引为 wow 的元素是 "</span>, mytable[<span class="string">"wow"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 释放变量</span></span><br><span class="line">alternatetable = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"alternatetable 是 "</span>, alternatetable)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- mytable 仍然可以访问</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"mytable 索引为 wow 的元素是 "</span>, mytable[<span class="string">"wow"</span>])</span><br><span class="line"></span><br><span class="line">mytable = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"mytable 是 "</span>, mytable)</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    mytable 的类型是 table</span></span><br><span class="line"><span class="comment">    mytable 索引为 1 的元素是 Lua</span></span><br><span class="line"><span class="comment">    mytable 索引为 wow 的元素是 修改前</span></span><br><span class="line"><span class="comment">    alternatetable 索引为 1 的元素是 Lua</span></span><br><span class="line"><span class="comment">    mytable 索引为 wow 的元素是 修改前</span></span><br><span class="line"><span class="comment">    mytable 索引为 wow 的元素是 修改后</span></span><br><span class="line"><span class="comment">    alternatetable 是 nil</span></span><br><span class="line"><span class="comment">    mytable 索引为 wow 的元素是 修改后</span></span><br><span class="line"><span class="comment">    mytable 是 nil</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h2 id="Table-操作"><a href="#Table-操作" class="headerlink" title="Table 操作"></a>Table 操作</h2><table><thead><tr><th>序号</th><th>方法 &amp; 用途</th></tr></thead><tbody><tr><td>1</td><td><strong>table.concat (table [, sep [, start [, end]]]):</strong>concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。</td></tr><tr><td>2</td><td><strong>table.insert (table, [pos,] value):</strong>在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾.</td></tr><tr><td>3</td><td><strong>table.maxn (table)</strong>指定table中所有正数key值中最大的key值. 如果不存在key值为正数的元素, 则返回0。(<strong>Lua5.2之后该方法已经不存在了,本文使用了自定义函数实现</strong>)</td></tr><tr><td>4</td><td><strong>table.remove (table [, pos])</strong>返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。</td></tr><tr><td>5</td><td><strong>table.sort (table [, comp])</strong>对给定的table进行升序排序。</td></tr></tbody></table><h3 id="Table-连接"><a href="#Table-连接" class="headerlink" title="Table 连接"></a>Table 连接</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fruits = &#123;<span class="string">"banana"</span>,<span class="string">"orange"</span>,<span class="string">"apple"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 返回 table 连接后的字符串</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"连接后的字符串 "</span>,<span class="built_in">table</span>.<span class="built_in">concat</span>(fruits))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定连接字符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"连接后的字符串 "</span>,<span class="built_in">table</span>.<span class="built_in">concat</span>(fruits,<span class="string">", "</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定索引来连接 table</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"连接后的字符串 "</span>,<span class="built_in">table</span>.<span class="built_in">concat</span>(fruits,<span class="string">", "</span>, <span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">连接后的字符串     bananaorangeapple</span></span><br><span class="line"><span class="comment">连接后的字符串     banana, orange, apple</span></span><br><span class="line"><span class="comment">连接后的字符串     orange, apple</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h3 id="插入和移除"><a href="#插入和移除" class="headerlink" title="插入和移除"></a>插入和移除</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">fruits = &#123;<span class="string">"banana"</span>,<span class="string">"orange"</span>,<span class="string">"apple"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在末尾插入</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(fruits,<span class="string">"mango"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"索引为 4 的元素为 "</span>,fruits[<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在索引为 2 的键处插入</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(fruits,<span class="number">2</span>,<span class="string">"grapes"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"索引为 2 的元素为 "</span>,fruits[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"最后一个元素为 "</span>,fruits[<span class="number">5</span>])</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">remove</span>(fruits)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"移除后最后一个元素为 "</span>,fruits[<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">索引为 4 的元素为     mango</span></span><br><span class="line"><span class="comment">    索引为 2 的元素为     grapes</span></span><br><span class="line"><span class="comment">    最后一个元素为     mango</span></span><br><span class="line"><span class="comment">    移除后最后一个元素为     nil</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h3 id="Table-排序"><a href="#Table-排序" class="headerlink" title="Table 排序"></a>Table 排序</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">fruits = &#123;<span class="string">"banana"</span>,<span class="string">"orange"</span>,<span class="string">"apple"</span>,<span class="string">"grapes"</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"排序前"</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(fruits) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(fruits)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"排序后"</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(fruits) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">排序前</span></span><br><span class="line"><span class="comment">1banana</span></span><br><span class="line"><span class="comment">2orange</span></span><br><span class="line"><span class="comment">3apple</span></span><br><span class="line"><span class="comment">4grapes</span></span><br><span class="line"><span class="comment">排序后</span></span><br><span class="line"><span class="comment">1apple</span></span><br><span class="line"><span class="comment">2banana</span></span><br><span class="line"><span class="comment">3grapes</span></span><br><span class="line"><span class="comment">4orange</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h3 id="Table-最大值"><a href="#Table-最大值" class="headerlink" title="Table 最大值"></a>Table 最大值</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">table_maxn</span><span class="params">(t)</span></span></span><br><span class="line">  <span class="keyword">local</span> mn=<span class="literal">nil</span>;</span><br><span class="line">  <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span>(mn==<span class="literal">nil</span>) <span class="keyword">then</span></span><br><span class="line">      mn=v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> mn &lt; v <span class="keyword">then</span></span><br><span class="line">      mn = v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> mn</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">tbl = &#123;[<span class="number">1</span>] = <span class="number">2</span>, [<span class="number">2</span>] = <span class="number">6</span>, [<span class="number">3</span>] = <span class="number">34</span>, [<span class="number">26</span>] =<span class="number">5</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"tbl 最大值："</span>, table_maxn(tbl))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"tbl 长度 "</span>, #tbl)</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    tbl 最大值：  34</span></span><br><span class="line"><span class="comment">    tbl 长度     3</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h3 id="Table长度"><a href="#Table长度" class="headerlink" title="Table长度"></a>Table长度</h3><p><strong>注意：</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们获取 table 的长度的时候无论是使用<code>#</code>还是<code>table.getn</code>其都会在索引中断的地方停止计数，而导致无法正确取得 table 的长度。</p><p>可以使用以下方法来代替：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">table_leng</span><span class="params">(t)</span></span></span><br><span class="line">  <span class="keyword">local</span> leng=<span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span></span><br><span class="line">    leng=leng+<span class="number">1</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> leng;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">tab=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(table_leng(tab)) <span class="comment">-- 3</span></span><br><span class="line"><span class="built_in">print</span>(#tab) <span class="comment">-- 3</span></span><br><span class="line"><span class="built_in">print</span>(#tab) <span class="comment">-- 3</span></span><br><span class="line"></span><br><span class="line">tab[<span class="number">100</span>]=<span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(#tab) <span class="comment">-- 3</span></span><br><span class="line"><span class="built_in">print</span>(#tab) <span class="comment">-- 3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">table</span>.<span class="built_in">getn</span>(tab)) <span class="comment">--3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(table_leng(tab)) <span class="comment">-- 4</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;table-表&quot;&gt;&lt;a href=&quot;#table-表&quot; class=&quot;headerlink&quot; title=&quot;table(表)&quot;&gt;&lt;/a&gt;table(表)&lt;/h1&gt;&lt;p&gt;table 是 Lua 的一种数据结构用来帮助我们创建不同的数据类型，如：数组、字典等。&lt;/p&gt;
      
    
    </summary>
    
      <category term="Lua" scheme="http://blog.com/categories/Lua/"/>
    
    
      <category term="Lua" scheme="http://blog.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>Nginx配置指令的执行顺序</title>
    <link href="http://blog.com/2019/09/19/Nginx%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <id>http://blog.com/2019/09/19/Nginx配置指令的执行顺序/</id>
    <published>2019-09-19T04:12:57.000Z</published>
    <updated>2019-09-22T14:08:02.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx配置指令的执行顺序"><a href="#Nginx配置指令的执行顺序" class="headerlink" title="Nginx配置指令的执行顺序"></a>Nginx配置指令的执行顺序</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Nginx</code>处理请求的过程一共划分为 11 个阶段，按照执行顺序依次是 <code>post-read</code>、<code>server-rewrite</code>、<code>find-config</code>、<code>rewrite</code>、<code>post-rewrite</code>、<code>preaccess</code>、<code>access</code>、<code>post-access</code>、<code>try-files</code>、<code>content</code> 以及 <code>log</code></p><h2 id="执行顺序初探"><a href="#执行顺序初探" class="headerlink" title="执行顺序初探"></a>执行顺序初探</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大多数<code>Nginx</code>新手都会频繁遇到这样一个困惑，那就是<strong>当同一个 <code>location</code> 配置块使用了多个 Nginx 模块的配置指令时，这些指令的执行顺序很可能会跟它们的书写顺序大相径庭</strong>。于是许多人选择了“试错法”，然后他们的配置文件就时常被改得一片狼藉。这个系列的教程就旨在帮助读者逐步地理解这些配置指令背后的执行时间和先后顺序的奥秘。</p><p>​    现在就来看这样一个令人困惑的例子：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /test &#123;</span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$a</span> <span class="number">32</span>;</span><br><span class="line">    <span class="attribute">echo</span> <span class="variable">$a</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$a</span> <span class="number">56</span>;</span><br><span class="line">    <span class="attribute">echo</span> <span class="variable">$a</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从这个例子的本意来看，我们期望的输出是一行 <code>32</code> 和一行 <code>56</code>，因为我们第一次用 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 配置指令输出了 <code>$a</code>变量的值以后，又紧接着使用 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 配置指令修改了 <code>$a</code>. 然而不幸的是，事实并非如此：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test</span><br><span class="line">56</span><br><span class="line">56</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，语句 <code>set $a 56</code> 似乎在第一条 <code>echo $a</code> 语句之前就执行过了。这究竟是为什么呢？难道我们遇到了 <code>Nginx</code>中的一个<code>bug</code>？</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，这里并没有 <code>Nginx</code> 的 <code>bug</code>；要理解这里发生的事情，就首先需要知道<strong><code>Nginx</code>处理每一个用户请求时，都是按照若干个不同阶段（<code>phase</code>）依次处理的</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Nginx</code> 的请求处理阶段共有 11 个之多，我们先介绍其中 3 个比较常见的。按照它们执行时的先后顺序，依次是 <code>rewrite</code> 阶段、<code>access</code> 阶段以及 <code>content</code> 阶段（后面我们还有机会见到其他更多的处理阶段）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>所有 <code>Nginx</code> 模块提供的配置指令一般只会注册并运行在其中的某一个处理阶段</strong>。比如上例中的 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令就是在 <code>rewrite</code> 阶段运行的，而 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令就只会在 <code>content</code> 阶段运行。前面我们已经知道，在单个请求的处理过程中，<code>rewrite</code> 阶段总是在 <code>content</code> 阶段之前执行，因此属于 <code>rewrite</code> 阶段的配置指令也总是会无条件地在 <code>content</code> 阶段的配置指令之前执行。于是在同一个 <code>location</code> 配置块中，<a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令总是会在 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令之前执行，即使我们在配置文件中有意把 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 语句写在 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 语句的后面。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回到刚才那个例子，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set $a 32;</span><br><span class="line">echo $a;</span><br><span class="line"> </span><br><span class="line">set $a 56;</span><br><span class="line">echo $a;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际的执行顺序应当是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set $a 32;</span><br><span class="line">set $a 56;</span><br><span class="line">echo $a;</span><br><span class="line">echo $a;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即先在 <code>rewrite</code> 阶段执行完这里的两条 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 赋值语句，然后再在后面的 <code>content</code> 阶段依次执行那两条 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a>语句。分属两个不同处理阶段的配置指令之间是不能穿插着运行的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了进一步验证这一点，我们不妨借助 <code>Nginx</code> 的“调试日志”来一窥 <code>Nginx</code>的实际执行过程。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为这是我们第一次提及<code>Nginx</code> 的“调试日志”，所以有必要先简单介绍一下它的启用方法。调试日志默认是禁用的，因为它会引入比较大的运行时开销，让 <code>Nginx</code>服务器显著变慢。一般我们需要重新编译和构造 <code>Nginx</code>可执行文件，并且在调用<strong><code>Nginx</code> 源码包提供的 <code>./configure</code> 脚本时传入 <code>--with-debug</code> 命令行选项</strong>。例如我们下载完 <code>Nginx</code>源码包后在<code>Linux</code> 或者 <code>Mac OS X</code>等系统上构建时，典型的步骤是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar xvf nginx-1.0.10.tar.gz</span><br><span class="line">cd nginx-1.0.10/</span><br><span class="line">./configure --with-debug</span><br><span class="line">make</span><br><span class="line">sudu make install</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你使用的是我维护的 <a href="http://openresty.org/" target="_blank" rel="noopener">ngx_openresty</a> 软件包，则同样可以向它的 <code>./configure</code> 脚本传递 <code>--with-debug</code> 命令行选项。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当我们启用 <code>--with-debug</code> 选项重新构建好调试版的 <code>Nginx</code> 之后，还需要同时在配置文件中通过标准的<a href="http://wiki.nginx.org/CoreModule#error_log" target="_blank" rel="noopener">error_log</a> 配置指令为错误日志使用 <code>debug</code> 日志级别（这同时也是最低的日志级别）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_log logs/error.log debug;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里重要的是 <a href="http://wiki.nginx.org/CoreModule#error_log" target="_blank" rel="noopener">error_log</a> 指令的第二个参数，<code>debug</code>，而前面第一个参数是错误日志文件的路径，<code>logs/error.log</code>. 当然，你也可以指定其他路径，但后面我们会检查这个文件的内容，所以请特别留意一下这里实际配置的文件路径。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们重新启动 <code>Nginx</code>（注意，如果 <code>Nginx</code> 可执行文件也被更新过，仅仅让 <code>Nginx</code>重新加载配置是不够的，需要关闭再启动 <code>Nginx</code> 主服务进程），然后再请求一下我们刚才那个示例接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">56</span><br><span class="line">56</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在可以检查一下前面配置的<code>Nginx</code> 错误日志文件中的输出。因为文件中的输出比较多（在我的机器上有 700 多行），所以不妨用 <code>grep</code> 命令在终端上过滤出我们感兴趣的部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E &apos;http (output filter|script (set|value))&apos; logs/error.log</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我机器上的输出是这个样子的（为了方便呈现，这里对 <code>grep</code> 命令的实际输出作了一些简单的编辑，略去了每一行的行首时间戳）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[debug] 5363#0: *1 http script value: &quot;32&quot;</span><br><span class="line">[debug] 5363#0: *1 http script set $a</span><br><span class="line">[debug] 5363#0: *1 http script value: &quot;56&quot;</span><br><span class="line">[debug] 5363#0: *1 http script set $a</span><br><span class="line">[debug] 5363#0: *1 http output filter &quot;/test?&quot;</span><br><span class="line">[debug] 5363#0: *1 http output filter &quot;/test?&quot;</span><br><span class="line">[debug] 5363#0: *1 http output filter &quot;/test?&quot;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里需要稍微解释一下这些调试信息的具体含义。<a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 配置指令在实际运行时会打印出两行以 <code>http script</code> 起始的调试信息，其中第一行信息是 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 语句中被赋予的值，而第二行则是 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 语句中被赋值的 Nginx 变量名。于是上面首先过滤出来的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[debug] 5363#0: *1 http script value: &quot;32&quot;</span><br><span class="line">[debug] 5363#0: *1 http script set $a</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这两行就对应我们例子中的配置语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set $a 32;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而接下来这两行调试信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[debug] 5363#0: *1 http script value: &quot;56&quot;</span><br><span class="line">[debug] 5363#0: *1 http script set $a</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则对应配置语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set $a 56;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，凡在 Nginx 中输出响应体数据时，都会调用 <code>Nginx</code> 的所谓“输出过滤器”（output filter），我们一直在使用的 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令自然也不例外。而一旦调用 <code>Nginx</code> 的“输出过滤器”，便会产生类似下面这样的调试信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[debug] 5363#0: *1 http output filter &quot;/test?&quot;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，这里的 <code>&quot;/test?&quot;</code> 部分对于其他接口可能会发生变化，因为它显示的是当前请求的<code>URI</code>. 这样联系起来看，就不难发现，上例中的那两条 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 语句确实都是在那两条 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 语句之前执行的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;细心的读者可能会问，为什么这个例子明明只使用了两条 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 语句进行输出，但却有三行 <code>http output filter</code> 调试信息呢？其实，前两行 <code>http output filter</code> 信息确实分别对应那两条 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 语句，而<strong>最后那一行信息则是对应 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 模块输出指示响应体末尾的结束标记</strong>。正是为了输出这个特殊的结束标记，才会多出一次对 <code>Nginx</code> “输出过滤器”的调用。包括 <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank" rel="noopener">ngx_proxy</a> 在内的许多模块在输出响应体数据流时都具有此种行为。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们就不会再为前面那个例子输出两行一模一样的 <code>56</code> 而感到惊讶了。我们根本没有机会在第二条 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 语句之前用 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 输出。幸运的是，仍然可以借助一些小技巧来达到最初的目的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    set $a 32;</span><br><span class="line">    set $saved_a $a;</span><br><span class="line">    set $a 56;</span><br><span class="line"> </span><br><span class="line">    echo $saved_a;</span><br><span class="line">    echo $a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时的输出便符合那个问题示例的初衷了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">32</span><br><span class="line">56</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里通过引入新的用户变量 <code>$saved_a</code>，在改写 <code>$a</code> 之前及时保存了 <code>$a</code> 的初始值。而对于多条 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令而言，它们之间的执行顺序是由 <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank" rel="noopener">ngx_rewrite</a> 模块来保证与书写顺序相一致的。同理，<a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 模块自身也会保证它的多条 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令之间的执行顺序。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;细心的读者应当发现，我们在 <a href="http://blog.sina.com.cn/s/articlelist_1834459124_1_1.html" target="_blank" rel="noopener">Nginx 变量漫谈系列</a> 的示例中已经广泛使用了这种技巧，来绕过因处理阶段而引起的指令执行顺序上的限制。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到这里，有的读者可能会问：“那么我在使用一条陌生的配置指令之前，如何知道它究竟运行在哪一个处理阶段呢？”答案是：查看该指令的文档（当然，高级开发人员也可以直接查看模块的 C 源码）。在许多模块的文档中，都会专门标记其配置指令所运行的具体阶段。例如 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令的文档中有这么一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phase: content</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一行便是说，当前配置指令运行在 <code>content</code> 阶段。如果你使用的 <code>Nginx</code>模块碰巧没有指示运行阶段的文档，可以直接联系该模块的作者请求补充。不过，值得一提的是，<strong>并非所有的配置指令都与某个处理阶段相关联</strong>，例如： <a href="http://wiki.nginx.org/HttpGeoModule#geo" target="_blank" rel="noopener">geo</a> 指令以及 <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 指令。<strong>这些不与处理阶段相关联的配置指令基本上都是“声明性的”（<code>declarative</code>），即不直接产生某种动作或者过程</strong>。<code>Nginx</code> 的作者 Igor Sysoev 在公开场合曾不止一次地强调，<strong><code>Nginx</code>配置文件所使用的语言本质上是“声明性的”，而非“过程性的”（procedural）</strong>。</p><h2 id="post-read"><a href="#post-read" class="headerlink" title="post-read"></a>post-read</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>最先执行的 <code>post-read</code> 阶段在 <code>Nginx</code> 读取并解析完请求头（request headers）之后就立即开始运行</strong>。这个阶段像前面介绍过的 <code>rewrite</code> 阶段那样支持 <code>Nginx</code> 模块注册处理程序。比如<strong>标准模块 <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank" rel="noopener">ngx_realip</a> 就在<code>post-read</code> 阶段注册了处理程序，它的功能是迫使 <code>Nginx</code> 认为当前请求的来源地址是指定的某一个请求头的值</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面这个例子就使用了 <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank" rel="noopener">ngx_realip</a> 模块提供的 <a href="http://wiki.nginx.org/HttpRealIpModule#set_real_ip_from" target="_blank" rel="noopener">set_real_ip_from</a> 和 <a href="http://wiki.nginx.org/HttpRealIpModule#real_ip_header" target="_blank" rel="noopener">real_ip_header</a> 这两条配置指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line"> </span><br><span class="line">    set_real_ip_from 127.0.0.1;</span><br><span class="line">    real_ip_header   X-My-IP;</span><br><span class="line"> </span><br><span class="line">    location /test &#123;</span><br><span class="line">        set $addr $remote_addr;</span><br><span class="line">        echo &quot;from: $addr&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的配置是让<code>Nginx</code> 把那些来自 <code>127.0.0.1</code> 的所有请求的来源地址，都改写为请求头 <code>X-My-IP</code> 所指定的值。同时该例使用了标准内建变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank" rel="noopener">$remote_addr</a> 来输出当前请求的来源地址，以确认是否被成功改写。</p><p>​    首先在本地请求一下这个 <code>/test</code> 接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -H &apos;X-My-IP: 1.2.3.4&apos; localhost:8080/test</span><br><span class="line">from: 1.2.3.4</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里使用了 <code>curl</code> 工具的 <code>-H</code> 选项指定了额外的 HTTP 请求头 <code>X-My-IP: 1.2.3.4</code>. 从输出可以看到，<a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank" rel="noopener">$remote_addr</a> 变量的值确实在 <code>rewrite</code> 阶段就已经成为了 <code>X-My-IP</code> 请求头中指定的值，即 <code>1.2.3.4</code>. 那么 <code>Nginx</code> 究竟是在什么时候改写了当前请求的来源地址呢？答案是：在 <code>post-read</code> 阶段。由于 <code>rewrite</code> 阶段的运行远在 <code>post-read</code> 阶段之后，所以当在 <code>location</code> 配置块中通过 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 配置指令读取 <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank" rel="noopener">$remote_addr</a> 内建变量时，读出的来源地址已经是经过 <code>post-read</code> 阶段篡改过的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果在请求上例中的 <code>/test</code> 接口时没有指定 <code>X-My-IP</code> 请求头，或者提供的 <code>X-My-IP</code> 请求头的值不是合法的 IP 地址，那么 <code>Nginx</code> 就不会对来源地址进行改写，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8080/test</span><br><span class="line">from: 127.0.0.1</span><br><span class="line"> </span><br><span class="line">$ curl -H &apos;X-My-IP: abc&apos; localhost:8080/test</span><br><span class="line">from: 127.0.0.1</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果从另一台机器访问这个 <code>/test</code> 接口，那么即使指定了合法的 <code>X-My-IP</code> 请求头，也不会触发 <code>Nginx</code> 对来源地址进行改写。这是因为上例已经使用 <a href="http://wiki.nginx.org/HttpRealIpModule#set_real_ip_from" target="_blank" rel="noopener">set_real_ip_from</a> 指令规定了来源地址的改写操作只对那些来自 <code>127.0.0.1</code> 的请求生效。这种过滤机制可以避免来自其他不受信任的地址的恶意欺骗。当然，也可以通过 <a href="http://wiki.nginx.org/HttpRealIpModule#set_real_ip_from" target="_blank" rel="noopener">set_real_ip_from</a> 指令指定一个 IP 网段。此外，同时配置多个<a href="http://wiki.nginx.org/HttpRealIpModule#set_real_ip_from" target="_blank" rel="noopener">set_real_ip_from</a> 语句也是允许的，这样可以指定多个受信任的来源地址或地址段。下面是一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_real_ip_from 10.32.10.5;</span><br><span class="line">set_real_ip_from 127.0.0.0/24;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有的读者可能会问，<a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank" rel="noopener">ngx_realip</a> 模块究竟有什么实际用途呢？为什么我们需要去改写请求的来源地址呢？答案是：当 <code>Nginx</code> 处理的请求经过了某个 <code>HTTP</code> 代理服务器的转发时，这个模块就变得特别有用。当原始的用户请求经过转发之后，<code>Nginx</code> 接收到的请求的来源地址无一例外地变成了该代理服务器的 IP 地址，于是 <code>Nginx</code> 以及 <code>Nginx</code> 背后的应用就无法知道原始请求的真实来源。所以，一般我们会在 <code>Nginx</code>之前的代理服务器中把请求的原始来源地址编码进某个特殊的<code>HTTP</code> 请求头中（例如上例中的 <code>X-My-IP</code> 请求头），然后再在 Nginx 一侧把这个请求头中编码的地址恢复出来。这样 <code>Nginx</code> 中的后续处理阶段（包括 <code>Nginx</code> 背后的各种后端应用）就会认为这些请求直接来自那些原始的地址，代理服务器就仿佛不存在一样。正是因为这个需求，所以 <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank" rel="noopener">ngx_realip</a> 模块才需要在第一个处理阶段，即 <code>post-read</code> 阶段，注册处理程序，以便尽可能早地改写请求的来源。</p><h2 id="server-rewrite"><a href="#server-rewrite" class="headerlink" title="server-rewrite"></a>server-rewrite</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>post-read</code> 阶段之后便是 <code>server-rewrite</code> 阶段</strong>。我们曾提到，当 <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank" rel="noopener">ngx_rewrite</a> 模块的配置指令直接书写在 <code>server</code> 配置块中时，基本上都是运行在 <code>server-rewrite</code> 阶段。下面就来看这样的一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line"> </span><br><span class="line">    location /test &#123;</span><br><span class="line">        set $b &quot;$a, world&quot;;</span><br><span class="line">        echo $b;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    set $a hello;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里，配置语句 <code>set $a hello</code> 直接写在了 <code>server</code> 配置块中，因此它就运行在 <code>server-rewrite</code> 阶段。而<code>server-rewrite</code> 阶段要早于 <code>rewrite</code> 阶段运行，因此写在 <code>location</code> 配置块中的语句 <code>set $b &quot;$a, world&quot;</code>便晚于外面的 <code>set $a hello</code> 语句运行。该例的测试结果证明了这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8080/test</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 <code>server-rewrite</code> 阶段位于 <code>post-read</code> 阶段之后，所以 <code>server</code> 配置块中的 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令也就总是运行在 <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank" rel="noopener">ngx_realip</a> 模块改写请求的来源地址之后。来看下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line"> </span><br><span class="line">    set $addr $remote_addr;</span><br><span class="line"> </span><br><span class="line">    set_real_ip_from 127.0.0.1;</span><br><span class="line">    real_ip_header   X-Real-IP;</span><br><span class="line"> </span><br><span class="line">    location /test &#123;</span><br><span class="line">        echo &quot;from: $addr&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请求 <code>/test</code> 接口的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -H &apos;X-Real-IP: 1.2.3.4&apos; localhost:8080/test</span><br><span class="line">from: 1.2.3.4</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个例子中，虽然 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令写在了 <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank" rel="noopener">ngx_realip</a> 的配置指令之前，但仍然晚于 <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank" rel="noopener">ngx_realip</a> 模块执行。所以<code>$addr</code> 变量在 <code>server-rewrite</code> 阶段被 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令赋值时，从 <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank" rel="noopener">$remote_addr</a> 变量读出的来源地址已经是经过改写过的了。</p><h2 id="find-config"><a href="#find-config" class="headerlink" title="find-config"></a>find-config</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;紧接在 <code>server-rewrite</code> 阶段后边的是 <code>find-config</code> 阶段。<strong>这个阶段并不支持 <code>Nginx</code> 模块注册处理程序，而是由 <code>Nginx</code> 核心来完成当前请求与 <code>location</code> 配置块之间的配对工作</strong>。换句话说，在此阶段之前，请求并没有与任何 <code>location</code> 配置块相关联。因此，对于运行在 <code>find-config</code> 阶段之前的 <code>post-read</code> 和 <code>server-rewrite</code> 阶段来说，只有 <code>server</code> 配置块以及更外层作用域中的配置指令才会起作用。这就是为什么只有写在<code>server</code> 配置块中的 <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank" rel="noopener">ngx_rewrite</a> 模块的指令才会运行在 <code>server-rewrite</code> 阶段，这也是为什么前面所有例子中的 <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank" rel="noopener">ngx_realip</a> 模块的指令也都特意写在了 <code>server</code> 配置块中，以确保其注册在 <code>post-read</code> 阶段的处理程序能够生效。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>当<code>Nginx</code> 在 <code>find-config</code> 阶段成功匹配了一个 <code>location</code> 配置块后，会立即打印一条调试信息到错误日志文件中</strong>。我们来看这样的一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /hello &#123;</span><br><span class="line">    echo &quot;hello world&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果启用了<code>Nginx</code> 的“调试日志”，那么当请求 <code>/hello</code> 接口时，便可以在 <code>error.log</code> 文件中过滤出下面这一行信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep &apos;using config&apos; logs/error.log</span><br><span class="line">[debug] 84579#0: *1 using configuration &quot;/hello&quot;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们有意省略了信息行首的时间戳，以便放在这里。</p><h2 id="rewrite与set"><a href="#rewrite与set" class="headerlink" title="rewrite与set"></a>rewrite与set</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行在 <code>find-config</code> 阶段之后的便是我们的老朋友 <code>rewrite</code> 阶段。由于 Nginx 已经在 <code>find-config</code> 阶段完成了当前请求与 <code>location</code> 的配对，所以从 <code>rewrite</code> 阶段开始，<code>location</code> 配置块中的指令便可以产生作用。前面已经介绍过，当 <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank" rel="noopener">ngx_rewrite</a> 模块的指令用于 <code>location</code> 块中时，便是运行在这个 <code>rewrite</code> 阶段。另外，<a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank" rel="noopener">ngx_set_misc</a> 模块的指令也是如此，还有 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 模块的 <a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank" rel="noopener">set_by_lua</a> 指令和 <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> 指令也不例外。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们前面已经知道，当<strong><a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令用在 <code>location</code> 配置块中时，都是在当前请求的 <code>rewrite</code> 阶段运行的</strong>。事实上，在此上下文中，<a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank" rel="noopener">ngx_rewrite</a> 模块中的几乎全部指令，都运行在 <code>rewrite</code> 阶段，包括  <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank" rel="noopener">rewrite</a> 指令。不过，值得一提的是，<strong>当这些指令使用在 <code>server</code> 配置块中时，则会运行在一个我们尚未提及的更早的处理阶段，<code>server-rewrite</code> 阶段</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank" rel="noopener">ngx_set_misc</a> 模块的 <a href="http://wiki.nginx.org/HttpSetMiscModule#set_unescape_uri" target="_blank" rel="noopener">set_unescape_uri</a> 指令同样也运行在 <code>rewrite</code> 阶段</strong>。特别地，<a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank" rel="noopener">ngx_set_misc</a> 模块的指令还可以和 <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank" rel="noopener">ngx_rewrite</a> 的指令混合在一起依次执行。我们来看这样的一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    set $a &quot;hello%20world&quot;;</span><br><span class="line">    set_unescape_uri $b $a;</span><br><span class="line">    set $c &quot;$b!&quot;;</span><br><span class="line"> </span><br><span class="line">    echo $c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;访问这个接口可以得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，<a href="http://wiki.nginx.org/HttpSetMiscModule#set_unescape_uri" target="_blank" rel="noopener">set_unescape_uri</a> 语句前后的 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 语句都按书写时的顺序一前一后地执行了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了进一步确认这一点，我们不妨再检查一下<code>Nginx</code> 的“调试日志”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E &apos;http script (value|copy|set)&apos; t/servroot/logs/error.log</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;过滤出来的调试日志信息如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[debug] 11167#0: *1 http script value: &quot;hello%20world&quot;</span><br><span class="line">[debug] 11167#0: *1 http script set $a</span><br><span class="line">[debug] 11167#0: *1 http script value (post filter): &quot;hello world&quot;</span><br><span class="line">[debug] 11167#0: *1 http script set $b</span><br><span class="line">[debug] 11167#0: *1 http script copy: &quot;!&quot;</span><br><span class="line">[debug] 11167#0: *1 http script set $c</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开头的两行信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[debug] 11167#0: *1 http script value: &quot;hello%20world&quot;</span><br><span class="line">[debug] 11167#0: *1 http script set $a</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就对应我们的配置语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set $a &quot;hello%20world&quot;;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而接下来的两行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[debug] 11167#0: *1 http script value (post filter): &quot;hello world&quot;</span><br><span class="line">[debug] 11167#0: *1 http script set $b</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则对应配置语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_unescape_uri $b $a;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到第一行信息与 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令略有区别，多了 <code>&quot;(post filter)&quot;</code> 这个标记，而且最后显示出 <code>URI</code>解码操作确实如我们期望的那样工作了，即 <code>&quot;hello%20world&quot;</code> 在这里被成功解码为 <code>&quot;hello world&quot;</code>.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 而最后两行调试信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[debug] 11167#0: *1 http script copy: &quot;!&quot;</span><br><span class="line">[debug] 11167#0: *1 http script set $c</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则对应最后一条 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set $c &quot;$b!&quot;;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意，因为这条指令在为 <code>$c</code> 变量赋值时使用了“变量插值”功能，所以第一行调试信息是以 <code>http script copy</code> 起始的，后面则是拼接到最终取值的字符串常量 <code>&quot;!&quot;</code>.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 把这些调试信息联系起来看，我们不难发现，这些配置指令的实际执行顺序是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set $a &quot;hello%20world&quot;;</span><br><span class="line">set_unescape_uri $b $a;</span><br><span class="line">set $c &quot;$b!&quot;;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这与它们在配置文件中的书写顺序完全一致。</p><h3 id="set与set-by-lua"><a href="#set与set-by-lua" class="headerlink" title="set与set_by_lua"></a>set与set_by_lua</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三方模块 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a>，它提供的 <a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank" rel="noopener">set_by_lua</a> 配置指令也和 <a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank" rel="noopener">ngx_set_misc</a> 模块的指令一样，可以和 <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank" rel="noopener">ngx_rewrite</a> 模块的指令混合使用。<a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank" rel="noopener">set_by_lua</a> 指令支持通过一小段用户 <code>Lua</code>代码来计算出一个结果，然后赋给指定的 <code>Nginx</code> 变量。和 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令相似，<a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank" rel="noopener">set_by_lua</a> 指令也有自动创建不存在的<code>Nginx</code>变量的功能。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面我们就来看一个 <a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank" rel="noopener">set_by_lua</a> 指令与 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令混合使用的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    set $a 32;</span><br><span class="line">    set $b 56;</span><br><span class="line">    set_by_lua $c &quot;return ngx.var.a + ngx.var.b&quot;;</span><br><span class="line">    set $equation &quot;$a + $b = $c&quot;;</span><br><span class="line"> </span><br><span class="line">    echo $equation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们先将 <code>$a</code> 和 <code>$b</code> 变量分别初始化为 <code>32</code> 和 <code>56</code>，然后利用 <a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank" rel="noopener">set_by_lua</a> 指令内联一行我们自己指定的 Lua 代码，计算出 Nginx 变量 <code>$a</code> 和 <code>$b</code> 的“代数和”（sum），并赋给变量 <code>$c</code>，接着利用“变量插值”功能，把变量 <code>$a</code>、 <code>$b</code> 和 <code>$c</code> 的值拼接成一个字符串形式的等式，赋予变量 <code>$equation</code>，最后再用 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令输出 <code>$equation</code> 的值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个例子值得注意的地方是：首先，我们在<code>Lua</code>代码中是通过 <a href="http://wiki.nginx.org/HttpLuaModule#ngx.var.VARIABLE" target="_blank" rel="noopener">ngx.var.VARIABLE</a> 接口来读取 <code>Nginx</code>变量 <code>$VARIABLE</code> 的；其次，因为 <code>Nginx</code> 变量的值只有字符串这一种类型，所以在<code>Lua</code> 代码里读取 <code>ngx.var.a</code> 和<code>ngx.var.b</code> 时得到的其实都是 <code>Lua</code> 字符串类型的值 <code>&quot;32&quot;</code> 和 <code>&quot;56&quot;</code>；接着，我们对两个字符串作加法运算会触发 <code>Lua</code>对加数进行自动类型转换（<code>Lua</code> 会把两个加数先转换为数值类型再求和）；然后，我们在<code>Lua</code> 代码中把最终结果通过 <code>return</code> 语句返回给外面的 <code>Nginx</code> 变量 <code>$c</code>；最后，<a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 模块在给 <code>$c</code> 实际赋值之前，也会把 <code>return</code> 语句返回的数值类型的结果，也就是<code>Lua</code>加法计算得出的“和”，自动转换为字符串（这同样是因为<code>Nginx</code>变量的值只能是字符串）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个例子的实际运行结果符合我们的期望：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">32 + 56 = 88</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是这验证了 <a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank" rel="noopener">set_by_lua</a> 指令确实也可以和 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 这样的 <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank" rel="noopener">ngx_rewrite</a> 模块提供的指令混合在一起工作。</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有不少第三方模块，例如 <a href="http://wiki.nginx.org/HttpArrayVarModule" target="_blank" rel="noopener">ngx_array_var</a> 以及后面即将接触到的用于加解密用户会话（session）的 <a href="http://wiki.nginx.org/HttpEncryptedSessionModule" target="_blank" rel="noopener">ngx_encrypted_session</a>，也都可以和 <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank" rel="noopener">ngx_rewrite</a> 模块的指令无缝混合工作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标准 <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank" rel="noopener">ngx_rewrite</a> 模块的应用是如此广泛，所以能够和它的配置指令混合使用的第三方模块是幸运的。事实上，上面提到的这些第三方模块都采用了特殊的技术，将它们自己的配置指令“注入”到了 <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank" rel="noopener">ngx_rewrite</a>模块的指令序列中（它们都借助了 Marcus Clyne 编写的第三方模块 <a href="https://github.com/simpl/ngx_devel_kit" target="_blank" rel="noopener">ngx_devel_kit</a>）。换句话说，更多常规的在 <code>Nginx</code> 的 <code>rewrite</code> 阶段注册和运行指令的第三方模块就没那么幸运了。这些“常规模块”的指令虽然也运行在 <code>rewrite</code> 阶段，但其配置指令和 <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank" rel="noopener">ngx_rewrite</a> 模块（以及同一阶段内的其他模块）都是分开独立执行的。在运行时，不同模块的配置指令集之间的先后顺序一般是不确定的（严格来说，一般是由模块的加载顺序决定的，但也有例外的情况）。比如 <code>A</code> 和 <code>B</code> 两个模块都在 <code>rewrite</code> 阶段运行指令，于是要么是 <code>A</code> 模块的所有指令全部执行完再执行 <code>B</code> 模块的那些指令，要么就是反过来，把 <code>B</code> 的指令全部执行完，再去运行 <code>A</code> 的指令。除非模块的文档中有明确的交待，否则用户一般不应编写依赖于此种不确定顺序的配置。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Nginx</code>的 <code>rewrite</code> 阶段是一个比较早的请求处理阶段，这个阶段的配置指令<strong>一般用来对当前请求进行各种修改</strong>（比如对<code>URI</code> 和 <code>URL</code> 参数进行改写），或者<strong>创建并初始化一系列后续处理阶段可能需要的 <code>Nginx</code>变量</strong>。当然，也不能阻止一些用户在 <code>rewrite</code> 阶段做一系列更复杂的事情，比如读取请求体，或者访问数据库等远方服务，毕竟有 <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> 这样的指令可以嵌入任意复杂的 <code>Lua</code> 代码。</p><h2 id="rewrite-tail"><a href="#rewrite-tail" class="headerlink" title="rewrite tail"></a>rewrite tail</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如前文所述，除非像 <a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank" rel="noopener">ngx_set_misc</a> 模块那样使用特殊技术，其他模块的配置指令即使是在 <code>rewrite</code> 阶段运行，也不能和 <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank" rel="noopener">ngx_rewrite</a> 模块的指令混合使用。不妨来看几个这样的例子。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三方模块 <a href="http://wiki.nginx.org/HttpHeadersMoreModule" target="_blank" rel="noopener">ngx_headers_more</a> 提供了一系列配置指令，用于操纵当前请求的请求头和响应头。其中有一条名叫 <a href="http://wiki.nginx.org/HttpHeadersMoreModule#more_set_input_headers" target="_blank" rel="noopener">more_set_input_headers</a> 的指令可以在 <code>rewrite</code> 阶段改写指定的请求头（或者在请求头不存在时自动创建）。这条指令总是运行在 <code>rewrite</code> 阶段的末尾，该指令的文档中有这么一行标记：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phase: rewrite tail</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中的<strong><code>rewrite tail</code> 的意思就是 <code>rewrite</code> 阶段的末尾</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 既然<strong>运行在 <code>rewrite</code> 阶段的末尾，那么也就总是会运行在 <code>ngx_rewrite</code> 模块的指令之后，即使我们在配置文件中把它写在前面</strong>。</p><h3 id="more-set-input-headers"><a href="#more-set-input-headers" class="headerlink" title="more_set_input_headers"></a>more_set_input_headers</h3><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    set $value dog;</span><br><span class="line">    more_set_input_headers &quot;X-Species: $value&quot;;</span><br><span class="line">    set $value cat;</span><br><span class="line">    </span><br><span class="line">    echo &quot;X-Species: $http_x_species&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个例子用到的 <a href="http://wiki.nginx.org/HttpCoreModule#.24http_HEADER" target="_blank" rel="noopener">$http_XXX</a> 内建变量在读取时会返回当前请求中名为 <code>XXX</code> 的请求头。需要注意的是，<strong><a href="http://wiki.nginx.org/HttpCoreModule#.24http_HEADER" target="_blank" rel="noopener">$http_XXX</a> 变量在匹配请求头时会自动对请求头的名字进行归一化，即将名字的大写字母转换为小写字母，同时把间隔符（<code>-</code>）替换为下划线（<code>_</code>）</strong>，所以变量名<code>$http_x_species</code> 才得以成功匹配 <a href="http://wiki.nginx.org/HttpHeadersMoreModule#more_set_input_headers" target="_blank" rel="noopener">more_set_input_headers</a> 语句中设置的请求头 <code>X-Species</code>.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此例书写的指令顺序会误导我们认为 <code>/test</code> 接口输出的 <code>X-Species</code> 头的值是 <code>dog</code>，然而实际的结果却并非如此：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">X-Species: cat</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，写在 <a href="http://wiki.nginx.org/HttpHeadersMoreModule#more_set_input_headers" target="_blank" rel="noopener">more_set_input_headers</a> 指令之后的 <code>set $value cat</code> 语句却先执行了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面这个例子证明了即使运行在同一个请求处理阶段，分属不同模块的配置指令也可能会分开独立运行（除非像 <a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank" rel="noopener">ngx_set_misc</a> 等模块那样针对 <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank" rel="noopener">ngx_rewrite</a> 模块提供特殊支持）。换句话说，在单个请求处理阶段内部，一般也会以 <code>Nginx</code>模块为单位进一步地划分出内部子阶段。</p><h3 id="rewrite-by-lua"><a href="#rewrite-by-lua" class="headerlink" title="rewrite_by_lua"></a>rewrite_by_lua</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <strong>第三方模块 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 提供的 <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> 配置指令也和 <a href="http://wiki.nginx.org/HttpHeadersMoreModule#more_set_input_headers" target="_blank" rel="noopener">more_set_input_headers</a> 一样运行在<code>rewrite</code> 阶段的末尾</strong>。我们来验证一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    set $a 1;</span><br><span class="line">    rewrite_by_lua &quot;ngx.var.a = ngx.var.a + 1&quot;;</span><br><span class="line">    set $a 56;</span><br><span class="line">    </span><br><span class="line">    echo $a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们在 <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> 语句内联的<code>Lua</code> 代码中对 <code>Nginx</code> 变量 <code>$a</code> 进行了自增计算。从该例的指令书写顺序上看，我们或许会期望输出是 <code>56</code>，可是因为<strong><a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> 会在所有的 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 语句之后执行</strong>，所以结果是 <code>57</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">57</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，<a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> 指令的行为不同于我们前面介绍过的 <a href="http://wiki.nginx.org/HttpLuaModule#set_by_lua" target="_blank" rel="noopener">set_by_lua</a> 指令。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有的读者可能要问，既然 <strong><a href="http://wiki.nginx.org/HttpHeadersMoreModule#more_set_input_headers" target="_blank" rel="noopener">more_set_input_headers</a> 和 <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> 指令都运行在 <code>rewrite</code> 阶段的末尾，那么它们之间的先后顺序又是怎样的呢？答案是：不一定</strong>。<strong>我们应当避免写出依赖它们二者间顺序的配置</strong>。</p><h2 id="post-rewrite"><a href="#post-rewrite" class="headerlink" title="post-rewrite"></a>post-rewrite</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>rewrite</code> 阶段再往后便是所谓的 <code>post-rewrite</code> 阶段。这个阶段也像 <code>find-config</code> 阶段那样<strong>不接受 <code>Nginx</code> 模块注册处理程序，而是由 <code>Nginx</code> 核心完成 <code>rewrite</code> 阶段所要求的“内部跳转”操作（如果 <code>rewrite</code>阶段有此要求的话）</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line"> </span><br><span class="line">    location /foo &#123;</span><br><span class="line">        set $a hello;</span><br><span class="line">        rewrite ^ /bar;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    location /bar &#123;</span><br><span class="line">        echo &quot;a = [$a]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里在 <code>location /foo</code> 中通过 <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank" rel="noopener">rewrite</a> 指令把当前请求的<code>URI</code>无条件地改写为 <code>/bar</code>，同时发起一个“内部跳转”，最终跳进了 <code>location /bar</code> 中。这里比较有趣的地方是“内部跳转”的工作原理。<strong>“内部跳转”本质上其实就是把当前的请求处理阶段强行倒退到 <code>find-config</code> 阶段，以便重新进行请求 <code>URI</code> 与 <code>location</code> 配置块的配对</strong>。比如上例中，运行在 <code>rewrite</code> 阶段的 <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank" rel="noopener">rewrite</a> 指令就让当前请求的处理阶段倒退回了 <code>find-config</code>阶段。由于此时当前请求的 <code>URI</code> 已经被 <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank" rel="noopener">rewrite</a> 指令修改为了 <code>/bar</code>，所以这一次换成了 <code>location /bar</code> 与当前请求相关联，然后再接着从 <code>rewrite</code> 阶段往下执行。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过这里更有趣的地方是，<strong>倒退回 <code>find-config</code> 阶段的动作并不是发生在 <code>rewrite</code> 阶段，而是发生在后面的 <code>post-rewrite</code> 阶段</strong>。上例中的 <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank" rel="noopener">rewrite</a> 指令只是简单地指示 <code>Nginx</code> 有必要在 <code>post-rewrite</code> 阶段发起“内部跳转”。这个设计对于 <code>Nginx</code> 初学者来说，或许显得有些古怪：“为什么不直接在 <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank" rel="noopener">rewrite</a> 指令执行时立即进行跳转呢？”答案其实很简单，那就是为了在最初匹配的 <code>location</code> 块中支持多次反复地改写<code>URI</code>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    rewrite ^ /bar;</span><br><span class="line">    rewrite ^ /baz;</span><br><span class="line"> </span><br><span class="line">    echo foo;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /bar &#123;</span><br><span class="line">    echo bar;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /baz &#123;</span><br><span class="line">    echo baz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里在 <code>location /foo</code> 中连续把当前请求的 <code>URI</code> 改写了两遍：第一遍先无条件地改写为 <code>/bar</code>，第二遍再无条件地改写为 <code>/baz</code>. 而这两条 <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank" rel="noopener">rewrite</a> 语句只会最终导致 <code>post-rewrite</code> 阶段发生一次“内部跳转”操作，从而不至于在第一次改写 <code>URI</code> 时就直接跳离了当前的 <code>location</code> 而导致后面的 <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank" rel="noopener">rewrite</a> 语句没有机会执行。请求 <code>/foo</code> 接口的结果证实了这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8080/foo</span><br><span class="line">baz</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从输出结果可以看到，上例确实成功地从 <code>/foo</code> 一步跳到了 <code>/baz</code> 中。如果启用 Nginx “调试日志”的话，还可以从 <code>find-config</code> 阶段生成的 <code>locatin</code> 块的匹配信息中进一步证实这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep &apos;using config&apos; logs/error.log</span><br><span class="line">[debug] 89449#0: *1 using configuration &quot;/foo&quot;</span><br><span class="line">[debug] 89449#0: *1 using configuration &quot;/baz&quot;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，对于该次请求，Nginx 一共只匹配过 <code>/foo</code> 和 <code>/baz</code> 这两个 <code>location</code>，从而只发生过一次“内部跳转”。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，如果在 <code>server</code> 配置块中直接使用 <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank" rel="noopener">rewrite</a> 配置指令对请求 URI 进行改写，则不会涉及“内部跳转”，因为此时 URI 改写发生在 <code>server-rewrite</code> 阶段，早于执行 <code>location</code> 配对的 <code>find-config</code> 阶段。比如下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line"> </span><br><span class="line">    rewrite ^/foo /bar;</span><br><span class="line"> </span><br><span class="line">    location /foo &#123;</span><br><span class="line">        echo foo;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    location /bar &#123;</span><br><span class="line">        echo bar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里，我们在 <code>server-rewrite</code> 阶段就把那些以 <code>/foo</code> 起始的 <code>URI</code> 改写为 <code>/bar</code>，而此时请求并没有和任何 <code>location</code> 相关联，所以 Nginx 正常往下运行 <code>find-config</code> 阶段，完成最终的 <code>location</code> 匹配。如果我们请求上例中的 <code>/foo</code> 接口，那么 <code>location /foo</code> 根本就没有机会匹配，因为在第一次（也是唯一的一次）运行 <code>find-config</code> 阶段时，当前请求的 <code>URI</code>已经被改写为 <code>/bar</code>，从而只会匹配 <code>location /bar</code>. 实际请求的输出正是如此：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8080/foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Nginx</code> “调试日志”可以再一次佐证我们的结论：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep &apos;using config&apos; logs/error.log</span><br><span class="line">[debug] 92693#0: *1 using configuration &quot;/bar&quot;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，<code>Nginx</code> 总共只进行过一次 <code>location</code> 匹配，并无“内部跳转”发生。</p><h2 id="preaccess"><a href="#preaccess" class="headerlink" title="preaccess"></a>preaccess</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运行在 <code>post-rewrite</code> 阶段之后的是所谓的 <code>preaccess</code> 阶段。该阶段在 <code>access</code> 阶段之前执行，故名 <code>preaccess</code>.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>标准模块 <a href="http://wiki.nginx.org/HttpLimitReqModule" target="_blank" rel="noopener">ngx_limit_req</a> 和 <a href="http://wiki.nginx.org/HttpLimitZoneModule" target="_blank" rel="noopener">ngx_limit_zone</a> 就运行在此阶段，前者可以控制请求的访问频度，而后者可以限制访问的并发度</strong>。这里我们仅仅和它们打个照面，后面还会有机会专门接触到这两个模块。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面反复提到的标准模块 <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank" rel="noopener">ngx_realip</a> 其实也在这个阶段注册了处理程序。有些读者可能会问：“这是为什么呢？它不是已经在 <code>post-read</code> 阶段注册处理程序了吗？”我们不妨通过下面这个例子来揭晓答案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line"> </span><br><span class="line">    location /test &#123;</span><br><span class="line">        set_real_ip_from 127.0.0.1;</span><br><span class="line">        real_ip_header X-Real-IP;</span><br><span class="line"> </span><br><span class="line">        echo &quot;from: $remote_addr&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与先看前到的例子相比，此例最重要的区别在于把 <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank" rel="noopener">ngx_realip</a> 的配置指令放在了 <code>location</code> 配置块中。前面我们介绍过，<code>Nginx</code> 匹配 <code>location</code> 的动作发生在 <code>find-config</code> 阶段，而 <code>find-config</code> 阶段远远晚于 <code>post-read</code>阶段执行，所以在 <code>post-read</code> 阶段，当前请求还没有和任何 <code>location</code> 相关联。在这个例子中，因为 <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank" rel="noopener">ngx_realip</a> 的配置指令都写在了 <code>location</code> 配置块中，所以在 <code>post-read</code> 阶段，<a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank" rel="noopener">ngx_realip</a> 模块的处理程序没有看到任何可用的配置信息，便不会执行来源地址的改写工作了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解决这个难题，<a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank" rel="noopener">ngx_realip</a> 模块便又特意在 <code>preaccess</code> 阶段注册了处理程序，这样它才有机会运行 <code>location</code> 块中的配置指令。正是因为这个缘故，上面这个例子的运行结果才符合直觉预期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -H &apos;X-Real-IP: 1.2.3.4&apos; localhost:8080/test</span><br><span class="line">from: 1.2.3.4</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不幸的是，<a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank" rel="noopener">ngx_realip</a> 模块的这个解决方案还是存在漏洞的，比如下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line"> </span><br><span class="line">    location /test &#123;</span><br><span class="line">        set_real_ip_from 127.0.0.1;</span><br><span class="line">        real_ip_header X-Real-IP;</span><br><span class="line"> </span><br><span class="line">        set $addr $remote_addr;</span><br><span class="line">        echo &quot;from: $addr&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里，我们在 <code>rewrite</code> 阶段将 <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank" rel="noopener">$remote_addr</a> 的值保存到了用户变量 <code>$addr</code> 中，然后再输出。因为 <code>rewrite</code>阶段先于 <code>preaccess</code> 阶段执行，所以当 <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank" rel="noopener">ngx_realip</a> 模块尚未在 <code>preaccess</code> 阶段改写来源地址时，最初的来源地址就已经在 <code>rewrite</code> 阶段被读取了。上例的实际请求结果证明了我们的结论：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -H &apos;X-Real-IP: 1.2.3.4&apos; localhost:8080/test</span><br><span class="line">from: 127.0.0.1</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出的地址确实是未经改写过的。<code>Nginx</code> 的“调试日志”可以进一步确认这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ grep -E &apos;http script (var|set)|realip&apos; logs/error.log</span><br><span class="line">[debug] 32488#0: *1 http script var: &quot;127.0.0.1&quot;</span><br><span class="line">[debug] 32488#0: *1 http script set $addr</span><br><span class="line">[debug] 32488#0: *1 realip: &quot;1.2.3.4&quot;</span><br><span class="line">[debug] 32488#0: *1 realip: 0100007F FFFFFFFF 0100007F</span><br><span class="line">[debug] 32488#0: *1 http script var: &quot;127.0.0.1&quot;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中第一行调试信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[debug] 32488#0: *1 http script var: &quot;127.0.0.1&quot;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 语句读取 <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank" rel="noopener">$remote_addr</a> 变量时产生的。信息中的字符串 <code>&quot;127.0.0.1&quot;</code> 便是 <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank" rel="noopener">$remote_addr</a> 当时读出来的值。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而第二行调试信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[debug] 32488#0: *1 http script set $addr</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则显示我们对变量 <code>$addr</code> 进行了赋值操作。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后面两行信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[debug] 32488#0: *1 realip: &quot;1.2.3.4&quot;</span><br><span class="line">[debug] 32488#0: *1 realip: 0100007F FFFFFFFF 0100007F</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是 <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank" rel="noopener">ngx_realip</a> 模块在 <code>preaccess</code> 阶段改写当前请求的来源地址。我们看到，改写后的新地址确实是期望的<code>1.2.3.4</code>. 但很明显这个操作发生在 <code>$addr</code> 变量赋值之后，所以已经太迟了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而最后一行信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[debug] 32488#0: *1 http script var: &quot;127.0.0.1&quot;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则是 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 配置指令在输出时读取变量 <code>$addr</code> 时产生的，我们看到它的值是改写前的来源地址。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看到这里，有的读者可能会问：“如果 <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank" rel="noopener">ngx_realip</a> 模块不在 <code>preaccess</code> 阶段注册处理程序，而在 <code>rewrite</code> 阶段注册，那么上例不就可以工作了？”答案是：不一定。因为 <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank" rel="noopener">ngx_rewrite</a> 模块的处理程序也同样注册在 <code>rewrite</code> 阶段，而前面特别提到，在这种情况下，<strong>不同模块之间的执行顺序一般是不确定的，所以 <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank" rel="noopener">ngx_realip</a> 的处理程序可能仍然在 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 语句之后执行</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  一个建议是：<strong>尽量在 <code>server</code> 配置块中配置 <a href="http://wiki.nginx.org/HttpRealIpModule" target="_blank" rel="noopener">ngx_realip</a> 这样的模块</strong>，以避免上面介绍的这种棘手的例外情况。</p><h2 id="access"><a href="#access" class="headerlink" title="access"></a>access</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>rewrite</code> 阶段之后，有一个名叫 <code>access</code> 的请求处理阶段。第三方模块 <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank" rel="noopener">ngx_auth_request</a> 的指令就运行在 <code>access</code> 阶段。在 <code>access</code> 阶段运行的配置指令多是<strong>执行访问控制</strong>性质的任务，比如检查用户的访问权限，检查用户的来源 IP 地址是否合法，诸如此类。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标准模块 <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank" rel="noopener">ngx_access</a>、第三方模块 <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank" rel="noopener">ngx_auth_request</a> 以及第三方模块 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 的 <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank" rel="noopener">access_by_lua</a> 指令就运行在这个阶段。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，<strong>标准模块 <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank" rel="noopener">ngx_access</a> 提供的 <a href="http://wiki.nginx.org/HttpAccessModule#allow" target="_blank" rel="noopener">allow</a> 和 <a href="http://wiki.nginx.org/HttpAccessModule#deny" target="_blank" rel="noopener">deny</a> 配置指令可用于控制哪些 IP 地址可以访问，哪些不可以</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /hello &#123;</span><br><span class="line">    allow 127.0.0.1;</span><br><span class="line">    deny all;</span><br><span class="line"> </span><br><span class="line">    echo &quot;hello world&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个 <code>/test</code> 接口被配置为只允许从本机（IP 地址为保留的 <code>127.0.0.1</code>）访问，而从其他 IP 地址访问都会被拒（返回 <code>403</code> 错误页）。<strong><a href="http://wiki.nginx.org/HttpAccessModule" target="_blank" rel="noopener">ngx_access</a> 模块自己的多条配置指令之间是按顺序执行的，直到遇到第一条满足条件的指令就不再执行后续的 <a href="http://wiki.nginx.org/HttpAccessModule#allow" target="_blank" rel="noopener">allow</a> 和 <a href="http://wiki.nginx.org/HttpAccessModule#deny" target="_blank" rel="noopener">deny</a> 指令</strong>。如果首先匹配的指令是 <a href="http://wiki.nginx.org/HttpAccessModule#allow" target="_blank" rel="noopener">allow</a>，则会继续执行后续其他模块的指令或者跳到后续的处理阶段；而如果首先满足的是 <a href="http://wiki.nginx.org/HttpAccessModule#deny" target="_blank" rel="noopener">deny</a> 则会立即中止当前整个请求的处理，并立即返回 <code>403</code>错误页。所以看上面这个例子，如果是从本地访问的，则首先匹配 <code>allow 127.0.0.1</code> 这一条语句，于是 <code>Nginx</code> 就继续往下执行其他模块的指令以及后续的处理阶段；而如果是从其他机器访问，则首先匹配的则是 <code>deny all</code>这一条语句，即拒绝所有地址，它会导致 <code>403</code> 错误页立即返回给客户端。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们来实测一下。从本机访问这个接口可以得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/hello&apos;</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而从另一台机器访问这台机器（假设运行 Nginx 的机器地址是 <code>192.168.1.101</code>）提供的接口时则得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://192.168.1.101:8080/hello&apos;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=&quot;white&quot;&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得一提的是，<a href="http://wiki.nginx.org/HttpAccessModule" target="_blank" rel="noopener">ngx_access</a> 模块还支持所谓的“CIDR 记法”来表示一个网段，例如 <code>169.200.179.4/24</code> 则表示路由前缀是 <code>169.200.179.0</code>（或者说子网掩码是 <code>255.255.255.0</code>）的网段。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为 <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank" rel="noopener">ngx_access</a> 模块的指令运行在 <code>access</code> 阶段，而 <code>access</code> 阶段又处于 <code>rewrite</code> 阶段之后，所以前面我们见到的所有那些在 <code>rewrite</code> 阶段运行的配置指令，都总是在 <a href="http://wiki.nginx.org/HttpAccessModule#allow" target="_blank" rel="noopener">allow</a> 和 <a href="http://wiki.nginx.org/HttpAccessModule#deny" target="_blank" rel="noopener">deny</a> 之前执行，而无论它们在配置文件中的书写顺序是怎样的。所以，<strong>为了避免阅读配置时的混乱，我们应该总是让指令的书写顺序和它们的实际执行顺序保持一致</strong>。</p><h2 id="access-tail与access-by-lua"><a href="#access-tail与access-by-lua" class="headerlink" title="access tail与access_by_lua"></a>access tail与access_by_lua</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 模块提供了配置指令 <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank" rel="noopener">access_by_lua</a>，用于在 <code>access</code> 请求处理阶段插入用户 <code>Lua</code>代码。这条指令<strong>运行于 <code>access</code> 阶段的末尾，因此总是在 <a href="http://wiki.nginx.org/HttpAccessModule#allow" target="_blank" rel="noopener">allow</a> 和 <a href="http://wiki.nginx.org/HttpAccessModule#deny" target="_blank" rel="noopener">deny</a> 这样的指令之后运行，虽然它们同属 <code>access</code> 阶段</strong>。一般我们通过 <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank" rel="noopener">access_by_lua</a> 在 <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank" rel="noopener">ngx_access</a> 这样的模块检查过客户端 IP 地址之后，再通过 <code>Lua</code>代码执行一系列更为复杂的请求验证操作，比如实时查询数据库或者其他后端服务，以验证当前用户的身份或权限。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们来看一个简单的例子，利用 <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank" rel="noopener">access_by_lua</a> 来实现 <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank" rel="noopener">ngx_access</a> 模块的 IP 地址过滤功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">location /hello &#123;</span><br><span class="line">    access_by_lua &apos;</span><br><span class="line">        if ngx.var.remote_addr == &quot;127.0.0.1&quot; then</span><br><span class="line">            return</span><br><span class="line">        end</span><br><span class="line"> </span><br><span class="line">        ngx.exit(403)</span><br><span class="line">    &apos;;</span><br><span class="line"> </span><br><span class="line">    echo &quot;hello world&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里在 <code>Lua</code> 代码中通过引用 <code>Nginx</code> 标准的内建变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank" rel="noopener">$remote_addr</a> 来获取字符串形式的客户端 IP 地址，然后用 <code>Lua</code> 的 <code>if</code> 语句判断是否为本机地址，即是否等于 <code>127.0.0.1</code>. 如果是本机地址，则直接利用<code>Lua</code> 的 <code>return</code> 语句返回，让 <code>Nginx</code> 继续执行后续的请求处理阶段（包括 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令所处的 <code>content</code> 阶段）；而如果不是本机地址，则通过 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 模块提供的 <code>Lua</code>函数 <a href="http://wiki.nginx.org/HttpLuaModule#ngx.exit" target="_blank" rel="noopener">ngx.exit</a> 中断当前的整个请求处理流程，直接返回 <code>403</code>错误页给客户端。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个例子在功能上完全等价于使用 <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank" rel="noopener">ngx_access</a> 模块的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /hello &#123;</span><br><span class="line">    allow 127.0.0.1;</span><br><span class="line">    deny all;</span><br><span class="line"> </span><br><span class="line">    echo &quot;hello world&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然这两个例子在功能上完全相同，但在性能上还是有区别的，毕竟 <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank" rel="noopener">ngx_access</a> 是用纯 C 实现的专门化的 <code>Nginx</code>模块。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面使用 <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank" rel="noopener">access_by_lua</a> 的例子还可以通过换用 <a href="http://wiki.nginx.org/HttpCoreModule#.24binary_remote_addr" target="_blank" rel="noopener">$binary_remote_addr</a> 内建变量进行优化，因为 <a href="http://wiki.nginx.org/HttpCoreModule#.24binary_remote_addr" target="_blank" rel="noopener">$binary_remote_addr</a> 读出的是二进制形式的 IP 地址，而 <a href="http://wiki.nginx.org/HttpCoreModule#.24remote_addr" target="_blank" rel="noopener">$remote_addr</a> 则返回更长一些的字符串形式的地址。更短的地址意味着用<code>Lua</code> 进行字符串比较时通常可以更快。</p><h2 id="post-access"><a href="#post-access" class="headerlink" title="post-access"></a>post-access</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>access</code> 阶段之后便是 <code>post-access</code> 阶段。从这个阶段的名字，我们也能一眼看出它是紧跟在 <code>access</code> 阶段后面执行的。这个阶段也和 <code>post-rewrite</code> 阶段类似，<strong>并不支持 <code>Nginx</code>模块注册处理程序，而是由 Nginx 核心自己完成一些处理工作</strong>。<code>post-access</code> 阶段<strong>主要用于配合 <code>access</code> 阶段实现标准 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html" target="_blank" rel="noopener">ngx_http_core</a> 模块提供的配置指令 <a href="http://wiki.nginx.org/HttpCoreModule#satisfy" target="_blank" rel="noopener">satisfy</a> 的功能</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于多个 Nginx 模块注册在 <code>access</code> 阶段的处理程序，<strong><a href="http://wiki.nginx.org/HttpCoreModule#satisfy" target="_blank" rel="noopener">satisfy</a> 配置指令可以用于控制它们彼此之间的协作方式</strong>。比如模块 A 和 B 都在 <code>access</code> 阶段注册了与访问控制相关的处理程序，那就有两种协作方式，一是模块 A 和模块 B 都得通过验证才算通过，二是模块 A 和模块 B 只要其中任一个通过验证就算通过。第一种协作方式称为 <code>all</code> 方式（或者说“与关系”），第二种方式则被称为 <code>any</code> 方式（或者说“或关系”）。默认情况下，<code>Nginx</code> 使用的是 <code>all</code> 方式。下面是一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    satisfy all;</span><br><span class="line"> </span><br><span class="line">    deny all;</span><br><span class="line">    access_by_lua &apos;ngx.exit(ngx.OK)&apos;;</span><br><span class="line"> </span><br><span class="line">    echo something important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里，我们在 <code>/test</code> 接口中同时配置了 <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank" rel="noopener">ngx_access</a> 模块和 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 模块，这样 <code>access</code> 阶段就由这两个模块一起来做检验工作。其中，语句 <code>deny all</code> 会让 <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank" rel="noopener">ngx_access</a> 模块的处理程序总是拒绝当前请求，而语句<code>access_by_lua &#39;ngx.exit(ngx.OK)&#39;</code> 则总是允许访问。当我们通过 <a href="http://wiki.nginx.org/HttpCoreModule#satisfy" target="_blank" rel="noopener">satisfy</a> 指令配置了 <code>all</code> 方式时，就需要 <code>access</code> 阶段的所有模块都通过验证，但不幸的是，这里 <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank" rel="noopener">ngx_access</a> 模块总是会拒绝访问，所以整个请求就会被拒：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8080/test</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=&quot;white&quot;&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;细心的读者会在 <code>Nginx</code> 错误日志文件中看到类似下面这一行的出错信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[error] 6549\#0: *1 access forbidden by rule</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然而，如果我们把上例中的 <code>satisfy all</code> 语句更改为 <code>satisfy any</code>，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    satisfy any;</span><br><span class="line"> </span><br><span class="line">    deny all;</span><br><span class="line">    access_by_lua &apos;ngx.exit(ngx.OK)&apos;;</span><br><span class="line"> </span><br><span class="line">    echo something important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结果则会完全不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8080/test</span><br><span class="line">something important</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即请求反而最终通过了验证。这是因为在 <code>any</code> 方式下，<code>access</code> 阶段只要有一个模块通过了验证，就会认为请求整体通过了验证，而在上例中，<a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 模块的 <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank" rel="noopener">access_by_lua</a> 语句总是会通过验证的。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在配置了 <code>satisfy any</code> 的情况下，只有当 <code>access</code> 阶段的所有模块的处理程序都拒绝访问时，整个请求才会被拒</strong>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    satisfy any;</span><br><span class="line"> </span><br><span class="line">    deny all;</span><br><span class="line">    access_by_lua &apos;ngx.exit(ngx.HTTP_FORBIDDEN)&apos;;</span><br><span class="line"> </span><br><span class="line">    echo something important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时访问 <code>/test</code> 接口才会得到 <code>403 Forbidden</code> 错误页。这里，<code>post-access</code> 阶段参与了 <code>access</code> 阶段各模块处理程序的“或关系”的实现。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得一提的是，上面这几个的例子需要 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 0.5.0rc19 或以上版本；之前的版本是不能和 <code>satisfy any</code> 配置语句一起工作的。</p><h2 id="try-files"><a href="#try-files" class="headerlink" title="try-files"></a>try-files</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;紧跟在 <code>post-access</code> 阶段之后的是 <code>try-files</code> 阶段。这个阶段专门用于实现标准配置指令 <a href="http://wiki.nginx.org/HttpCoreModule#try_files" target="_blank" rel="noopener">try_files</a>的功能，<strong>并不支持 Nginx 模块注册处理程序</strong>。由于 <a href="http://wiki.nginx.org/HttpCoreModule#try_files" target="_blank" rel="noopener">try_files</a> 指令在许多 <code>FastCGI</code> 应用的配置中都有用到，所以我们不妨在这里简单介绍一下。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://wiki.nginx.org/HttpCoreModule#try_files" target="_blank" rel="noopener">try_files</a> 指令接受两个以上任意数量的参数，每个参数都指定了一个 <code>URI</code>. 这里假设配置了 <code>N</code> 个参数，则 <code>Nginx</code> 会在 <code>try-files</code> 阶段，依次把前 <code>N-1</code> 个参数映射为文件系统上的对象（文件或者目录），然后检查这些对象是否存在。一旦<code>Nginx</code> 发现某个文件系统对象存在，就会在 <code>try-files</code> 阶段把当前请求的 <code>URI</code> 改写为该对象所对应的参数 <code>URI</code>（但不会包含末尾的斜杠字符，也不会发生 “内部跳转”）。如果前 <code>N-1</code> 个参数所对应的文件系统对象都不存在，<code>try-files</code> 阶段就会立即发起“内部跳转”到最后一个参数（即第 <code>N</code> 个参数）所指定的<code>URI</code>.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;静态资源服务模块会把当前请求的 <code>URI</code> 映射到文件系统，通过 <a href="http://wiki.nginx.org/HttpCoreModule#root" target="_blank" rel="noopener">root</a> 配置指令所指定的“文档根目录”进行映射。例如，当“文档根目录”是 <code>/var/www/</code> 的时候，请求 <code>URI</code> <code>/foo/bar</code> 会被映射为文件 <code>/var/www/foo/bar</code>，而请求 <code>URI</code> <code>/foo/baz/</code> 则会被映射为目录 <code>/var/www/foo/baz/</code>. 注意这里是如何通过 <code>URI</code> 末尾的斜杠字符是否存在来区分“目录”和“文件”的。我们正在讨论的 <a href="http://wiki.nginx.org/HttpCoreModule#try_files" target="_blank" rel="noopener">try_files</a>配置指令使用同样的规则来完成其各个参数 <code>URI</code> 到文件系统对象的映射。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不妨来看下面这个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">root /var/www/;</span><br><span class="line"> </span><br><span class="line">location /test &#123;</span><br><span class="line">    try_files /foo /bar/ /baz;</span><br><span class="line">    echo &quot;uri: $uri&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /foo &#123;</span><br><span class="line">    echo foo;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /bar/ &#123;</span><br><span class="line">    echo bar;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /baz &#123;</span><br><span class="line">    echo baz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里通过 <a href="http://wiki.nginx.org/HttpCoreModule#root" target="_blank" rel="noopener">root</a> 指令把“文档根目录”配置为 <code>/var/www/</code>，如果你系统中的 <code>/var/www/</code> 路径下存放有重要数据，则可以把它替换为其他任意路径，但此路径对运行 <code>Nginx worker</code> 进程的系统帐号至少有可读权限。我们在<code>location /test</code> 中使用了 <a href="http://wiki.nginx.org/HttpCoreModule#try_files" target="_blank" rel="noopener">try_files</a> 配置指令，并提供了三个参数，<code>/foo</code>、<code>/bar/</code> 和 <code>/baz</code>. 根据前面对 <a href="http://wiki.nginx.org/HttpCoreModule#try_files" target="_blank" rel="noopener">try_files</a> 指令的介绍，我们可以知道，它会在 <code>try-files</code> 阶段依次检查前两个参数 <code>/foo</code> 和 <code>/bar/</code> 所对应的文件系统对象是否存在。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不妨先来做一组实验。假设现在 <code>/var/www/</code> 路径下是空的，则第一个参数 <code>/foo</code> 映射成的文件<code>/var/www/foo</code> 是不存在的；同样，对于第二个参数 <code>/bar/</code> 所映射成的目录 <code>/var/www/bar/</code> 也是不存在的。于是此时 <code>Nginx</code> 会在 <code>try-files</code> 阶段发起到最后一个参数所指定的<code>URI</code>（即 <code>/baz</code>）的“内部跳转”。实际的请求结果证实了这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8080/test</span><br><span class="line">baz</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，该请求最终和 <code>location /baz</code> 绑定在一起，执行了输出 <code>baz</code> 字符串的工作。上例中定义的 <code>location /foo</code> 和 <code>location /bar/</code> 完全不会参与这里的运行过程，因为对于 <a href="http://wiki.nginx.org/HttpCoreModule#try_files" target="_blank" rel="noopener">try_files</a> 的前 <code>N-1</code> 个参数，<code>Nginx</code> 只会检查文件系统，而不会去执行 <code>URI</code>与 <code>location</code> 之间的匹配。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于上面这个请求，<code>Nginx</code> 会产生类似下面这样的“调试日志”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ grep trying logs/error.log</span><br><span class="line">[debug] 3869#0: *1 trying to use file: &quot;/foo&quot; &quot;/var/www/foo&quot;</span><br><span class="line">[debug] 3869#0: *1 trying to use dir: &quot;/bar&quot; &quot;/var/www/bar&quot;</span><br><span class="line">[debug] 3869#0: *1 trying to use file: &quot;/baz&quot; &quot;/var/www/baz&quot;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过这些信息可以清楚地看到 <code>try-files</code> 阶段发生的事情：Nginx 依次检查了文件 <code>/var/www/foo</code> 和目录<code>/var/www/bar</code>，末了又处理了最后一个参数 <code>/baz</code>. 这里最后一条“调试信息”容易产生误解，会让人误以为 <code>Nginx</code>也把最后一个参数 <code>/baz</code> 给映射成了文件系统对象进行检查，事实并非如此。当 <a href="http://wiki.nginx.org/HttpCoreModule#try_files" target="_blank" rel="noopener">try_files</a> 指令处理到它的最后一个参数时，总是直接执行“内部跳转”，而不论其对应的文件系统对象是否存在。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来再做一组实验：在 <code>/var/www/</code> 下创建一个名为 <code>foo</code> 的文件，其内容为 <code>hello world</code>（注意你需要有 <code>/var/www/</code> 目录下的写权限）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &apos;hello world&apos; &gt; /var/www/foo</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后再请求 <code>/test</code> 接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8080/test</span><br><span class="line">uri: /foo</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里发生了什么？我们来看，<a href="http://wiki.nginx.org/HttpCoreModule#try_files" target="_blank" rel="noopener">try_files</a> 指令的第一个参数 <code>/foo</code> 可以映射为文件 <code>/var/www/foo</code>，而 <code>Nginx</code> 在 <code>try-files</code> 阶段发现此文件确实存在，于是立即把当前请求的 <code>URI</code> 改写为这个参数的值，即 <code>/foo</code>，并且不再继续检查后面的参数，而直接运行后面的请求处理阶段。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面这个请求在 <code>try-files</code> 阶段所产生的“调试日志”如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep trying logs/error.log</span><br><span class="line">[debug] 4132#0: *1 trying to use file: &quot;/foo&quot; &quot;/var/www/foo&quot;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，在 <code>try-files</code> 阶段，<code>Nginx</code> 确实只检查和处理了 <code>/foo</code> 这一个参数，而后面的参数都被“短路”掉了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类似地，假设我们删除刚才创建的 <code>/var/www/foo</code> 文件，而在 <code>/var/www/</code> 下创建一个名为 <code>bar</code> 的子目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /var/www/bar</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则请求 <code>/test</code> 的结果也是类似的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8080/test</span><br><span class="line">uri: /bar</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这种情况下，<code>Nginx</code> 在 <code>try-files</code> 阶段发现第一个参数 <code>/foo</code> 对应的文件不存在，就会转向检查第二个参数对应的文件系统对象（在这里便是目录 <code>/var/www/bar/</code>）。由于此目录存在，<code>Nginx</code> 就会把当前请求的 <code>URI</code> 改写为第二个参数的值，即 <code>/bar</code>（注意，原始参数值是 <code>/bar/</code>，但 <a href="http://wiki.nginx.org/HttpCoreModule#try_files" target="_blank" rel="noopener">try_files</a> 会自动去除末尾的斜杠字符）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一组实验所产生的“调试日志”如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ grep trying logs/error.log</span><br><span class="line">[debug] 4223#0: *1 trying to use file: &quot;/foo&quot; &quot;/var/www/foo&quot;</span><br><span class="line">[debug] 4223#0: *1 trying to use dir: &quot;/bar&quot; &quot;/var/www/bar&quot;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，<a href="http://wiki.nginx.org/HttpCoreModule#try_files" target="_blank" rel="noopener">try_files</a> 指令在这里只检查和处理了它的前两个参数。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过前面这几组实验不难看到，<a href="http://wiki.nginx.org/HttpCoreModule#try_files" target="_blank" rel="noopener">try_files</a> 指令本质上只是有条件地改写当前请求的 <code>URI</code>，而这里说的“条件”其实就是文件系统上的对象是否存在。当“条件”都不满足时，它就会无条件地发起一个指定的“内部跳转”。当然，除了无条件地发起“内部跳转”之外，<a href="http://wiki.nginx.org/HttpCoreModule#try_files" target="_blank" rel="noopener">try_files</a> 指令还支持直接返回指定状态码的<code>HTTP</code>错误页，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">try_files /foo /bar/ =404;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这行配置是说，当 <code>/foo</code> 和 <code>/bar/</code> 参数所对应的文件系统对象都不存在时，就直接返回 <code>404 Not Found</code> 错误页。注意这里它是如何使用等号字符前缀来标识 HTTP 状态码的。</p><h2 id="content"><a href="#content" class="headerlink" title="content"></a>content</h2><h3 id="location里面指定生成内容方式"><a href="#location里面指定生成内容方式" class="headerlink" title="location里面指定生成内容方式"></a>location里面指定生成内容方式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Nginx</code>的 <code>content</code> 阶段是所有请求处理阶段中最为重要的一个，因为运行在这个阶段的配置指令一般都肩负着<strong>生成“内容”（content）并输出 HTTP 响应的使命</strong>。正因为其重要性，这个阶段的配置指令也异常丰富，例如前面我们一直在示例中使用的 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令、 <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank" rel="noopener">echo_exec</a> 指令、<a href="http://wiki.nginx.org/HttpProxyModule#proxy_pass" target="_blank" rel="noopener">proxy_pass</a> 指令、<a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank" rel="noopener">echo_location</a> 指令、<a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> 指令，都运行在这个阶段。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>content</code> 阶段属于一个比较靠后的处理阶段，运行在先前介绍过的 <code>rewrite</code> 和 <code>access</code> 这两个阶段之后。当和 <code>rewrite</code>、<code>access</code> 阶段的指令一起使用时，这个阶段的指令总是最后运行，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    # rewrite phase</span><br><span class="line">    set $age 1;</span><br><span class="line">    rewrite_by_lua &quot;ngx.var.age = ngx.var.age + 1&quot;;</span><br><span class="line"> </span><br><span class="line">    # access phase</span><br><span class="line">    deny 10.32.168.49;</span><br><span class="line">    access_by_lua &quot;ngx.var.age = ngx.var.age * 3&quot;;</span><br><span class="line"> </span><br><span class="line">    # content phase</span><br><span class="line">    echo &quot;age = $age&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个例子中各个配置指令的执行顺序便是它们的书写顺序。测试结果完全符合预期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">age = 6</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使改变它们的书写顺序，也不会影响到执行顺序。其中，<a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令来自 <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank" rel="noopener">ngx_rewrite</a> 模块，运行于 <code>rewrite</code>阶段；而 <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> 指令来自 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 模块，运行于 <code>rewrite</code> 阶段的末尾；接下来，<a href="http://wiki.nginx.org/HttpAccessModule#deny" target="_blank" rel="noopener">deny</a> 指令来自 <a href="http://wiki.nginx.org/HttpAccessModule" target="_blank" rel="noopener">ngx_access</a> 模块，运行于 <code>access</code> 阶段；再下来，<a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank" rel="noopener">access_by_lua</a> 指令同样来自 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 模块，运行于 <code>access</code> 阶段的末尾；最后，我们的老朋友 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令则来自 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 模块，运行在 <code>content</code> 阶段。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个例子展示了通过同时使用多个处理阶段的配置指令来实现多个模块协同工作的效果。在这个过程中，<code>Nginx</code> 变量则经常扮演着在指令间乃至模块间传递（小份）数据的角色。这些配置指令的执行顺序，也强烈地受到请求处理阶段的影响。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进一步地，在 <code>rewrite</code> 和 <code>access</code> 这两个阶段，多个模块的配置指令可以同时使用，譬如上例中的 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a>指令和 <a href="http://wiki.nginx.org/HttpLuaModule#rewrite_by_lua" target="_blank" rel="noopener">rewrite_by_lua</a> 指令同处 <code>rewrite</code> 阶段，而 <a href="http://wiki.nginx.org/HttpAccessModule#deny" target="_blank" rel="noopener">deny</a> 指令和 <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank" rel="noopener">access_by_lua</a> 指令则同处 <code>access</code> 阶段。但不幸的是，这通常不适用于 <code>content</code> 阶段。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;绝大多数 <code>Nginx</code> 模块在向 <code>content</code> 阶段注册配置指令时，本质上是在当前的 <code>location</code> 配置块中注册所谓的“内容处理程序”（<code>content handler</code>）。<strong>每一个 <code>location</code> 只能有一个“内容处理程序”，因此，当在 <code>location</code> 中同时使用多个模块的 <code>content</code> 阶段指令时，只有其中一个模块能成功注册“内容处理程序”</strong>。考虑下面这个有问题的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    echo hello;</span><br><span class="line">    content_by_lua &apos;ngx.say(&quot;world&quot;)&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里，<a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 模块的 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令和 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 模块的 <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> 指令同处 <code>content</code> 阶段，于是只有其中一个模块能注册和运行这个 <code>location</code> 的“内容处理程序”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">world</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际运行结果表明，写在后面的 <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> 指令反而胜出了，而 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令则完全没有运行。具体哪一个模块的指令会胜出是不确定的，例如把上例中的 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 语句和 <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> 语句交换顺序，则输出就会变成<code>hello</code>，即 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 模块胜出。所以我们应当<strong>避免在同一个 <code>location</code> 中使用多个模块的 <code>content</code> 阶段指令</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将上例中的 <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> 指令替换为 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令就可以如愿了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    echo hello;</span><br><span class="line">    echo world;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试结果证明了这一点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">hello</span><br><span class="line">world</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里使用多条 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令是没问题的，因为它们同属 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 模块，而且 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 模块规定和实现了它们之间的执行顺序。值得一提的是，并非所有模块的指令都支持在同一个 <code>location</code> 中被使用多次，例如 <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> 就只能使用一次，所以下面这个例子是错误的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> location /test &#123;</span><br><span class="line">    content_by_lua &apos;ngx.say(&quot;hello&quot;)&apos;;</span><br><span class="line">    content_by_lua &apos;ngx.say(&quot;world&quot;)&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个配置在 <code>Nginx</code> 启动时就会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[emerg] &quot;content_by_lua&quot; directive is duplicate ...</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;正确的写法应当是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    content_by_lua &apos;ngx.say(&quot;hello&quot;) ngx.say(&quot;world&quot;)&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即在 <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> 内联的 Lua 代码中调用两次 <a href="http://wiki.nginx.org/HttpLuaModule#ngx.say" target="_blank" rel="noopener">ngx.say</a> 函数，而不是在当前 <code>location</code> 中使用两次<a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> 指令。</p><p>​    类似地，<strong><a href="http://wiki.nginx.org/HttpProxyModule" target="_blank" rel="noopener">ngx_proxy</a> 模块的 <a href="http://wiki.nginx.org/HttpProxyModule#proxy_pass" target="_blank" rel="noopener">proxy_pass</a> 指令和 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令也不能同时用在一个 <code>location</code> 中，因为它们也同属 <code>content</code> 阶段</strong>。不少 <code>Nginx</code> 新手都会犯类似下面这样的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    echo &quot;before...&quot;;</span><br><span class="line">    proxy_pass http://127.0.0.1:8080/foo;</span><br><span class="line">    echo &quot;after...&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /foo &#123;</span><br><span class="line">    echo &quot;contents to be proxied&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个例子表面上是想在 <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank" rel="noopener">ngx_proxy</a> 模块返回的内容前后，通过 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 模块的 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令分别输出字符串 <code>&quot;before...&quot;</code> 和 <code>&quot;after...&quot;</code>，但其实只有其中一个模块能在 <code>content</code> 阶段运行。测试结果表明，在这个例子中是 <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank" rel="noopener">ngx_proxy</a> 模块胜出，而 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 模块的 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令根本没有运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">contents to be proxied</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要实现这个例子希望达到的效果，需要改用 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 模块提供的 <a href="http://wiki.nginx.org/HttpEchoModule#echo_before_body" target="_blank" rel="noopener">echo_before_body</a> 和 <a href="http://wiki.nginx.org/HttpEchoModule#echo_after_body" target="_blank" rel="noopener">echo_after_body</a> 这两条配置指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    echo_before_body &quot;before...&quot;;</span><br><span class="line">    proxy_pass http://127.0.0.1:8080/foo;</span><br><span class="line">    echo_after_body &quot;after...&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /foo &#123;</span><br><span class="line">    echo &quot;contents to be proxied&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;测试结果表明这一次我们成功了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">before...</span><br><span class="line">contents to be proxied</span><br><span class="line">after...</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>配置指令 <a href="http://wiki.nginx.org/HttpEchoModule#echo_before_body" target="_blank" rel="noopener">echo_before_body</a> 和 <a href="http://wiki.nginx.org/HttpEchoModule#echo_after_body" target="_blank" rel="noopener">echo_after_body</a> 之所以可以和其他模块运行在 <code>content</code> 阶段的指令一起工作，是因为它们运行在 <code>Nginx</code> 的“输出过滤器”中</strong>。前面我们在分析 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令产生的“调试日志”时已经知道，<code>Nginx</code>在输出响应体数据时都会调用“输出过滤器”，所以 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 模块才有机会在“输出过滤器”中对 <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank" rel="noopener">ngx_proxy</a> 模块产生的响应体输出进行修改（即在首尾添加新的内容）。值得一提的是，“输出过滤器”并不属于中提到的那 11 个请求处理阶段（毕竟许多阶段都可以通过输出响应体数据来调用“输出过滤器”），但这并不妨碍 <a href="http://wiki.nginx.org/HttpEchoModule#echo_before_body" target="_blank" rel="noopener">echo_before_body</a> 和 <a href="http://wiki.nginx.org/HttpEchoModule#echo_after_body" target="_blank" rel="noopener">echo_after_body</a> 指令在文档中标记下面这一行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phase: output filter</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一行的意思是，当前配置指令运行在“输出过滤器”这个特殊的阶段。</p><h3 id="静态资源服务模块"><a href="#静态资源服务模块" class="headerlink" title="静态资源服务模块"></a><strong>静态资源服务模块</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面我们提到，在一个 <code>location</code> 中使用 <code>content</code> 阶段指令时，通常情况下就是对应的 <code>Nginx</code> 模块注册该 <code>location</code> 中的“内容处理程序”。那么<strong>当一个 <code>location</code> 中未使用任何 <code>content</code> 阶段的指令，即没有模块注册“内容处理程序”时，<code>content</code> 阶段会发生什么事情呢？</strong>谁又来担负起生成内容和输出响应的重担呢？答案就是那些把当前请求的 <code>URI</code>映射到文件系统的<strong>静态资源服务模块</strong>。当存在“内容处理程序”时，这些静态资源服务模块并不会起作用；反之，请求的处理权就会自动落到这些模块上。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Nginx</code> 一般会在 <code>content</code> 阶段安排三个这样的静态资源服务模块（除非你的<code>Nginx</code>在构造时显式禁用了这三个模块中的一个或者多个，又或者启用了这种类型的其他模块）。按照它们在 <code>content</code> 阶段的运行顺序，<strong>依次是 <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank" rel="noopener">ngx_index</a> 模块，<a href="http://wiki.nginx.org/HttpAutoindexModule" target="_blank" rel="noopener">ngx_autoindex</a> 模块，以及 <code>ngx_static</code> 模块</strong>。下面就来逐一介绍一下这三个模块。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="http://wiki.nginx.org/HttpIndexModule" target="_blank" rel="noopener">ngx_index</a> 和 <a href="http://wiki.nginx.org/HttpAutoindexModule" target="_blank" rel="noopener">ngx_autoindex</a> 模块都只会作用于那些 URI 以 <code>/</code> 结尾的请求</strong>，例如请求 <code>GET /cats/</code>，而对于不以 <code>/</code> 结尾的请求则会直接忽略，同时把处理权移交给 <code>content</code> 阶段的下一个模块。而<strong><code>ngx_static</code> 模块则刚好相反，直接忽略那些 URI 以 <code>/</code> 结尾的请求</strong>。</p><h4 id="ngx-index"><a href="#ngx-index" class="headerlink" title="ngx_index"></a>ngx_index</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><a href="http://wiki.nginx.org/HttpIndexModule" target="_blank" rel="noopener">ngx_index</a> 模块主要用于在文件系统目录中自动查找指定的首页文件</strong>，类似 <code>index.html</code> 和 <code>index.htm</code>这样的，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root /var/www/;</span><br><span class="line">    index index.htm index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样，当用户请求 <code>/</code> 地址时，<code>Nginx</code> 就会自动在 <a href="http://wiki.nginx.org/HttpCoreModule#root" target="_blank" rel="noopener">root</a> 配置指令指定的文件系统目录下依次寻找 <code>index.htm</code> 和 <code>index.html</code> 这两个文件。如果 <code>index.htm</code> 文件存在，则直接发起“内部跳转”到 <code>/index.htm</code> 这个新的地址；而如果 <code>index.htm</code> 文件不存在，则继续检查 <code>index.html</code> 是否存在。如果存在，同样发起“内部跳转”到<code>/index.html</code>；如果 <code>index.html</code> 文件仍然不存在，则放弃处理权给 <code>content</code> 阶段的下一个模块。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们前面提到， <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank" rel="noopener">echo_exec</a> 指令和 <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank" rel="noopener">rewrite</a> 指令可以发起“内部跳转”。这种跳转会自动修改当前请求的 <code>URI</code>，并且重新匹配与之对应的 <code>location</code> 配置块，再重新执行<code>rewrite</code>、<code>access</code>、<code>content</code> 等处理阶段。因为是“内部跳转”，所以有别于 HTTP 协议中定义的基于 302 和 301 响应的“外部跳转”，最终用户的浏览器的地址栏也不会发生变化，依然是原来的 <code>URI</code>位置。而 <strong><a href="http://wiki.nginx.org/HttpIndexModule" target="_blank" rel="noopener">ngx_index</a> 模块一旦找到了 <a href="http://wiki.nginx.org/HttpIndexModule#index" target="_blank" rel="noopener">index</a> 指令中列举的文件之后，就会发起这样的“内部跳转”，仿佛用户是直接请求的这个文件所对应的 <code>URI</code>一样</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了进一步确认 <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank" rel="noopener">ngx_index</a> 模块在找到文件时的“内部跳转”行为，我们不妨设计下面这个小例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root /var/www/;</span><br><span class="line">    index index.html;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /index.html &#123;</span><br><span class="line">    set $a 32;</span><br><span class="line">    echo &quot;a = $a&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时我们在本机的 <code>/var/www/</code> 目录下创建一个空白的 <code>index.html</code> 文件，并确保该文件的权限设置对于运行<code>Nginx worker</code> 进程的帐户可读。然后我们来请求一下根位置（<code>/</code>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/&apos;</span><br><span class="line">a = 32</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里发生了什么？为什么输出不是 <code>index.html</code> 文件的内容（即空白）？首先对于用户的原始请求 <code>GET /</code>，<code>Nginx</code> 匹配出 <code>location /</code> 来处理它，然后 <code>content</code> 阶段的 <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank" rel="noopener">ngx_index</a> 模块在 <code>/var/www/</code> 下找到了 <code>index.html</code>，于是立即发起一个到 <code>/index.html</code> 位置的“内部跳转”。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这里，相信大家都不会有问题。接下来有趣的事情发生了！在重新为 <code>/index.html</code> 这个新位置匹配<code>location</code> 配置块时，<code>location /index.html</code> 的优先级要高于 <code>location /</code>，因为 <code>location</code> 块按照<code>URI</code> 前缀来匹配时遵循所谓的“最长子串匹配语义”。这样，在进入 <code>location /index.html</code> 配置块之后，又重新开始执行 <code>rewrite</code> 、<code>access</code>、以及 <code>content</code> 等阶段。最终输出 <code>a = 32</code> 自然也就在情理之中了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们接着研究上面这个例子。如果此时把 <code>/var/www/index.html</code> 文件删除，再访问 <code>/</code> 又会发生什么事情呢？答案是返回 <code>403 Forbidden</code> 出错页。为什么呢？因为 <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank" rel="noopener">ngx_index</a> 模块找不到 <a href="http://wiki.nginx.org/HttpIndexModule#index" target="_blank" rel="noopener">index</a> 指令指定的文件（在这里就是 <code>index.html</code>），接着把处理权转给 <code>content</code> 阶段的后续模块，而后续的模块也都无法处理这个请求，于是 <code>Nginx</code>只好放弃，输出了错误页，并且在 <code>Nginx</code>错误日志中留下了类似这一行信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[error] 28789#0: *1 directory index of &quot;/var/www/&quot; is forbidden</span><br></pre></td></tr></table></figure><h4 id="ngx-autoindex"><a href="#ngx-autoindex" class="headerlink" title="ngx_autoindex"></a>ngx_autoindex</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓<strong><code>directory index</code> 便是生成“目录索引”的意思，典型的方式就是生成一个网页，上面列举出 <code>/var/www/</code>目录下的所有文件和子目录</strong>。而运行在 <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank" rel="noopener">ngx_index</a> 模块之后的 <a href="http://wiki.nginx.org/HttpAutoindexModule" target="_blank" rel="noopener">ngx_autoindex</a> 模块就可以用于自动生成这样的“目录索引”网页。我们来把上例修改一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root /var/www/;</span><br><span class="line">    index index.html;</span><br><span class="line">    autoindex on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时仍然保持文件系统中的 <code>/var/www/index.html</code> 文件不存在。我们再访问 <code>/</code> 位置时，就会得到一张漂亮的网页：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/&apos;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;Index of /&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=&quot;white&quot;&gt;</span><br><span class="line">&lt;h1&gt;Index of /&lt;/h1&gt;&lt;hr&gt;&lt;pre&gt;&lt;a href=&quot;../&quot;&gt;../&lt;/a&gt;</span><br><span class="line">&lt;a href=&quot;cgi-bin/&quot;&gt;cgi-bin/&lt;/a&gt;  08-Mar-2010 19:36   -</span><br><span class="line">&lt;a href=&quot;error/&quot;&gt;error/&lt;/a&gt;      08-Mar-2010 19:36   -</span><br><span class="line">&lt;a href=&quot;htdocs/&quot;&gt;htdocs/&lt;/a&gt;    05-Apr-2010 03:55   -</span><br><span class="line">&lt;a href=&quot;icons/&quot;&gt;icons/&lt;/a&gt;      08-Mar-2010 19:36   -</span><br><span class="line">&lt;/pre&gt;&lt;hr&gt;&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;生成的 <code>HTML</code> 源码显示，我本机的 <code>/var/www/</code> 目录下还有 <code>cgi-bin/</code>, <code>error/</code>, <code>htdocs/</code>, 以及 <code>icons/</code> 这几个子目录。在你的系统中尝试上面的例子，输出很可能会不太一样。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值得一提的是，当你的文件系统中存在 <code>/var/www/index.html</code> 时，优先运行的 <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank" rel="noopener">ngx_index</a> 模块就会发起“内部跳转”，根本轮不到 <a href="http://wiki.nginx.org/HttpAutoindexModule" target="_blank" rel="noopener">ngx_autoindex</a> 执行。感兴趣的读者可以自己测试一下。</p><h4 id="ngx-static"><a href="#ngx-static" class="headerlink" title="ngx_static"></a>ngx_static</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>content</code> 阶段默认“垫底”的最后一个模块便是极为常用的 <code>ngx_static</code> 模块。这个模块主要实现<strong>服务静态文件</strong>的功能。比方说，一个网站的静态资源，包括静态 <code>.html</code> 文件、静态 <code>.css</code> 文件、静态 <code>.js</code> 文件、以及静态图片文件等等，全部可以通过这个模块对外服务。前面介绍的 <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank" rel="noopener">ngx_index</a> 模块虽然可以在指定的首页文件存在时发起“内部跳转”，但<strong>真正把相应的首页文件服务出去（即把该文件的内容作为响应体数据输出，并设置相应的响应头），还是得靠这个 <code>ngx_static</code> 模块来完成</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;来看一个 <code>ngx_static</code> 模块服务磁盘文件的例子。我们使用下面这个配置片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    root /var/www/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同时在本机的 <code>/var/www/</code> 目录下创建两个文件，一个文件叫做 <code>index.html</code>，内容是一行文本 <code>this is my home</code>；另一个文件叫做 <code>hello.html</code>，内容是一行文本 <code>hello world</code>. 同时注意这两个文件的权限设置，确保它们都对运行 <code>Nginx worker</code> 进程的系统帐户可读。</p><p>​    现在来通过 HTTP 协议请求一下这两个文件所对应的 URI：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/index.html&apos;</span><br><span class="line">this is my home</span><br><span class="line"> </span><br><span class="line">$ curl &apos;http://localhost:8080/hello.html&apos;</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，先前创建的那两个磁盘文件的内容被分别输出了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不妨来分析一下这里发生的事情：<code>location /</code> 中没有使用运行在 <code>content</code> 阶段的模块指令，于是也就没有模块注册这个 <code>location</code> 的“内容处理程序”，处理权便自动落到了在 <code>content</code> 阶段“垫底”的那 3 个静态资源服务模块。首先运行的 <a href="http://wiki.nginx.org/HttpIndexModule" target="_blank" rel="noopener">ngx_index</a> 和 <a href="http://wiki.nginx.org/HttpAutoindexModule" target="_blank" rel="noopener">ngx_autoindex</a> 模块先后看到当前请求的 URI，<code>/index.html</code> 和<code>/hello.html</code>，并不以 <code>/</code> 结尾，于是直接弃权，将处理权转给了最后运行的 <code>ngx_static</code> 模块。<code>ngx_static</code> 模块根据 <a href="http://wiki.nginx.org/HttpCoreModule#root" target="_blank" rel="noopener">root</a> 指令指定的“文档根目录”（document root），分别将请求 URI <code>/index.html</code> 和 <code>/hello.html</code>映射为文件系统路径 <code>/var/www/index.html</code> 和 <code>/var/www/hello.html</code>，在确认这两个文件存在后，将它们的内容分别作为响应体输出，并自动设置 <code>Content-Type</code>、<code>Content-Length</code> 以及 <code>Last-Modified</code> 等响应头。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了确认 <code>ngx_static</code> 模块确实运行了，可以启用 <code>Nginx</code> “调试日志”，然后再次请求 <code>/index.html</code> 这个接口。此时，在 <code>Nginx</code> 错误日志文件中可以看到类似下面这一行的调试信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[debug] 3033#0: *1 http static fd: 8</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一行信息便是 <code>ngx_static</code> 模块生成的，其含义是“正在输出的静态文件的描述符是数字 <code>8</code>”。当然，具体的文件描述符编号会经常发生变化，这里只是我机器的一次典型输出。值得一提的是，能生成这一行调试信息的还有标准模块 <a href="http://wiki.nginx.org/HttpGzipStaticModule" target="_blank" rel="noopener">ngx_gzip_static</a> ，但它默认是不启用的，后面会专门介绍到这个模块。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意上面这个例子中使用的 <a href="http://wiki.nginx.org/HttpCoreModule#root" target="_blank" rel="noopener">root</a> 配置指令只起到了声明“文档根目录”的作用，并不是它开启了 <code>ngx_static</code> 模块。<code>ngx_static</code> 模块总是处于开启状态，但是否轮得到它运行就要看 <code>content</code> 阶段先于它运行的那些模块是否“弃权”了。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了进一步确认这一点，来看下面这个空白 <code>location</code> 的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为没有配置 <a href="http://wiki.nginx.org/HttpCoreModule#root" target="_blank" rel="noopener">root</a> 指令，所以在访问这个接口时，<code>Nginx</code> 会自动计算出一个缺省的“文档根目录”。该缺省值是取所谓的“配置前缀”（configure prefix）路径下的 <code>html/</code> 子目录。举一个例子，假设“配置前缀”是<code>/foo/bah/</code>，则缺省的“文档根目录”便是 <code>/foo/bar/html/</code>.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 那么“配置前缀”是由什么来决定的呢？默认情况下，就是 Nginx 安装时的根目录（或者说 Nginx 构造时传递给 <code>./configure</code> 脚本的 <code>--prefix</code> 选项的路径值）。如果 Nginx 安装到了 <code>/usr/local/nginx/</code> 下，则“配置前缀”便是 <code>/usr/local/nginx/</code>，同时默认的“文档根目录”便是 <code>/usr/local/nginx/html/</code>. 不过，我们也可以在启动 <code>Nginx</code> 的时候，通过 <code>--prefix</code> 命令行选项临时指定自己的“配置前缀”路径。假设我们启动<code>Nginx</code> 时使用的命令是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -p /home/agentzh/test/</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;则对于该服务器实例，其“配置前缀”便是 <code>/home/agentzh/test/</code>，而默认的“文档根目录”便是<code>/home/agentzh/test/html/</code>. “配置前缀”不仅会决定默认的“文档根目录”，还决定着 <code>Nginx</code>配置文件中许多相对路径值如何解释为绝对路径，后面我们还会看到许多需要引用到“配置前缀”的例子。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 获取当前“文档根目录”的路径有一个非常简便的方法，那就是请求一个肯定不存在的文件所对应的资源名，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/blah-blah.txt&apos;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=&quot;white&quot;&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们会很自然地得到 <code>404</code> 错误页。此时再看 <code>Nginx</code> 错误日志文件，应该会看到类似下面这一行错误消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[error] 9364#0: *1 open() &quot;/home/agentzh/test/html/blah-blah.txt&quot; failed (2: No such file or directory)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这条错误消息是 <code>ngx_static</code> 模块打印出来的，因为它并不能在文件系统的对应路径上找到名为 <code>blah-blah.txt</code>的文件。因为这条错误信息中包含有 <code>ngx_static</code> 试图打开的文件的绝对路径，所以从这个路径不难看出，当前的“文档根目录”是 <code>/home/agentzh/test/html/</code>.</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多初学者会想当然地把 <code>404</code> 错误理解为某个 <code>location</code> 不存在，其实上面这个例子表明，即使<code>location</code> 存在并成功匹配，也是可能返回 <code>404</code> 错误页的。因为<strong>决定着 <code>404</code> 错误页的是抽象的“资源”是否存在，而非某个具体的 <code>location</code> 是否存在</strong>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;初学者常犯的一个错误是忘记配置 <code>content</code> 阶段的模块指令，而他们自己其实并不期望使用 <code>content</code> 阶段缺省运行的静态资源服务，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location /auth &#123;</span><br><span class="line">    access_by_lua &apos;</span><br><span class="line">        -- a lot of Lua code omitted here...</span><br><span class="line">    &apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，这个 <code>/auth</code> 接口只定义了 <code>access</code> 阶段的配置指令，即 <a href="http://wiki.nginx.org/HttpLuaModule#access_by_lua" target="_blank" rel="noopener">access_by_lua</a>，并未定义任何 <code>content</code> 阶段的配置指令。于是当我们请求 <code>/auth</code> 接口时，在 <code>access</code> 阶段的 <code>Lua</code> 代码会如期执行，然后 <code>content</code> 阶段的那些静态文件服务会紧接着自动发生作用，直至 <code>ngx_static</code> 模块去文件系统上找名为 <code>auth</code> 的文件。而经常地，<code>404</code> 错误页会抛出，除非运气太好，在对应路径上确实存在一个叫做 <code>auth</code> 的文件。所以，一条经验是，<strong>当遇到意外的 <code>404</code> 错误并且又不涉及静态文件服务时，应当首先检查是否在对应的 <code>location</code> 配置块中恰当地配置了 <code>content</code> 阶段的模块指令</strong>，例如 <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank" rel="noopener">content_by_lua</a>、 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 以及 <a href="http://wiki.nginx.org/HttpProxyModule#proxy_pass" target="_blank" rel="noopener">proxy_pass</a> 之类。当然，<code>Nginx</code> 的 <code>error.log</code>文件一般总是会提供各种意外问题的答案，例如对于上面这个例子，我的 <code>error.log</code> 中有下面这条错误信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[error] 9364#0: *1 open() &quot;/home/agentzh/test/html/auth&quot; failed (2: No such file or directory)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Nginx配置指令的执行顺序&quot;&gt;&lt;a href=&quot;#Nginx配置指令的执行顺序&quot; class=&quot;headerlink&quot; title=&quot;Nginx配置指令的执行顺序&quot;&gt;&lt;/a&gt;Nginx配置指令的执行顺序&lt;/h1&gt;&lt;h2 id=&quot;总览&quot;&gt;&lt;a href=&quot;#总览&quot;
      
    
    </summary>
    
      <category term="Nginx" scheme="http://blog.com/categories/Nginx/"/>
    
      <category term="OpenResty" scheme="http://blog.com/categories/Nginx/OpenResty/"/>
    
      <category term="Lua" scheme="http://blog.com/categories/Nginx/OpenResty/Lua/"/>
    
    
      <category term="Nginx" scheme="http://blog.com/tags/Nginx/"/>
    
      <category term="Lua" scheme="http://blog.com/tags/Lua/"/>
    
      <category term="OpenResty" scheme="http://blog.com/tags/OpenResty/"/>
    
  </entry>
  
  <entry>
    <title>lua操作数据库</title>
    <link href="http://blog.com/2019/09/19/lua%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://blog.com/2019/09/19/lua操作数据库/</id>
    <published>2019-09-19T04:12:57.000Z</published>
    <updated>2019-09-19T14:53:55.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lua操作数据库"><a href="#lua操作数据库" class="headerlink" title="lua操作数据库"></a>lua操作数据库</h1><h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">wget http://luarocks.org/releases/luarocks-2.2.1.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zvxf luarocks-2.2.1.tar.gz </span><br><span class="line"></span><br><span class="line">cd luarocks-2.2.1/</span><br><span class="line"></span><br><span class="line">./configure --prefix=/usr/local/lua/luarocks --with-lua=/usr/local/lua</span><br><span class="line"></span><br><span class="line">make bootstrap</span><br><span class="line"></span><br><span class="line">/usr/local/lua/luarocks/bin/luarocks install luasql-mysql MYSQL_DIR=/usr/local/mysql</span><br><span class="line"></span><br><span class="line">mkdir /usr/local/lua/lib/lua/5.3/luasql</span><br><span class="line"></span><br><span class="line">cp /usr/local/lua/luarocks/lib/lua/5.3/luasql/mysql.so </span><br><span class="line"></span><br><span class="line">/usr/local/lua/lib/lua/5.3/luasql/</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">package</span>.<span class="built_in">cpath</span> = <span class="string">'/usr/local/lua/lib/lua/5.3/?.so;'</span></span><br><span class="line"> </span><br><span class="line">luasql=<span class="built_in">require</span> <span class="string">"luasql.mysql"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--创建环境对象</span></span><br><span class="line">env = luasql.mysql()</span><br><span class="line"></span><br><span class="line"><span class="comment">----连接数据库</span></span><br><span class="line">conn = env:connect(<span class="string">"dish"</span>,<span class="string">"root"</span>,<span class="string">"liuzemingtenxun"</span>,<span class="string">"127.0.0.1"</span>,<span class="number">3306</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">----设置数据库的编码格式</span></span><br><span class="line">conn:<span class="built_in">execute</span>(<span class="string">"SET NAMES UTF8"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">----执行数据库操作</span></span><br><span class="line">cur = conn:<span class="built_in">execute</span>(<span class="string">"select * from user"</span>)</span><br><span class="line"></span><br><span class="line">row = cur:fetch(&#123;&#125;,<span class="string">"a"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> row <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(row.id, row.openid)</span><br><span class="line">    row = cur:fetch(row,<span class="string">"a"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">conn:<span class="built_in">close</span>()  <span class="comment">--关闭数据库连接</span></span><br><span class="line">env:<span class="built_in">close</span>()   <span class="comment">--关闭数据库环境</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;lua操作数据库&quot;&gt;&lt;a href=&quot;#lua操作数据库&quot; class=&quot;headerlink&quot; title=&quot;lua操作数据库&quot;&gt;&lt;/a&gt;lua操作数据库&lt;/h1&gt;&lt;h2 id=&quot;安装包&quot;&gt;&lt;a href=&quot;#安装包&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="Lua" scheme="http://blog.com/categories/Lua/"/>
    
    
      <category term="Lua" scheme="http://blog.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>Lua基础语法</title>
    <link href="http://blog.com/2019/09/19/Lua%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://blog.com/2019/09/19/Lua基础语法/</id>
    <published>2019-09-19T04:12:57.000Z</published>
    <updated>2019-09-19T14:47:18.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lua基础语法"><a href="#Lua基础语法" class="headerlink" title="Lua基础语法"></a>Lua基础语法</h1><h2 id="lua脚本"><a href="#lua脚本" class="headerlink" title="lua脚本"></a>lua脚本</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim hello.lua</span><br><span class="line"></span><br><span class="line">#!/usr/bin/lua</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Hello World！"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"www.runoob.com"</span>)</span><br><span class="line"></span><br><span class="line">chmod <span class="number">755</span> hello.lua</span><br><span class="line">./hello.lua</span><br><span class="line">lua hello.lua</span><br></pre></td></tr></table></figure><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(1)两个减号是单行注释 </span><br><span class="line">--</span><br><span class="line">(2)多行注释  </span><br><span class="line">--[[</span><br><span class="line"> 多行注释</span><br><span class="line"> 多行注释</span><br><span class="line"> --]]</span><br><span class="line"> </span><br><span class="line"> 多行注释推荐使用 --[=[注释内容]=]，这样可以避免遇到table[table[idx]]时就将多行注释结束了。</span><br></pre></td></tr></table></figure><h3 id="2-命名规则"><a href="#2-命名规则" class="headerlink" title="2. 命名规则"></a>2. 命名规则</h3><ol><li><strong>变量名中只能够包含字母、数字、_</strong></li><li><strong>不能够以数字开头</strong></li><li>建议不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样</li><li><strong>区分大小写</strong></li></ol><h3 id="3-关键词"><a href="#3-关键词" class="headerlink" title="3. 关键词"></a>3. 关键词</h3><p>以下列出了 Lua 的保留关键字。保留关键字不能作为常量或变量或其他用户自定义标示符：</p><table><thead><tr><th>and</th><th>break</th><th>do</th><th>else</th></tr></thead><tbody><tr><td>elseif</td><td>end</td><td>false</td><td>for</td></tr><tr><td>function</td><td>if</td><td>in</td><td>local</td></tr><tr><td>nil</td><td>not</td><td>or</td><td>repeat</td></tr><tr><td>return</td><td>then</td><td>true</td><td>until</td></tr><tr><td>while</td><td></td><td></td></tr></tbody></table><p>一般约定，**以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量</p><h3 id="4-变量"><a href="#4-变量" class="headerlink" title="4. 变量"></a>4. 变量</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>1. 在默认情况下，变量总是认为是全局的，那怕是语句块或是函数里，除非用 local 显式声明为局部变量</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>2. 全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，只不过得到的结果是：nil</strong></p><p>​     <strong>3. 使用local关键字可以标识为局部变量</strong></p><p>​     <strong>4. 如果你想删除一个全局变量，只需要将变量赋值为nil</strong></p><p>​     <strong>5. 当且仅当一个变量不等于nil时，这个变量即存在</strong></p><p>​     <strong>6. 局部变量的作用域为从声明位置开始到所在语句块结束</strong></p><p>​     <strong>7. 变量的默认值均为 nil</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(b)</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&gt; b=<span class="number">10</span></span><br><span class="line">&gt; <span class="built_in">print</span>(b)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"></span><br><span class="line">如果你想删除一个全局变量，只需要将变量赋值为<span class="literal">nil</span>。</span><br><span class="line">&gt; b = <span class="literal">nil</span></span><br><span class="line">&gt; <span class="built_in">print</span>(b)      <span class="comment">--&gt; nil</span></span><br><span class="line">这样变量b就好像从没被使用过一样。换句话说, 当且仅当一个变量不等于<span class="literal">nil</span>时，这个变量即存在。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1. 变量在使用前，必须在代码中进行声明，即创建该变量。</span><br><span class="line"></span><br><span class="line">2. 编译程序执行代码之前编译器需要知道如何给语句变量开辟存储区，用于存储变量的值。</span><br><span class="line"></span><br><span class="line">3. Lua 变量有三种类型：全局变量、局部变量、表中的域。</span><br><span class="line"></span><br><span class="line">4. Lua 中的变量全是全局变量，那怕是语句块或是函数里，除非用 local 显式声明为局部变量。</span><br><span class="line"></span><br><span class="line">5. 局部变量的作用域为从声明位置开始到所在语句块结束。</span><br><span class="line"></span><br><span class="line">6. 变量的默认值均为 nil。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a = 5               -- 全局变量</span><br><span class="line">local b = 5         -- 局部变量</span><br><span class="line"></span><br><span class="line">function joke()</span><br><span class="line">    c = 5           -- 全局变量</span><br><span class="line">    local d = 6     -- 局部变量</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">joke()</span><br><span class="line">print(c,d)          --&gt; 5 nil</span><br><span class="line"></span><br><span class="line">do </span><br><span class="line">    local a = 6     -- 局部变量</span><br><span class="line">    b = 6           -- 对局部变量重新赋值</span><br><span class="line">    print(a,b);     --&gt; 6 6</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">print(a,b)      --&gt; 5 6</span><br></pre></td></tr></table></figure><h4 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">"hello"</span> .. <span class="string">"world"</span></span><br><span class="line">t=&#123;&#125;</span><br><span class="line">t[<span class="string">"n"</span>]=<span class="number">100</span></span><br><span class="line">t.n = t.n + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">--hello world</span></span><br><span class="line"><span class="built_in">print</span>(t.n) <span class="comment">--101</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lua可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="number">10</span>, <span class="number">2</span>*x       &lt;<span class="comment">--&gt;       a=10; b=2*x</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遇到赋值语句Lua会<strong>先计算右边所有的值然后再执行赋值操作</strong>，所以我们可以这样进行交换变量的值</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y = y, x                     <span class="comment">-- swap 'x' for 'y'</span></span><br><span class="line">a[i], a[j] = a[j], a[i]         <span class="comment">-- swap 'a[i]' for 'a[j]'</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a. 变量个数 &gt; 值的个数             按变量个数补足nil</span><br><span class="line">b. 变量个数 &lt; 值的个数             多余的值会被忽略</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = 0, 1</span><br><span class="line">print(a,b,c)             --&gt; 0   1   nil</span><br><span class="line"> </span><br><span class="line">a, b = a+1, b+1, b+2     -- value of b+2 is ignored</span><br><span class="line">print(a,b)               --&gt; 1   2</span><br><span class="line"> </span><br><span class="line">a, b, c = 0</span><br><span class="line">print(a,b,c)             --&gt; 0   nil   nil</span><br></pre></td></tr></table></figure><p><strong>如果要对多个变量赋值必须依次对每个变量赋值</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a, b, c = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(a,b,c)             <span class="comment">--&gt; 0   0   0</span></span><br></pre></td></tr></table></figure><p><strong>多值赋值经常用来交换变量，或将函数调用返回给变量</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>,<span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">a,b=f()</span><br><span class="line"><span class="built_in">print</span>(a, b) <span class="comment">-- 1 2</span></span><br></pre></td></tr></table></figure><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>尽可能的使用局部变量，有两个好处：</p><ul><li>避免命名冲突。</li><li>访问局部变量的速度比全局变量更快</li></ul><h3 id="5-数据类型"><a href="#5-数据类型" class="headerlink" title="5. 数据类型"></a>5. 数据类型</h3><p>Lua是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。</p><p>Lua中有8个基本类型分别为：<strong>nil、boolean、number、string、userdata、function、thread和table</strong></p><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>nil</td><td>这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。</td></tr><tr><td>boolean</td><td>包含两个值：false和true。</td></tr><tr><td>number</td><td>表示双精度类型的实浮点数</td></tr><tr><td>string</td><td>字符串由一对双引号或单引号来表示</td></tr><tr><td>function</td><td>由 C 或 Lua 编写的函数</td></tr><tr><td>userdata</td><td>表示任意存储在变量中的C数据结构</td></tr><tr><td>thread</td><td>表示执行的独立线路，用于执行协同程序</td></tr><tr><td>table</td><td>Lua 中的表（table）其实是一个”关联数组”（associative arrays），数组的索引可以是数字或者是字符串。在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。</td></tr></tbody></table><p><strong>使用type函数测试给定变量或者值的类型</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="string">"Hello world"</span>))      <span class="comment">--&gt; string</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">10.4</span>*<span class="number">3</span>))             <span class="comment">--&gt; number</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">print</span>))              <span class="comment">--&gt; function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>))               <span class="comment">--&gt; function</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">true</span>))               <span class="comment">--&gt; boolean</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">nil</span>))                <span class="comment">--&gt; nil</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">type</span>(X)))            <span class="comment">--&gt; string</span></span><br></pre></td></tr></table></figure><h4 id="1-nil（空）"><a href="#1-nil（空）" class="headerlink" title="(1) nil（空）"></a>(1) nil（空）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nil 类型表示一种没有任何有效值，它只有一个值 – nil，例如打印一个没有赋值的变量，便会输出一个 nil 值，<strong>等价于其它语言的null</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(<span class="built_in">type</span>(a))</span><br><span class="line"><span class="literal">nil</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>对于全局变量和 table，nil 还有一个”删除”作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">tab1 = &#123; key1 = <span class="string">"val1"</span>, key2 = <span class="string">"val2"</span>, <span class="string">"val3"</span> &#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(tab1) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k .. <span class="string">" - "</span> .. v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    1 - val3</span></span><br><span class="line"><span class="comment">    key1 - val1</span></span><br><span class="line"><span class="comment">    key2 - val2 </span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line"></span><br><span class="line">tab1.key1 = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(tab1) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k .. <span class="string">" - "</span> .. v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    key1 - val1</span></span><br><span class="line"><span class="comment">    key2 - val2 </span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><p><strong>nil 作类型比较时应该加上双引号 “</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(<span class="built_in">type</span>(X))</span><br><span class="line"><span class="literal">nil</span></span><br><span class="line">&gt; <span class="built_in">print</span>(<span class="built_in">type</span>(X)==<span class="literal">nil</span>)</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&gt; <span class="built_in">print</span>(<span class="built_in">type</span>(X)==<span class="string">"nil"</span>)</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p><code>type(X)==nil</code>结果为 <strong>false</strong> 的原因是因为 <code>type(type(X))</code>返回<strong>string</strong></p><p><code>print(type(type(nil)))</code>返回<strong>string</strong></p><h4 id="2-boolean（布尔）"><a href="#2-boolean（布尔）" class="headerlink" title="(2) boolean（布尔）"></a>(2) boolean（布尔）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean 类型只有两个可选值：true（真） 和 false（假），<strong>Lua 把 false 和 nil 看作是”假”，其他的都为”真”</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">true</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">false</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="literal">nil</span>))</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> <span class="literal">false</span> <span class="keyword">or</span> <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"至少有一个是 true"</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"false 和 nil 都为 false!"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    boolean</span></span><br><span class="line"><span class="comment">boolean</span></span><br><span class="line"><span class="comment">    nil</span></span><br><span class="line"><span class="comment">    false 和 nil 都为 false!  </span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h4 id="3-number（数字）"><a href="#3-number（数字）" class="headerlink" title="(3) number（数字）"></a>(3) number（数字）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Lua 默认只有一种 number 类型 – double（双精度）类型</strong>（默认类型可以修改 luaconf.h 里的定义）</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">2.2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">0.2</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">2e+1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">0.2e-1</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="number">7.8263692594256e-06</span>))</span><br><span class="line"></span><br><span class="line">number</span><br><span class="line">number</span><br><span class="line">number</span><br><span class="line">number</span><br><span class="line">number</span><br><span class="line">number</span><br></pre></td></tr></table></figure><h4 id="4-string（字符串）"><a href="#4-string（字符串）" class="headerlink" title="(4) string（字符串）"></a>(4) string（字符串）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串由一对<strong>双引号或单引号</strong>来表示。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string1 = <span class="string">"this is string1"</span></span><br><span class="line">string2 = <span class="string">'this is string2'</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也可以用<strong>2 个方括号 “[[]]” 来表示”一块”字符串</strong>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">html = <span class="string">[[</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;a href="http://www.runoob.com/"&gt;菜鸟教程&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br><span class="line"><span class="string">]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(html)</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    &lt;html&gt;</span></span><br><span class="line"><span class="comment">    &lt;head&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="comment">    &lt;body&gt;</span></span><br><span class="line"><span class="comment">        &lt;a href="http://www.runoob.com/"&gt;菜鸟教程&lt;/a&gt;</span></span><br><span class="line"><span class="comment">    &lt;/body&gt;</span></span><br><span class="line"><span class="comment">    &lt;/html&gt;</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><p><strong>在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(<span class="string">"2"</span> + <span class="number">6</span>)</span><br><span class="line"><span class="number">8.0</span></span><br><span class="line">&gt; <span class="built_in">print</span>(<span class="string">"2"</span> + <span class="string">"6"</span>)</span><br><span class="line"><span class="number">8.0</span></span><br><span class="line">&gt; <span class="built_in">print</span>(<span class="string">"2 + 6"</span>)</span><br><span class="line"><span class="number">2</span> + <span class="number">6</span></span><br><span class="line">&gt; <span class="built_in">print</span>(<span class="string">"-2e2"</span> * <span class="string">"6"</span>)</span><br><span class="line"><span class="number">-1200.0</span></span><br><span class="line">&gt; <span class="built_in">print</span>(<span class="string">"error"</span> + <span class="number">1</span>)</span><br><span class="line"><span class="built_in">stdin</span>:<span class="number">1</span>: attempt to perform arithmetic on a <span class="built_in">string</span> value</span><br><span class="line">stack <span class="built_in">traceback</span>:</span><br><span class="line">    <span class="built_in">stdin</span>:<span class="number">1</span>: <span class="keyword">in</span> main chunk</span><br><span class="line">    [C]: <span class="keyword">in</span> ?</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p> <strong>字符串连接使用的是.. </strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">print</span>(<span class="string">"a"</span> .. <span class="string">'b'</span>)</span><br><span class="line">ab</span><br><span class="line">&gt; <span class="built_in">print</span>(<span class="number">157</span> .. <span class="number">428</span>)</span><br><span class="line"><span class="number">157428</span></span><br></pre></td></tr></table></figure><p><strong>使用 # 来计算字符串的长度，放在字符串前面</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">len</span> = <span class="string">"www.runoob.com"</span></span><br><span class="line">&gt; <span class="built_in">print</span>(#<span class="built_in">len</span>)</span><br><span class="line"><span class="number">14</span></span><br><span class="line">&gt; <span class="built_in">print</span>(#<span class="string">"www.runoob.com"</span>)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure><h4 id="5-table（表）"><a href="#5-table（表）" class="headerlink" title="(5) table（表）"></a>(5) table（表）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Lua 里，table 的创建是通过”构造表达式”来完成，最简单<strong>构造表达式是{}</strong>，用来创建一个空表。也可以在表里添加一些数据，直接初始化表</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个空的 table</span></span><br><span class="line"><span class="keyword">local</span> tbl1 = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 直接初始表</span></span><br><span class="line"><span class="keyword">local</span> tbl2 = &#123;<span class="string">"apple"</span>, <span class="string">"pear"</span>, <span class="string">"orange"</span>, <span class="string">"grape"</span>&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lua 中的表（table）其实是一个<strong>“关联数组”</strong>（<code>associative arrays</code>），<strong>数组的索引可以是数字或者是字符串</strong>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- table_test.lua 脚本文件</span></span><br><span class="line">a = &#123;&#125;</span><br><span class="line">a[<span class="string">"key"</span>] = <span class="string">"value"</span></span><br><span class="line">key = <span class="number">10</span></span><br><span class="line">a[key] = <span class="number">22</span></span><br><span class="line">a[key] = a[key] + <span class="number">11</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k .. <span class="string">" : "</span> .. v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    key : value</span></span><br><span class="line"><span class="comment">10 : 33</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不同于其他语言的数组把 0 作为数组的初始索引，<strong>在 Lua 里表的默认初始索引一般以 1 开始</strong>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- table_test2.lua 脚本文件</span></span><br><span class="line"><span class="keyword">local</span> tbl = &#123;<span class="string">"apple"</span>, <span class="string">"pear"</span>, <span class="string">"orange"</span>, <span class="string">"grape"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key, val <span class="keyword">in</span> <span class="built_in">pairs</span>(tbl) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Key"</span>, key)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    Key    1</span></span><br><span class="line"><span class="comment">    Key    2</span></span><br><span class="line"><span class="comment">    Key    3</span></span><br><span class="line"><span class="comment">    Key    4</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><p><strong>table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil</strong>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- table_test3.lua 脚本文件</span></span><br><span class="line">a3 = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">    a3[i] = i</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">a3[<span class="string">"key"</span>] = <span class="string">"val"</span></span><br><span class="line"><span class="built_in">print</span>(a3[<span class="string">"key"</span>])</span><br><span class="line"><span class="built_in">print</span>(a3[<span class="string">"none"</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a3[<span class="string">"key"</span>]) <span class="comment">--val</span></span><br><span class="line"><span class="built_in">print</span>(a3[<span class="string">"none"</span>]) <span class="comment">--nil</span></span><br><span class="line"><span class="built_in">print</span>(a3[<span class="number">1</span>]) <span class="comment">--1</span></span><br><span class="line"><span class="built_in">print</span>(a3[<span class="number">2</span>]) <span class="comment">--2</span></span><br></pre></td></tr></table></figure><p>对 table 的索引使用方括号 []。<strong>Lua 也提供了 . 操作</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t[i]</span><br><span class="line">t.i                 -- 当索引为字符串类型时的一种简化写法</span><br><span class="line">gettable_event(t,i) -- 采用索引访问本质上是一个类似这样的函数调用</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">site = &#123;&#125;</span><br><span class="line">site[<span class="string">"key"</span>] = <span class="string">"www.w3cschool.cc"</span></span><br><span class="line"><span class="built_in">print</span>(site[<span class="string">"key"</span>]) <span class="comment">--www.w3cschool.cc</span></span><br><span class="line"><span class="built_in">print</span>(site.key)    <span class="comment">--www.w3cschool.cc</span></span><br></pre></td></tr></table></figure><h4 id="6-function（函数）"><a href="#6-function（函数）" class="headerlink" title="(6) function（函数）"></a>(6) function（函数）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Lua 中，函数是被看作是”第一类值（First-Class Value）”，<strong>函数可以存在变量里</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- function_test.lua 脚本文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial1</span><span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n * factorial1(n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(factorial1(<span class="number">5</span>)) <span class="comment">--120</span></span><br><span class="line">factorial2 = factorial1</span><br><span class="line"><span class="built_in">print</span>(factorial2(<span class="number">5</span>)) <span class="comment">--120</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>function 可以以匿名函数（anonymous function）的方式通过参数传递</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- function_test2.lua 脚本文件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFun</span><span class="params">(tab,fun)</span></span></span><br><span class="line">    <span class="keyword">for</span> k ,v <span class="keyword">in</span> <span class="built_in">pairs</span>(tab) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(fun(k,v));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tab=&#123;key1=<span class="string">"val1"</span>,key2=<span class="string">"val2"</span>&#125;;</span><br><span class="line">testFun(tab,</span><br><span class="line"><span class="function"><span class="keyword">function</span><span class="params">(key,val)</span></span><span class="comment">--匿名函数</span></span><br><span class="line">    <span class="keyword">return</span> key..<span class="string">"="</span>..val;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">func= <span class="function"><span class="keyword">function</span><span class="params">(key,val)</span></span></span><br><span class="line">    <span class="keyword">return</span> key..<span class="string">"="</span>..val;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">testFun(tab, func)</span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    key1=val1</span></span><br><span class="line"><span class="comment">    key2=val2</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h4 id="7-协程"><a href="#7-协程" class="headerlink" title="(7) 协程"></a>(7) 协程</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Lua 里，最主要的线程是协同程序（coroutine）。它跟线程（thread）差不多，拥有自己独立的栈、局部变量和指令指针，可以跟其他协同程序共享全局变量和其他大部分东西。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;线程跟协程的区别：线程可以同时多个运行，而<strong>协程任意时刻只能运行一个，并且处于运行状态的协程只有被挂起（suspend）时才会暂停</strong>。</p><h4 id="8-userdata（自定义类型）"><a href="#8-userdata（自定义类型）" class="headerlink" title="(8) userdata（自定义类型）"></a>(8) userdata（自定义类型）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;userdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。</p><h3 id="6-流程控制"><a href="#6-流程控制" class="headerlink" title="6. 流程控制"></a>6. 流程控制</h3><h4 id="1-if语句"><a href="#1-if语句" class="headerlink" title="1. if语句"></a>1. if语句</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( 布尔表达式 <span class="number">1</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 在布尔表达式 1 为 true 时执行该语句块 --]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elseif</span>( 布尔表达式 <span class="number">2</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 在布尔表达式 2 为 true 时执行该语句块 --]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">elseif</span>( 布尔表达式 <span class="number">3</span>)</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 在布尔表达式 3 为 true 时执行该语句块 --]</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">   <span class="comment">--[ 如果以上布尔表达式都不为 true 则执行该语句块 --]</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[ 定义变量 --]</span></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[ 检查布尔条件 --]</span></span><br><span class="line"><span class="keyword">if</span>( a == <span class="number">10</span> )</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ 如果条件为 true 打印以下信息 --]</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"a 的值为 10"</span> )</span><br><span class="line"><span class="keyword">elseif</span>( a == <span class="number">20</span> )</span><br><span class="line"><span class="keyword">then</span>   </span><br><span class="line">   <span class="comment">--[ if else if 条件为 true 时打印以下信息 --]</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"a 的值为 20"</span> )</span><br><span class="line"><span class="keyword">elseif</span>( a == <span class="number">30</span> )</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="comment">--[ if else if condition 条件为 true 时打印以下信息 --]</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"a 的值为 30"</span> )</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="comment">--[ 以上条件语句没有一个为 true 时打印以下信息 --]</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"没有匹配 a 的值"</span> )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"a 的真实值为: "</span>, a )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    没有匹配 a 的值</span></span><br><span class="line"><span class="comment">    a 的真实值为: 100</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h4 id="2-循环"><a href="#2-循环" class="headerlink" title="2. 循环"></a>2. 循环</h4><h5 id="1-while循环"><a href="#1-while循环" class="headerlink" title="(1) while循环"></a>(1) while循环</h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   statements</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">10</span></span><br><span class="line"><span class="keyword">while</span>( a &lt; <span class="number">20</span> )</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"a 的值为:"</span>, a)</span><br><span class="line">   a = a+<span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    a 的值为:10</span></span><br><span class="line"><span class="comment">    a 的值为:11</span></span><br><span class="line"><span class="comment">    a 的值为:12</span></span><br><span class="line"><span class="comment">    a 的值为:13</span></span><br><span class="line"><span class="comment">    a 的值为:14</span></span><br><span class="line"><span class="comment">    a 的值为:15</span></span><br><span class="line"><span class="comment">    a 的值为:16</span></span><br><span class="line"><span class="comment">    a 的值为:17</span></span><br><span class="line"><span class="comment">    a 的值为:18</span></span><br><span class="line"><span class="comment">    a 的值为:19</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h5 id="2-for-循环"><a href="#2-for-循环" class="headerlink" title="(2) for 循环"></a>(2) for 循环</h5><p>​    <strong>数值for循环</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var=exp1,exp2,exp3 <span class="keyword">do</span>  </span><br><span class="line">    &lt;执行体&gt;  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">var从exp1变化到exp2，每次变化以exp3为步长递增var，并执行一次<span class="string">"执行体"</span>。exp3是可选的，如果不指定，默认为<span class="number">1</span>。</span><br></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">10</span>,<span class="number">1</span>,<span class="number">-1</span> </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">9</span></span><br><span class="line"><span class="comment">8</span></span><br><span class="line"><span class="comment">7</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">5</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>for的三个表达式在循环开始前一次性求值，以后不再进行求值</strong>。比如下面的f(x)只会在循环开始前执行一次，其结果用在后面的循环中。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span>  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"function"</span>)  </span><br><span class="line">    <span class="keyword">return</span> x*<span class="number">2</span>   </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,f(<span class="number">5</span>) <span class="keyword">do</span> <span class="built_in">print</span>(i)  </span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    function</span></span><br><span class="line"><span class="comment">    1</span></span><br><span class="line"><span class="comment">    2</span></span><br><span class="line"><span class="comment">    3</span></span><br><span class="line"><span class="comment">    4</span></span><br><span class="line"><span class="comment">    5</span></span><br><span class="line"><span class="comment">    6</span></span><br><span class="line"><span class="comment">    7</span></span><br><span class="line"><span class="comment">    8</span></span><br><span class="line"><span class="comment">    9</span></span><br><span class="line"><span class="comment">    10</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><p>   <strong>泛型for循环</strong></p><p>泛型 for 循环通过一个<strong>迭代器函数</strong>来遍历所有值</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--打印数组a的所有值  </span></span><br><span class="line">a = &#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i, v)</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line">a = &#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(i, v)</span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">1one</span></span><br><span class="line"><span class="comment">2two</span></span><br><span class="line"><span class="comment">3three</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><p><strong>i是数组索引值，v是对应索引的数组元素值。ipairs是Lua提供的一个迭代器函数，用来迭代数组</strong>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">days = &#123;<span class="string">"Sunday"</span>,<span class="string">"Monday"</span>,<span class="string">"Tuesday"</span>,<span class="string">"Wednesday"</span>,<span class="string">"Thursday"</span>,<span class="string">"Friday"</span>,<span class="string">"Saturday"</span>&#125;  </span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(days) </span><br><span class="line"><span class="keyword">do</span>  </span><br><span class="line">    <span class="built_in">print</span>(v) </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    Sunday</span></span><br><span class="line"><span class="comment">    Monday</span></span><br><span class="line"><span class="comment">    Tuesday</span></span><br><span class="line"><span class="comment">    Wednesday</span></span><br><span class="line"><span class="comment">    Thursday</span></span><br><span class="line"><span class="comment">    Friday</span></span><br><span class="line"><span class="comment">    Saturday</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h5 id="3-repeat-until语句（等价于do-while）"><a href="#3-repeat-until语句（等价于do-while）" class="headerlink" title="(3) repeat until语句（等价于do while）"></a>(3) repeat until语句（等价于do while）</h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeat</span></span><br><span class="line">   statements</span><br><span class="line"><span class="keyword">until</span>( condition )</span><br></pre></td></tr></table></figure><p><strong>在条件进行判断前循环体都会执行一次</strong></p><p><strong>如果条件判断语句（condition）为 false，循环会重新开始执行，直到条件判断语句（condition）为 true 才会停止执行</strong></p><p><strong>区别在do……while是为false跳出循环，repeat……until是为true跳出循环</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[ 变量定义 --]</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="comment">--[ 执行循环 --]</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"a的值为:"</span>, a)</span><br><span class="line">   a = a + <span class="number">1</span></span><br><span class="line"><span class="keyword">until</span>( a &gt; <span class="number">15</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    a的值为:10</span></span><br><span class="line"><span class="comment">    a的值为:11</span></span><br><span class="line"><span class="comment">    a的值为:12</span></span><br><span class="line"><span class="comment">    a的值为:13</span></span><br><span class="line"><span class="comment">    a的值为:14</span></span><br><span class="line"><span class="comment">    a的值为:15  </span></span><br><span class="line"><span class="comment">--]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[ 变量定义 --]</span></span><br><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="comment">--[ 执行循环 --]</span></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"a的值为:"</span>, a)</span><br><span class="line"><span class="keyword">until</span>( a &gt;= <span class="number">10</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    a的值为:10 </span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h5 id="4-break-和continue"><a href="#4-break-和continue" class="headerlink" title="(4) break 和continue"></a>(4) break 和continue</h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">5</span></span><br><span class="line"><span class="keyword">while</span> a&lt;<span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> (a==<span class="number">7</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"a的值为:"</span>, a)</span><br><span class="line">a=a+<span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    a的值为:5</span></span><br><span class="line"><span class="comment">    a的值为:6</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><p>注意： <strong>lua语法中无continue关键字</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- continue的模拟实现</span></span><br><span class="line"></span><br><span class="line">#!/usr/bin/lua</span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">10.</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="keyword">while</span> <span class="literal">true</span>.</span><br><span class="line">   <span class="keyword">do</span>  </span><br><span class="line">      <span class="keyword">if</span> i == <span class="number">3</span> <span class="keyword">then</span>.</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">"3 is continue"</span>)</span><br><span class="line">           <span class="keyword">break</span>.</span><br><span class="line">       <span class="keyword">elseif</span> (i==<span class="number">6</span>) <span class="keyword">then</span>                                                               </span><br><span class="line">           <span class="built_in">print</span>(<span class="string">"6 is continue"</span>)</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="built_in">print</span>(i)</span><br><span class="line">           <span class="keyword">break</span></span><br><span class="line">       <span class="keyword">end</span> </span><br><span class="line">   <span class="keyword">end</span> </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="7-运算符"><a href="#7-运算符" class="headerlink" title="7. 运算符"></a>7. 运算符</h3><h5 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="(1) 算术运算符"></a>(1) 算术运算符</h5><table><thead><tr><th>操作符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>加法</td><td>A + B 输出结果 30</td></tr><tr><td>-</td><td>减法</td><td>A - B 输出结果 -10</td></tr><tr><td>*</td><td>乘法</td><td>A * B 输出结果 200</td></tr><tr><td>/</td><td>除法</td><td>B / A w输出结果 2</td></tr><tr><td>%</td><td>取余</td><td>B % A 输出结果 0</td></tr><tr><td>^</td><td>乘幂</td><td>A^2 输出结果 100</td></tr><tr><td>-</td><td>负号</td><td>-A 输出结果v -10</td></tr></tbody></table><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">21</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">c = a + b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Line 1 - c 的值为 "</span>, c )</span><br><span class="line">c = a - b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Line 2 - c 的值为 "</span>, c )</span><br><span class="line">c = a * b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Line 3 - c 的值为 "</span>, c )</span><br><span class="line">c = a / b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Line 4 - c 的值为 "</span>, c )</span><br><span class="line">c = a % b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Line 5 - c 的值为 "</span>, c )</span><br><span class="line">c = a^<span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Line 6 - c 的值为 "</span>, c )</span><br><span class="line">c = -a</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Line 7 - c 的值为 "</span>, c )</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    Line 1 - c 的值为     31</span></span><br><span class="line"><span class="comment">    Line 2 - c 的值为     11</span></span><br><span class="line"><span class="comment">    Line 3 - c 的值为     210</span></span><br><span class="line"><span class="comment">    Line 4 - c 的值为     2.1</span></span><br><span class="line"><span class="comment">    Line 5 - c 的值为     1</span></span><br><span class="line"><span class="comment">    Line 6 - c 的值为     441</span></span><br><span class="line"><span class="comment">    Line 7 - c 的值为     -21</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h5 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="(2) 关系运算符"></a>(2) 关系运算符</h5><table><thead><tr><th>操作符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>==</td><td>等于，检测两个值是否相等，相等返回 true，否则返回 false</td><td>(A == B) 为 false。</td></tr><tr><td>~=</td><td>不等于，检测两个值是否相等，相等返回 false，否则返回 true</td><td>(A ~= B) 为 true。</td></tr><tr><td>&gt;</td><td>大于，如果左边的值大于右边的值，返回 true，否则返回 false</td><td>(A &gt; B) 为 false。</td></tr><tr><td>&lt;</td><td>小于，如果左边的值大于右边的值，返回 false，否则返回 true</td><td>(A &lt; B) 为 true。</td></tr><tr><td>&gt;=</td><td>大于等于，如果左边的值大于等于右边的值，返回 true，否则返回 false</td><td>(A &gt;= B) 返回 false。</td></tr><tr><td>&lt;=</td><td>小于等于， 如果左边的值小于等于右边的值，返回 true，否则返回 false</td><td>(A &lt;= B) 返回 true。</td></tr></tbody></table><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">21</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( a == b )</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"Line 1 - a 等于 b"</span> )</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"Line 1 - a 不等于 b"</span> )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( a ~= b )</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"Line 2 - a 不等于 b"</span> )</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"Line 2 - a 等于 b"</span> )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( a &lt; b )</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"Line 3 - a 小于 b"</span> )</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"Line 3 - a 大于等于 b"</span> )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( a &gt; b ) </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"Line 4 - a 大于 b"</span> )</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"Line 5 - a 小于等于 b"</span> )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改 a 和 b 的值</span></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"><span class="keyword">if</span> ( a &lt;= b ) </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"Line 5 - a 小于等于  b"</span> )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( b &gt;= a ) </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"Line 6 - b 大于等于 a"</span> )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    Line 1 - a 不等于 b</span></span><br><span class="line"><span class="comment">    Line 2 - a 不等于 b</span></span><br><span class="line"><span class="comment">    Line 3 - a 大于等于 b</span></span><br><span class="line"><span class="comment">    Line 4 - a 大于 b</span></span><br><span class="line"><span class="comment">    Line 5 - a 小于等于  b</span></span><br><span class="line"><span class="comment">    Line 6 - b 大于等于 a</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h5 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="(3) 逻辑运算符"></a>(3) 逻辑运算符</h5><table><thead><tr><th>操作符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>and</td><td>逻辑与操作符。 若 A 为 false，则返回 A，否则返回 B。</td><td>(A and B) 为 false。</td></tr><tr><td>or</td><td>逻辑或操作符。 若 A 为 true，则返回 A，否则返回 B。</td><td>(A or B) 为 true。</td></tr><tr><td>not</td><td>逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false。</td><td>not(A and B) 为 true。</td></tr></tbody></table><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="literal">true</span></span><br><span class="line">b = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">and</span> b )</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"a and b - 条件为 true"</span> )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">or</span> b )</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"a or b - 条件为 true"</span> )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"---------分割线---------"</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改 a 和 b 的值</span></span><br><span class="line">a = <span class="literal">false</span></span><br><span class="line">b = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( a <span class="keyword">and</span> b )</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"a and b - 条件为 true"</span> )</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"a and b - 条件为 false"</span> )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">not</span>( a <span class="keyword">and</span> b) )</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"not( a and b) - 条件为 true"</span> )</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"not( a and b) - 条件为 false"</span> )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    a and b - 条件为 true</span></span><br><span class="line"><span class="comment">    a or b - 条件为 true</span></span><br><span class="line"><span class="comment">    ---------分割线---------</span></span><br><span class="line"><span class="comment">    a and b - 条件为 false</span></span><br><span class="line"><span class="comment">    not( a and b) - 条件为 true  </span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h5 id="4-其他运算符"><a href="#4-其他运算符" class="headerlink" title="(4) 其他运算符"></a>(4) 其他运算符</h5><table><thead><tr><th>操作符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>..</td><td>连接两个字符串</td><td>a..b ，其中 a 为 “Hello “ ， b 为 “World”, 输出结果为 “Hello World”。</td></tr><tr><td>#</td><td>一元运算符，返回字符串或表的长度。</td><td>#”Hello” 返回 5</td></tr></tbody></table><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">"Hello "</span></span><br><span class="line">b = <span class="string">"World"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"连接字符串 a 和 b "</span>, a..b )</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"b 字符串长度 "</span>,#b )</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"字符串 Test 长度 "</span>,#<span class="string">"Test"</span> )</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"菜鸟教程网址长度 "</span>,#<span class="string">"www.runoob.com"</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    连接字符串 a 和 b     Hello World</span></span><br><span class="line"><span class="comment">    b 字符串长度     5</span></span><br><span class="line"><span class="comment">    字符串 Test 长度     4</span></span><br><span class="line"><span class="comment">    菜鸟教程网址长度     14</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h5 id="6-运算符优先级"><a href="#6-运算符优先级" class="headerlink" title="(6) 运算符优先级"></a>(6) 运算符优先级</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">从高到低的顺序：</span><br><span class="line"></span><br><span class="line">^</span><br><span class="line">not    - (unary)</span><br><span class="line">*      /</span><br><span class="line">+      -</span><br><span class="line">..</span><br><span class="line">&lt;      &gt;      &lt;=     &gt;=     ~=     ==</span><br><span class="line">and</span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">除了^和..外所有的二元运算符都是左连接的。</span><br></pre></td></tr></table></figure><h3 id="8-函数"><a href="#8-函数" class="headerlink" title="8. 函数"></a>8. 函数</h3><h5 id="1-函数定义"><a href="#1-函数定义" class="headerlink" title="(1) 函数定义"></a>(1) 函数定义</h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--[[ 函数返回两个值的最大值 --]]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span><span class="params">(num1, num2)</span></span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2) <span class="keyword">then</span></span><br><span class="line">      result = num1;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      result = num2;</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> result; </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 调用函数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"两值比较最大值为 "</span>,<span class="built_in">max</span>(<span class="number">10</span>,<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"两值比较最大值为 "</span>,<span class="built_in">max</span>(<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    两值比较最大值为     10</span></span><br><span class="line"><span class="comment">    两值比较最大值为     6</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><h5 id="2-将函数作为参数传递给函数"><a href="#2-将函数作为参数传递给函数" class="headerlink" title="(2) 将函数作为参数传递给函数"></a>(2) 将函数作为参数传递给函数</h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">myprint = <span class="function"><span class="keyword">function</span><span class="params">(param)</span></span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"这是打印函数 -   ##"</span>,param,<span class="string">"##"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(num1,num2,functionPrint)</span></span></span><br><span class="line">   result = num1 + num2</span><br><span class="line">   <span class="comment">-- 调用传递的函数参数</span></span><br><span class="line">   functionPrint(result)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">myprint(<span class="number">10</span>)</span><br><span class="line"><span class="comment">-- myprint 函数作为参数传递</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">5</span>,myprint)</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">这是打印函数 -   ##    10    ##</span></span><br><span class="line"><span class="comment">这是打印函数 -   ##    7    ##</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure><h5 id="3-多返回值"><a href="#3-多返回值" class="headerlink" title="(3) 多返回值"></a>(3) 多返回值</h5><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Lua函数可以返回多个结果值，比如<span class="built_in">string</span>.<span class="built_in">find</span>，其返回匹配串<span class="string">"开始和结束的下标"</span>（如果不存在匹配串返回<span class="literal">nil</span>）。</span><br><span class="line"></span><br><span class="line">&gt; s, e = <span class="built_in">string</span>.<span class="built_in">find</span>(<span class="string">"www.runoob.com"</span>, <span class="string">"runoob"</span>) </span><br><span class="line">&gt; <span class="built_in">print</span>(s, e)</span><br><span class="line"><span class="number">5</span>    <span class="number">10</span></span><br></pre></td></tr></table></figure><p><strong>Lua函数中，在return后列出要返回的值得列表即可返回多值</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maximum</span> <span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">local</span> mi = <span class="number">1</span>             <span class="comment">-- 最大值索引</span></span><br><span class="line">    <span class="keyword">local</span> m = a[mi]          <span class="comment">-- 最大值</span></span><br><span class="line">    <span class="keyword">for</span> i,val <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">       <span class="keyword">if</span> val &gt; m <span class="keyword">then</span></span><br><span class="line">           mi = i</span><br><span class="line">           m = val</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> m, mi</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(maximum(&#123;<span class="number">8</span>,<span class="number">10</span>,<span class="number">23</span>,<span class="number">12</span>,<span class="number">5</span>&#125;)) <span class="comment">-- 23    3</span></span><br></pre></td></tr></table></figure><h5 id="4-可变参数"><a href="#4-可变参数" class="headerlink" title="(4) 可变参数"></a>(4) 可变参数</h5><p><strong>Lua 函数可以接受可变数目的参数</strong>，和 C 语言类似，在函数参数列表中使用三点 <code>...</code>表示函数有可变的参数。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(...)</span></span>  </span><br><span class="line"><span class="keyword">local</span> s = <span class="number">0</span>  </span><br><span class="line">  <span class="keyword">for</span> i, v <span class="keyword">in</span> <span class="built_in">ipairs</span>&#123;...&#125; <span class="keyword">do</span>   <span class="comment">--&gt; &#123;...&#125; 表示一个由所有变长参数构成的数组  </span></span><br><span class="line">    s = s + v  </span><br><span class="line">  <span class="keyword">end</span>  </span><br><span class="line">  <span class="keyword">return</span> s  </span><br><span class="line"><span class="keyword">end</span>  </span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>))  <span class="comment">---&gt;25</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">average</span><span class="params">(...)</span></span></span><br><span class="line">   result = <span class="number">0</span></span><br><span class="line">   <span class="keyword">local</span> <span class="built_in">arg</span>=&#123;...&#125;    <span class="comment">--&gt; arg 为一个表，局部变量</span></span><br><span class="line">   <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(<span class="built_in">arg</span>) <span class="keyword">do</span></span><br><span class="line">      result = result + v</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"总共传入 "</span> .. #<span class="built_in">arg</span> .. <span class="string">" 个数"</span>)</span><br><span class="line">   <span class="keyword">return</span> result/#<span class="built_in">arg</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"平均值为"</span>,average(<span class="number">10</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">总共传入 6 个数</span></span><br><span class="line"><span class="comment">    平均值为    5.5</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure><p>通过<code>select(&quot;#&quot;,...)</code>来<strong>获取可变参数的数量</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">average</span><span class="params">(...)</span></span></span><br><span class="line">   result = <span class="number">0</span></span><br><span class="line">   <span class="keyword">local</span> <span class="built_in">arg</span>=&#123;...&#125;</span><br><span class="line">   <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(<span class="built_in">arg</span>) <span class="keyword">do</span></span><br><span class="line">      result = result + v</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">"总共传入 "</span> .. <span class="built_in">select</span>(<span class="string">"#"</span>,...) .. <span class="string">" 个数"</span>)</span><br><span class="line">   <span class="keyword">return</span> result/<span class="built_in">select</span>(<span class="string">"#"</span>,...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"平均值为"</span>,average(<span class="number">10</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    总共传入 6 个数</span></span><br><span class="line"><span class="comment">    平均值为    5.5</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><p><strong>固定参数加上可变参数，固定参数必须放在变长参数之前</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fwrite</span><span class="params">(fmt, ...)</span></span>  <span class="comment">---&gt; 固定的参数fmt</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(fmt, ...))     </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">fwrite(<span class="string">"runoob\n"</span>)       <span class="comment">---&gt;fmt = "runoob", 没有变长参数。  </span></span><br><span class="line">fwrite(<span class="string">"%d%d\n"</span>, <span class="number">1</span>, <span class="number">2</span>)   <span class="comment">---&gt;fmt = "%d%d", 变长参数为 1 和 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    runoob</span></span><br><span class="line"><span class="comment">    12</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>遍历可变参数</strong></p></li><li><p>通常在遍历变长参数的时候只需要使用 {…}，然而变长参数可能会包含一些 nil，那么就可以用 <strong>select</strong> 函数来访问变长参数了：<strong>select(‘#’, …)</strong>或者 <strong>select(n, …)</strong></p></li><li><ul><li><code>·select(&#39;#&#39;, …)</code>返回可变参数的长度</li><li><code>select(n, …)</code> 用于访问 <strong>n</strong> 到 <strong>select(‘#’,…)</strong> 的参数</li></ul></li><li><p>调用select时，必须传入一个固定实参selector(选择开关)和一系列变长参数。如果selector为数字n,那么select返回它的第n个可变实参，否则只能为字符串”#”,这样select会返回变长参数的总数。</p></li><li><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>  </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(...)</span></span>  </span><br><span class="line">        <span class="keyword">for</span> i = <span class="number">1</span>, <span class="built_in">select</span>(<span class="string">'#'</span>, ...)   <span class="comment">--&gt;获取参数总数</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">local</span> <span class="built_in">arg</span> = <span class="built_in">select</span>(i, ...); <span class="comment">--&gt;读取参数</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"arg"</span>, <span class="built_in">arg</span>);  </span><br><span class="line">        <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">  </span><br><span class="line">    foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">    arg    1</span></span><br><span class="line"><span class="comment">    arg    2</span></span><br><span class="line"><span class="comment">    arg    3</span></span><br><span class="line"><span class="comment">    arg    4</span></span><br><span class="line"><span class="comment">--]]</span></span><br></pre></td></tr></table></figure></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lua基础语法&quot;&gt;&lt;a href=&quot;#Lua基础语法&quot; class=&quot;headerlink&quot; title=&quot;Lua基础语法&quot;&gt;&lt;/a&gt;Lua基础语法&lt;/h1&gt;&lt;h2 id=&quot;lua脚本&quot;&gt;&lt;a href=&quot;#lua脚本&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="Lua" scheme="http://blog.com/categories/Lua/"/>
    
    
      <category term="Lua" scheme="http://blog.com/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>Lua 模块</title>
    <link href="http://blog.com/2019/09/19/Lua%20%E6%A8%A1%E5%9D%97/"/>
    <id>http://blog.com/2019/09/19/Lua 模块/</id>
    <published>2019-09-19T04:12:57.000Z</published>
    <updated>2019-09-19T14:43:45.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lua-模块"><a href="#Lua-模块" class="headerlink" title="Lua 模块"></a>Lua 模块</h1><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 文件名为 module.lua</span></span><br><span class="line"><span class="comment">-- 定义一个名为 module 的模块</span></span><br><span class="line">module = &#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 定义一个常量</span></span><br><span class="line">module.constant = <span class="string">"这是一个常量"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.func1</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">"这是一个公有函数！\n"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"这是一个私有函数！"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module.func3</span><span class="params">()</span></span></span><br><span class="line">    func2()</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> module</span><br></pre></td></tr></table></figure><h2 id="require-函数"><a href="#require-函数" class="headerlink" title="require 函数"></a>require 函数</h2><p>Lua提供了一个名为require的函数用来加载模块。要加载一个模块，只需要简单地调用就可以了。例如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"&lt;模块名&gt;"</span>)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span> <span class="string">"&lt;模块名&gt;"</span></span><br></pre></td></tr></table></figure><p>执行 require 后会返回一个由模块常量或函数组成的 table，并且还会定义一个包含该 table 的全局变量。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- test_module.lua 文件</span></span><br><span class="line"><span class="comment">-- module 模块为上文提到到 module.lua</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"module"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(module.constant)</span><br><span class="line"> </span><br><span class="line">module.func3()</span><br></pre></td></tr></table></figure><p>以上代码执行结果为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是一个常量</span><br><span class="line">这是一个私有函数！</span><br></pre></td></tr></table></figure><p>或者给加载的模块定义一个别名变量，方便调用：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- test_module2.lua 文件</span></span><br><span class="line"><span class="comment">-- module 模块为上文提到到 module.lua</span></span><br><span class="line"><span class="comment">-- 别名变量 m</span></span><br><span class="line"><span class="keyword">local</span> m = <span class="built_in">require</span>(<span class="string">"module"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(m.constant)</span><br><span class="line"> </span><br><span class="line">m.func3()</span><br></pre></td></tr></table></figure><p>以上代码执行结果为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是一个常量</span><br><span class="line">这是一个私有函数！</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lua-模块&quot;&gt;&lt;a href=&quot;#Lua-模块&quot; class=&quot;headerlink&quot; title=&quot;Lua 模块&quot;&gt;&lt;/a&gt;Lua 模块&lt;/h1&gt;&lt;figure class=&quot;highlight lua&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte
      
    
    </summary>
    
      <category term="Lua" scheme="http://blog.com/categories/Lua/"/>
    
    
      <category term="Lua" scheme="http://blog.com/tags/Lua/"/>
    
  </entry>
  
</feed>
