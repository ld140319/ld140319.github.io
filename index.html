<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="做一个懂业务的程序员">
<meta property="og:type" content="website">
<meta property="og:title" content="搬运工 + 践行者">
<meta property="og:url" content="http://blog.com/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="做一个懂业务的程序员">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="搬运工 + 践行者">
<meta name="twitter:description" content="做一个懂业务的程序员">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/">





  <title>搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/10/15/数组元素差值V2/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/15/数组元素差值V2/" itemprop="url">数组元素差值V2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T12:12:57+08:00">
                2019-10-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数组/" itemprop="url" rel="index">
                    <span itemprop="name">数组</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数组/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数组元素差值V2"><a href="#数组元素差值V2" class="headerlink" title="数组元素差值V2"></a>数组元素差值V2</h1><blockquote>
<p>原文地址：<a href="https://www.cnblogs.com/freedom-wangyb/p/4192611.html" target="_blank" rel="noopener">https://www.cnblogs.com/freedom-wangyb/p/4192611.html</a></p>
</blockquote>
<p><strong>对于无序数组a，求a[i]-a[j]的最大值，其中i&lt;j</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindMax</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">9</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="number">16</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        System.out.println(<span class="string">"a["</span> + a.length + <span class="string">"]="</span> + Arrays.toString(a));</span><br><span class="line">        System.out.println(<span class="string">"find max of a[i]-a[j],i&lt;j : "</span> + findMax(a));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMax</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化为最小可能的int值</span></span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">// a[i]右边元素中的最小值</span></span><br><span class="line">        <span class="keyword">int</span> minRight = a[a.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> tempMax;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            tempMax = a[i] - minRight;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; minRight) &#123;</span><br><span class="line">                minRight = a[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (tempMax &gt; max) &#123;</span><br><span class="line">                max = tempMax;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/10/15/数组中两个元素的最小距离/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/15/数组中两个元素的最小距离/" itemprop="url">数组中两个元素的最小距离</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T12:12:57+08:00">
                2019-10-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数组/" itemprop="url" rel="index">
                    <span itemprop="name">数组</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数组/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数组中两个元素的最小距离"><a href="#数组中两个元素的最小距离" class="headerlink" title="数组中两个元素的最小距离"></a>数组中两个元素的最小距离</h1><blockquote>
<p>原文地址：<a href="https://blog.csdn.net/luckyxiaoqiang/article/details/8985198" target="_blank" rel="noopener">https://blog.csdn.net/luckyxiaoqiang/article/details/8985198</a></p>
</blockquote>
<p>一个数组，含有重复元素，给出两个数num1和num2，求这两个数字在数组中出现的位置的最小距离</p>
<p><strong><code>O(n)</code>时间复杂度，<code>O(1)</code>空间复杂度</strong></p>
<p>给定一个数组，数组中含有重复元素，给出两个数n1和n2，求这两个数在数组中所出现位置的最小距离。例如，数组{4,5,6,4,7,4,6,4,7,8,5,6,4,3,10,8}，4和8的最小距离是2.</p>
<p>思路：遍历数组，会遇到两个情况：</p>
<p>一，当遇到n1时候，记录下n1对应的数组下标的位置n1_index，通过求n1_index与上次遍历到n2的下标值n2_index的差，可以求出最近一次遍历到n1和n2的距离。</p>
<p>二，当遇到n2时候，同样记录n2在数组位置下标n2_index，然后求n2_index与上次遍历到的n1的下标值n1_index的差，求出最近一次遍历到的n1和n2的距离。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinDistance</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? b : a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = a.length;</span><br><span class="line">        <span class="keyword">int</span> n1_index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n2_index = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> min_dist = Integer.MIN_VALUE + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == n1) &#123;</span><br><span class="line">                n1_index = i;</span><br><span class="line">                <span class="keyword">if</span> (n2_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    min_dist = min(Math.abs(min_dist), Math.abs(n1_index - n2_index));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == n2) &#123;</span><br><span class="line">                n2_index = i;</span><br><span class="line">                <span class="keyword">if</span> (n1_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    min_dist = min(Math.abs(min_dist), Math.abs(n2_index - n1_index));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min_dist;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        System.out.println(minDistance(a, <span class="number">5</span>, <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/09/19/Nginx变量/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/19/Nginx变量/" itemprop="url">Nginx变量</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-19T12:12:57+08:00">
                2019-09-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Nginx/" itemprop="url" rel="index">
                    <span itemprop="name">Nginx</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Nginx/OpenResty/" itemprop="url" rel="index">
                    <span itemprop="name">OpenResty</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Nginx/OpenResty/Lua/" itemprop="url" rel="index">
                    <span itemprop="name">Lua</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Nginx变量"><a href="#Nginx变量" class="headerlink" title="Nginx变量"></a>Nginx变量</h1><blockquote>
<p>原文地址：<a href="http://blog.sina.com.cn/openresty" target="_blank" rel="noopener">http://blog.sina.com.cn/openresty</a></p>
</blockquote>
<h2 id="Nginx变量初识"><a href="#Nginx变量初识" class="headerlink" title="Nginx变量初识"></a>Nginx变量初识</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Nginx</code> 的配置文件使用的就是一门微型的编程语言，许多真实世界里的 <code>Nginx</code> 配置文件其实就是一个一个的小程序。当然，是不是“图灵完全的”暂且不论，至少据我观察，它在设计上受<code>Perl</code> 和 <code>Bourne Shell</code> 这两种语言的影响很大。在这一点上，相比<code>Apache</code>和 <code>Lighttpd</code>等其他 <code>Web</code>服务器的配置记法，不能不说算是 Nginx 的一大特色了。既然是编程语言，一般也就少不了“变量”这种东西（当然，<code>Haskell</code>这样奇怪的函数式语言除外了）。</p>
<h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;熟悉 <code>Perl</code>、<code>Bourne Shell</code>、<code>C/C++</code> 等命令式编程语言的朋友肯定知道，变量说白了就是存放“值”的容器。而所谓“值”，在许多编程语言里，既可以是 <code>3.14</code> 这样的数值，也可以是 <code>hello world</code> 这样的字符串，甚至可以是像数组、哈希表这样的复杂数据结构。然而，<strong>在 Nginx 配置中，变量只能存放一种类型的值，因为也只存在一种类型的值，那就是字符串</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比如我们的 <code>nginx.conf</code> 文件中有下面这一行配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set $a &quot;hello world&quot;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们使用了标准 <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank" rel="noopener">ngx_rewrite</a> 模块的 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 配置指令对变量 <code>$a</code> 进行了赋值操作。特别地，我们把字符串 <code>hello world</code> 赋给了它。</p>
<h2 id="变量插值"><a href="#变量插值" class="headerlink" title="变量插值"></a>变量插值</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，<code>Nginx</code>变量名前面有一个 <code>$</code> 符号，这是记法上的要求。<strong>所有的 Nginx 变量在 Nginx 配置文件中引用时都须带上 <code>$</code> 前缀</strong>。这种表示方法和 <code>Perl</code>、<code>PHP</code> 这些语言是相似的。</p>
<p>​    虽然 <code>$</code> 这样的变量前缀修饰会让正统的 <code>Java</code> 和 <code>C#</code> 程序员不舒服，但这种表示方法的好处也是显而易见的，那就是<strong>可以直接把变量嵌入到字符串常量中以构造出新的字符串</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set $a hello;</span><br><span class="line">set $b &quot;$a, $a&quot;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们通过已有的 <code>Nginx</code>变量 <code>$a</code> 的值，来构造变量 <code>$b</code> 的值，于是这两条指令顺序执行完之后，<code>$a</code> 的值是 <code>hello</code>，而 <code>$b</code> 的值则是 <code>hello, hello</code>. 这种技术在 Perl 世界里被称为<strong>“变量插值”（variable interpolation）</strong>，它让专门的字符串拼接运算符变得不再那么必要。我们在这里也不妨采用此术语。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们来看一个比较完整的配置示例：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">location</span> /test &#123;</span><br><span class="line">        <span class="attribute">set</span> <span class="variable">$foo</span> hello;</span><br><span class="line">        <span class="attribute">echo</span> <span class="string">"foo: <span class="variable">$foo</span>"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个例子省略了 <code>nginx.conf</code> 配置文件中最外围的 <code>http</code> 配置块以及 <code>events</code> 配置块。使用 <code>curl</code> 这个 <code>HTTP</code> 客户端在命令行上请求这个 <code>/test</code> 接口，我们可以得到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">foo: hello</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们使用第三方 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 模块的 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 配置指令将 <code>$foo</code> 变量的值作为当前请求的响应体输出。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，<a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 配置指令的参数也支持“变量插值”。不过，需要说明的是，<strong>并非所有的配置指令都支持“变量插值”</strong>。事实上，<strong>指令参数是否允许“变量插值”，取决于该指令的实现模块</strong>。</p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出$"></a>输出$</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们想通过 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令<strong>直接输出含有“美元符”（<code>$</code>）的字符串，那么有没有办法把特殊的 <code>$</code> 字符给转义掉呢</strong>？答案是否定的（至少到目前最新的 <code>Nginx</code> 稳定版 <code>1.0.10</code>）。不过幸运的是，我们可以绕过这个限制，比如通过不支持“变量插值”的模块配置指令专门构造出取值为 <code>$</code> 的 Nginx 变量，然后再在 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 中使用这个变量。看下面这个例子：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">geo</span> <span class="variable">$dollar</span> &#123;</span><br><span class="line">    <span class="attribute">default</span> <span class="string">"$"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">location</span> /test &#123;</span><br><span class="line">        <span class="attribute">echo</span> <span class="string">"This is a dollar sign: <span class="variable">$dollar</span>"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">This is a dollar sign: $</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里用到了标准模块 <a href="http://wiki.nginx.org/HttpGeoModule" target="_blank" rel="noopener">ngx_geo</a> 提供的配置指令 <a href="http://wiki.nginx.org/HttpGeoModule#geo" target="_blank" rel="noopener">geo</a> 来为变量 <code>$dollar</code> 赋予字符串 <code>&quot;$&quot;</code>，这样我们在下面需要使用美元符的地方，就直接引用我们的 <code>$dollar</code> 变量就可以了。其实 <a href="http://wiki.nginx.org/HttpGeoModule" target="_blank" rel="noopener">ngx_geo</a> 模块最常规的用法是根据客户端的 IP 地址对指定的 <code>Nginx</code> 变量进行赋值，这里只是借用它以便“无条件地”对我们的 <code>$dollar</code> 变量赋予“美元符”这个值。</p>
<h2 id="符号的使用"><a href="#符号的使用" class="headerlink" title="{}符号的使用"></a>{}符号的使用</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在“变量插值”的上下文中，还有一种特殊情况，即<strong>当引用的变量名之后紧跟着变量名的构成字符时（比如后跟字母、数字以及下划线），我们就需要使用特别的记法来消除歧义</strong>，例如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">location</span> /test &#123;</span><br><span class="line">        <span class="attribute">set</span> <span class="variable">$first</span> <span class="string">"hello "</span>;</span><br><span class="line">        <span class="attribute">echo</span> <span class="string">"<span class="variable">$&#123;first&#125;</span>world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里，我们在 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 配置指令的参数值中引用变量 <code>$first</code> 的时候，后面紧跟着 <code>world</code> 这个单词，所以如果直接写作 <code>&quot;$firstworld&quot;</code> 则 <code>Nginx</code> “变量插值”计算引擎会将之识别为引用了变量 <code>$firstworld</code>. <strong>为了解决这个难题，<code>Nginx</code> 的字符串记法支持使用花括号在 <code>$</code> 之后把变量名围起来</strong>，比如这里的 <code>${first}</code>. 上面这个例子的输出是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h2 id="变量与Nginx服务启动"><a href="#变量与Nginx服务启动" class="headerlink" title="变量与Nginx服务启动"></a>变量与Nginx服务启动</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令（以及前面提到的 <a href="http://wiki.nginx.org/HttpGeoModule#geo" target="_blank" rel="noopener">geo</a> 指令）不仅有赋值的功能，它还有创建 <code>Nginx</code> 变量的副作用，即<strong>当作为赋值对象的变量尚不存在时，它会自动创建该变量</strong>。比如在上面这个例子中，如果 <code>$a</code> 这个变量尚未创建，则 <code>set</code> 指令会自动创建 <code>$a</code> 这个用户变量。如果我们不创建就直接使用它的值，则会报错。例如</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">location</span> /bad &#123;</span><br><span class="line">        <span class="attribute">echo</span> <span class="variable">$foo</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时 <code>Nginx</code> 服务器会拒绝加载配置:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[emerg] unknown &quot;foo&quot; variable</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是的，我们甚至都无法启动服务！</p>
<h2 id="变量创建赋值声明、作用范围"><a href="#变量创建赋值声明、作用范围" class="headerlink" title="变量创建赋值声明、作用范围"></a>变量创建赋值声明、作用范围</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有趣的是，<strong><code>Nginx</code> 变量的创建和赋值操作发生在全然不同的时间阶段</strong>。<strong><code>Nginx</code>变量的创建只能发生在 <code>Nginx</code> 配置加载的时候，或者说 <code>Nginx</code> 启动的时候；而赋值操作则只会发生在请求实际处理的时候</strong>。这意味着不创建而直接使用变量会导致启动失败，同时也意味着我们无法在请求处理时动态地创建新的 <code>Nginx</code>变量。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Nginx</code>变量一旦创建，其变量名的可见范围就是整个<code>Nginx</code> 配置，甚至可以跨越不同虚拟主机的 <code>server</code>配置块</strong>。我们来看一个例子：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">   <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="attribute">location</span> /foo &#123;</span><br><span class="line">      <span class="attribute">echo</span> <span class="string">"foo = [<span class="variable">$foo</span>]"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="attribute">location</span> /bar &#123;</span><br><span class="line">      <span class="attribute">set</span> <span class="variable">$foo</span> <span class="number">32</span>;</span><br><span class="line">      <span class="attribute">echo</span> <span class="string">"foo = [<span class="variable">$foo</span>]"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们在 <code>location /bar</code> 中用 <code>set</code> 指令创建了变量 <code>$foo</code>，于是<strong>在整个配置文件中这个变量都是可见的</strong>，因此我们可以在 <code>location /foo</code> 中直接引用这个变量而不用担心<code>Nginx</code>会报错。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面是在命令行上用 <code>curl</code> 工具访问这两个接口的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/foo&apos;</span><br><span class="line">foo = []</span><br><span class="line"> </span><br><span class="line">$ curl &apos;http://localhost:8080/bar&apos;</span><br><span class="line">foo = [32]</span><br><span class="line"> </span><br><span class="line">$ curl &apos;http://localhost:8080/foo&apos;</span><br><span class="line">foo = []</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从这个例子我们可以看到，<code>set</code> 指令因为是在 <code>location /bar</code> 中使用的，所以赋值操作只会在访问 <code>/bar</code> 的请求中执行。而请求 <code>/foo</code> 接口时，我们总是得到空的 <code>$foo</code> 值，因为<strong>用户变量未赋值就输出的话，得到的便是空字符串</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从这个例子我们可以窥见的另一个重要特性是，<strong><code>Nginx</code> 变量名的可见范围虽然是整个配置，但每个请求都有所有变量的独立副本，或者说都有各变量用来存放值的容器的独立副本，彼此互不干扰</strong>。比如前面我们请求了<code>/bar</code> 接口后，<code>$foo</code> 变量被赋予了值 <code>32</code>，但它丝毫不会影响后续对 <code>/foo</code> 接口的请求所对应的 <code>$foo</code> 值（它仍然是空的！），因为各个请求都有自己独立的 <code>$foo</code> 变量的副本。</p>
<p>​    对于<code>Nginx</code> 新手来说，最常见的错误之一，就是将<strong><code>Nginx</code>变量理解成某种在请求之间全局共享的东西，或者说“全局变量”</strong>。而事实上，<strong><code>Nginx</code>变量的生命期是不可能跨越请求边界的</strong>。</p>
<h2 id="Nginx变量容器的生命期是否与location有关"><a href="#Nginx变量容器的生命期是否与location有关" class="headerlink" title="Nginx变量容器的生命期是否与location有关"></a>Nginx变量容器的生命期是否与location有关</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于 <code>Nginx</code> 变量的另一个常见误区是认为变量容器的生命期，是与 <code>location</code> 配置块绑定的。其实不然。我们来看一个涉及“内部跳转”的例子：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">location</span> /foo &#123;</span><br><span class="line">        <span class="attribute">set</span> <span class="variable">$a</span> hello;</span><br><span class="line">        <span class="attribute">echo_exec</span> /bar;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">location</span> /bar &#123;</span><br><span class="line">        <span class="attribute">echo</span> <span class="string">"a = [<span class="variable">$a</span>]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们在 <code>location /foo</code> 中，使用第三方模块 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 提供的 <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank" rel="noopener">echo_exec</a> 配置指令，发起到 <code>location /bar</code> 的“内部跳转”。所谓<strong>“内部跳转”，就是在处理请求的过程中，于服务器内部，从一个 <code>location</code> 跳转到另一个 <code>location</code> 的过程</strong>。这不同于利用 <code>HTTP</code> 状态码 <code>301</code> 和 <code>302</code> 所进行的“外部跳转”，因为后者是由 <code>HTTP</code> 客户端配合进行跳转的，而且在客户端，用户可以通过浏览器地址栏这样的界面，看到请求的 <code>URL</code> 地址发生了变化。内部跳转和 <code>Bourne Shell</code>（或 <code>Bash</code>）中的 <code>exec</code> 命令很像，都是“有去无回”。另一个相近的例子是 <code>C</code> 语言中的 <code>goto</code> 语句。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然是<strong>内部跳转，当前正在处理的请求就还是原来那个，只是当前的 <code>location</code> 发生了变化，所以还是原来的那一套 <code>Nginx</code>变量的容器副本</strong>。对应到上例，如果我们请求的是 <code>/foo</code> 这个接口，那么整个工作流程是这样的：先在 <code>location /foo</code> 中通过 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令将 <code>$a</code> 变量的值赋为字符串 <code>hello</code>，然后通过 <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank" rel="noopener">echo_exec</a> 指令发起内部跳转，又进入到 <code>location /bar</code> 中，再输出 <code>$a</code> 变量的值。因为 <code>$a</code> 还是原来的 <code>$a</code>，所以我们可以期望得到 <code>hello</code> 这行输出。测试证实了这一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl localhost:8080/foo</span><br><span class="line">a = [hello]</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但如果我们从客户端直接访问 <code>/bar</code> 接口，就会得到空的 <code>$a</code> 变量的值，因为它依赖于 <code>location /foo</code> 来对 <code>$a</code>进行初始化。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面这个例子我们看到，<strong>一个请求在其处理过程中，即使经历多个不同的 <code>location</code> 配置块，它使用的还是同一套 <code>Nginx</code> 变量的副本</strong>。这里，我们也首次涉及到了“内部跳转”这个概念。值得一提的是，标准 <a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank" rel="noopener">ngx_rewrite</a> 模块的 <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank" rel="noopener">rewrite</a> 配置指令其实也可以发起“内部跳转”，例如上面那个例子用 <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank" rel="noopener">rewrite</a> 配置指令可以改写成下面这样的形式：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">location</span> /foo &#123;</span><br><span class="line">        <span class="attribute">set</span> <span class="variable">$a</span> hello;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^</span> /bar;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">location</span> /bar &#123;</span><br><span class="line">        <span class="attribute">echo</span> <span class="string">"a = [<span class="variable">$a</span>]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其效果和使用 <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank" rel="noopener">echo_exec</a> 是完全相同的。后面我们还会专门介绍这个 <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank" rel="noopener">rewrite</a> 指令的更多用法，比如发起 <code>301</code>和 <code>302</code> 这样的“外部跳转”。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面这个例子我们看到，<strong><code>Nginx</code>变量值容器的生命期是与当前正在处理的请求绑定的，而与 <code>location</code>无关</strong>。</p>
<h2 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面我们接触到的都是通过 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令隐式创建的 <code>Nginx</code> 变量。这些变量我们一般称为“用户自定义变量”，或者更简单一些，“用户变量”。既然有“用户自定义变量”，自然也就有由<code>Nginx</code> 核心和各个 <code>Nginx</code>模块提供的“预定义变量”，或者说“内建变量”（<code>builtin variables</code>）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Nginx</code>内建变量最常见的用途就是获取关于请求或响应的各种信息。例如由 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html" target="_blank" rel="noopener">ngx_http_core</a> 模块提供的内建变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank" rel="noopener">$uri</a>，可以用来获取当前请求的 <code>URI</code>（经过解码，并且不含请求参数），而 <a href="http://wiki.nginx.org/HttpCoreModule#.24request_uri" target="_blank" rel="noopener">$request_uri</a> 则用来获取请求最原始的 <code>URI</code> （未经解码，并且包含请求参数）。请看下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    echo &quot;uri = $uri&quot;;</span><br><span class="line">    echo &quot;request_uri = $request_uri&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里为了简单起见，连 <code>server</code> 配置块也省略了，和前面所有示例一样，我们监听的依然是 <code>8080</code> 端口。在这个例子里，我们把 <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank" rel="noopener">$uri</a> 和 <a href="http://wiki.nginx.org/HttpCoreModule#.24request_uri" target="_blank" rel="noopener">$request_uri</a> 的值输出到响应体中去。下面我们用不同的请求来测试一下这个 <code>/test</code>接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">uri = /test</span><br><span class="line">request_uri = /test</span><br><span class="line"> </span><br><span class="line">$ curl &apos;http://localhost:8080/test?a=3&amp;b=4&apos;</span><br><span class="line">uri = /test</span><br><span class="line">request_uri = /test?a=3&amp;b=4</span><br><span class="line"> </span><br><span class="line">$ curl &apos;http://localhost:8080/test/hello%20world?a=3&amp;b=4&apos;</span><br><span class="line">uri = /test/hello world</span><br><span class="line">request_uri = /test/hello%20world?a=3&amp;b=4</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一个特别常用的内建变量其实并不是单独一个变量，而是有无限多变种的一群变量，即名字以 <code>arg_</code> 开头的所有变量，我们估且称之为 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 变量群。一个例子是 <code>$arg_name</code>，这个变量的值是当前请求名为 <code>name</code> 的 <code>URI</code>参数的值，而且还是未解码的原始形式的值。我们来看一个比较完整的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    echo &quot;name: $arg_name&quot;;</span><br><span class="line">    echo &quot;class: $arg_class&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后在命令行上使用各种参数组合去请求这个 <code>/test</code> 接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">name: </span><br><span class="line">class: </span><br><span class="line"> </span><br><span class="line">$ curl &apos;http://localhost:8080/test?name=Tom&amp;class=3&apos;</span><br><span class="line">name: Tom</span><br><span class="line">class: 3</span><br><span class="line"> </span><br><span class="line">$ curl &apos;http://localhost:8080/test?name=hello%20world&amp;class=9&apos;</span><br><span class="line">name: hello%20world</span><br><span class="line">class: 9</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实 <code>$arg_name</code> 不仅可以匹配 <code>name</code> 参数，也可以匹配 <code>NAME</code> 参数，抑或是 <code>Name</code>，等等：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test?NAME=Marry&apos;</span><br><span class="line">name: Marry</span><br><span class="line">class: </span><br><span class="line"> </span><br><span class="line">$ curl &apos;http://localhost:8080/test?Name=Jimmy&apos;</span><br><span class="line">name: Jimmy</span><br><span class="line">class:</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Nginx</code> 会在匹配参数名之前，自动把原始请求中的参数名调整为全部小写的形式</strong>。</p>
<h3 id="url-decode"><a href="#url-decode" class="headerlink" title="url decode"></a>url decode</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想对 <code>URI</code> 参数值中的 <code>%XX</code> 这样的编码序列进行解码，可以使用第三方 <a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank" rel="noopener">ngx_set_misc</a> 模块提供的 <a href="http://wiki.nginx.org/HttpSetMiscModule#set_unescape_uri" target="_blank" rel="noopener">set_unescape_uri</a> 配置指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    set_unescape_uri $name $arg_name;</span><br><span class="line">    set_unescape_uri $class $arg_class;</span><br><span class="line"> </span><br><span class="line">    echo &quot;name: $name&quot;;</span><br><span class="line">    echo &quot;class: $class&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们再看一下效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test?name=hello%20world&amp;class=9&apos;</span><br><span class="line">name: hello world</span><br><span class="line">class: 9</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;空格果然被解码出来了！</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从这个例子我们同时可以看到，这个 <a href="http://wiki.nginx.org/HttpSetMiscModule#set_unescape_uri" target="_blank" rel="noopener">set_unescape_uri</a> 指令也像 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令那样，拥有自动创建 <code>Nginx</code> 变量的功能。后面我们还会专门介绍到 <a href="http://wiki.nginx.org/HttpSetMiscModule" target="_blank" rel="noopener">ngx_set_misc</a> 模块。</p>
<h3 id="变量群"><a href="#变量群" class="headerlink" title="变量群"></a>变量群</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;像 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 这种类型的变量拥有无穷无尽种可能的名字，所以它们并不对应任何存放值的容器。而且这种变量在 <code>Nginx</code> 核心中是经过特别处理的，第三方 <code>Nginx</code> 模块是不能提供这样充满魔法的内建变量的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;类似 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 的内建变量还有不少，比如用来取 <code>cookie</code> 值的 <a href="http://wiki.nginx.org/HttpCoreModule#.24cookie_COOKIE" target="_blank" rel="noopener">$cookie_XXX</a> 变量群，用来取请求头的 <a href="http://wiki.nginx.org/HttpCoreModule#.24http_HEADER" target="_blank" rel="noopener">$http_XXX</a> 变量群，以及用来取响应头的 <a href="http://wiki.nginx.org/HttpCoreModule#.24sent_http_HEADER" target="_blank" rel="noopener">$sent_http_XXX</a> 变量群。这里就不一一介绍了，感兴趣的读者可以参考 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html" target="_blank" rel="noopener">ngx_http_core</a> 模块的官方文档。</p>
<h3 id="只读内建变量"><a href="#只读内建变量" class="headerlink" title="只读内建变量"></a>只读内建变量</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要指出的是，<strong>许多内建变量都是只读的</strong>，比如我们刚才介绍的 <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank" rel="noopener">$uri</a> 和 <a href="http://wiki.nginx.org/HttpCoreModule#.24request_uri" target="_blank" rel="noopener">$request_uri</a>. 对只读变量进行赋值是应当绝对避免的，因为会有意想不到的后果，比如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /bad &#123;</span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$uri</span> /blah;</span><br><span class="line">    <span class="attribute">echo</span> <span class="variable">$uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个有问题的配置会让<code>Nginx</code>在启动的时候报出一条令人匪夷所思的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[emerg] the duplicate &quot;uri&quot; variable in ...</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你尝试改写另外一些只读的内建变量，比如 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 变量，在某些 Nginx 的版本中甚至可能导致进程崩溃。</p>
<h3 id="改写内建变量"><a href="#改写内建变量" class="headerlink" title="改写内建变量"></a>改写内建变量</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也有一些内建变量是支持改写的，其中一个例子是 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a>. 这个变量在读取时返回当前请求的 <code>URL</code> 参数串（即请求 <code>URL</code>中问号后面的部分，如果有的话 ），而在赋值时可以直接修改参数串。我们来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    set $orig_args $args;</span><br><span class="line">    set $args &quot;a=3&amp;b=4&quot;;</span><br><span class="line"> </span><br><span class="line">    echo &quot;original args: $orig_args&quot;;</span><br><span class="line">    echo &quot;args: $args&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们把原始的 <code>URL</code> 参数串先保存在 <code>$orig_args</code> 变量中，然后通过改写 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 变量来修改当前的 URL 参数串，最后我们用 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令分别输出 <code>$orig_args</code> 和 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 变量的值。接下来我们这样来测试这个 <code>/test</code> 接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">original args: </span><br><span class="line">args: a=3&amp;b=4</span><br><span class="line"> </span><br><span class="line">$ curl &apos;http://localhost:8080/test?a=0&amp;b=1&amp;c=2&apos;</span><br><span class="line">original args: a=0&amp;b=1&amp;c=2</span><br><span class="line">args: a=3&amp;b=4</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在第一次测试中，我们没有设置任何 <code>URL</code> 参数串，所以输出 <code>$orig_args</code> 变量的值时便得到空。而在第一次和第二次测试中，无论我们是否提供<code>URL</code> 参数串，参数串都会在 <code>location /test</code> 中被强行改写成 <code>a=3&amp;b=4</code>.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要特别指出的是，这里的 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 变量和 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 一样，也不再使用属于自己的存放值的容器。当我们读取 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 时，<code>Nginx</code> 会执行一小段代码，从 <code>Nginx</code>核心中专门存放当前 <code>URL</code> 参数串的位置去读取数据；而当我们改写 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 时，<code>Nginx</code>会执行另一小段代码，对相同位置进行改写。<code>Nginx</code> 的其他部分在需要当前 <code>URL</code>参数串的时候，都会从那个位置去读数据，所以我们对 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 的修改会影响到所有部分的功能。我们来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    set $orig_a $arg_a;</span><br><span class="line">    set $args &quot;a=5&quot;;</span><br><span class="line">    echo &quot;original a: $orig_a&quot;;</span><br><span class="line">    echo &quot;a: $arg_a&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们先把内建变量 <code>$arg_a</code> 的值，即原始请求的 <code>URL</code> 参数 <code>a</code> 的值，保存在用户变量 <code>$orig_a</code> 中，然后通过对内建变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 进行赋值，把当前请求的参数串改写为 <code>a=5</code> ，最后再用 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令分别输出 <code>$orig_a</code> 和<code>$arg_a</code> 变量的值。因为对内建变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 的修改会直接导致当前请求的 <code>URL</code> 参数串发生变化，因此内建变量<a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 自然也会随之变化。测试的结果证实了这一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test?a=3&apos;</span><br><span class="line">original a: 3</span><br><span class="line">a: 5</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，因为原始请求的 <code>URL</code> 参数串是 <code>a=3</code>, 所以 <code>$arg_a</code> 最初的值为 <code>3</code>, 但随后通过改写 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 变量，将<code>URL</code> 参数串又强行修改为 <code>a=5</code>, 所以最终 <code>$arg_a</code> 的值又自动变为了 <code>5</code>.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们再来看一个通过修改 <code>$args</code> 变量影响标准的 <code>HTTP</code> 代理模块 <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank" rel="noopener">ngx_proxy</a> 的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line"> </span><br><span class="line">    location /test &#123;</span><br><span class="line">        set $args &quot;foo=1&amp;bar=2&quot;;</span><br><span class="line">        proxy_pass http://127.0.0.1:8081/args;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">server &#123;</span><br><span class="line">    listen 8081;</span><br><span class="line"> </span><br><span class="line">    location /args &#123;</span><br><span class="line">        echo &quot;args: $args&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们在 <code>http</code> 配置块中定义了两个虚拟主机。第一个虚拟主机监听 8080 端口，其 <code>/test</code> 接口自己通过改写 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 变量，将当前请求的<code>URL</code> 参数串无条件地修改为 <code>foo=1&amp;bar=2</code>. 然后 <code>/test</code> 接口再通过 <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank" rel="noopener">ngx_proxy</a>模块的 <a href="http://wiki.nginx.org/HttpProxyModule#proxy_pass" target="_blank" rel="noopener">proxy_pass</a> 指令配置了一个反向代理，指向本机的 8081 端口上的 <code>HTTP</code> 服务 <code>/args</code>. 默认情况下，<a href="http://wiki.nginx.org/HttpProxyModule" target="_blank" rel="noopener">ngx_proxy</a> 模块在转发<code>HTTP</code>请求到远方 <code>HTTP</code>服务的时候，会自动把当前请求的 <code>URL</code> 参数串也转发到远方。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而本机的 8081 端口上的 <code>HTTP</code> 服务正是由我们定义的第二个虚拟主机来提供的。我们在第二个虚拟主机的 <code>location /args</code> 中利用 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令输出当前请求的 <code>URL</code> 参数串，以检查 <code>/test</code> 接口通过 <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank" rel="noopener">ngx_proxy</a> 模块实际转发过来的 <code>URL</code> 请求参数串。</p>
<p>​    我们来实际访问一下第一个虚拟主机的 <code>/test</code> 接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test?blah=7&apos;</span><br><span class="line">args: foo=1&amp;bar=2</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，虽然请求自己提供了 URL 参数串 <code>blah=7</code>，但在 <code>location /test</code> 中，参数串被强行改写成了 <code>foo=1&amp;bar=2</code>. 接着经由 <a href="http://wiki.nginx.org/HttpProxyModule#proxy_pass" target="_blank" rel="noopener">proxy_pass</a> 指令将我们被改写掉的参数串转发给了第二个虚拟主机上配置的 <code>/args</code> 接口，然后再把 <code>/args</code> 接口的 URL 参数串输出。事实证明，我们<strong>对 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 变量的赋值操作，也成功影响到了 <a href="http://wiki.nginx.org/HttpProxyModule" target="_blank" rel="noopener">ngx_proxy</a> 模块的行为</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在读取变量时执行的这段特殊代码，在 Nginx 中被称为“取处理程序”（get handler）；而改写变量时执行的这段特殊代码，则被称为“存处理程序”（set handler）</strong>。<strong>不同的 <code>Nginx</code> 模块一般会为它们的变量准备不同的“存取处理程序”，从而让这些变量的行为充满魔法</strong>。</p>
<h2 id="Nginx变量读取逻辑"><a href="#Nginx变量读取逻辑" class="headerlink" title="Nginx变量读取逻辑"></a>Nginx变量读取逻辑</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实这种技巧在计算世界并不鲜见。比如在面向对象编程中，类的设计者一般不会把类的成员变量直接暴露给类的用户，而是另行提供两个方法（<code>method</code>），分别用于该成员变量的读操作和写操作，这两个方法常常被称为“存取器”（<code>accessor</code>）。下面是 C++ 语言中的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">    const string get_name() &#123;</span><br><span class="line">        return m_name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    void set_name(const string name) &#123;</span><br><span class="line">        m_name = name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">private:</span><br><span class="line">    string m_name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个名叫 <code>Person</code> 的 C++ 类中，我们提供了 <code>get_name</code> 和 <code>set_name</code> 这两个公共方法，以作为私有成员变量 <code>m_name</code> 的“存取器”。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样设计的好处是显而易见的。<strong>类的设计者可以在“存取器”中执行任意代码，以实现所需的业务逻辑以及“副作用”</strong>，比如自动更新与当前成员变量存在依赖关系的其他成员变量，抑或是直接修改某个与当前对象相关联的数据库表中的对应字段。而对于后一种情况，也许“存取器”所对应的成员变量压根就不存在，或者即使存在，也顶多扮演着数据缓存的角色，以缓解被代理数据库的访问压力。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>与面向对象编程中的“存取器”概念相对应，<code>Nginx</code> 变量也是支持绑定“存取处理程序”的</strong>。<strong><code>Nginx</code>模块在创建变量时，可以选择是否为变量分配存放值的容器，以及是否自己提供与读写操作相对应的“存取处理程序”</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>不是所有的 <code>Nginx</code>变量都拥有存放值的容器</strong>。<strong>拥有值容器的变量在<code>Nginx</code>核心中被称为“被索引的”（<code>indexed</code>）；反之，则被称为“未索引的”（<code>non-indexed</code>）</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们前面在 <a href="http://blog.sina.com.cn/s/blog_6d579ff40100wk2j.html" target="_blank" rel="noopener">（二）</a> 中已经知道，像 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 这样具有无数变种的变量群，是“未索引的”。当读取这样的变量时，其实是它的<strong>“取处理程序”在起作用，即实时扫描当前请求的 <code>URL</code> 参数串，提取出变量名所指定的<code>URL</code>参数的值</strong>。很多新手都会对 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 的实现方式产生误解，以为<code>Nginx</code> 会事先解析好当前请求的所有 <code>URL</code>参数，并且把相关的 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 变量的值都事先设置好。然而事实并非如此，<code>Nginx</code>根本不会事先就解析好<code>URL</code>参数串，而是在用户读取某个 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 变量时，调用其“取处理程序”，即时去扫描<code>URL</code>参数串。类似地，内建变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24cookie_COOKIE" target="_blank" rel="noopener">$cookie_XXX</a> 也是通过它的“取处理程序”，即时去扫描 <code>Cookie</code> 请求头中的相关定义的。</p>
<h2 id="值容器缓存"><a href="#值容器缓存" class="headerlink" title="值容器缓存"></a>值容器缓存</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在设置了“取处理程序”的情况下，<strong><code>Nginx</code>变量也可以选择将其值容器用作缓存，这样在多次读取变量的时候，就只需要调用“取处理程序”计算一次</strong>。我们下面就来看一个这样的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">map $args $foo &#123;</span><br><span class="line">    default     0;</span><br><span class="line">    debug       1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">server &#123;</span><br><span class="line">    listen 8080;</span><br><span class="line"> </span><br><span class="line">    location /test &#123;</span><br><span class="line">        set $orig_foo $foo;</span><br><span class="line">        set $args debug;</span><br><span class="line"> </span><br><span class="line">        echo &quot;orginal foo: $orig_foo&quot;;</span><br><span class="line">        echo &quot;foo: $foo&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里首次用到了标准 <a href="http://wiki.nginx.org/HttpMapModule" target="_blank" rel="noopener">ngx_map</a> 模块的 <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 配置指令，我们有必要在此介绍一下。<code>map</code> 在英文中除了“地图”之外，也有“映射”的意思。比方说，中学数学里讲的“函数”就是一种“映射”。而 <code>Nginx</code> 的这个 <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 指令就可以用于定义两个 <code>Nginx</code>变量之间的映射关系，或者说是函数关系。回到上面这个例子，我们用 <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 指令定义了用户变量 <code>$foo</code> 与 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 内建变量之间的映射关系。特别地，用数学上的函数记法 <code>y = f(x)</code> 来说，我们的 <code>$args</code> 就是“自变量” <code>x</code>，而 <code>$foo</code> 则是“因变量” <code>y</code>，即 <code>$foo</code> 的值是由 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 的值来决定的，或者按照书写顺序可以说，我们将 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 变量的值映射到了 <code>$foo</code> 变量上。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在我们再来看 <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 指令定义的映射规则：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map $args $foo &#123;</span><br><span class="line">    default     0;</span><br><span class="line">    debug       1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;花括号中第一行的 <code>default</code> 是一个特殊的匹配条件，即当其他条件都不匹配的时候，这个条件才匹配。当这个默认条件匹配时，就把“因变量” <code>$foo</code> 映射到值 <code>0</code>. 而花括号中第二行的意思是说，如果“自变量” <code>$args</code>精确匹配了 <code>debug</code> 这个字符串，则把“因变量” <code>$foo</code> 映射到值 <code>1</code>. 将这两行合起来，我们就得到如下完整的映射规则：<strong>当 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 的值等于 <code>debug</code> 的时候，<code>$foo</code> 变量的值就是 <code>1</code>，否则 <code>$foo</code> 的值就为 <code>0</code></strong>.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;明白了 <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 指令的含义，再来看 <code>location /test</code>. 在那里，我们先把当前 <code>$foo</code> 变量的值保存在另一个用户变量 <code>$orig_foo</code> 中，然后再强行把 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 的值改写为 <code>debug</code>，最后我们再用 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令分别输出 <code>$orig_foo</code> 和 <code>$foo</code> 的值。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 从逻辑上看，似乎当我们强行改写 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 的值为 <code>debug</code> 之后，根据先前的 <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 映射规则，<code>$foo</code> 变量此时的值应当自动调整为字符串 <code>1</code>, 而不论 <code>$foo</code> 原先的值是怎样的。然而测试结果并非如此：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">original foo: 0</span><br><span class="line">foo: 0</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一行输出指示 <code>$orig_foo</code> 的值为 <code>0</code>，这正是我们期望的：上面这个请求并没有提供<code>URL</code> 参数串，于是 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a>最初的取值就是空，再根据我们先前定义的映射规则，<code>$foo</code> 变量在第一次被读取时的值就应当是 <code>0</code>（即匹配默认的那个 <code>default</code> 条件）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 而第二行输出显示，在强行改写 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 变量的值为字符串 <code>debug</code> 之后，<code>$foo</code> 的条件仍然是 <code>0</code> ，这显然不符合映射规则，因为当 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 为 <code>debug</code> 时，<code>$foo</code> 的值应当是 <code>1</code>. 这究竟是为什么呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实原因很简单，那就是 <code>$foo</code> 变量在第一次读取时，根据映射规则计算出的值被缓存住了。刚才我们说过，Nginx 模块可以为其创建的变量选择使用值容器，作为其“取处理程序”计算结果的缓存。显然，<strong><a href="http://wiki.nginx.org/HttpMapModule" target="_blank" rel="noopener">ngx_map</a>模块认为变量间的映射计算足够昂贵，需要自动将因变量的计算结果缓存下来，这样在当前请求的处理过程中如果再次读取这个因变量，<code>Nginx</code>就可以直接返回缓存住的结果，而不再调用该变量的“取处理程序”再行计算了</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了进一步验证这一点，我们不妨在请求中直接指定 <code>URL</code> 参数串为 <code>debug</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test?debug&apos;</span><br><span class="line">original foo: 1</span><br><span class="line">foo: 1</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，现在 <code>$orig_foo</code> 的值就成了 <code>1</code>，因为变量 <code>$foo</code> 在第一次被读取时，自变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 的值就是<code>debug</code>，于是按照映射规则，“取处理程序”计算返回的值便是 <code>1</code>. 而后续再读取 <code>$foo</code> 的值时，就总是得到被缓存住的 <code>1</code> 这个结果，而不论 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 后来变成什么样了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 指令其实是一个比较特殊的例子，因为它可以为用户变量注册“取处理程序”，而且用户可以自己定义这个“取处理程序”的计算规则。当然，此规则在这里被限定为与另一个变量的映射关系。同时，也并非所有使用了“取处理程序”的变量都会缓存结果，例如我们前面在 <a href="http://blog.sina.com.cn/s/blog_6d579ff40100wm63.html" target="_blank" rel="noopener">（三）</a> 中已经看到 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 并不会使用值容器进行缓存。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>类似 <a href="http://wiki.nginx.org/HttpMapModule" target="_blank" rel="noopener">ngx_map</a> 模块，标准的 <a href="http://wiki.nginx.org/HttpGeoModule" target="_blank" rel="noopener">ngx_geo</a> 等模块也一样使用了变量值的缓存机制</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上面的例子中，我们还应当注意到 <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 指令是在 <code>server</code> 配置块之外，也就是在最外围的 <code>http</code> 配置块中定义的。很多读者可能会对此感到奇怪，毕竟我们只是在 <code>location /test</code> 中用到了它。这倒不是因为我们不想把 <code>map</code> 语句直接挪到 <code>location</code> 配置块中，而是因为<strong><a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 指令只能在 <code>http</code> 块中使用！</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多 <code>Nginx</code> 新手都会担心如此“全局”范围的 <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 设置会让访问所有虚拟主机的所有 <code>location</code> 接口的请求都执行一遍变量值的映射计算，然而事实并非如此。前面我们已经了解到<strong><a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 配置指令的工作原理是为用户变量注册 “取处理程序”，并且实际的映射计算是在“取处理程序”中完成的，而“取处理程序”只有在该用户变量被实际读取时才会执行（当然，因为缓存的存在，只在请求生命期中的第一次读取中才被执行），所以对于那些根本没有用到相关变量的请求来说，就根本不会执行任何的无用计算</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种只在实际使用对象时才计算对象值的技术，在计算领域被称为<strong>“惰性求值”（lazy evaluation）</strong>。提供“惰性求值” 语义的编程语言并不多见，最经典的例子便是 Haskell. 与之相对的便是“主动求值” （eager evaluation）。我们有幸在 <code>Nginx</code> 中也看到了“惰性求值”的例子，但“主动求值”语义其实在 <code>Nginx</code> 里面更为常见，例如下面这行再普通不过的 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set $b &quot;$a,$a&quot;;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里会在<strong>执行 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 规定的赋值操作时，“主动”地计算出变量 <code>$b</code> 的值，而不会将该求值计算延缓到变量 <code>$b</code>实际被读取的时候</strong>。</p>
<h2 id="主请求与子请求"><a href="#主请求与子请求" class="headerlink" title="主请求与子请求"></a>主请求与子请求</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经了解到变量值容器的生命期是与请求绑定的，但是我当时有意避开了“请求”的正式定义。大家应当一直默认这里的“请求”都是指客户端发起的 <code>HTTP</code> 请求。其实<strong>在 Nginx 世界里有两种类型的“请求”，一种叫做“主请求”（main request），而另一种则叫做“子请求”（subrequest）</strong>。我们先来介绍一下它们。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓<strong>“主请求”，就是由 <code>HTTP</code> 客户端从 <code>Nginx</code> 外部发起的请求</strong>。我们前面见到的所有例子都只涉及到“主请求”，包括 两个使用 <a href="http://wiki.nginx.org/HttpEchoModule#echo_exec" target="_blank" rel="noopener">echo_exec</a> 和 <a href="http://wiki.nginx.org/HttpRewriteModule#rewrite" target="_blank" rel="noopener">rewrite</a> 指令发起“内部跳转”的例子。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而<strong>“子请求”则是由 <code>Nginx</code> 正在处理的请求在 <code>Nginx</code> 内部发起的一种级联请求</strong>。“子请求”在外观上很像 <code>HTTP</code>请求，但实现上却和 <code>HTTP</code> 协议乃至网络通信一点儿关系都没有。<strong>它是 <code>Nginx</code> 内部的一种抽象调用，目的是为了方便用户把“主请求”的任务分解为多个较小粒度的“内部请求”，并发或串行地访问多个<code>location</code> 接口，然后由这些 <code>location</code> 接口通力协作，共同完成整个“主请求”</strong>。当然，“子请求”的概念是相对的，任何一个“子请求”也可以再发起更多的“子子请求”，甚至可以玩递归调用（即自己调用自己）。当一个请求发起一个“子请求”的时候，按照 <code>Ngin</code>x 的术语，习惯把前者称为后者的“父请求”（parent request）。值得一提的是，<code>Apache</code>服务器中其实也有“子请求”的概念，所以来自<code>Apache</code>世界的读者对此应当不会感到陌生。</p>
<p>​    下面就来看一个使用了“子请求”的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location /main &#123;</span><br><span class="line">    echo_location /foo;</span><br><span class="line">    echo_location /bar;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /foo &#123;</span><br><span class="line">    echo foo;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /bar &#123;</span><br><span class="line">    echo bar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里在 <code>location /main</code> 中，通过第三方 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 模块的 <a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank" rel="noopener">echo_location</a> 指令分别发起到 <code>/foo</code> 和 <code>/bar</code> 这两个接口的 <code>GET</code> 类型的“子请求”。由 <a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank" rel="noopener">echo_location</a> 发起的“子请求”，其执行是按照配置书写的顺序串行处理的，即只有当 <code>/foo</code> 请求处理完毕之后，才会接着处理 <code>/bar</code> 请求。这两个“子请求”的输出会按执行顺序拼接起来，作为 <code>/main</code> 接口的最终输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/main&apos;</span><br><span class="line">foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，“子请求”方式的通信是在同一个虚拟主机内部进行的，所以<strong><code>Nginx</code> 核心在实现“子请求”的时候，就只调用了若干个<code>C</code> 函数，完全不涉及任何网络或者 <code>UNIX</code>套接字（<code>socket</code>）通信</strong>。我们由此可以看出“子请求”的执行效率是极高的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;回到先前对<code>Nginx</code> 变量值容器的生命期的讨论，我们现在依旧可以说，它们的<strong>生命期是与当前请求相关联的。每个请求都有所有变量值容器的独立副本，只不过当前请求既可以是“主请求”，也可以是“子请求”</strong>。即便是<strong>父子请求之间，同名变量一般也不会相互干扰</strong>。让我们来通过一个小实验证明一下这个说法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">location /main &#123;</span><br><span class="line">    set $var main;</span><br><span class="line"> </span><br><span class="line">    echo_location /foo;</span><br><span class="line">    echo_location /bar;</span><br><span class="line"> </span><br><span class="line">    echo &quot;main: $var&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /foo &#123;</span><br><span class="line">    set $var foo;</span><br><span class="line">    echo &quot;foo: $var&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /bar &#123;</span><br><span class="line">    set $var bar;</span><br><span class="line">    echo &quot;bar: $var&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个例子中，我们分别在 <code>/main</code>，<code>/foo</code> 和 <code>/bar</code> 这三个 <code>location</code> 配置块中为同一名字的变量，<code>$var</code>，分别设置了不同的值并予以输出。特别地，我们在 <code>/main</code> 接口中，故意在调用过 <code>/foo</code> 和 <code>/bar</code> 这两个“子请求”之后，再输出它自己的 <code>$var</code> 变量的值。请求 <code>/main</code> 接口的结果是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/main&apos;</span><br><span class="line">foo: foo</span><br><span class="line">bar: bar</span><br><span class="line">main: main</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，<code>/foo</code> 和 <code>/bar</code> 这两个“子请求”在处理过程中对变量 <code>$var</code> 各自所做的修改都丝毫没有影响到“主请求” <code>/main</code>. 于是这成功印证了“主请求”以及各个“子请求”都拥有不同的变量 <code>$var</code> 的值容器副本。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不幸的是，<strong>一些 <code>Nginx</code>模块发起的“子请求”却会自动共享其“父请求”的变量值容器</strong>，比如第三方模块 <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank" rel="noopener">ngx_auth_request</a>. 下面是一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">location /main &#123;</span><br><span class="line">    set $var main;</span><br><span class="line">    auth_request /sub;</span><br><span class="line">    echo &quot;main: $var&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /sub &#123;</span><br><span class="line">    set $var sub;</span><br><span class="line">    echo &quot;sub: $var&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们在 <code>/main</code> 接口中先为 <code>$var</code> 变量赋初值 <code>main</code>，然后使用 <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank" rel="noopener">ngx_auth_request</a> 模块提供的配置指令 <code>auth_request</code>，发起一个到 <code>/sub</code> 接口的“子请求”，最后利用 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令输出变量 <code>$var</code> 的值。而我们在<code>/sub</code> 接口中则故意把 <code>$var</code> 变量的值改写成 <code>sub</code>. 访问 <code>/main</code> 接口的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/main&apos;</span><br><span class="line">main: sub</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，<code>/sub</code> 接口对 <code>$var</code> 变量值的修改影响到了主请求 <code>/main</code>. 所以<strong><a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank" rel="noopener">ngx_auth_request</a> 模块发起的“子请求”确实是与其“父请求”共享一套 Nginx 变量的值容器</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于上面这个例子，相信有读者会问：“为什么‘子请求’ <code>/sub</code> 的输出没有出现在最终的输出里呢？”答案很简单，那就是因为 <code>auth_request</code> 指令会自动忽略“子请求”的响应体，而只检查“子请求”的响应状态码。当状态码是 <code>2XX</code> 的时候，<code>auth_request</code> 指令会忽略“子请求”而让 Nginx 继续处理当前的请求，否则它就会立即中断当前（主）请求的执行，返回相应的出错页。在我们的例子中，<code>/sub</code> “子请求”只是使用 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令作了一些输出，所以隐式地返回了指示正常的 <code>200</code> 状态码。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如 <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank" rel="noopener">ngx_auth_request</a> 模块这样父子请求共享一套 <code>Nginx</code>变量的行为，虽然可以让父子请求之间的数据双向传递变得极为容易，但是对于足够复杂的配置，却也经常导致不少难于调试的诡异<code>bug</code>. 因为用户时常不知道“父请求”的某个 <code>Nginx</code>变量的值，其实已经在它的某个“子请求”中被意外修改了。诸如此类的因共享而导致的不好的“副作用”，让包括 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a>，<a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a>，以及 <a href="http://wiki.nginx.org/HttpSRCacheModule" target="_blank" rel="noopener">ngx_srcache</a> 在内的许多第三方模块都选择了<strong>禁用父子请求间的变量共享</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Nginx</code>内建变量用在“子请求”的上下文中时，其行为也会变得有些微妙。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们已经知道许多内建变量都不是简单的“存放值的容器”，它们一般会<strong>通过注册“存取处理程序”来表现得与众不同，而它们即使有存放值的容器，也只是用于缓存“存取处理程序”的计算结果</strong>。我们之前讨论过的 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 变量正是通过它的“取处理程序”来返回当前请求的 <code>URL</code> 参数串。因为当前请求也可以是“子请求”，所以在“子请求”中读取 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a>，其“取处理程序”会很自然地返回当前“子请求”的参数串。我们来看这样的一个例子：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /main &#123;</span><br><span class="line">    <span class="attribute">echo</span> <span class="string">"main args: <span class="variable">$args</span>"</span>;</span><br><span class="line">    <span class="attribute">echo_location</span> /sub <span class="string">"a=1&amp;b=2"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="attribute">location</span> /sub &#123;</span><br><span class="line">    <span class="attribute">echo</span> <span class="string">"sub args: <span class="variable">$args</span>"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里在 <code>/main</code> 接口中，先用 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令输出当前请求的 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 变量的值，接着再用 <a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank" rel="noopener">echo_location</a> 指令发起子请求 <code>/sub</code>. 这里值得注意的是，我们在 <a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank" rel="noopener">echo_location</a> 语句中除了通过第一个参数指定“子请求”的 <code>URI</code> 之外，还提供了第二个参数，用以指定该“子请求”的 URL 参数串（即 <code>a=1&amp;b=2</code>）。最后我们定义了 <code>/sub</code> 接口，在里面输出了一下 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 的值。请求 <code>/main</code> 接口的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/main?c=3&apos;</span><br><span class="line">main args: c=3</span><br><span class="line">sub args: a=1&amp;b=2</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;显然，当 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 用在“主请求” <code>/main</code> 中时，输出的就是“主请求”的 URL 参数串，<code>c=3</code>；而当用在“子请求” <code>/sub</code> 中时，输出的则是“子请求”的参数串，<code>a=1&amp;b=2</code>。这种行为正符合我们的直觉。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与 <a href="http://wiki.nginx.org/HttpCoreModule#.24args" target="_blank" rel="noopener">$args</a> 类似，内建变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank" rel="noopener">$uri</a> 用在“子请求”中时，其“取处理程序”也会正确返回当前“子请求”解析过的 URI:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /main &#123;</span><br><span class="line">    <span class="attribute">echo</span> <span class="string">"main uri: <span class="variable">$uri</span>"</span>;</span><br><span class="line">    <span class="attribute">echo_location</span> /sub;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="attribute">location</span> /sub &#123;</span><br><span class="line">    <span class="attribute">echo</span> <span class="string">"sub uri: <span class="variable">$uri</span>"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求 <code>/main</code> 的结果是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/main&apos;</span><br><span class="line">main uri: /main</span><br><span class="line">sub uri: /sub</span><br></pre></td></tr></table></figure>
<p>这依然是我们所期望的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但不幸的是，<strong>并非所有的内建变量都作用于当前请求</strong>。<strong>少数内建变量只作用于“主请求”</strong>，比如由标准模块 <a href="http://nginx.org/en/docs/http/ngx_http_core_module.html" target="_blank" rel="noopener">ngx_http_core</a> 提供的内建变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank" rel="noopener">$request_method</a>.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank" rel="noopener">$request_method</a> 在读取时，总是会得到“主请求”的请求方法</strong>，比如 <code>GET</code>、<code>POST</code> 之类。我们来测试一下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /main &#123;</span><br><span class="line">    <span class="attribute">echo</span> <span class="string">"main method: <span class="variable">$request_method</span>"</span>;</span><br><span class="line">    <span class="attribute">echo_location</span> /sub;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="attribute">location</span> /sub &#123;</span><br><span class="line">    <span class="attribute">echo</span> <span class="string">"sub method: <span class="variable">$request_method</span>"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个例子里，<code>/main</code> 和 <code>/sub</code> 接口都会分别输出 <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank" rel="noopener">$request_method</a> 的值。同时，我们在 <code>/main</code> 接口里利用 <a href="http://wiki.nginx.org/HttpEchoModule#echo_location" target="_blank" rel="noopener">echo_location</a> 指令发起一个到 <code>/sub</code> 接口的 <code>GET</code> “子请求”。我们现在利用 <code>curl</code> 命令行工具来发起一个到<code>/main</code> 接口的 <code>POST</code> 请求：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl --data hello &apos;http://localhost:8080/main&apos;</span><br><span class="line">main method: POST</span><br><span class="line">sub method: POST</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们利用 <code>curl</code> 程序的 <code>--data</code> 选项，指定 <code>hello</code> 作为我们的请求体数据，同时 <code>--data</code> 选项会自动让发送的请求使用 <code>POST</code> 请求方法。测试结果证明了我们先前的预言，<a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank" rel="noopener">$request_method</a> 变量即使在 <code>GET</code> “子请求” <code>/sub</code> 中使用，得到的值依然是“主请求” <code>/main</code> 的请求方法，<code>POST</code>.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 有的读者可能觉得我们在这里下的结论有些草率，因为上例是先在“主请求”里读取（并输出）<a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank" rel="noopener">$request_method</a> 变量，然后才发“子请求”的，所以这些读者可能认为这<strong>并不能排除 <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank" rel="noopener">$request_method</a> 在进入子请求之前就已经把第一次读到的值给缓存住，从而影响到后续子请求中的输出结果</strong>。不过，这样的顾虑是多余的，因为我们前面在也特别提到过，<strong>缓存所依赖的变量的值容器，是与当前请求绑定的，而由 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 模块发起的“子请求”都禁用了父子请求之间的变量共享</strong>，所以在上例中，<a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank" rel="noopener">$request_method</a> 内建变量即使真的使用了值容器作为缓存（事实上它也没有），它也不可能影响到 <code>/sub</code> 子请求。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了进一步消除这部分读者的疑虑，我们不妨稍微修改一下刚才那个例子，将 <code>/main</code> 接口输出 <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank" rel="noopener">$request_method</a> 变量的时间推迟到“子请求”执行完毕之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /main &#123;</span><br><span class="line">    echo_location /sub;</span><br><span class="line">    echo &quot;main method: $request_method&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /sub &#123;</span><br><span class="line">    echo &quot;sub method: $request_method&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;让我们重新测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl --data hello &apos;http://localhost:8080/main&apos;</span><br><span class="line">sub method: POST</span><br><span class="line">main method: POST</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，再次以 <code>POST</code> 方法请求 <code>/main</code> 接口的结果与原先那个例子完全一致，除了父子请求的输出顺序颠倒了过来（因为我们在本例中交换了 <code>/main</code> 接口中那两条输出配置指令的先后次序）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由此可见，我们并不能通过标准的 <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank" rel="noopener">$request_method</a> 变量取得“子请求”的请求方法。为了达到我们最初的目的，我们需要求助于第三方模块 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 提供的内建变量 <a href="http://wiki.nginx.org/HttpEchoModule#.24echo_request_method" target="_blank" rel="noopener">$echo_request_method</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /main &#123;</span><br><span class="line">    echo &quot;main method: $echo_request_method&quot;;</span><br><span class="line">    echo_location /sub;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /sub &#123;</span><br><span class="line">    echo &quot;sub method: $echo_request_method&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时的输出终于是我们想要的了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl --data hello &apos;http://localhost:8080/main&apos;</span><br><span class="line">main method: POST</span><br><span class="line">sub method: GET</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，父子请求分别输出了它们各自不同的请求方法，<code>POST</code> 和 <code>GET</code>.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>类似 <a href="http://wiki.nginx.org/HttpCoreModule#.24request_method" target="_blank" rel="noopener">$request_method</a>，内建变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24request_uri" target="_blank" rel="noopener">$request_uri</a> 一般也返回的是“主请求”未经解析过的 <code>URL</code>，毕竟“子请求”都是在 <code>Nginx</code>内部发起的，并不存在所谓的“未解析的”原始形式</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果真如前面那部分读者所担心的，内建变量的值缓存在共享变量的父子请求之间起了作用，这无疑是灾难性的。我们前面已经看到 <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank" rel="noopener">ngx_auth_request</a> 模块发起的“子请求”是与其“父请求”共享一套变量的。下面是一个这样的可怕例子：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">map</span> <span class="variable">$uri</span> <span class="variable">$tag</span> &#123;</span><br><span class="line">    <span class="attribute">default</span>     <span class="number">0</span>;</span><br><span class="line">    /main       1;</span><br><span class="line">    /sub        2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">location</span> /main &#123;</span><br><span class="line">        <span class="attribute">auth_request</span> /sub;</span><br><span class="line">        <span class="attribute">echo</span> <span class="string">"main tag: <span class="variable">$tag</span>"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">location</span> /sub &#123;</span><br><span class="line">        <span class="attribute">echo</span> <span class="string">"sub tag: <span class="variable">$tag</span>"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们使用久违了的 <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 指令来把内建变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank" rel="noopener">$uri</a> 的值映射到用户变量 <code>$tag</code> 上。当 <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank" rel="noopener">$uri</a> 的值为 <code>/main</code>时，则赋予 <code>$tag</code> 值 1，当 <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank" rel="noopener">$uri</a> 取值 <code>/sub</code> 时，则赋予 <code>$tag</code> 值 2，其他情况都赋 <code>0</code>. 接着，我们在 <code>/main</code>接口中先用 <a href="http://mdounin.ru/hg/ngx_http_auth_request_module/" target="_blank" rel="noopener">ngx_auth_request</a> 模块的 <code>auth_request</code> 指令发起到 <code>/sub</code> 接口的子请求，然后再输出变量 <code>$tag</code>的值。而在 <code>/sub</code> 接口中，我们直接输出变量 <code>$tag</code>. 猜猜看，如果我们访问接口 <code>/main</code>，将会得到什么样的输出呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/main&apos;</span><br><span class="line">main tag: 2</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;咦？我们不是分明把 <code>/main</code> 这个值映射到 <code>1</code> 上的么？为什么实际输出的是 <code>/sub</code> 映射的结果 <code>2</code> 呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实道理很简单，因为我们的 <code>$tag</code> 变量在“子请求” <code>/sub</code> 中首先被读取，于是在那里计算出了值<code>2</code>（因为 <a href="http://wiki.nginx.org/HttpCoreModule#.24uri" target="_blank" rel="noopener">$uri</a> 在那里取值 <code>/sub</code>，而根据 <a href="http://wiki.nginx.org/HttpMapModule#map" target="_blank" rel="noopener">map</a> 映射规则，<code>$tag</code> 应当取值 <code>2</code>），从此就被 <code>$tag</code> 的值容器给缓存住了。而 <strong><code>auth_request</code> 发起的“子请求”又是与“父请求”共享一套变量的，于是当 <code>Nginx</code> 的执行流回到“父请求”输出 <code>$tag</code> 变量的值时，<code>Nginx</code> 就直接返回缓存住的结果 <code>2</code> 了</strong>。这样的结果确实太意外了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从这个例子我们再次看到，父子请求间的变量共享，实在不是一个好主意。</p>
<h2 id="变量是否存在判断"><a href="#变量是否存在判断" class="headerlink" title="变量是否存在判断"></a>变量是否存在判断</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前面我们提到过，<code>Nginx</code> 变量的值只有一种类型，那就是字符串，但是变量也有可能压根就不存在有意义的值。<strong>没有值的变量也有两种特殊的值：一种是“不合法”（invalid），另一种是“没找到”（not found）</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举例说来，当<code>Nginx</code> 用户变量 <code>$foo</code> 创建了却未被赋值时，<code>$foo</code> 的值便是“不合法”；而如果当前请求的 URL 参数串中并没有提及 <code>XXX</code> 这个参数，则 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 内建变量的值便是“没找到”。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论是“不合法”也好，还是“没找到”也罢，这两种 <code>Nginx</code> 变量所拥有的特殊值，和空字符串（””）这种取值是完全不同的，比如<code>JavaScript</code> 语言中也有专门的 <code>undefined</code> 和 <code>null</code> 这两种特殊值，而 <code>Lua</code> 语言中也有专门的 <code>nil</code> 值: 它们既不等同于空字符串，也不等同于数字 <code>0</code>，更不是布尔值 <code>false</code>. 其实 <code>SQL</code> 语言中的 <code>NULL</code> 也是类似的一种东西。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然前面我们看到，<strong>由 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令创建的变量未初始化就用在“变量插值”中时，效果等同于空字符串，但那是因为 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令为它创建的变量自动注册了一个“取处理程序”，将“不合法”的变量值转换为空字符串</strong>。为了验证这一点，我们再重新看一下前面讨论过的那个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">location /foo &#123;</span><br><span class="line">    echo &quot;foo = [$foo]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">location /bar &#123;</span><br><span class="line">    set $foo 32;</span><br><span class="line">    echo &quot;foo = [$foo]&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里为了简单起见，省略了原先写出的外围 <code>server</code> 配置块。在这个例子里，我们在 <code>/bar</code> 接口中用 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令隐式地创建了 <code>$foo</code> 变量这个名字，然后我们在 <code>/foo</code> 接口中不对 <code>$foo</code> 进行初始化就直接使用 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令输出。我们当时测试 <code>/foo</code> 接口的结果是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/foo&apos;</span><br><span class="line">foo = []</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从输出上看，<strong>未初始化的 <code>$foo</code> 变量确实和空字符串的效果等同</strong>。但细心的读者当时应该就已经注意到，对于上面这个请求，<strong><code>Nginx</code> 的错误日志文件（一般文件名叫做 <code>error.log</code>）中多出一行类似下面这样的警告</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[warn] 5765#0: *1 using uninitialized &quot;foo&quot; variable, ...</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一行警告是谁输出的呢？答案是 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令为 <code>$foo</code> 注册的“取处理程序”。当 <code>/foo</code> 接口中的 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 指令实际执行的时候，它会对它的参数 <code>&quot;foo = [$foo]&quot;</code> 进行“变量插值”计算。于是，参数串中的 <code>$foo</code> 变量会被读取，而 <code>Nginx</code> 会首先检查其值容器里的取值，结果它看到了“不合法”这个特殊值，于是它这才决定继续调用 <code>$foo</code> 变量的“取处理程序”。于是 <code>$foo</code> 变量的“取处理程序”开始运行，它向 <code>Nginx</code> 的错误日志打印出上面那条警告消息，然后返回一个空字符串作为 <code>$foo</code> 的值，并从此缓存在 <code>$foo</code> 的值容器中。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;细心的读者会注意到刚刚描述的这个过程其实就是那些支持值缓存的内建变量的工作原理，只不过 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a>指令在这里借用了这套机制来处理未正确初始化的 <code>Nginx</code> 变量。值得一提的是，<strong>只有“不合法”这个特殊值才会触发 <code>Nginx</code> 调用变量的“取处理程序”，而特殊值“没找到”却不会</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面<strong>这样的警告一般会指示出我们的 <code>Nginx</code> 配置中存在变量名拼写错误，抑或是在错误的场合使用了尚未初始化的变量</strong>。因为值缓存的存在，这条警告在一个请求的生命期中也不会打印多次。当然，<a href="http://wiki.nginx.org/HttpRewriteModule" target="_blank" rel="noopener">ngx_rewrite</a> 模块专门提供了一条 <a href="http://wiki.nginx.org/HttpRewriteModule#uninitialized_variable_warn" target="_blank" rel="noopener">uninitialized_variable_warn</a> 配置指令可用于禁止这条警告日志。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 刚才提到，内建变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 在请求 <code>URL</code> 参数 <code>XXX</code> 并不存在时会返回特殊值“找不到”，但遗憾的是在 <code>Nginx</code> 原生配置语言（我们估且这么称呼它）中是不能很方便地把它和空字符串区分开来的，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    echo &quot;name: [$arg_name]&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我们输出 <code>$arg_name</code> 变量的值同时故意在请求中不提供 <code>URL</code>参数 <code>name</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">name: []</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，<strong>输出特殊值“找不到”的效果和空字符串是相同的</strong>。因为这一回是 <strong><code>Nginx</code> 的“变量插值”引擎自动把“找不到”给忽略了</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么我们究竟应当如何捕捉到“找不到”这种特殊值的踪影呢？换句话说，我们应当如何把它和空字符串给区分开来呢？显然，下面这个请求中，<code>URL</code> 参数 <code>name</code> 是有值的，而且其值应当是空字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test?name=&apos;</span><br><span class="line">name: []</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但我们却无法将之和前面完全不提供 <code>name</code> 参数的情况给区分开。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;幸运的是，通过第三方模块 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a>，我们可以轻松地在 <code>Lua</code> 代码中做到这一点。请看下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location /test &#123;</span><br><span class="line">    content_by_lua &apos;</span><br><span class="line">        if ngx.var.arg_name == nil then</span><br><span class="line">            ngx.say(&quot;name: missing&quot;)</span><br><span class="line">        else</span><br><span class="line">            ngx.say(&quot;name: [&quot;, ngx.var.arg_name, &quot;]&quot;)</span><br><span class="line">        end</span><br><span class="line">    &apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个例子和前一个例子功能上非常接近，除了我们在 <code>/test</code> 接口中使用了 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 模块的 <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> 配置指令，嵌入了一小段我们自己的<code>Lua</code> 代码来对 <code>Nginx</code> 变量 <code>$arg_name</code> 的特殊值进行判断。在这个例子中，当 <code>$arg_name</code> 的值为“没找到”（或者“不合法”）时，<code>/foo</code> 接口会输出 <code>name: missing</code> 这一行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">name: missing</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为这是我们第一次接触到 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 模块，所以需要先简单介绍一下。<a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 模块将 Lua 语言解释器（或者 <a href="http://luajit.org/luajit.html" target="_blank" rel="noopener">LuaJIT</a> 即时编译器）嵌入到了 <code>Nginx</code> 核心中，从而可以让用户在<code>Nginx</code> 核心中直接运行 <code>Lua</code>语言编写的程序。我们可以选择在 <code>Nginx</code> 不同的请求处理阶段插入我们的 <code>Lua</code>代码。这些<code>Lua</code>代码既可以直接内联在 <code>Nginx</code> 配置文件中，也可以单独放置在外部 <code>.lua</code> 文件里，然后在 <code>Nginx</code> 配置文件中引用 <code>.lua</code> 文件的路径。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 回到上面这个例子，我们在 <code>Lua</code> 代码里引用 <code>Nginx</code>变量都是通过 <code>ngx.var</code> 这个由 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 模块提供的 Lua 接口。比如引用 Nginx 变量 <code>$VARIABLE</code> 时，就在 <code>Lua</code>代码里写作 <a href="http://wiki.nginx.org/HttpLuaModule#ngx.var.VARIABLE" target="_blank" rel="noopener">ngx.var.VARIABLE</a> 就可以了。当 Nginx 变量 <code>$arg_name</code> 为特殊值“没找到”（或者“不合法”）时， <code>ngx.var.arg_name</code> 在 <code>Lua</code>世界中的值就是 <code>nil</code>，即<code>Lua</code>语言里的“空”（不同于 <code>Lua</code> 空字符串）。我们在 <code>Lua</code>里输出响应体内容的时候，则使用了 <a href="http://wiki.nginx.org/HttpLuaModule#ngx.say" target="_blank" rel="noopener">ngx.say</a> 这个 <code>Lua</code>函数，也是 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 模块提供的，功能上等价于 <a href="http://wiki.nginx.org/HttpEchoModule" target="_blank" rel="noopener">ngx_echo</a> 模块的 <a href="http://wiki.nginx.org/HttpEchoModule#echo" target="_blank" rel="noopener">echo</a> 配置指令。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 现在，如果我们提供空字符串取值的 <code>name</code> 参数，则输出就和刚才不相同了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test?name=&apos;</span><br><span class="line">name: []</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这种情况下，Nginx 变量 <code>$arg_name</code> 的取值便是空字符串，这既不是“没找到”，也不是“不合法”，因此在 <code>Lua</code>里，<code>ngx.var.arg_name</code> 就返回 <code>Lua</code>空字符串（””），和刚才的<code>Lua</code> <code>nil</code> 值就完全区分开了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种区分在有些应用场景下非常重要，比如有的 <code>web service</code> 接口会根据 <code>name</code> 这个 URL 参数是否存在来决定是否按 <code>name</code> 属性对数据集合进行过滤，而显然提供空字符串作为 <code>name</code> 参数的值，也会导致对数据集中取值为空串的记录进行筛选操作。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，标准的 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 变量还是有一些局限，比如我们用下面这个请求来测试刚才那个 <code>/test</code> 接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test?name&apos;</span><br><span class="line">name: missing</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时，<code>$arg_name</code> 变量仍然读出“找不到”这个特殊值，这就明显有些违反常识。此外，<a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 变量在请求 <code>URL</code> 中有多个同名 <code>XXX</code> 参数时，就只会返回最先出现的那个 <code>XXX</code> 参数的值，而默默忽略掉其他实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test?name=Tom&amp;name=Jim&amp;name=Bob&apos;</span><br><span class="line">name: [Tom]</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要解决这些局限，可以直接在<code>Lua</code>代码中使用 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 模块提供的 <a href="http://wiki.nginx.org/HttpLuaModule#ngx.req.get_uri_args" target="_blank" rel="noopener">ngx.req.get_uri_args</a> 函数。</p>
<h2 id="Nginx变量与Lua"><a href="#Nginx变量与Lua" class="headerlink" title="Nginx变量与Lua"></a>Nginx变量与Lua</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与 <a href="http://wiki.nginx.org/HttpCoreModule#.24arg_PARAMETER" target="_blank" rel="noopener">$arg_XXX</a> 类似，我们在前面提到过的内建变量 <a href="http://wiki.nginx.org/HttpCoreModule#.24cookie_COOKIE" target="_blank" rel="noopener">$cookie_XXX</a> 变量也会在名为 <code>XXX</code> 的 <code>cookie</code>不存在时返回特殊值“没找到”：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /test &#123;</span><br><span class="line">    <span class="attribute">content_by_lua</span> <span class="string">'</span></span><br><span class="line"><span class="string">        if ngx.var.cookie_user == nil then</span></span><br><span class="line"><span class="string">            ngx.say("cookie user: missing")</span></span><br><span class="line"><span class="string">        else</span></span><br><span class="line"><span class="string">            ngx.say("cookie user: [", ngx.var.cookie_user, "]")</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string">    '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利用 <code>curl</code> 命令行工具的 <code>--cookie name=value</code> 选项可以指定 <code>name=value</code> 为当前请求携带的 <code>cookie</code>（通过添加相应的 <code>Cookie</code> 请求头）。下面是若干次测试结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ curl --cookie user=agentzh &apos;http://localhost:8080/test&apos;</span><br><span class="line">cookie user: [agentzh]</span><br><span class="line"> </span><br><span class="line">$ curl --cookie user= &apos;http://localhost:8080/test&apos;</span><br><span class="line">cookie user: []</span><br><span class="line"> </span><br><span class="line">$ curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">cookie user: missing</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，<code>cookie user</code> 不存在以及取值为空字符串这两种情况被很好地区分开了：当 <code>cookie user</code> 不存在时，<code>Lua</code> 代码中的 <code>ngx.var.cookie_user</code> 返回了期望的<code>Lua nil</code> 值。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Lua</code> 里访问未创建的 <code>Nginx</code> 用户变量时，在 <code>Lua</code> 里也会得到 <code>nil</code> 值，而不会像先前的例子那样直接让 <code>Nginx</code> 拒绝加载配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /test &#123;</span><br><span class="line">    <span class="attribute">content_by_lua</span> <span class="string">'</span></span><br><span class="line"><span class="string">        ngx.say("<span class="variable">$blah</span> = ", ngx.var.blah)</span></span><br><span class="line"><span class="string">    '</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里<strong>假设我们并没有在当前的 <code>nginx.conf</code> 配置文件中创建过用户变量 <code>$blah</code>，然后我们在<code>Lua</code>代码中通过 <code>ngx.var.blah</code> 直接引用它</strong>。<strong>上面这个配置可以顺利启动，因为 <code>Nginx</code>在加载配置时只会编译 <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank" rel="noopener">content_by_lua</a>配置指令指定的 <code>Lua</code>代码而不会实际执行它，所以 <code>Nginx</code> 并不知道 <code>Lua</code>代码里面引用了 <code>$blah</code> 这个变量</strong>。于是我们在运行时也会得到 <code>nil</code> 值。而 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 提供的 <a href="http://wiki.nginx.org/HttpLuaModule#ngx.say" target="_blank" rel="noopener">ngx.say</a> 函数会自动把 <code>Lua</code> 的 <code>nil</code> 值格式化为字符串<code>&quot;nil&quot;</code> 输出，于是访问 <code>/test</code> 接口的结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl &apos;http://localhost:8080/test&apos;</span><br><span class="line">$blah = nil</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这正是我们所期望的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面这个例子中另一个值得注意的地方是，我们在 <a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank" rel="noopener">content_by_lua</a> 配置指令的参数中提及了 <code>$bar</code> 符号，但却并没有触发“变量插值”（否则 <code>Nginx</code> 会在启动时抱怨 <code>$blah</code> 未创建）。这是因为 <strong><a href="http://wiki.nginx.org/HttpLuaModule#content_by_lua" target="_blank" rel="noopener">content_by_lua</a>配置指令并不支持参数的“变量插值”功能</strong>。我们在前面中提到过，<strong>配置指令的参数是否允许“变量插值”，其实取决于该指令的实现模块</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设计返回“不合法”这一特殊值的例子是困难的，因为我们 在前面已经看到，<strong>由 <a href="http://wiki.nginx.org/HttpRewriteModule#set" target="_blank" rel="noopener">set</a> 指令创建的变量在未初始化时确实是“不合法”，但一旦尝试读取它们时，<code>Nginx</code> 就会自动调用其“取处理程序”，而它们的“取处理程序”会自动返回空字符串并将之缓存住</strong>。于是我们最终得到的是完全合法的空字符串。下面这个使用了 Lua 代码的例子证明了这一点：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /foo &#123;</span><br><span class="line">    <span class="attribute">content_by_lua</span> <span class="string">'</span></span><br><span class="line"><span class="string">        if ngx.var.foo == nil then</span></span><br><span class="line"><span class="string">            ngx.say("<span class="variable">$foo</span> is nil")</span></span><br><span class="line"><span class="string">        else</span></span><br><span class="line"><span class="string">            ngx.say("<span class="variable">$foo</span> = [", ngx.var.foo, "]")</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string">    '</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="attribute">location</span> /bar &#123;</span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$foo</span> <span class="number">32</span>;</span><br><span class="line">    <span class="attribute">echo</span> <span class="string">"foo = [<span class="variable">$foo</span>]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请求 <code>/foo</code> 接口的结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/foo&apos;</span><br><span class="line">$foo = []</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到<strong>在 <code>Lua</code>里面读取未初始化的 <code>Nginx</code> 变量 <code>$foo</code> 时得到的是空字符串</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后值得一提的是，虽然前面反复指出<code>Nginx</code> 变量只有字符串这一种数据类型，但这并不能阻止像 <a href="http://wiki.nginx.org/HttpArrayVarModule" target="_blank" rel="noopener">ngx_array_var</a> 这样的第三方模块让 <code>Nginx</code>变量也能存放数组类型的值。下面就是这样的一个例子：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /test &#123;</span><br><span class="line">    <span class="attribute">array_split</span> <span class="string">","</span> <span class="variable">$arg_names</span> to=<span class="variable">$array</span>;</span><br><span class="line">    <span class="attribute">array_map</span> <span class="string">"[<span class="variable">$array_it</span>]"</span> <span class="variable">$array</span>;</span><br><span class="line">    <span class="attribute">array_join</span> <span class="string">" "</span> <span class="variable">$array</span> to=<span class="variable">$res</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="attribute">echo</span> <span class="variable">$res</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个例子中使用了 <a href="http://wiki.nginx.org/HttpArrayVarModule" target="_blank" rel="noopener">ngx_array_var</a> 模块的 <code>array_split</code>、 <code>array_map</code> 和 <code>array_join</code> 这三条配置指令，其含义很接近<code>Perl</code>语言中的内建函数 <code>split</code>、<code>map</code> 和 <code>join</code>（当然，其他脚本语言也有类似的等价物）。我们来看看访问 <code>/test</code> 接口的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl &apos;http://localhost:8080/test?names=Tom,Jim,Bob</span><br><span class="line">[Tom] [Jim] [Bob]</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们看到，使用 <a href="http://wiki.nginx.org/HttpArrayVarModule" target="_blank" rel="noopener">ngx_array_var</a> 模块可以很方便地处理这样具有不定个数的组成元素的输入数据，例如此例中的 <code>names URL</code> 参数值就是由不定个数的逗号分隔的名字所组成。不过，这种类型的复杂任务通过 <a href="http://wiki.nginx.org/HttpLuaModule" target="_blank" rel="noopener">ngx_lua</a> 来做通常会更灵活而且更容易维护。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/09/19/mysql自定义排序规则函数——field()/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/19/mysql自定义排序规则函数——field()/" itemprop="url">mysql自定义排序规则函数——field()</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-19T12:12:57+08:00">
                2019-09-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Mysql/" itemprop="url" rel="index">
                    <span itemprop="name">Mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="mysql自定义排序规则函数——field"><a href="#mysql自定义排序规则函数——field" class="headerlink" title="mysql自定义排序规则函数——field()"></a>mysql自定义排序规则函数——field()</h1><blockquote>
<p>原文地址：<a href="https://blog.csdn.net/u011193276/article/details/52531439" target="_blank" rel="noopener">https://blog.csdn.net/u011193276/article/details/52531439</a></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>mysql order by</code>排序中，大多数情况下仅使用默认排序规则就够了：字符串按字典顺序，数字按大小等等。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可有时候，某个<strong>字段是有自身业务含义的</strong>，比如 有个字段<code>type</code>，<strong>值1、2、3可能分别表示早/中/晚，如果我想把中午信息靠前，这时候普通的升降序排列就不好办了</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>field(column,value1,value2,value3,……)</code>是解决这种问题的利器。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中<code>column</code>代表要排序的列，<code>value1……</code>代表自定义的顺序： </p>
<blockquote>
<p> <code>order by field(type,2,3,1)</code>就是按2在前，3次之，1最后的顺序来排。</p>
</blockquote>
<p><strong>缺陷：在排序时，使用不了索引</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `test_order` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `cur_date` date DEFAULT &apos;2018-09-21&apos; COMMENT &apos;日期&apos;,</span><br><span class="line">  `type` tinyint(3) NOT NULL DEFAULT &apos;1&apos; COMMENT &apos;阶段  1=早上 2=中午 3=下午&apos;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `type-idx` (`type`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `cur_date`, `type`) VALUES (1, &apos;2018-09-21&apos;, 1);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `cur_date`, `type`) VALUES (2, &apos;2018-09-21&apos;, 2);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `cur_date`, `type`) VALUES (3, &apos;2018-09-21&apos;, 3);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `cur_date`, `type`) VALUES (4, &apos;2018-09-22&apos;, 1);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `cur_date`, `type`) VALUES (5, &apos;2018-09-22&apos;, 2);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `cur_date`, `type`) VALUES (6, &apos;2018-09-22&apos;, 3);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `test_order` order by field(type, 2, 3, 1)</span><br><span class="line">+----+------------+------+</span><br><span class="line">| id | cur_date   | type |</span><br><span class="line">+----+------------+------+</span><br><span class="line">|  2 | 2018-09-21 |    2 |</span><br><span class="line">|  5 | 2018-09-22 |    2 |</span><br><span class="line">|  3 | 2018-09-21 |    3 |</span><br><span class="line">|  6 | 2018-09-22 |    3 |</span><br><span class="line">|  1 | 2018-09-21 |    1 |</span><br><span class="line">|  4 | 2018-09-22 |    1 |</span><br><span class="line">+----+------------+------+</span><br></pre></td></tr></table></figure>
<p><strong>使用order by field</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">explain SELECT * FROM `test_order` order by field(type, 2, 3, 1);</span><br><span class="line">+----+------------+--------------+------+--------------+------+---------+------+-------+-------------+</span><br><span class="line">| id | select_type | table         | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+------------+--------------+------+--------------+------+---------+------+-------+-------------+</span><br><span class="line">|  1 | SIMPLE     | test_order_v1 | ALL | NULL         | NULL | NULL    | NULL |     6 | Using filesort |</span><br><span class="line">+----+------------+--------------+------+--------------+------+---------+------+-------+-------------+</span><br></pre></td></tr></table></figure>
<p><strong>未能够使用索引</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">explain SELECT type FROM `test_order` order by field(type, 2, 3, 1);</span><br><span class="line">+----+------------+--------------+-------+--------------+---------+---------+------+-------+-----------------------+</span><br><span class="line">| id | select_type | table         | type  | possible_keys | key     | key_len | ref  | rows | Extra                 |</span><br><span class="line">+----+------------+--------------+-------+--------------+---------+---------+------+-------+-----------------------+</span><br><span class="line">|  1 | SIMPLE     | test_order_v1 | index | NULL         | type-idx | 1       | NULL |     6 | Using index; Using filesort |</span><br><span class="line">+----+------------+--------------+-------+--------------+---------+---------+------+-------+-----------------------+</span><br></pre></td></tr></table></figure>
<p><strong>在排序时未能够使用索引，Using filesort</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">explain SELECT type FROM `test_order` where type in (1,2) order by field(type, 2, 3, 1);</span><br><span class="line">+----+------------+--------------+-------+--------------+---------+---------+------+-------+-----------------------------------+</span><br><span class="line">| id | select_type | table         | type  | possible_keys | key     | key_len | ref  | rows | Extra                             |</span><br><span class="line">+----+------------+--------------+-------+--------------+---------+---------+------+-------+-----------------------------------+</span><br><span class="line">|  1 | SIMPLE     | test_order_v1 | range | type-idx      | type-idx | 1       | NULL |     4 | Using where; Using index; Using filesort |</span><br><span class="line">+----+------------+--------------+-------+--------------+---------+---------+------+-------+-----------------------------------+</span><br></pre></td></tr></table></figure>
<p><strong>在索引覆盖时，取数据可以用到索引，但是排序仍然不能，Using filesort</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">explain SELECT * FROM `test_order` where type in (1,2) order by field(type, 2, 3, 1);</span><br><span class="line">+----+------------+--------------+------+--------------+------+---------+------+-------+------------------------+</span><br><span class="line">| id | select_type | table         | type | possible_keys | key  | key_len | ref  | rows | Extra                  |</span><br><span class="line">+----+------------+--------------+------+--------------+------+---------+------+-------+------------------------+</span><br><span class="line">|  1 | SIMPLE     | test_order_v1 | ALL | type-idx      | NULL | NULL    | NULL |     6 | Using where; Using filesort |</span><br><span class="line">+----+------------+--------------+------+--------------+------+---------+------+-------+------------------------+</span><br></pre></td></tr></table></figure>
<p><strong>select * 时，不能够使用索引</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `test_order` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(255) NOT NULL DEFAULT &apos;&apos; COMMENT &apos;系统名称&apos;,</span><br><span class="line">  `version` tinyint(3) NOT NULL DEFAULT &apos;0&apos; COMMENT &apos;系统版本&apos;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  KEY `name_idx` (`name`) USING BTREE</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;</span><br><span class="line"></span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `name`, `version`) VALUES (1, &apos;ios&apos;, 2);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `name`, `version`) VALUES (2, &apos;ios&apos;, 3);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `name`, `version`) VALUES (3, &apos;android&apos;, 1);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `name`, `version`) VALUES (4, &apos;android&apos;, 4);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `name`, `version`) VALUES (5, &apos;other&apos;, 5);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `name`, `version`) VALUES (6, &apos;other&apos;, 0);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `name`, `version`) VALUES (7, &apos;鸿蒙&apos;, 1);</span><br><span class="line">INSERT INTO `test`.`test_order`(`id`, `name`, `version`) VALUES (8, &apos;阿里云&apos;, 2);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `test_order`;</span><br><span class="line">+----+--------+--------+</span><br><span class="line">| id | name  | version |</span><br><span class="line">+----+--------+--------+</span><br><span class="line">|  1 | ios    |      2 |</span><br><span class="line">|  2 | ios    |      3 |</span><br><span class="line">|  3 | android |      1 |</span><br><span class="line">|  4 | android |      4 |</span><br><span class="line">|  5 | other  |      5 |</span><br><span class="line">|  6 | other  |      0 |</span><br><span class="line">|  7 | 鸿蒙   |      1 |</span><br><span class="line">|  8 | 阿里云 |      2 |</span><br><span class="line">+----+--------+--------+</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `test_order` order by field(version, 2, 3, 1);</span><br><span class="line">+----+--------+--------+</span><br><span class="line">| id | name  | version |</span><br><span class="line">+----+--------+--------+</span><br><span class="line">|  4 | android |      4 |</span><br><span class="line">|  5 | other  |      5 |</span><br><span class="line">|  6 | other  |      0 |</span><br><span class="line">|  1 | ios    |      2 |</span><br><span class="line">|  8 | 阿里云 |      2 |</span><br><span class="line">|  2 | ios    |      3 |</span><br><span class="line">|  3 | android |      1 |</span><br><span class="line">|  7 | 鸿蒙   |      1 |</span><br><span class="line">+----+--------+--------+</span><br></pre></td></tr></table></figure>
<p><strong>默认升序时，未指定在排序列表里面的，排在最前面</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM `test_order` order by field(version, 2, 3, 1) desc;</span><br><span class="line">+----+--------+--------+</span><br><span class="line">| id | name  | version |</span><br><span class="line">+----+--------+--------+</span><br><span class="line">|  3 | android |      1 |</span><br><span class="line">|  7 | 鸿蒙   |      1 |</span><br><span class="line">|  2 | ios    |      3 |</span><br><span class="line">|  1 | ios    |      2 |</span><br><span class="line">|  8 | 阿里云 |      2 |</span><br><span class="line">|  4 | android |      4 |</span><br><span class="line">|  5 | other  |      5 |</span><br><span class="line">|  6 | other  |      0 |</span><br><span class="line">+----+--------+--------+</span><br></pre></td></tr></table></figure>
<p><strong>降序时，未指定在排序列表里面的，排在最后面</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/09/19/Lua查找表元素过程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/19/Lua查找表元素过程/" itemprop="url">Lua查找表元素过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-19T12:12:57+08:00">
                2019-09-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Lua/" itemprop="url" rel="index">
                    <span itemprop="name">Lua</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Lua查找表元素过程"><a href="#Lua查找表元素过程" class="headerlink" title="Lua查找表元素过程"></a>Lua查找表元素过程</h1><blockquote>
<p>原文地址：<a href="https://blog.csdn.net/xocoder/article/details/9028347" target="_blank" rel="noopener">https://blog.csdn.net/xocoder/article/details/9028347</a></p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Lua</code>的表本质其实是个类似<code>HashMap</code>的东西，其元素是很多的<code>Key-Value</code>对，如果尝试访问了一个表中并不存在的元素时，就会<strong>触发Lua的一套查找机制，也是凭借这个机制来模拟了类似“继承”的行为</strong></p>
<p>举例说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tempTable = &#123;&#125;</span><br><span class="line">print(tempTable.memberA) --这里试图打印tempTable并不存在的成员memberA</span><br></pre></td></tr></table></figure>
<p>执行结果：<code>nil</code></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输出为<code>nil</code>的原因很简单，<code>tempTable</code>中并没有<code>memberA</code>这个成员，这符合我们平时对<code>HashMap</code>的认知。但对于<code>Lua</code>表，如果<code>tempTable</code>有元表，情况就不同了。</p>
<p><strong>什么是元表：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>元表像是一个“操作指南”，里面包含了一系列操作的解决方案</strong>，例如：<code>__index</code>方法就是定义了这个表在索引失败的情况下该怎么办。</p>
<p><strong>__index元方法：</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多人对此都有误解，这个<strong>误解是：如果A的元表是B，那么如果访问了一个A中不存在的成员，就会访问查找B中有没有这个成员</strong>。而这个理解是完全错误的，实际上，即使将A的元表设置为B，而且B中也确实有这个成员，返回结果仍然会是<code>nil</code>，原因就是B的<code>index</code>元方法没有赋值。别忘了我们之前说过的：“元表是一个操作指南”，定义了元表，只是有了操作指南，但不应该在操作指南里面去查找元素，而<strong><code>index</code>方法则是“操作指南”的“索引失败时该怎么办”</strong>。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">father = &#123;</span><br><span class="line">	house=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">son = &#123;</span><br><span class="line">	car=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(son, father) <span class="comment">--把son的metatable设置为father</span></span><br><span class="line"><span class="built_in">print</span>(son.house)</span><br></pre></td></tr></table></figure>
<p>输出的结果是<code>nil</code></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">father = &#123;</span><br><span class="line">	house=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">father.<span class="built_in">__index</span> = father <span class="comment">-- 把father的__index方法指向自己</span></span><br><span class="line">son = &#123;</span><br><span class="line">	car=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(son, father)</span><br><span class="line"><span class="built_in">print</span>(son.house)</span><br></pre></td></tr></table></figure>
<p>输出的结果为1，符合预期</p>
<p>这样一来，结合上例，来解释<code>__index</code>元方法的含义：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在上述例子中，访问son.house时，son中没有house这个成员，但Lua接着发现son有元表father，注意：此时，<code>Lua</code>并不是直接在father中找名为house的成员，而是调用father的<code>__index</code>方法，<strong>如果<code>__index</code>方法为<code>nil</code>，则返回<code>nil</code></strong>，如果是一个表（上例中father的<code>__index</code>方法等于自己，就是这种情况），那么就到__index方法所指的这个表中查找名为house的成员，于是，最终找到了house成员。</p>
<p>注：<code>__index</code>方法除了<strong>可以是一个表，还可以是一个函数</strong>，如果是一个函数，<code>__index</code>方法被调用时将返回该函数的返回值。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这里，总结一下<code>Lua</code>查找一个表元素时的规则，其实就是如下3个步骤:</p>
<p>1.在表中查找，如果找到，返回该元素，找不到则继续</p>
<p>2.判断该表是否有元表（操作指南），如果没有元表，返回<code>nil</code>，有元表则继续</p>
<p>3.判断元表（操作指南）中<strong>有没有关于索引失败的指南（即__index方法）</strong>，如果没有（即__index方法为nil），则返回nil；如果__index方法是一个表，则重复1、2、3；如果__index方法是一个函数，则返回该函数的返回值</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/147/">147</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
