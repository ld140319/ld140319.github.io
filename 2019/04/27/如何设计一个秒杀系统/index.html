<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="架构,秒杀,">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="如何设计一个秒杀系统 根据极客时间专栏：如何设计一个秒杀系统进行整理  秒杀系统&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;从整体上思考问题，秒杀其实主要解决两个问题，一个是并发读，一个是并发写。   &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;并发读一方面是在活动开始前会有大量的请求来看活动是否已经开始，另一方面是在活动开始时，大量的浏览下">
<meta name="keywords" content="架构,秒杀">
<meta property="og:type" content="article">
<meta property="og:title" content="如何设计一个秒杀系统">
<meta property="og:url" content="http://blog.com/2019/04/27/如何设计一个秒杀系统/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="如何设计一个秒杀系统 根据极客时间专栏：如何设计一个秒杀系统进行整理  秒杀系统&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;从整体上思考问题，秒杀其实主要解决两个问题，一个是并发读，一个是并发写。   &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;并发读一方面是在活动开始前会有大量的请求来看活动是否已经开始，另一方面是在活动开始时，大量的浏览下">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://blog.com/2019/04/27/如何设计一个秒杀系统/ba65c2b4e2a2bae28192e1d456131f3d.jpg">
<meta property="og:image" content="http://blog.com/2019/04/27/如何设计一个秒杀系统/5010fe68abebec4ed71e87147c0ee665.jpg">
<meta property="og:image" content="http://blog.com/2019/04/27/如何设计一个秒杀系统/2c608715621afc9c95570dce00a87546.jpg">
<meta property="og:image" content="http://blog.com/2019/04/27/如何设计一个秒杀系统/1.jpg">
<meta property="og:image" content="http://blog.com/2019/04/27/如何设计一个秒杀系统/2.jpg">
<meta property="og:image" content="http://blog.com/2019/04/27/如何设计一个秒杀系统/3.jpg">
<meta property="og:image" content="http://blog.com/2019/04/27/如何设计一个秒杀系统/4.jpg">
<meta property="og:image" content="http://blog.com/2019/04/27/如何设计一个秒杀系统/5.jpg">
<meta property="og:image" content="http://blog.com/2019/04/27/如何设计一个秒杀系统/6.jpg">
<meta property="og:image" content="http://blog.com/2019/04/27/如何设计一个秒杀系统/7.jpg">
<meta property="og:image" content="http://blog.com/2019/04/27/如何设计一个秒杀系统/8.jpg">
<meta property="og:image" content="https://static001.geekbang.org/resource/image/4a/09/4a5b7e080e7d357986f02ed1fd8b7309.jpg">
<meta property="og:image" content="http://blog.com/2019/04/27/如何设计一个秒杀系统/10.jpg">
<meta property="og:image" content="http://blog.com/2019/04/27/如何设计一个秒杀系统/11.jpg">
<meta property="og:image" content="http://blog.com/2019/04/27/如何设计一个秒杀系统/12.jpg">
<meta property="og:updated_time" content="2019-04-26T16:12:09.712Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="如何设计一个秒杀系统">
<meta name="twitter:description" content="如何设计一个秒杀系统 根据极客时间专栏：如何设计一个秒杀系统进行整理  秒杀系统&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;从整体上思考问题，秒杀其实主要解决两个问题，一个是并发读，一个是并发写。   &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;并发读一方面是在活动开始前会有大量的请求来看活动是否已经开始，另一方面是在活动开始时，大量的浏览下">
<meta name="twitter:image" content="http://blog.com/2019/04/27/如何设计一个秒杀系统/ba65c2b4e2a2bae28192e1d456131f3d.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/2019/04/27/如何设计一个秒杀系统/">





  <title>如何设计一个秒杀系统 | 搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/04/27/如何设计一个秒杀系统/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">如何设计一个秒杀系统</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-27T12:12:57+08:00">
                2019-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/秒杀/" itemprop="url" rel="index">
                    <span itemprop="name">秒杀</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="如何设计一个秒杀系统"><a href="#如何设计一个秒杀系统" class="headerlink" title="如何设计一个秒杀系统"></a>如何设计一个秒杀系统</h1><blockquote>
<p>根据极客时间专栏：如何设计一个秒杀系统进行整理</p>
</blockquote>
<h2 id="秒杀系统"><a href="#秒杀系统" class="headerlink" title="秒杀系统"></a>秒杀系统</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从整体上思考问题，<strong>秒杀其实主要解决两个问题，一个是并发读，一个是并发写</strong>。</p>
<blockquote>
<p> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并发读一方面是在活动开始前会有大量的请求来看活动是否已经开始，另一方面是在活动开始时，大量的浏览下单。</p>
</blockquote>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并发写是因为在秒杀开始后，大量请求库存扣减、订单创建、订单支付，数据库压力较大。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并发读的核心优化理念是<strong>尽量减少用户到服务端来“读”数据，或者让他们读更少的数据</strong>；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并发写的处理原则也一样，它要求尽量<strong>把数据进行隔离</strong>，如打造单独的秒杀系统，库存、订单进行管理，<strong>将并发写变成串行写</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从一个架构师的角度来看，要想打造并维护一个超大流量并发读写、高性能、高可用的系统，在整个用户请求路径上从浏览器到服务端我们要遵循几个原则，就是要<strong>保证用户请求的数据尽量少、请求数尽量少、路径尽量短、依赖尽量少，并且不要有单点</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>其实，秒杀的整体架构可以概括为“稳、准、快”几个关键字。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓<strong>“稳”</strong>，就是<strong>整个系统架构要满足高可用</strong>，流量符合预期时肯定要稳定，就是超出预期时也同样不能掉链子，你要<strong>保证秒杀活动顺利完成，即秒杀商品顺利地卖出去，这个是最基本的前提</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后就是<strong>“准”</strong>，就是秒杀 10 台 iPhone，那就只能成交 10 台，多一台少一台都不行。一旦库存不对，那平台就要承担损失，所以“准”就是要求<strong>保证数据的一致性，保证不超卖</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后再看<strong>“快”</strong>，“快”其实很好理解，它就是说系统的性能要足够高，否则你怎么支撑这么大的流量呢？不光是服务端要做极致的性能优化，而且<strong>在整个请求链路上都要做协同的优化，每个地方快一点，整个系统就完美了，将秒杀结果以最快的速度反馈给用户，用户体验好</strong>。</p>
<ul>
<li><strong>高性能：</strong>分离方案、热点的发现与隔离、请求的削峰与分层过滤、服务端的极致优化</li>
<li><strong>一致性：</strong> 在大并发更新的过程中都要保证数据的准确性</li>
<li><strong>高可用：</strong>避免单点、plan B</li>
</ul>
<h2 id="架构原则"><a href="#架构原则" class="headerlink" title="架构原则"></a>架构原则</h2><h3 id="数据要尽量少"><a href="#数据要尽量少" class="headerlink" title="数据要尽量少"></a>数据要尽量少</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓“数据要尽量少”，首先是指<strong>用户请求的数据能少就少</strong>。请求的数据包括上传给系统的数据和系统返回给用户的数据（通常就是网页）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为啥“数据要尽量少”呢？因为首先这些数据在网络上传输需要时间，其次不管是请求数据还是返回数据都需要服务器做处理，而<strong>服务器在写网络时通常都要做压缩和字符编码</strong>，这些都非常消耗 CPU，所以减少传输的数据量可以显著减少 CPU 的使用。例如，我们可以简化秒杀页面的大小，去掉不必要的页面装修效果，等等。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其次，“数据要尽量少”还要求系统依赖的数据能少就少，包括系统完成某些业务逻辑需要读取和保存的数据，这些数据一般是和后台服务以及数据库打交道的。调用其他服务会<strong>涉及数据的序列化和反序列化</strong>，而这也是 CPU 的一大杀手，同样也会增加延时。而且，<strong>数据库本身也容易成为一个瓶颈</strong>，所以和数据库打交道越少越好，数据越简单、越小则越好。</p>
<p><strong>js、css进行压缩，图片压缩裁剪【减少数据量的传输】，背景图片可以使用雪碧图【避免多次请求，握手耗时】</strong></p>
<p><strong>接口合并，将一些接口进行合并，避免请求太多的接口</strong></p>
<h3 id="请求数要尽量少"><a href="#请求数要尽量少" class="headerlink" title="请求数要尽量少"></a>请求数要尽量少</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户请求的页面返回后，浏览器渲染这个页面还要包含其他的额外请求，比如说，这个页面依赖的 CSS/JavaScript、图片，以及 Ajax 请求等等都定义为“额外请求”，这些额外请求应该尽量少。因为浏览器每发出一个请求都多少会有一些消耗，例如<strong>建立连接要做三次握手</strong>，有的时候有页面依赖或者连接数限制，一些请求（例如 JavaScript）还需要串行加载等。另外，如果不同请求的域名不一样的话，还涉及这些<strong>域名的 DNS 解析</strong>，可能会耗时更久。所以你要记住的是，减少请求数可以显著减少以上这些因素导致的资源消耗。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，减少请求数最常用的一个实践就是合并 CSS 和 JavaScript 文件，把多个 JavaScript 文件合并成一个文件，在 URL 中用逗号隔开（<a href="https://g.xxx.com/tm/xx-b/4.0.94/mods/" target="_blank" rel="noopener">https://g.xxx.com/tm/xx-b/4.0.94/mods/</a>??module-preview/index.xtpl.js,module-jhs/index.xtpl.js,module-focus/index.xtpl.js）。这种方式在服务端仍然是单个文件各自存放，只是服务端会有一个组件解析这个 URL，然后动态把这些文件合并起来一起返回。</p>
<h3 id="路径要尽量短"><a href="#路径要尽量短" class="headerlink" title="路径要尽量短"></a>路径要尽量短</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓“路径”，就是用户发出请求到返回数据这个过程中，需求经过的中间的节点数。通常，这些节点可以表示为一个系统或者一个新的 Socket 连接（比如代理服务器只是创建一个新的 Socket 连接来转发请求）。每经过一个节点，一般都会产生一个新的 Socket 连接。然而，每增加一个连接都会<strong>增加新的不确定性</strong>。从概率统计上来说，加入一次请求经过 5 个节点，每个节点的可用性是 99.9% 的话，那么整个请求的可用性是：99.9% 的 5 次方，约等于 99.5%。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以缩短请求路径不仅可以增加可用性，同样可以有效提升性能<strong>（减少中间节点可以减少数据的序列化与反序列化），并减少延时（可以减少网络传输耗时）</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要缩短访问路径有一种办法，就是多个相互强依赖的应用合并部署在一起，把远程过程调用（RPC）变成 JVM 内部之间的方法调用。</p>
<h3 id="依赖要尽量少"><a href="#依赖要尽量少" class="headerlink" title="依赖要尽量少"></a>依赖要尽量少</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>所谓依赖，指的是要完成一次用户请求必须依赖的系统或者服务，这里的依赖指的是强依赖</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举个例子，比如说你要展示秒杀页面，而这个页面必须强依赖商品信息、用户信息，还有其他如优惠券、成交列表等这些对秒杀不是非要不可的信息（弱依赖），这些弱依赖在紧急情况下就可以去掉。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要减少依赖，我们可以给系统进行分级，比如 0 级系统、1 级系统、2 级系统、3 级系统，0 级系统如果是最重要的系统，那么 0 级系统强依赖的系统也同样是最重要的系统，以此类推。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意，0 级系统要尽量减少对 1 级系统的强依赖，<strong>防止重要的系统被不重要的系统拖垮</strong>。例如支付系统是 0 级系统，而优惠券是 1 级系统的话，在极端情况下可以把优惠券给降级，防止支付系统被优惠券这个 1 级系统给拖垮。</p>
<h3 id="不要有单点"><a href="#不要有单点" class="headerlink" title="不要有单点"></a>不要有单点</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;系统中的单点可以说是系统架构上的一个大忌，因为单点意味着没有备份，风险不可控，我们设计分布式系统最重要的原则就是“消除单点”。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那如何避免单点呢？我认为关键点是<strong>避免将服务的状态和机器绑定，即把服务无状态化，这样服务就可以在机器中随意移动</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何那把服务的状态和机器解耦呢？这里也有很多实现方式。例如把和机器相关的配置动态化，这些参数可以通过配置中心来动态推送，在服务启动时动态拉取下来，我们在这些配置中心设置一些规则来方便地改变这些映射关系。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>应用无状态化是有效避免单点的一种方式，但是像存储服务本身很难无状态化，因为数据要存储在磁盘上，本身就要和机器绑定，那么这种场景一般要通过冗余多个备份的方式来解决单点问题</strong>。</p>
<h2 id="不同场景下的不同架构案例"><a href="#不同场景下的不同架构案例" class="headerlink" title="不同场景下的不同架构案例"></a>不同场景下的不同架构案例</h2><p>下面我以淘宝早期秒杀系统架构的演进为主线，来帮你梳理不同的请求体量下，我认为的最佳秒杀系统架构。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你想快速搭建一个简单的秒杀系统，只需要把你的商品购买页面增加一个“定时上架”功能，<code>仅在秒杀开始时才让用户看到购买按钮，当商品的库存卖完了也就结束了</code>。这就是当时第一个版本的秒杀系统实现方式。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但随着请求量的加大（比如从 1w/s 到了 10w/s 的量级），这个简单的架构很快就遇到了瓶颈，因此需要做架构改造来提升系统性能。这些架构改造包括：</p>
<ol>
<li><strong>把秒杀系统独立出来单独打造一个系统</strong>，这样可以有针对性地做优化，例如这个独立出来的系统就减少了店铺装修的功能，减少了页面的复杂度；</li>
<li>在系统部署上也<strong>独立做一个机器集群</strong>，这样秒杀的大流量就不会影响到正常的商品购买集群的机器负载；</li>
<li><strong>将热点数据（如库存数据）单独放到一个缓存系统中，以提高“读性能”</strong>；</li>
<li><strong>增加秒杀答题，防止有秒杀器抢单</strong>；</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时的系统架构变成了下图这个样子。最重要的就是，<strong>秒杀详情成为了一个独立的新系统，另外核心的一些数据放到了缓存（Cache）中，其他的关联系统也都以独立集群的方式进行部署</strong>。</p>
<p><img src="//blog.com/2019/04/27/如何设计一个秒杀系统/ba65c2b4e2a2bae28192e1d456131f3d.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然而这个架构仍然支持不了超过 100w/s 的请求量，所以为了进一步提升秒杀系统的性能，我们又对架构做进一步升级，比如：</p>
<ol>
<li><strong>对页面进行彻底的动静分离</strong>，使得用户秒杀时不需要刷新整个页面，而只需要点击抢宝按钮，借此把页面刷新的数据降到最少；</li>
<li><strong>在服务端对秒杀商品进行本地缓存</strong>，不需要再调用依赖系统的后台服务获取数据，甚至不需要去公共的缓存集群中查询数据，这样不仅可以减少系统调用，而且能够避免压垮公共缓存集群。</li>
<li><strong>增加系统限流保护，防止最坏情况发生</strong>。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经过这些优化，系统架构变成了下图中的样子。在这里，我们对页面进行了进一步的静态化，秒杀过程中不需要刷新整个页面，而<strong>只需要向服务端请求很少的动态数据</strong>。而且，最关键的详情和交易系统都<strong>增加了本地缓存，来提前缓存秒杀商品的信息，热点数据库也做了独立部署</strong>，等等。</p>
<p><img src="//blog.com/2019/04/27/如何设计一个秒杀系统/5010fe68abebec4ed71e87147c0ee665.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从前面的几次升级来看，其实越到后面需要定制的地方越多，也就是越“不通用”。例如，<strong>把秒杀商品缓存在每台机器的内存中，这种方式显然不适合太多的商品同时进行秒杀的情况，因为单机的内存始终有限</strong>。所以要取得极致的性能，就要在其他地方（比如，通用性、易用性、成本等方面）有所牺牲。</p>
<blockquote>
<ol>
<li><p>本地cache用什么实现好呢？</p>
<pre><code>**本地cache一般就是用内存实现**，用java集合类型就行
</code></pre></li>
<li><p>通过什么方式往本地cache 写数据呢？<br> <strong>用订阅的方式，在初始化时加载到内存</strong></p>
</li>
<li><p>秒杀系统的及时性非常高，把库存写进cache ，怎么及时更新呢？<br>有两种方法，一是定时更新取3秒，二是，主动更新，数据库字段更新后发消息更新缓存，这个需要用到一个组件阿里叫metaq就是就是数据库字段更新会产生一条消息。另外cache里库存不需要100%和数据库一致。</p>
</li>
<li><p>数据缓存在机器内存中的话，集群内如何实现多台机器数据一致性？</p>
<p><strong>在内存的数据是静态数据，不会更新，没有一致性问题</strong>，如：一般都是存商品的静态数据，如：商品详情页、商品的描述信息这些</p>
</li>
<li><p><strong>库存不会放在localcache，localcache只放静态数据</strong><br>库存是放在独立的缓存系统里，如redis，库存是采用主动失效的方式来失效缓存</p>
</li>
<li><p>将大量的数据都放在缓存中，如何防止内存溢出了，内存溢出后的挽救方案怎么设计了</p>
<p><strong>一般专门的缓存系统都有内存保护机制，一般超过内存空间都会淘汰一部分数据</strong></p>
</li>
</ol>
</blockquote>
<h2 id="如何做秒杀时间控制"><a href="#如何做秒杀时间控制" class="headerlink" title="如何做秒杀时间控制"></a>如何做秒杀时间控制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;秒杀的时间是怎么控制的，比如十点开始，十点十分结束。各个客户端、客户端与服务器、以及集群内的服务器之间。时间如何精确同步？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>都是以服务端的时间为准，服务端的时间同步需要依赖一个时间同步组件完成如ntp，当然当前的服务器时间同步还是有一定的时间延时，但是也不是太影响</strong></p>
<h2 id="如何才能做好动静分离？有哪些方案可选？"><a href="#如何才能做好动静分离？有哪些方案可选？" class="headerlink" title="如何才能做好动静分离？有哪些方案可选？"></a>如何才能做好动静分离？有哪些方案可选？</h2><h3 id="何为动静数据"><a href="#何为动静数据" class="headerlink" title="何为动静数据"></a>何为动静数据</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那到底什么才是动静分离呢？所谓“动静分离”，其实就是把用户请求的数据（如 HTML 页面）划分为“动态数据”和“静态数据”。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单来说，<strong>“动态数据”和“静态数据”的主要区别就是看页面中输出的数据是否和 URL、浏览者、时间、地域相关，以及是否含有 Cookie 等私密数据</strong>。比如说：</p>
<ol>
<li>很多媒体类的网站，某一篇文章的内容不管是你访问还是我访问，它都是一样的。所以它就是一个典型的静态数据，但是它是个动态页面。</li>
<li>我们如果现在访问淘宝的首页，每个人看到的页面可能都是不一样的，淘宝首页中包含了很多根据访问者特征推荐的信息，而这些个性化的数据就可以理解为动态数据了。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里再强调一下，我们所说的静态数据，不能仅仅理解为传统意义上完全存在磁盘上的 HTML 页面，它也可能是经过 Java 系统产生的页面，但是它输出的页面本身不包含上面所说的那些因素。也就是<strong>所谓“动态”还是“静态”，并不是说数据本身是否动静，而是数据中是否含有和访问者相关的个性化数据</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一点要注意，就是页面中“不包含”，指的是“页面的 HTML 源码中不含有”，这一点务必要清楚。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，怎样对静态数据做缓存呢？我在这里总结了几个重点。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>第一，你应该把静态数据缓存到离用户最近的地方</strong>。静态数据就是那些相对不会变化的数据，因此我们可以把它们缓存起来。缓存到哪里呢？常见的就三种，用户浏览器里、CDN 上或者在服务端的 Cache 中。你应该根据情况，把它们尽量缓存到离用户最近的地方。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>第二，静态化改造就是要直接缓存 HTTP 连接</strong>。相较于普通的数据缓存而言，你肯定还听过系统的静态化改造。静态化改造是直接缓存 HTTP 连接而不是仅仅缓存数据，如下图所示，Web 代理服务器根据请求 URL，直接取出对应的 HTTP 响应头和响应体然后直接返回，这个响应过程简单得连 HTTP 协议都不用重新组装，甚至连 HTTP 请求头也不需要解析。</p>
<p><img src="//blog.com/2019/04/27/如何设计一个秒杀系统/2c608715621afc9c95570dce00a87546.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>第三，让谁来缓存静态数据也很重要</strong>。不同语言写的 Cache 软件处理缓存数据的效率也各不相同。以 Java 为例，因为 Java 系统本身也有其弱点（比如不擅长处理大量连接请求，每个连接消耗的内存较多，Servlet 容器解析 HTTP 协议较慢），所以你可以不在 Java 层做缓存，而是直接在 Web 服务器层上做，这样你就可以屏蔽 Java 语言层面的一些弱点；而相比起来，Web 服务器（如 Nginx、Apache、Varnish）也更擅长处理大并发的静态文件请求。</p>
<h3 id="如何做动静分离的改造"><a href="#如何做动静分离的改造" class="headerlink" title="如何做动静分离的改造"></a>如何做动静分离的改造</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;理解了动静态数据的“why”和“what”，接下来我们就要看“how”了。我们如何把动态页面改造成适合缓存的静态页面呢？其实也很简单，就是去除前面所说的那几个影响因素，把它们单独分离出来，做动静分离。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面，我以典型的商品详情系统为例来详细介绍。这里，你可以先打开京东或者淘宝的商品详情页，看看这个页面里都有哪些动静数据。我们从以下 5 个方面来分离出动态内容。</p>
<ol>
<li><strong>URL 唯一化</strong>。商品详情系统天然地就可以做到 URL 唯一化，比如每个商品都由 ID 来标识，那么 <a href="http://item.xxx.com/item.htm?id=xxxx" target="_blank" rel="noopener">http://item.xxx.com/item.htm?id=xxxx</a> 就可以作为唯一的 URL 标识。为啥要 URL 唯一呢？前面说了我们是要缓存整个 HTTP 连接，那么以什么作为 Key 呢？就以 URL 作为缓存的 Key，例如以 id=xxx 这个格式进行区分。</li>
<li><strong>分离浏览者相关的因素</strong>。浏览者相关的因素包括是否已登录，以及登录身份等，这些相关因素我们可以单独拆分出来，通过动态请求来获取。</li>
<li><strong>分离时间因素</strong>。服务端输出的时间也通过动态请求获取。（因为时间要以服务端为准，客户端的时间用户可以自己修改）</li>
<li><strong>异步化地域因素</strong>。详情页面上与地域相关的因素做成异步方式获取，当然你也可以通过动态请求方式获取，只是这里通过异步获取更合适。</li>
<li><strong>去掉 Cookie</strong>。服务端输出的页面包含的 Cookie 可以通过代码软件来删除，如 Web 服务器 Varnish 可以通过 unset req.http.cookie 命令去掉 Cookie。注意，这里说的去掉 Cookie 并不是用户端收到的页面就不含 Cookie 了，而是说，在缓存的静态数据中不含有 Cookie。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分离出动态内容之后，如何组织这些内容页就变得非常关键了。这里我要提醒你一点，因为这其中很多动态内容都会被页面中的其他模块用到，如判断该用户是否已登录、用户 ID 是否匹配等，所以这个时候我们应该将这些信息 JSON 化（用 JSON 格式组织这些数据），以方便前端获取。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面我们介绍里用缓存的方式来处理静态数据。而动态内容的处理通常有两种方案：ESI（Edge Side Includes）方案和 CSI（Client Side Include）方案。</p>
<ol>
<li><p><strong>ESI 方案（或者 SSI）</strong>：即在 Web 代理服务器上做动态内容请求，并将请求插入到静态页面中，当用户拿到页面时已经是一个完整的页面了。这种方式对服务端性能有些影响，但是用户体验较好。</p>
</li>
<li><p><strong>CSI 方案</strong>。即单独发起一个异步 JavaScript 请求，以向服务端获取动态内容。这种方式服务端性能更佳，但是用户端页面可能会延时，体验稍差。</p>
</li>
</ol>
<h4 id="动静分离的几种架构方案"><a href="#动静分离的几种架构方案" class="headerlink" title="动静分离的几种架构方案"></a>动静分离的几种架构方案</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面我们通过改造把静态数据和动态数据做了分离，那么如何在系统架构上进一步对这些动态和静态数据重新组合，再完整地输出给用户呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就涉及对用户请求路径进行合理的架构了。根据架构上的复杂度，有 3 种方案可选：</p>
<ol>
<li>实体机单机部署；</li>
<li>统一 Cache 层；</li>
<li>上 CDN；</li>
</ol>
<h5 id="方案-1：实体机单机部署"><a href="#方案-1：实体机单机部署" class="headerlink" title="方案 1：实体机单机部署"></a>方案 1：实体机单机部署</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方案是将虚拟机改为实体机，以增大 Cache 的容量，并且采用了一致性 Hash 分组的方式来提升命中率。这里将 Cache 分成若干组，是希望能达到命中率和访问热点的平衡。Hash 分组越少，缓存的命中率肯定就会越高，但短板是也会使单个商品集中在一个分组中，容易导致 Cache 被击穿，所以我们应该适当增加多个相同的分组，来平衡访问热点和命中率的问题。</p>
<p>这里我给出了实体机单机部署方案的结构图，如下：</p>
<p><img src="//blog.com/2019/04/27/如何设计一个秒杀系统/1.jpg" alt="img"></p>
<p>实体机单机部署有以下几个优点：</p>
<ol>
<li>没有网络瓶颈，而且能使用大内存；</li>
<li>既能提升命中率，又能减少 Gzip 压缩；</li>
<li>减少 Cache 失效压力，因为采用定时失效方式，例如只缓存 3 秒钟，过期即自动失效；</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方案中，虽然把通常只需要虚拟机或者容器运行的 Java 应用换成实体机，优势很明显，它会增加单机的内存容量，但是一定程度上也造成了 CPU 的浪费，因为单个的 Java 进程很难用完整个实体机的 CPU。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外就是，一个实体机上部署了 Java 应用又作为 Cache 来使用，这造成了运维上的高复杂度，所以这是一个折中的方案。如果你的公司里，没有更多的系统有类似需求，那么这样做也比较合适，如果你们有多个业务系统都有静态化改造的需求，那还是建议把 Cache 层单独抽出来公用比较合理，如下面的方案 2 所示。</p>
<h5 id="方案-2：统一-Cache-层"><a href="#方案-2：统一-Cache-层" class="headerlink" title="方案 2：统一 Cache 层"></a>方案 2：统一 Cache 层</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓统一 Cache 层，就是将单机的 Cache 统一分离出来，形成一个单独的 Cache 集群。统一 Cache 层是个更理想的可推广方案，该方案的结构图如下：</p>
<p><img src="//blog.com/2019/04/27/如何设计一个秒杀系统/2.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将 Cache 层单独拿出来统一管理可以减少运维成本，同时也方便接入其他静态化系统。此外，它还有一些优点：</p>
<ol>
<li>单独一个 Cache 层，可以减少多个应用接入时使用 Cache 的成本。这样接入的应用只要维护自己的 Java 系统就好，不需要单独维护 Cache，而只关心如何使用即可。</li>
<li>统一 Cache 的方案更易于维护，如后面加强监控、配置的自动化，只需要一套解决方案就行，统一起来维护升级也比较方便。</li>
<li>可以共享内存，最大化利用内存，不同系统之间的内存可以动态切换，从而能够有效应对各种攻击。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方案虽然维护上更方便了，但是也带来了其他一些问题，比如缓存更加集中，导致：</p>
<ol>
<li>Cache 层内部交换网络成为瓶颈；</li>
<li>缓存服务器的网卡也会是瓶颈；</li>
<li>机器少风险较大，挂掉一台就会影响很大一部分缓存数据。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决上面这些问题，可以再对 Cache 做 Hash 分组，即一组 Cache 缓存的内容相同，这样能够避免热点数据过度集中导致新的瓶颈产生。</p>
<h5 id="方案-3：上-CDN"><a href="#方案-3：上-CDN" class="headerlink" title="方案 3：上 CDN"></a>方案 3：上 CDN</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在将整个系统做动静分离后，我们自然会想到更进一步的方案，就是将 Cache 进一步前移到 CDN 上，因为 CDN 离用户最近，效果会更好。</p>
<p>但是要想这么做，有以下几个问题需要解决。</p>
<ol>
<li><strong>失效问题</strong>。前面我们也有提到过缓存时效的问题，不知道你有没有理解，我再来解释一下。谈到静态数据时，我说过一个关键词叫“相对不变”，它的言外之意是“可能会变化”。比如一篇文章，现在不变，但如果你发现个错别字，是不是就会变化了？如果你的缓存时效很长，那用户端在很长一段时间内看到的都是错的。所以，这个方案中也是，我们需要<strong>保证 CDN 可以在秒级时间内，让分布在全国各地的 Cache 同时失效，这对 CDN 的失效系统要求很高</strong>。</li>
<li><strong>命中率问题</strong>。Cache 最重要的一个衡量指标就是“高命中率”，不然 Cache 的存在就失去了意义。同样，<strong>如果将数据全部放到全国的 CDN 上，必然导致 Cache 分散，而 Cache 分散又会导致访问请求命中同一个 Cache 的可能性降低，那么命中率就成为一个问题</strong>。</li>
<li><strong>发布更新问题</strong>。如果一个业务系统每周都有日常业务需要发布，那么发布系统必须足够简洁高效，而且你还要考虑有问题时快速回滚和排查问题的简便性。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从前面的分析来看，将商品详情系统放到全国的所有 CDN 节点上是不太现实的，因为存在失效问题、命中率问题以及系统的发布更新问题。那么是否可以选择若干个节点来尝试实施呢？答案是“可以”，但是这样的节点需要满足几个条件：</p>
<ol>
<li>靠近访问量比较集中的地区；</li>
<li>离主站相对较远；</li>
<li>节点到主站间的网络比较好，而且稳定；</li>
<li>节点容量比较大，不会占用其他 CDN 太多的资源。</li>
</ol>
<p>最后，还有一点也很重要，那就是：节点不要太多。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于上面几个因素，选择 CDN 的二级 Cache 比较合适，因为二级 Cache 数量偏少，容量也更大，让用户的请求先回源的 CDN 的二级 Cache 中，如果没命中再回源站获取数据，部署方式如下图所示：</p>
<p><img src="//blog.com/2019/04/27/如何设计一个秒杀系统/3.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 CDN 的二级 Cache 作为缓存，可以达到和当前服务端静态化 Cache 类似的命中率，因为节点数不多，Cache 不是很分散，访问量也比较集中，这样也就解决了命中率问题，同时能够给用户最好的访问体验，是当前比较理想的一种 CDN 化方案。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除此之外，CDN 化部署方案还有以下几个特点：</p>
<ol>
<li>把整个页面缓存在用户浏览器中；</li>
<li>如果强制刷新整个页面，也会请求 CDN；</li>
<li>实际有效请求，只是用户对“刷新抢宝”按钮的点击。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>这样就把 90% 的静态数据缓存在了用户端或者 CDN 上，当真正秒杀时，用户只需要点击特殊的“刷新抢宝”按钮，而不需要刷新整个页面</strong>。这样一来，系统只是向服务端请求很少的有效数据，而不需要重复请求大量的静态数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;秒杀的动态数据和普通详情页面的动态数据相比更少，性能也提升了 3 倍以上。所以“抢宝”这种设计思路，让我们不用刷新页面就能够很好地请求到服务端最新的动态数据。</p>
<h5 id="存储在浏览器或-CDN-上，有多大区别？"><a href="#存储在浏览器或-CDN-上，有多大区别？" class="headerlink" title="存储在浏览器或 CDN 上，有多大区别？"></a>存储在浏览器或 CDN 上，有多大区别？</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;区别很大！因为在 CDN 上，我们可以做主动失效，而<strong>在用户的浏览器里就更不可控，如果用户不主动刷新的话，你很难主动地把消息推送给用户的浏览器</strong>。</p>
<h5 id="在什么地方把静态数据和动态数据合并并渲染出一个完整的页面"><a href="#在什么地方把静态数据和动态数据合并并渲染出一个完整的页面" class="headerlink" title="在什么地方把静态数据和动态数据合并并渲染出一个完整的页面"></a>在什么地方把静态数据和动态数据合并并渲染出一个完整的页面</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如在用户的浏览器里合并，那么服务端可以减少合并页面的 CPU 消耗，但传输的数据量就会较大，因为在服务端合并可以压缩。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果在服务端合并的话，就要考虑缓存的数据是否进行 Gzip 压缩了：如果缓存 Gzip 压缩后的静态数据可以<strong>减少缓存的数据量</strong>，但是进行页面合并渲染时就要先解压，然后再压缩完整的页面数据输出给用户；如果缓存未压缩的静态数据，这样不用解压静态数据，但是会增加缓存容量。</p>
<h2 id="二八原则：有针对性地处理好系统的“热点数据”"><a href="#二八原则：有针对性地处理好系统的“热点数据”" class="headerlink" title="二八原则：有针对性地处理好系统的“热点数据”"></a>二八原则：有针对性地处理好系统的“热点数据”</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设你的系统中存储有几十亿上百亿的商品，而每天有千万级的商品被上亿的用户访问，那么肯定有一部分被大量用户访问的热卖商品，这就是我们常说的“热点商品”。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些热点商品中最极端的例子就是秒杀商品，它们在很短时间内被大量用户执行访问、添加购物车、下单等操作，这些操作我们就称为“热点操作”。那么问题来了：这些热点对系统有啥影响，我们非要关注这些热点吗？</p>
<h3 id="为什么要关注热点"><a href="#为什么要关注热点" class="headerlink" title="为什么要关注热点"></a>为什么要关注热点</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们一定要关注热点，因为热点会对系统产生一系列的影响。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>首先，热点请求会大量占用服务器处理资源，虽然这个热点可能只占请求总量的亿分之一，然而却可能抢占 90% 的服务器资源，如果这个热点请求还是没有价值的无效请求，那么对系统资源来说完全是浪费</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其次，即使这些热点是有效的请求，我们也要识别出来做针对性的优化，从而用更低的代价来支撑这些热点请求。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然热点对系统来说这么重要，那么热点到底包含哪些内容呢？</p>
<h3 id="什么是“热点”"><a href="#什么是“热点”" class="headerlink" title="什么是“热点”"></a>什么是“热点”</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;热点分为<strong>热点操作</strong>和<strong>热点数据</strong>。所谓“热点操作”，例如大量的刷新页面、大量的添加购物车、双十一零点大量的下单等都属于此类操作。对系统来说，这些操作可以抽象为“读请求”和“写请求”，这两种热点请求的处理方式大相径庭，读请求的优化空间要大一些，而<strong>写请求的瓶颈一般都在存储层，优化的思路就是根据 CAP 理论做平衡</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而“热点数据”比较好理解，那就是用户的热点请求对应的数据。而热点数据又分为“静态热点数据”和“动态热点数据”。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>所谓“静态热点数据”，就是能够提前预测的热点数据</strong>。例如，我们可以通过<strong>卖家报名</strong>的方式提前筛选出来，通过报名系统对这些<strong>热点商品进行打标</strong>。另外，我们还可以<strong>通过大数据分析来提前发现热点商品</strong>，比如我们分析历史成交记录、用户的购物车记录，来发现哪些商品可能更热门、更好卖，这些都是可以提前分析出来的热点。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>所谓“动态热点数据”，就是不能被提前预测到的，系统在运行过程中临时产生的热点</strong>。例如，卖家在抖音上做了广告，然后商品一下就火了，导致它在短时间内被大量购买。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>由于热点操作是用户的行为，我们不好改变，但能做一些限制和保护</strong>。</p>
<h3 id="发现热点数据"><a href="#发现热点数据" class="headerlink" title="发现热点数据"></a>发现热点数据</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如何发现这些秒杀商品，或者更准确地说，如何发现热点商品呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能会说“参加秒杀的商品就是秒杀商品啊”，没错，关键是系统怎么知道哪些商品参加了秒杀活动呢？所以，你要有一个机制提前来区分普通商品和秒杀商品。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们从发现静态热点和发现动态热点两个方面来看一下。</p>
<h4 id="发现静态热点数据"><a href="#发现静态热点数据" class="headerlink" title="发现静态热点数据"></a>发现静态热点数据</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>静态热点数据可以通过商业手段</strong>，例如强制让<strong>卖家通过报名参加的方式提前把热点商品筛选出来</strong>，实现方式是通过一个运营系统，把参加活动的商品数据进行打标，然后通过一个后台系统对这些热点商品进行预处理，如提前进行缓存。但是<strong>这种通过报名提前筛选的方式也会带来新的问题，即增加卖家的使用成本，而且实时性较差，也不太灵活</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，除了提前报名筛选这种方式，你还可以<strong>通过技术手段提前预测</strong>，例如<strong>对买家每天访问的商品进行大数据计算，然后统计出 TOP N 的商品，我们可以认为这些 TOP N 的商品就是热点商品</strong>。</p>
<h4 id="发现动态热点数据"><a href="#发现动态热点数据" class="headerlink" title="发现动态热点数据"></a>发现动态热点数据</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以通过卖家报名或者大数据预测这些手段来提前预测静态热点数据，但这<strong>其中有一个痛点，就是实时性较差，如果我们的系统能在秒级内自动发现热点商品那就完美了</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;能够动态地实时发现热点不仅对秒杀商品，对其他热卖商品也同样有价值，所以我们需要想办法实现热点的动态发现功能。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我给出一个动态热点发现系统的具体实现。</p>
<ol>
<li>构建一个异步的系统，它可以<strong>收集交易链路上各个环节中的中间件产品的热点 Key</strong>，如 Nginx、缓存、RPC 服务框架等这些中间件（一些中间件产品本身已经有热点统计模块）。</li>
<li><strong>建立一个热点上报和可以按照需求订阅的热点服务的下发规范</strong>，主要目的是通过交易链路上各个系统（包括详情、购物车、交易、优惠、库存、物流等）访问的时间差，把上游已经发现的热点透传给下游系统，提前做好保护。比如，对于大促高峰期，详情系统是最早知道的，在统一接入层上 Nginx 模块统计的热点 URL。</li>
<li><strong>将上游系统收集的热点数据发送到热点服务台，然后下游系统（如交易系统）就会知道哪些商品会被频繁调用，然后做热点保护</strong>。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里我给出了一个图，其中用户访问商品时经过的路径有很多，我们主要是依赖前面的导购页面（包括首页、搜索页面、商品详情、购物车等）提前识别哪些商品的访问量高，通过这些系统中的中间件来收集热点数据，并记录到日志中。</p>
<p><img src="//blog.com/2019/04/27/如何设计一个秒杀系统/4.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们<strong>通过部署在每台机器上的 Agent 把日志汇总到聚合和分析集群中，然后把符合一定规则的热点数据，通过订阅分发系统再推送到相应的系统中</strong>。你可以是<strong>把热点数据填充到 Cache 中，或者直接推送到应用服务器的内存中，还可以对这些数据进行拦截，总之下游系统可以订阅这些数据，然后根据自己的需求决定如何处理这些数据</strong>。</p>
<p>打造热点发现系统时，我根据以往经验总结了几点注意事项：</p>
<ol>
<li>这个<strong>热点服务后台抓取热点数据日志最好采用异步方式</strong>，因为“异步”一方面便于保证通用性，另一方面又不影响业务系统和中间件产品的主流程。</li>
<li>热点服务发现和中间件自身的热点保护模块并存，每个中间件和应用还需要保护自己。<strong>热点服务台提供热点数据的收集和订阅服务，便于把各个系统的热点数据透明出来</strong>。</li>
<li><strong>热点发现要做到接近实时（3s 内完成热点数据的发现），因为只有做到接近实时，动态发现才有意义，才能实时地对下游系统提供保护</strong>。</li>
</ol>
<h3 id="处理热点数据"><a href="#处理热点数据" class="headerlink" title="处理热点数据"></a>处理热点数据</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>处理热点数据通常有几种思路：一是优化，二是限制，三是隔离</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先来说说优化。<strong>优化热点数据最有效的办法就是缓存热点数据</strong>，如果热点数据做了动静分离，那么可以长期缓存静态数据。但是，缓存热点数据更多的是“临时”缓存，即不管是静态数据还是动态数据，都用一个队列短暂地缓存数秒钟，由于队列长度有限，可以采用 LRU 淘汰算法替换。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再来说说限制。限制更多的是一种保护机制，限制的办法也有很多，例如<strong>对被访问商品的 ID 做一致性 Hash，然后根据 Hash 做分桶，每个分桶设置一个处理队列，这样可以把热点商品限制在一个请求队列里，防止因某些热点商品占用太多的服务器资源，而使其他请求始终得不到服务器的处理资源</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后介绍一下隔离。<strong>秒杀系统设计的第一个原则就是将这种热点数据隔离出来，不要让 1% 的请求影响到另外的 99%，隔离出来后也更方便对这 1% 的请求做针对性的优化</strong>。</p>
<p>具体到“秒杀”业务，我们可以在以下几个层次实现隔离。</p>
<ol>
<li><strong>业务隔离</strong>。把秒杀做成一种营销活动，卖家要参加秒杀这种营销活动需要单独报名，从技术上来说，卖家报名后对我们来说就有了已知热点，因此可以提前做好预热。</li>
<li><strong>系统隔离</strong>。系统隔离更多的是运行时的隔离，可以通过分组部署的方式和另外 99% 分开。秒杀可以申请单独的域名，目的也是让请求落到不同的集群中。</li>
<li><strong>数据隔离</strong>。秒杀所调用的数据大部分都是热点数据，比如会启用单独的 Cache 集群或者 MySQL 数据库来放热点数据，目的也是不想 0.01% 的数据有机会影响 99.99% 数据。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然了，实现隔离有很多种办法。比如：</p>
<ol>
<li>你可以按照用户来区分，给不同的用户分配不同的 Cookie，在接入层，路由到不同的服务接口中；</li>
<li>你还可以在接入层针对 URL 中的不同 Path 来设置限流策略。服务层调用不同的服务接口</li>
<li>数据层通过给数据打标来区分等等这些措施，其目的都是把已经识别出来的热点请求和普通的请求区分开。</li>
</ol>
<blockquote>
<p>  缓存热点数据更多的是“临时”缓存，即不管是静态数据还是动态数据，都用一个队列短暂地缓存数秒钟，由于队列长度有限，可以采用 LRU 淘汰算法替换。</p>
<p>为什么选择用队列来缓存数据呢，队列如何做到快速读取缓存数据的呢？</p>
<p><strong>不一定非要用队列，也可以用其他内存集合如hashmap都行</strong><br>缓存数据，一般静态数据可以提前加载到内存，如通过配置系统推送的方式。动态数据可以在远程调用时零时缓存在本机中。  </p>
</blockquote>
<blockquote>
<p>例如对被访问商品的 ID 做一致性 Hash，然后根据 Hash 做分桶，每个分桶设置一个处理队列，这样可以把热点商品限制在一个请求队列里</p>
<p>分桶设置处理队列是怎么实现的？</p>
<p>例如：<strong>对每个请求的商品id取模</strong>，让后根据取模的结果分别设置多个linkedhashmap，每个map当做一个队列</p>
</blockquote>
<blockquote>
<p>热点发现系统: 中间件nginx cache rpc 为什么不是后台服务的一部分呢 ？ 还是说中间件构成的异步监控系统用来日志记录？</p>
<p>也可以把他当成后台系统的一部分，但是中间件本身就一直存在，并不是因为热点发现系统才加入的。</p>
<p><strong>中间件记录热点大部分是记录到日志里面的</strong>，但也不绝对  </p>
</blockquote>
<blockquote>
<p>怎么判断数据是不是热点呢？</p>
<p><strong>热点的统计可以很简单的对访问的商品进行访问计数，然后排序</strong><br>还有就是用通常的队列的淘汰算法如lru等都可以实现</p>
</blockquote>
<blockquote>
<p>缓存数据，LRU淘汰算法，那么缓存的这些数据会不会频繁的移动、删除，并发比较大的时候会不会成为性能的瓶颈？</p>
<p>对秒杀这个场景，商品基本是固定的，基本都会一直在内存中</p>
</blockquote>
<blockquote>
<p>数据层给数据打标怎么做和具体应用?</p>
<p><strong>数据打标的方式有很多，例如给数据库表的一个字段标识一下这个商品是否是热点数据</strong></p>
</blockquote>
<blockquote>
<p>动态发现的热点数据如何隔离？</p>
<p><strong>动态发现的热点更多的是实现保护，例如加入cache，或者放到队列中</strong></p>
<p><strong>隔离理论上也是可以做的，例如把热点数据从普通的数据库自动的迁移到热点数据库中</strong> </p>
</blockquote>
<h2 id="流量削峰这事应该怎么做？"><a href="#流量削峰这事应该怎么做？" class="headerlink" title="流量削峰这事应该怎么做？"></a>流量削峰这事应该怎么做？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从业务上来说，秒杀活动是希望更多的人来参与的，也就是开始之前希望有更多的人来刷页面，但是<strong>真正开始下单时，秒杀请求并不是越多越好</strong>。因此我们可以设计一些规则，让并发的请求更多地延缓，而且我们甚至可以过滤掉一些无效请求。</p>
<h3 id="为什么要削峰"><a href="#为什么要削峰" class="headerlink" title="为什么要削峰"></a>为什么要削峰</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么要削峰呢？或者说峰值会带来哪些坏处？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们知道服务器的处理资源是恒定的，你用或者不用它的处理能力都是一样的，所以出现峰值的话，很容易导致忙到处理不过来，闲的时候却又没有什么要处理。但是<strong>由于要保证服务质量，我们的很多处理资源只能按照忙的时候来预估，而这会导致资源的一个浪费</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就好比因为存在早高峰和晚高峰的问题，所以有了错峰限行的解决方案。<strong>削峰的存在，一是可以让服务端处理变得更加平稳，二是可以节省服务器的资源成本</strong>。<strong>针对秒杀这一场景，削峰从本质上来说就是更多地延缓用户请求的发出，以便减少和过滤掉一些无效请求，它遵从“请求数要尽量少”的原则</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;介绍一下流量削峰的一些操作思路：排队、答题、分层过滤。这几种方式都是无损（即不会损失用户的发出请求）的实现方案，当然还有些有损的实现方案，包括我们后面要介绍的关于稳定性的一些办法，比如限流和机器负载保护等一些强制措施也能达到削峰保护的目的，当然这都是不得已的一些措施，因此就不归类到这里了。</p>
<h3 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要对流量进行削峰，最容易想到的解决方案就是<strong>用消息队列来缓冲瞬时流量，把同步的直接调用转换成异步的间接推送，中间通过一个队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去</strong>。在这里，消息队列就像“水库”一样，    拦蓄上游的洪水，削减进入下游河道的洪峰流量，从而达到减免洪水灾害的目的。</p>
<p>前提：<strong>消费者处理特别快，不然用户体验会特别不好，很长时间才能够看见订单</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用消息队列来缓冲瞬时流量的方案，如下图所示：</p>
<p><img src="//blog.com/2019/04/27/如何设计一个秒杀系统/5.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是，如果流量峰值持续一段时间达到了消息队列的处理上限，例如本机的消息积压达到了存储空间的上限，消息队列同样也会被压垮，这样虽然保护了下游的系统，但是和直接把请求丢弃也没多大的区别。就像遇到洪水爆发时，即使是有水库恐怕也无济于事。</p>
<p>除了消息队列，类似的排队方式还有很多，例如：</p>
<ol>
<li>利用线程池加锁等待也是一种常用的排队方式；</li>
<li>先进先出、先进后出等常用的内存排队算法的实现方式；</li>
<li>把请求序列化到文件中，然后再顺序地读文件（例如基于 MySQL binlog 的同步机制）来恢复请求等方式。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，<strong>这些方式都有一个共同特征，就是把“一步的操作”变成“两步的操作”，其中增加的一步操作用来起到缓冲的作用</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说到这里你可能会说，这样一来增加了访问请求的路径啊，并不符合我们介绍的“4 要 1 不要”原则。没错，的确看起来不太合理，但是如果不增加一个缓冲步骤，那么在一些场景下系统很可能会直接崩溃，所以最终还是需要你做出妥协和平衡。</p>
<h3 id="答题"><a href="#答题" class="headerlink" title="答题"></a>答题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你是否还记得，最早期的秒杀只是纯粹地刷新页面和点击购买按钮，它是后来才增加了答题功能的。那么，为什么要增加答题功能呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这主要是为了增加购买的复杂度，从而达到两个目的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>第一个目的是防止部分买家使用秒杀器在参加秒杀时作弊</strong>。2011 年秒杀非常火的时候，秒杀器也比较猖獗，因而没有达到全民参与和营销的目的，所以系统增加了答题来限制秒杀器。增加答题后，下单的时间基本控制在 2s 后，秒杀器的下单比例也大大下降。答题页面如下图所示。</p>
<p><img src="//blog.com/2019/04/27/如何设计一个秒杀系统/6.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>第二个目的其实就是延缓请求，起到对请求流量进行削峰的作用，从而让系统能够更好地支持瞬时的流量高峰</strong>。这个重要的功能就是把峰值的下单请求拉长，从以前的 1s 之内延长到 2s~10s。这样一来，请求峰值基于时间分片了。这个时间的分片对服务端处理并发非常重要，会大大减轻压力。而且，由于请求具有先后顺序，靠后的请求到来时自然也就没有库存了，因此根本到不了最后的下单步骤，所以真正的并发写就非常有限了。这种设计思路目前用得非常普遍，如当年支付宝的“咻一咻”、微信的“摇一摇”都是类似的方式。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里，我重点说一下秒杀答题的设计思路。</p>
<p><img src="//blog.com/2019/04/27/如何设计一个秒杀系统/7.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上图所示，整个秒杀答题的逻辑主要分为 3 部分。</p>
<ol>
<li><strong>题库生成模块</strong>，这个部分主要就是生成一个个问题和答案，其实题目和答案本身并不需要很复杂，重要的是能够防止由机器来算出结果，即防止秒杀器来答题。</li>
<li><strong>题库的推送模块</strong>，用于在秒杀答题前，把题目提前推送给详情系统和交易系统。题库的推送主要是为了保证每次用户请求的题目是唯一的，目的也是防止答题作弊。</li>
<li><strong>题目的图片生成模块</strong>，用于把题目生成为图片格式，并且在图片里增加一些干扰因素。这也同样是为防止机器直接来答题，它要求只有人才能理解题目本身的含义。这里还要注意一点，由于答题时网络比较拥挤，我们应该把题目的图片提前推送到 CDN 上并且要进行预热，不然的话当用户真正请求题目时，图片可能加载比较慢，从而影响答题的体验。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实真正答题的逻辑比较简单，很好理解：当用户提交的答案和题目对应的答案做比较，如果通过了就继续进行下一步的下单逻辑，否则就失败。我们可以把问题和答案用下面这样的 key 来进行 MD5 加密：</p>
<ul>
<li>问题 key：userId+itemId+question_Id+time+PK</li>
<li>答案 key：userId+itemId+answer+PK</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;验证的逻辑如下图所示：</p>
<p><img src="//blog.com/2019/04/27/如何设计一个秒杀系统/8.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意，这里面的验证逻辑，<strong>除了验证问题的答案以外，还包括用户本身身份的验证，例如是否已经登录、用户的 Cookie 是否完整、用户是否重复频繁提交等</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>除了做正确性验证，我们还可以对提交答案的时间做些限制</strong>，例如从开始答题到接受答案要超过 1s，因为小于 1s 是人为操作的可能性很小，这样也能防止机器答题的情况。</p>
<h3 id="分层过滤"><a href="#分层过滤" class="headerlink" title="分层过滤"></a>分层过滤</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面介绍的排队和答题要么是少发请求，要么对发出来的请求进行缓冲，而针对秒杀场景还有一种方法，就是对请求进行分层过滤，从而过滤掉一些无效的请求。分层过滤其实就是采用“漏斗”式设计来处理请求的，如下图所示。</p>
<p><img src="https://static001.geekbang.org/resource/image/4a/09/4a5b7e080e7d357986f02ed1fd8b7309.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如请求分别经过 CDN、前台读系统（如商品详情系统）、后台系统（如交易系统）和数据库这几层，那么：</p>
<ul>
<li>大部分数据和流量在用户浏览器或者 CDN 上获取，这一层可以拦截大部分数据的读取；</li>
<li>经过第二层（即前台系统）时数据（包括强一致性的数据）尽量得走 Cache，过滤一些无效的请求；</li>
<li>再到第三层后台系统，主要做数据的二次检验，对系统做好保护和限流，这样数据量和请求就进一步减少；</li>
<li>最后在数据层完成数据的强一致性校验。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样就像漏斗一样，尽量把数据量和请求量一层一层地过滤和减少了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>分层过滤的核心思想是：在不同的层次尽可能地过滤掉无效请求，让“漏斗”最末端的才是有效请求</strong>。而要达到这种效果，我们就必须对数据做分层的校验。</p>
<p>分层校验的基本原则是：</p>
<ol>
<li><p><strong>将动态请求的读数据缓存（Cache）在 Web 端，过滤掉无效的数据读</strong>；</p>
</li>
<li><p><strong>对读数据不做强一致性校验，减少因为一致性校验产生瓶颈的问题</strong>；</p>
</li>
<li><p><strong>对写数据进行基于时间的合理分片，过滤掉过期的失效请求</strong>；</p>
</li>
<li><p><strong>对写请求做限流保护，将超出系统承载能力的请求过滤掉</strong>；       </p>
<p>【业务限制：最多买n次、n台，ip每秒请求次数限制等】</p>
</li>
<li><p><strong>对写数据进行强一致性校验，只保留最后有效的数据</strong>。</p>
</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>分层校验的目的是：在读系统中，尽量减少由于一致性校验带来的系统瓶颈，但是尽量将不影响性能的检查条件提前，如用户是否具有秒杀资格、商品状态是否正常、用户答题是否正确、秒杀是否已经结束、是否非法请求、营销等价物是否充足等；在写数据系统中，主要对写的数据（如“库存”）做一致性检查，最后在数据库层保证数据的最终准确性（如“库存”不能减为负数）</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>队列缓冲方式更加通用，它适用于内部上下游系统之间调用请求不平缓的场景</strong>，由于内部系统的服务质量要求不能随意丢弃请求，所以使用消息队列能起到很好的削峰和缓冲作用。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>答题更适用于秒杀或者营销活动等应用场景，在请求发起端就控制发起请求的速度，因为越到后面无效请求也会越多，所以配合后面介绍的分层拦截的方式，可以更进一步减少无效请求对系统资源的消耗</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>分层过滤非常适合交易性的写请求</strong>，比如减库存或者拼车这种场景，在读的时候需要知道还有没有库存或者是否还有剩余空座位。但是由于库存和座位又是不停变化的，所以读的数据是否一定要非常准确呢？其实不一定，你可以放一些请求过去，然后在真正减的时候再做强一致性保证，这样既过滤一些请求又解决了强一致性读的瓶颈。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过，在削峰的处理方式上除了采用技术手段，其实还<strong>可以采用业务手段来达到一定效果，例如在零点开启大促的时候由于流量太大导致支付系统阻塞，这个时候可以采用发放优惠券、发起抽奖活动等方式，将一部分流量分散到其他地方，这样也能起到缓冲流量的作用。</strong></p>
<blockquote>
<p>用消息队列实现的话，处理结果无法立即知晓，用户体验不真实，有没有更实时的方案？</p>
<p>大前提是<strong>消息队列的消费速度特别快并且消息不会出现丢失，由消息队列保证最后最终被投递</strong>。</p>
<ol>
<li><p>先校验库存是否还有剩余，如果库存为0了，就直接提示秒杀失败。</p>
<p>【这里的库存校验采用分布式锁的方式进行，可采用redis+lua script来实现】</p>
</li>
<li><p>库存校验通过的请求，将uid、pid放入消息队列，后台程序异步进行消费，这里直接提示用户秒杀成功。【消息不会出现丢失这是为保证订单一定会创建成功，所以必须要订单创建成功以后，才将消息从队列中删除】</p>
<p>【消费速度特别快，因为秒杀的场景就是一旦用户秒杀成功，大部分立马就会去支付，所以要求我们生成订单的速度就要特别快】</p>
</li>
<li><p>后台程序异步进行消费，先过来先处理，保证每一个用户等待的时间最短。</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>消息队列这个方式也,如果我们进入消息队列的话,想要用户实时知道抢购结果,是不是需要像小米的抢购那种,直接把页面设置成抢购中,然后再回来通知…<br>这个通知是否需要 websocket 长链接,又或者其他实现?</p>
<p>用消息队列处理秒杀请求，然后长连接异步推送处理结果出来了也是一种实现方式，这是一种异步处理方式，<strong>优点是简化了服务端的复杂度，缺点是，用户体验偏差</strong></p>
</blockquote>
<h2 id="秒杀系统“减库存”设计的核心逻辑"><a href="#秒杀系统“减库存”设计的核心逻辑" class="headerlink" title="秒杀系统“减库存”设计的核心逻辑"></a>秒杀系统“减库存”设计的核心逻辑</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要设计一套秒杀系统，那我想你的老板肯定会先对你说：千万不要超卖，这是大前提。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你第一次接触秒杀，那你可能还不太理解，库存 100 件就卖 100 件，在数据库里减到 0 就好了啊，这有什么麻烦的？是的，理论上是这样，但是具体到业务场景中，“减库存”就不是这么简单了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，我们平常购物都是这样，看到喜欢的商品然后下单，但并不是每个下单请求你都最后付款了。你说系统是用户下单了就算这个商品卖出去了，还是等到用户真正付款了才算卖出了呢？这的确是个问题！</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以先根据减库存是发生在下单阶段还是付款阶段，把减库存做一下划分。</p>
<h3 id="减库存有哪几种方式"><a href="#减库存有哪几种方式" class="headerlink" title="减库存有哪几种方式"></a>减库存有哪几种方式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在正常的电商平台购物场景中，用户的实际购买过程一般分为两步：下单和付款。你想买一台 iPhone 手机，在商品页面点了“立即购买”按钮，核对信息之后点击“提交订单”，这一步称为下单操作。下单之后，你只有真正完成付款操作才能算真正购买，也就是俗话说的“落袋为安”。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那如果你是架构师，你会在哪个环节完成减库存的操作呢？总结来说，减库存操作一般有如下几个方式：</p>
<ul>
<li><strong>下单减库存</strong>，即当买家下单后，在商品的总库存中减去买家购买数量。下单减库存是最简单的减库存方式，也是控制最精确的一种，下单时直接通过数据库的事务机制控制商品库存，这样一定不会出现超卖的情况。但是你要知道，有些人下完单可能并不会付款。</li>
<li><strong>付款减库存</strong>，即买家下单后，并不立即减库存，而是等到有用户付款后才真正减库存，否则库存一直保留给其他买家。但因为付款时才减库存，如果并发比较高，有可能出现买家下单后付不了款的情况，因为可能商品已经被其他人买走了。</li>
<li><strong>预扣库存</strong>，这种方式相对复杂一些，买家下单后，库存为其保留一定的时间（如 10 分钟），超过这个时间，库存将会自动释放，释放后其他买家就可以继续购买。在买家付款前，系统会校验该订单的库存是否还有保留：如果没有保留，则再次尝试预扣；如果库存不足（也就是预扣失败）则不允许继续付款；如果预扣成功，则完成付款并实际地减去库存。</li>
</ul>
<p>以上这几种减库存的方式都会存在一些问题，下面我们一起来看下。</p>
<h3 id="减库存可能存在的问题"><a href="#减库存可能存在的问题" class="headerlink" title="减库存可能存在的问题"></a>减库存可能存在的问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于购物过程中存在两步或者多步的操作，因此在不同的操作步骤中减库存，就会存在一些可能被恶意买家利用的漏洞，例如发生恶意下单的情况。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如我们采用“下单减库存”的方式，即用户下单后就减去库存，正常情况下，买家下单后付款的概率会很高，所以不会有太大问题。但是有一种场景例外，就是<strong>当卖家参加某个活动时，此时活动的有效时间是商品的黄金售卖时间，如果有竞争对手通过恶意下单的方式将该卖家的商品全部下单，让这款商品的库存减为零，那么这款商品就不能正常售卖了</strong>。要知道，这些恶意下单的人是不会真正付款的，这正是“下单减库存”方式的不足之处。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然“下单减库存”可能导致恶意下单，从而影响卖家的商品销售，那么有没有办法解决呢？你可能会想，采用“付款减库存”的方式是不是就可以了？的确可以。但是，“付款减库存”又会导致另外一个问题：库存超卖。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如有 100 件商品，就可能出现 300 人下单成功的情况，因为<strong>下单时不会减库存</strong>，所以也就可能出现下单成功数远远超过真正库存数的情况，这尤其会发生在做活动的热门商品上。这样一来，就会<strong>导致很多买家下单成功但是付不了款，买家的购物体验自然比较差</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看到，不管是“下单减库存”还是“付款减库存”，都会导致商品库存不能完全和实际售卖情况对应起来的情况，看来要把商品准确地卖出去还真是不容易啊！</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，既然“下单减库存”和“付款减库存”都有缺点，我们能否把两者相结合，将两次操作进行前后关联起来，<strong>下单时先预扣，在规定时间内不付款再释放库存</strong>，即采用“预扣库存”这种方式呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方案确实可以在一定程度上缓解上面的问题。但是否就彻底解决了呢？其实没有！<strong>针对恶意下单这种情况，虽然把有效的付款时间设置为 10 分钟，但是恶意买家完全可以在 10 分钟后再次下单，或者采用一次下单很多件的方式把库存减完</strong>。<strong>针对这种情况，解决办法还是要结合安全和反作弊的措施来制止</strong>。例如：</p>
<ol>
<li><strong>给经常下单不付款的买家进行识别打标</strong>（可以在被打标的买家下单时不减库存）</li>
<li><strong>给某些类目设置最大购买件数</strong>（例如，参加活动的商品一人最多只能买 3 件）</li>
<li><strong>对重复下单不付款的操作进行次数限制</strong></li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;针对“库存超卖”这种情况，在 10 分钟时间内下单的数量仍然有可能超过库存数量，遇到这种情况我们只能区别对待：对普通的商品下单数量超过库存数量的情况，可以通过补货来解决；但是有些卖家完全不允许库存为负数的情况，那只能在买家付款时提示库存不足。</p>
<h3 id="大型秒杀中如何减库存？"><a href="#大型秒杀中如何减库存？" class="headerlink" title="大型秒杀中如何减库存？"></a>大型秒杀中如何减库存？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前来看，<strong>业务系统中最常见的就是预扣库存方案</strong>，像你在买机票、买电影票时，<strong>下单后一般都有个“有效付款时间”，超过这个时间订单自动释放，这都是典型的预扣库存方案</strong>。而具体到秒杀这个场景，应该采用哪种方案比较好呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于参加秒杀的商品，一般都是“抢到就是赚到”，所以成功下单后却不付款的情况比较少，再加上卖家对秒杀商品的库存有严格限制，所以秒杀商品采用“下单减库存”更加合理。另外，理论上由于“下单减库存”比“预扣库存”以及涉及第三方支付的“付款减库存”在逻辑上更为简单，所以性能上更占优势。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“下单减库存”在数据一致性上，<strong>主要就是保证大并发请求时库存数据不能为负数，也就是要保证数据库中的库存字段值不能为负数</strong>，一般我们有多种解决方案：</p>
<ol>
<li>在应用程序中通过事务来判断，即保证减后库存不能为负数，否则就回滚；</li>
<li>直接设置数据库的字段数据为无符号整数，这样减后库存字段值小于零时会直接执行 SQL 语句来报错；</li>
<li>使用 CASE WHEN 判断语句，例如这样的 SQL 语句：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE item SET inventory = CASE WHEN inventory &gt;= xxx THEN inventory-xxx ELSE inventory END</span><br></pre></td></tr></table></figure>
<h3 id="秒杀减库存的极致优化"><a href="#秒杀减库存的极致优化" class="headerlink" title="秒杀减库存的极致优化"></a>秒杀减库存的极致优化</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在交易环节中，“库存”是个关键数据，也是个热点数据，因为交易的各个环节中都可能涉及对库存的查询。但是，我在前面介绍分层过滤时提到过，秒杀中并不需要对库存有精确的一致性读，<strong>把库存数据放到缓存（Cache）中，可以大大提升读性能</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决大并发读问题，可以采用 LocalCache（即在秒杀系统的单机上缓存商品相关的数据）和对数据进行分层过滤的方式，但是<strong>像减库存这种大并发写无论如何还是避免不了，这也是秒杀场景下最为核心的一个技术难题</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>因此，这里我想专门来说一下秒杀场景下减库存的极致优化思路，包括如何在缓存中减库存以及如何在数据库中减库存</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;秒杀商品和普通商品的减库存还是有些差异的，例如商品数量比较少，交易时间段也比较短，因此<strong>这里有一个大胆的假设，即能否把秒杀商品减库存直接放到缓存系统中实现，也就是直接在缓存中减库存或者在一个带有持久化功能的缓存系统（如 Redis）中完成呢</strong>？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>如果你的秒杀商品的减库存逻辑非常单一，比如没有复杂的 SKU 库存和总库存这种联动关系的话，我觉得完全可以</strong>（可以利用redis+lua script来判断库存是否还有剩余，如果有，将库存扣减、订单创建异步处理）。但是如果有比较复杂的减库存逻辑，或者需要使用事务，你还是必须在数据库中完成减库存。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于 MySQL 存储数据的特点，同一数据在数据库里肯定是一行存储（MySQL），因此会有大量线程来竞争 InnoDB 行锁，而并发度越高时等待线程会越多，TPS（Transaction Per Second，即每秒处理的消息数）会下降，响应时间（RT）会上升，数据库的吞吐量就会严重受影响。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就可能引发一个问题，就是单个热点商品会影响整个数据库的性能， 导致 0.01% 的商品影响 99.99% 的商品的售卖，这是我们不愿意看到的情况。一个解决思路是遵循前面介绍的原则进行隔离，<strong>把热点商品放到单独的热点库中</strong>。但是这无疑会带来维护上的麻烦，比如要做热点数据的动态迁移以及单独的数据库等。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>这两种做法我没有理解</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而分离热点商品到单独的数据库还是没有解决并发锁的问题，我们应该怎么办呢？要解决并发锁的问题，有两种办法：</p>
<ul>
<li><strong>应用层做排队</strong>。按照商品维度设置队列顺序执行，这样能减少同一台机器对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量，防止热点商品占用太多的数据库连接。</li>
<li><strong>数据库层做排队</strong>。应用层只能做到单机的排队，但是应用机器数本身很多，这种排队方式控制并发的能力仍然有限，所以如果能在数据库层做全局排队是最理想的。阿里的数据库团队开发了针对这种 MySQL 的 InnoDB 层上的补丁程序（patch），可以在数据库层上对单行记录做到并发排队。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能有疑问了，排队和锁竞争不都是要等待吗，有啥区别？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果熟悉 MySQL 的话，你会知道 InnoDB 内部的死锁检测，以及 MySQL Server 和 InnoDB 的切换会比较消耗性能，淘宝的 MySQL 核心团队还做了很多其他方面的优化，如 COMMIT_ON_SUCCESS 和 ROLLBACK_ON_FAIL 的补丁程序，配合在 SQL 里面加提示（hint），在事务里不需要等待应用层提交（COMMIT），而在数据执行完最后一条 SQL 后，直接根据 TARGET_AFFECT_ROW 的结果进行提交或回滚，可以减少网络等待时间（平均约 0.7ms）。据我所知，目前阿里 MySQL 团队已经将包含这些补丁程序的 MySQL 开源。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，数据更新问题除了前面介绍的热点隔离和排队处理之外，还有些场景（如对商品的 lastmodifytime 字段的）更新会非常频繁，在某些场景下这些多条 SQL 是可以合并的，一定时间内只要执行最后一条 SQL 就行了，以便减少对数据库的更新操作。</p>
<blockquote>
<p>下单和扣库存两个操作的事务性是怎么做的？</p>
<p>可以分两步来做，先创建订单但是先不生效，然后减库存，如果减库存成功后再生效订单，否则订单不生效</p>
</blockquote>
<blockquote>
<p><strong>一个有趣的做法</strong></p>
<p>针对确定库存，提前下好单，下单人留空，订单短时间内失效<br>订单id压入Redis队列，<br>请求来到，订单队列lpop，队空则返回失败，<br><strong>pop出来的订单补充下单人为当前用户，<br>如果订单过期失效则再次下同一商品的空单存入队列</strong></p>
<p>这个设计可以考虑单个Redis不够用的时候将队列分组，利用轮转或时间戳hash将请求分配到不同队列，</p>
<p>想问下老师，这个和扣数字库存相比，会不会有更好的并发性能呢？</p>
<p>说实话，没看出来哪里性能会更好😄<br>不过提前下单的思路还比较新颖，你的思路我理解，但是这样就把一个事情分两次来做，会增加了复杂度，有可能导致得不偿失</p>
</blockquote>
<blockquote>
<p>这种无只能在串行隔离级别才能用吧，不然肯定超售。。。UPDATE item SET inventory = CASE WHEN inventory &gt;= xxx THEN inventory-xxx ELSE inventory END</p>
<p>数据库层不都是串行操作吗😊</p>
<p><strong>消息队列消费，保证串行</strong></p>
</blockquote>
<blockquote>
<p>预扣库存方案中如何确保十分钟后库存自动解冻？定时任务还是会有延迟吧？</p>
<ol>
<li><strong>定时任务</strong>扫描  <strong>不推荐，增加了数据库压力</strong></li>
<li><strong>redis zset</strong>  【 item为订单id score为失效时间  一个后台进程，根据score来倒排，取出top n的订单依次判断是否到达过期时间，到达订单置为无效，库存+1，未到达，扔回zset】</li>
<li><strong>redis key过期通知</strong>  key:订单id  ttl:超时时间     <strong>缺点：一旦通知订阅出现问题，就无法复现了</strong>，可以和定时任务结合使用</li>
<li>类似于kafka的<strong>层级时间轮</strong></li>
<li><strong>RabbitMQ 延时消息队列</strong></li>
</ol>
</blockquote>
<blockquote>
<p>“按照商品维度设置队列顺序执行”这句话是什么意思？可以举例说明一下吗？谢谢老师</p>
<p><strong>“按照商品维度设置队列顺序执行”的意思就是，为了防止同一个商品对数据库的操作占用太多的数据库资源，所以采用队列的方式，让其他商品也有公平的机会得到数据的响应</strong>，例如如果秒杀的时候，秒杀商品肯定占用大量的请求，数据库的连接池有可能都被秒杀商品占用了，如果不做队列的话，那么其他商品就得不到数据库执行机会了。加入我们分10个队列，那么秒杀商品就会落在这10个队列中的一个，那么最多也就占用机器10分之一的资源。</p>
</blockquote>
<h2 id="Plan-B-方案"><a href="#Plan-B-方案" class="headerlink" title="Plan B 方案"></a>Plan B 方案</h2><h3 id="高可用建设应该从哪里着手"><a href="#高可用建设应该从哪里着手" class="headerlink" title="高可用建设应该从哪里着手"></a>高可用建设应该从哪里着手</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;说到系统的高可用建设，它其实是一个系统工程，需要考虑到系统建设的各个阶段，也就是说它其实贯穿了系统建设的整个生命周期，如下图所示：</p>
<p><img src="//blog.com/2019/04/27/如何设计一个秒杀系统/10.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具体来说，系统的高可用建设涉及架构阶段、编码阶段、测试阶段、发布阶段、运行阶段，以及故障发生时。接下来，我们分别看一下。</p>
<ol>
<li><strong>架构阶段</strong>：架构阶段主要考虑系统的可扩展性和容错性，要避免系统出现单点问题。例如多机房单元化部署，即使某个城市的某个机房出现整体故障，仍然不会影响整体网站的运转。</li>
<li><strong>编码阶段</strong>：编码最重要的是保证代码的健壮性，例如涉及远程调用问题时，要设置合理的超时退出机制，防止被其他系统拖垮，也要对调用的返回结果集有预期，防止返回的结果超出程序处理范围，最常见的做法就是对错误异常进行捕获，对无法预料的错误要有默认处理结果。</li>
<li><strong>测试阶段</strong>：测试主要是保证测试用例的覆盖度，保证最坏情况发生时，我们也有相应的处理流程。</li>
<li><strong>发布阶段</strong>：发布时也有一些地方需要注意，因为发布时最容易出现错误，因此要有紧急的回滚机制。</li>
<li><strong>运行阶段</strong>：运行时是系统的常态，系统大部分时间都会处于运行态，运行态最重要的是对系统的监控要准确及时，发现问题能够准确报警并且报警数据要准确详细，以便于排查问题。</li>
<li><strong>故障发生</strong>：故障发生时首先最重要的就是及时止损，例如由于程序问题导致商品价格错误，那就要及时下架商品或者关闭购买链接，防止造成重大资产损失。然后就是要能够及时恢复服务，并定位原因解决问题。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么系统的高可用建设要放到整个生命周期中全面考虑？因为我们在每个环节中都可能犯错，而有些环节犯的错，你在后面是无法弥补的。例如在架构阶段，你没有消除单点问题，那么系统上线后，遇到突发流量把单点给挂了，你就只能干瞪眼，有时候想加机器都加不进去。所以高可用建设是一个系统工程，必须在每个环节都做好。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么针对秒杀系统，我们重点介绍在遇到大流量时，应该从哪些方面来保障系统的稳定运行，所以更多的是看如何针对运行阶段进行处理，这就引出了接下来的内容：降级、限流和拒绝服务。</p>
<h3 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>所谓“降级”，就是当系统的容量达到一定程度时，限制或者关闭系统的某些非核心功能，从而把有限的资源保留给更核心的业务</strong>。<strong>它是一个有目的、有计划的执行过程，所以对降级我们一般需要有一套预案来配合执行。如果我们把它系统化，就可以通过预案系统和开关系统来实现降级</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;降级方案可以这样设计：当秒杀流量达到 5w/s 时，把成交记录的获取从展示 20 条降级到只展示 5 条。“从 20 改到 5”这个操作由一个开关来实现，也就是<strong>设置一个能够从开关系统动态获取的系统参数</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里，我给出开关系统的示意图。它分为两部分，一部分是开关控制台，它保存了开关的具体配置信息，以及具体执行开关所对应的机器列表；另一部分是执行下发开关数据的 Agent，主要任务就是保证开关被正确执行，即使系统重启后也会生效。</p>
<p><img src="//blog.com/2019/04/27/如何设计一个秒杀系统/11.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行降级无疑是在系统性能和用户体验之间选择了前者，降级后肯定会影响一部分用户的体验，例如在双 11 零点时，如果优惠券系统扛不住，可能会临时降级商品详情的优惠信息展示，把有限的系统资源用在保障交易系统正确展示优惠信息上，即保障用户真正下单时的价格是正确的。所以<strong>降级的核心目标是牺牲次要的功能和用户体验来保证核心业务流程的稳定，是一个不得已而为之的举措</strong>。</p>
<h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果说降级是牺牲了一部分次要的功能和用户的体验效果，那么限流就是更极端的一种保护措施了。<strong>限流就是当系统容量达到瓶颈时，我们需要通过限制一部分流量来保护系统，并做到既可以人工执行开关，也支持自动化保护的措施</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里，我同样给出了限流系统的示意图。总体来说，限流既可以是在客户端限流，也可以是在服务端限流。此外，限流的实现方式既要支持 URL 以及方法级别的限流，也要支持基于 QPS 和线程的限流。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，我以内部的系统调用为例，来分别说下客户端限流和服务端限流的优缺点。</p>
<ul>
<li><strong>客户端限流</strong>，好处可以限制请求的发出，通过减少发出无用请求从而减少对系统的消耗。缺点就是<strong>当客户端比较分散时，没法设置合理的限流阈值</strong>：如果阈值设的太小，会导致服务端没有达到瓶颈时客户端已经被限制；而如果设的太大，则起不到限制的作用。</li>
<li><strong>服务端限流</strong>，好处是可以根据服务端的性能设置合理的阈值，而<strong>缺点就是被限制的请求都是无效的请求，处理这些无效的请求本身也会消耗服务器资源</strong>。</li>
</ul>
<p><img src="//blog.com/2019/04/27/如何设计一个秒杀系统/12.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在限流的实现手段上来讲，基于 QPS 和线程数的限流应用最多，最大 QPS 很容易通过压测提前获取，例如我们的系统最高支持 1w QPS 时，可以设置 8000 来进行限流保护。线程数限流在客户端比较有效，例如在远程调用时我们设置连接池的线程数，超出这个并发线程请求，就将线程进行排队或者直接超时丢弃。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>限流无疑会影响用户的正常请求，所以必然会导致一部分用户请求失败，因此在系统处理这种异常时一定要设置超时时间，防止因被限流的请求不能 fast fail（快速失败）而拖垮系统</strong>。</p>
<h3 id="拒绝服务"><a href="#拒绝服务" class="headerlink" title="拒绝服务"></a>拒绝服务</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果限流还不能解决问题，最后一招就是直接拒绝服务了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>当系统负载达到一定阈值时，例如 CPU 使用率达到 90% 或者系统 load 值达到 2*CPU 核数时，系统直接拒绝所有请求，这种方式是最暴力但也最有效的系统保护方式</strong>。例如秒杀系统，我们在如下几个环节设计过载保护：</p>
<blockquote>
<p>在最前端的 Nginx 上设置过载保护，当机器负载达到某个值时直接拒绝 HTTP 请求并返回 503 错误码，在 Java 层同样也可以设计过载保护。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>拒绝服务可以说是一种不得已的兜底方案，用以防止最坏情况发生，防止因把服务器压跨而长时间彻底无法提供服务</strong>。像这种系统过载保护虽然在过载时无法提供服务，但是系统仍然可以运作，当负载下降时又很容易恢复，所以每个系统和每个环节都应该设置这个兜底方案，对系统做最坏情况下的保护。</p>
<blockquote>
<p>网站的高可用建设是基础，可以说要深入到各个环节，更要长期规划并进行体系化建设，要在<strong>预防（建立常态的压力体系，例如上线前的单机压测到上线后的全链路压测）、管控（做好线上运行时的降级、限流和兜底保护）、监控（建立性能基线来记录性能的变化趋势以及线上机器的负载报警体系，发现问题及时预警）和恢复体系（遇到故障要及时止损，并提供快速的数据订正工具等）</strong>等这些地方加强建设，每一个环节可能都有很多事情要做。</p>
<p>另外，要保证高可用建设的落实，你不仅要做系统建设，还要在组织上做好保障。高可用其实就是在说“稳定性”。稳定性是一个平时不重要，但真出了问题就会要命的事儿，所以很可能平时业务发展良好，稳定性建设就会给业务让路，相关的稳定性负责人员平时根本得不到重视，一旦遇到故障却又成了“背锅侠”。</p>
<p>而要防止出现这种情况，就必须在组织上有所保障，例如可以让业务负责人背上稳定性 KPI 考核指标，然后在技术部门中建立稳定性建设小组，小组成员由每个业务线的核心力量兼任，他们的 KPI 由稳定性负责人来打分，这样稳定性小组就可以把一些体系化的建设任务落实到具体的业务系统中了。</p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/架构/" rel="tag"># 架构</a>
          
            <a href="/tags/秒杀/" rel="tag"># 秒杀</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/27/error_page与return/" rel="next" title="error_page与return">
                <i class="fa fa-chevron-left"></i> error_page与return
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/27/命令行通配符教程/" rel="prev" title="命令行通配符教程">
                命令行通配符教程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#如何设计一个秒杀系统"><span class="nav-number">1.</span> <span class="nav-text">如何设计一个秒杀系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#秒杀系统"><span class="nav-number">1.1.</span> <span class="nav-text">秒杀系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#架构原则"><span class="nav-number">1.2.</span> <span class="nav-text">架构原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据要尽量少"><span class="nav-number">1.2.1.</span> <span class="nav-text">数据要尽量少</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#请求数要尽量少"><span class="nav-number">1.2.2.</span> <span class="nav-text">请求数要尽量少</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路径要尽量短"><span class="nav-number">1.2.3.</span> <span class="nav-text">路径要尽量短</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#依赖要尽量少"><span class="nav-number">1.2.4.</span> <span class="nav-text">依赖要尽量少</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不要有单点"><span class="nav-number">1.2.5.</span> <span class="nav-text">不要有单点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不同场景下的不同架构案例"><span class="nav-number">1.3.</span> <span class="nav-text">不同场景下的不同架构案例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何做秒杀时间控制"><span class="nav-number">1.4.</span> <span class="nav-text">如何做秒杀时间控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何才能做好动静分离？有哪些方案可选？"><span class="nav-number">1.5.</span> <span class="nav-text">如何才能做好动静分离？有哪些方案可选？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#何为动静数据"><span class="nav-number">1.5.1.</span> <span class="nav-text">何为动静数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何做动静分离的改造"><span class="nav-number">1.5.2.</span> <span class="nav-text">如何做动静分离的改造</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动静分离的几种架构方案"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">动静分离的几种架构方案</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#方案-1：实体机单机部署"><span class="nav-number">1.5.2.1.1.</span> <span class="nav-text">方案 1：实体机单机部署</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方案-2：统一-Cache-层"><span class="nav-number">1.5.2.1.2.</span> <span class="nav-text">方案 2：统一 Cache 层</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方案-3：上-CDN"><span class="nav-number">1.5.2.1.3.</span> <span class="nav-text">方案 3：上 CDN</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#存储在浏览器或-CDN-上，有多大区别？"><span class="nav-number">1.5.2.1.4.</span> <span class="nav-text">存储在浏览器或 CDN 上，有多大区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#在什么地方把静态数据和动态数据合并并渲染出一个完整的页面"><span class="nav-number">1.5.2.1.5.</span> <span class="nav-text">在什么地方把静态数据和动态数据合并并渲染出一个完整的页面</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二八原则：有针对性地处理好系统的“热点数据”"><span class="nav-number">1.6.</span> <span class="nav-text">二八原则：有针对性地处理好系统的“热点数据”</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要关注热点"><span class="nav-number">1.6.1.</span> <span class="nav-text">为什么要关注热点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是“热点”"><span class="nav-number">1.6.2.</span> <span class="nav-text">什么是“热点”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发现热点数据"><span class="nav-number">1.6.3.</span> <span class="nav-text">发现热点数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#发现静态热点数据"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">发现静态热点数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#发现动态热点数据"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">发现动态热点数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理热点数据"><span class="nav-number">1.6.4.</span> <span class="nav-text">处理热点数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流量削峰这事应该怎么做？"><span class="nav-number">1.7.</span> <span class="nav-text">流量削峰这事应该怎么做？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要削峰"><span class="nav-number">1.7.1.</span> <span class="nav-text">为什么要削峰</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排队"><span class="nav-number">1.7.2.</span> <span class="nav-text">排队</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#答题"><span class="nav-number">1.7.3.</span> <span class="nav-text">答题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分层过滤"><span class="nav-number">1.7.4.</span> <span class="nav-text">分层过滤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#秒杀系统“减库存”设计的核心逻辑"><span class="nav-number">1.8.</span> <span class="nav-text">秒杀系统“减库存”设计的核心逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#减库存有哪几种方式"><span class="nav-number">1.8.1.</span> <span class="nav-text">减库存有哪几种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#减库存可能存在的问题"><span class="nav-number">1.8.2.</span> <span class="nav-text">减库存可能存在的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#大型秒杀中如何减库存？"><span class="nav-number">1.8.3.</span> <span class="nav-text">大型秒杀中如何减库存？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#秒杀减库存的极致优化"><span class="nav-number">1.8.4.</span> <span class="nav-text">秒杀减库存的极致优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Plan-B-方案"><span class="nav-number">1.9.</span> <span class="nav-text">Plan B 方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#高可用建设应该从哪里着手"><span class="nav-number">1.9.1.</span> <span class="nav-text">高可用建设应该从哪里着手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#降级"><span class="nav-number">1.9.2.</span> <span class="nav-text">降级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#限流"><span class="nav-number">1.9.3.</span> <span class="nav-text">限流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拒绝服务"><span class="nav-number">1.9.4.</span> <span class="nav-text">拒绝服务</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
