<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Redis,">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="Redis面试经典问题集锦Redis有哪些数据结构？&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;字符串String、字典Hash、列表List、集合Set、有序集合SortedSet。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果你是Redis中高级用户，还需要加上下面几种数据结构HyperLogLog、Geo、Pub/Sub。 &amp;nbs">
<meta name="keywords" content="Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis面试经典问题集锦">
<meta property="og:url" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="Redis面试经典问题集锦Redis有哪些数据结构？&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;字符串String、字典Hash、列表List、集合Set、有序集合SortedSet。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果你是Redis中高级用户，还需要加上下面几种数据结构HyperLogLog、Geo、Pub/Sub。 &amp;nbs">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825172905.jpg">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825172927.jpg">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825172953.jpg">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825173821.jpg">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825174147.jpg">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825174522.jpg">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825175223.jpg">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825161205.jpg">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825161236.jpg">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825161309.jpg">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825161331.jpg">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825161353.jpg">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825163136.jpg">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdaaD23JRv9Ekia9yACEasZN2u5KbESkSQOmlxK0vkBsib7nr49iaGVMfdvrrGlhJRV3LMMiavLLT4PxOA/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825164627.jpg">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825164647.jpg">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825164708.jpg">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825164752.jpg">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825164830.jpg">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825164849.jpg">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825164941.jpg">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825165009.jpg">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825165033.jpg">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825165101.jpg">
<meta property="og:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825155844.jpg">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdaaD23JRv9Ekia9yACEasZN2ic4WBOYib1gJ0aIVTzOtmYO4ialqY0gibgxqM36SpicbBp8wKqXKwe9bibjA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdaaD23JRv9Ekia9yACEasZN2crrTA4ryGLQeZ7LjS9ibCFohrBFQakKIOMTYrbGXagQagaUOicLFCpJg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdaaD23JRv9Ekia9yACEasZN28tEgX78RooNTI4cw8SpoHWLYjFNFN1ROluUia69quEUtI4l4Y5pniatg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdaaD23JRv9Ekia9yACEasZN2VKmER3ReJboExfFzO0V1RbZEB7gttwHoAZx61VjUrLu9icLqIN6jvCg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:image" content="https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdaaD23JRv9Ekia9yACEasZN2luG8JfOic61h6dytADBSiaRichm29fje6lTXiar0C7Q0zL06SaHQyKAXDQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1">
<meta property="og:updated_time" content="2019-08-25T10:24:30.304Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis面试经典问题集锦">
<meta name="twitter:description" content="Redis面试经典问题集锦Redis有哪些数据结构？&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;字符串String、字典Hash、列表List、集合Set、有序集合SortedSet。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果你是Redis中高级用户，还需要加上下面几种数据结构HyperLogLog、Geo、Pub/Sub。 &amp;nbs">
<meta name="twitter:image" content="http://blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825172905.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/2019/08/25/Redis面试经典问题集锦/">





  <title>Redis面试经典问题集锦 | 搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/08/25/Redis面试经典问题集锦/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Redis面试经典问题集锦</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-25T12:12:57+08:00">
                2019-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Redis面试经典问题集锦"><a href="#Redis面试经典问题集锦" class="headerlink" title="Redis面试经典问题集锦"></a>Redis面试经典问题集锦</h1><h2 id="Redis有哪些数据结构？"><a href="#Redis有哪些数据结构？" class="headerlink" title="Redis有哪些数据结构？"></a>Redis有哪些数据结构？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字符串<code>String</code>、字典<code>Hash</code>、列表<code>List</code>、集合<code>Set</code>、有序集合<code>SortedSet</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你是<code>Redis</code>中高级用户，还需要加上下面几种数据结构<code>HyperLogLog</code>、<code>Geo</code>、<code>Pub/Sub</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果你说还玩过<code>Redis Module</code>，像<code>BloomFilter</code>，<code>RedisSearch</code>，<code>Redis-ML</code>，面试官得眼睛就开始发亮了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近还支持了流<code>Stream</code></p>
<h2 id="数据结构而非类型"><a href="#数据结构而非类型" class="headerlink" title="数据结构而非类型"></a>数据结构而非类型</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>redis</code>里存的都是二进制数据，其实就是<strong>字节数组（<code>byte[]</code>）</strong>，这些字节数据是没有数据类型的，只有把它们按照合理的格式<strong>解码后，可以变成一个字符串，整数或对象，此时才具有数据类型</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一点必须要记住。所以任何东西只要能转化成字节数组（<code>byte[]</code>）的，都可以存到<code>redis</code>里。管你是字符串、数字、对象、图片、声音、视频、还是文件，只要变成<code>byte</code>数组。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此<code>redis</code>里的<code>String</code>指的并不是字符串，它其实表示的是一种最简单的数据结构，即一个<code>key</code>只能对应一个<code>value</code>。这里的<code>key</code>和<code>value</code>都是<code>byte</code>数组，只不过<code>key</code>一般是由一个字符串转换成的<code>byte</code>数组，<code>value</code>则根据实际需要而定。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在特定情况下，对<code>value</code>也会有一些要求，比如要进行自增或自减操作，那<code>value</code>对应的<code>byte</code>数组必须要能被解码成一个数字才行，否则会报错。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>List</code>这种数据结构，其实表示一个<code>key</code>可以对应多个<code>value</code>，且<code>value</code>之间是有先后顺序的，<code>value</code>值可以重复。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Set</code>这种数据结构，表示一个<code>key</code>可以对应多个<code>value</code>，且<code>value</code>之间是没有先后顺序的，<code>value</code>值也不可以重复。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Hash</code>这种数据结构，表示一个<code>key</code>可以对应多个<code>key-value</code>对，此时这些<code>key-value</code>对之间的先后顺序一般意义不大，这是一个按照名称语义来访问的数据结构，而非位置语义。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Sorted Set</code>这种数据结构，表示一个key可以对应多个<code>value</code>，<code>value</code>之间是有大小排序的，<code>value</code>值不可以重复。每个<code>value</code>都和一个浮点数相关联，该浮点数叫<code>score</code>。元素排序规则是：先按<code>score</code>排序，再按<code>value</code>排序。</p>
<h2 id="Redis常见数据结构的用法"><a href="#Redis常见数据结构的用法" class="headerlink" title="Redis常见数据结构的用法"></a>Redis常见数据结构的用法</h2><p><code>string</code>             =&gt; 缓存、计数器（频率控制）、分布式锁</p>
<p><code>sortedset</code>      =&gt; 排行榜、分页、延时队列</p>
<p><code>list</code>                =&gt; 队列  </p>
<p><code>set</code>                  =&gt; 标签存储、集合运算</p>
<p><code>hash</code>               =&gt; 对象存储</p>
<p><code>bitmap</code>          =&gt; 统计（签到天数） </p>
<p><code>pub/sub</code>        =&gt; 通知、队列</p>
<p>布隆过滤器</p>
<p>流</p>
<p>模糊计数</p>
<h2 id="使用过Redis分布式锁么，它是什么回事？"><a href="#使用过Redis分布式锁么，它是什么回事？" class="headerlink" title="使用过Redis分布式锁么，它是什么回事？"></a>使用过Redis分布式锁么，它是什么回事？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时候对方会告诉你说你回答得不错，然后接着问如果在<code>setnx</code>之后执行<code>expire</code>之前进程意外<code>crash</code>或者要重启维护了，那会怎么样？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后回答：我记得<strong>set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！</strong>（如果版本不支持，可以通过<code>lua script</code>来实现）</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对方这时会显露笑容，心里开始默念：摁，这小子还不错。</p>
<h2 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用<code>keys</code>指令可以扫出指定模式的<code>key</code>列表。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对方接着追问：如果这个redis正在给线上的业务提供服务，那使用<code>keys</code>指令会有什么问题？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个时候你要回答<code>redis</code>关键的一个特性：<code>redis</code>的单线程的。<strong><code>keys</code>指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个时候可以<strong>使用<code>scan</code>指令，<code>scan</code>指令可以无阻塞的提取出指定模式的<code>key</code>列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用<code>keys</code>指令长</strong>。（迭代器模式）</p>
<h2 id="使用过Redis做异步队列么，你是怎么用的？"><a href="#使用过Redis做异步队列么，你是怎么用的？" class="headerlink" title="使用过Redis做异步队列么，你是怎么用的？"></a>使用过Redis做异步队列么，你是怎么用的？</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般使用list结构作为队列，<code>rpush</code>生产消息，<code>lpop</code>消费消息。当<code>lpop</code>没有消息的时候，要适当<code>sleep</code>一会再重试。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果对方追问可不可以不用<code>sleep</code>呢？list还有个指令叫<code>blpop</code>，在没有消息的时候，它会阻塞住直到消息到来。</p>
<h3 id="pub-sub"><a href="#pub-sub" class="headerlink" title="pub/sub"></a>pub/sub</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果对方追问能不能<strong>生产一次消费多次</strong>呢？使用<code>pub/sub</code>主题订阅者模式，可以实现<code>1:N</code>的消息队列。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果对方追问<code>pub/sub</code>有什么缺点？<strong>在消费者下线的情况下，生产的消息会丢失</strong>，得使用专业的消息队列如<code>rabbitmq</code>等。</p>
<h3 id="sortedset"><a href="#sortedset" class="headerlink" title="sortedset"></a>sortedset</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果对方追问<code>redis</code>如何实现<strong>延时队列</strong>？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是你很克制，然后神态自若的回答道：<strong>使用<code>sortedset</code>，拿时间戳作为<code>score</code>，消息内容作为<code>value</code>调用<code>zadd</code>来生产消息，消费者用<code>zrangebyscore</code>指令获取N秒之前的数据轮询进行处理</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</p>
<h2 id="如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果大量的<code>key</code>过期时间设置的过于集中，到过期的那个时间点，<code>redis</code>可能会出现短暂的卡顿现象。<strong>一般需要在时间上加一个随机值，使得过期时间分散一些</strong>。</p>
<h2 id="Redis如何做持久化的？"><a href="#Redis如何做持久化的？" class="headerlink" title="Redis如何做持久化的？"></a>Redis如何做持久化的？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>bgsave</code>做镜像全量持久化，<code>aof</code>做增量持久化</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为<code>bgsave</code>会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要<code>aof</code>来配合使用。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>redis</code>实例重启时，会使用<code>bgsave</code>持久化文件重新构建内存，再使用<code>aof</code>重放近期的操作指令来实现完整恢复重启之前的状态。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对方追问那如果突然机器掉电会怎样？<strong>取决于<code>aof</code>日志<code>sync</code>属性的配置</strong>，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是在高性能的要求下每次都<code>sync</code>是不现实的，<strong>一般都使用定时<code>sync</code>，比如1s 1次，这个时候最多就会丢失1s的数据</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对方追问<code>bgsave</code>的原理是什么？你给出两个词汇就可以了，<strong>fork和cow</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>fork</code>是指<code>redis</code>通过创建子进程来进行<code>bgsave</code>操作，<code>cow</code>指的是<code>copy on write</code>，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来</strong>。</p>
<h2 id="Redis-是如何持久化的"><a href="#Redis-是如何持久化的" class="headerlink" title="Redis 是如何持久化的"></a>Redis 是如何持久化的</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis</code> 的持久化有两种机制，一个是 <code>RDB</code>，也就是快照，快照就是一次全量的备份，会把所有<code>Redis</code> 的内存数据进行二进制的序列化存储到磁盘。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另一种是<code>AOF</code> 日志，<code>AOF</code>日志记录的是数据操作修改的指令记录日志，可以类比 <code>MySQL</code> 的 <code>Binlog</code>，<code>AOF</code> 日期随着时间的推移只会无限增量。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在对 <code>Redis</code>进行恢复时，<code>RDB</code>快照直接读取磁盘即可恢复，而 AOF 需要对所有的操作指令进行重放进行恢复，这个过程有可能非常漫长。</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825172905.jpg" alt="img"></p>
<h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis</code> 在进行 <code>RDB</code> 的快照生成有两种方法，一种是 <code>Save</code>，由于 <code>Redis</code>是单进程单线程，直接使用 <code>Save</code>，<code>Redis</code> 会进行一个庞大的文件 <code>IO</code>操作。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于单进程单线程势必会阻塞线上的业务，一般的话不会直接采用 <code>Save</code>，而是采用<code>Bgsave</code>，之前一直说 <code>Redis</code>是单进程单线程，其实不然。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在使用 <code>Bgsave</code> 的时候，<code>Redis</code> 会<code>Fork</code> 一个子进程，快照的持久化就交给子进程去处理，而父进程继续处理线上业务的请求</strong>。</p>
<h4 id="Fork-机制"><a href="#Fork-机制" class="headerlink" title="Fork 机制"></a>Fork 机制</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;想要弄清楚 <code>RDB</code> 快照的生成原理就必须弄清楚 <code>Fork</code>机制，<code>Fork</code> 机制是 <code>Linux</code> 操作系统的一个进程机制。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>当父进程<code>Fork</code> 出来一个子进程，子进程和父进程拥有共同的内存数据结构，子进程刚刚产生时，它和父进程共享内存里面的代码段和数据段</strong>。</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825172927.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一开始两个进程都具备了相同的内存段，<strong>子进程在做数据持久化时，不会去修改现在的内存数据，而是会采用 <code>COW(Copy On Write)</code>的方式将数据段页面进行分离</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>当父进程修改了某一个数据段时，被共享的页面就会复制一份分离出来，然后父进程再在新的数据段进行修改</strong>。</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825172953.jpg" alt="img"></p>
<h4 id="分裂"><a href="#分裂" class="headerlink" title="分裂"></a>分裂</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个过程也成为分裂的过程，<strong>本来父子进程都指向很多相同的内存块，但是如果父进程对其中某个内存块进行该修改，就会将其复制出来，进行分裂再在新的内存块上面进行修改</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为子进程在 <code>Fork</code> 的时候就可以固定内存，这个时间点的数据将不会产生变化。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以我们可以安心的产生快照不用担心快照的内容受到父进程业务请求的影响。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外可以想象，如果在 <code>Bgsave</code> 的过程中，<code>Redis</code> 没有任何操作，父进程没有接收到任何业务请求也没有任何的背后例如过期移除等操作，父进程和子进程将会使用相同的内存块。</p>
<h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>AOF</code>是 <code>Redis</code>操作指令的日志存储，类同于 <code>MySQL</code> 的 <code>Binlog</code>，假设 <code>AOF</code>从 <code>Redis</code> 创建以来就一直执行，那么 <code>AOF</code> 就记录了所有的<code>Redis</code> 指令的记录。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果要恢复<code>Redis</code>，可以对 <code>AOF</code>进行指令重放，便可修复整个 <code>Redis</code>实例。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过 <code>AOF</code> 日志也有两个比较大的问题：</p>
<ul>
<li><p>一个是<code>AOF</code> 的日志会随着时间递增，如果一个数据量大运行的时间久，<code>AOF</code> <strong>日志量将变得异常庞大</strong>。</p>
</li>
<li><p>另一个问题是 <code>AOF</code> 在做数据恢复时，由于重放的量非常庞大，<strong>恢复的时间将会非常的长</strong>。</p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>AOF</code> 写操作是在 <code>Redis</code> 处理完业务逻辑之后，按照一定的策略才会进行些 <code>AOF</code>日志存盘</strong>，这点跟 <code>MySQL</code>的<code>Redo log</code>和 <code>Binlog</code>有很大的不同。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也因为此原因，<strong><code>Redis</code> 因为处理逻辑在前而记录操作日志在后，也是导致 <code>Redis</code> 无法进行回滚的一个原因</strong>。</p>
<p><code>bgrewriteaof</code>：针对上述的问题，<code>Redis</code> 在 2.4 之后也使用了<code>bgrewriteaof</code> 对<code>AOF</code> 日志进行瘦身。</p>
<p><code>bgrewriteaof</code>命令用于异步执行一个<code>AOF</code> 文件重写操作。重写会创建一个当前<code>AOF</code> 文件的体积优化版本。</p>
<h3 id="RDB-和-AOF-混合搭配模式"><a href="#RDB-和-AOF-混合搭配模式" class="headerlink" title="RDB 和 AOF 混合搭配模式"></a>RDB 和 AOF 混合搭配模式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在对<code>Redis</code>进行恢复的时候，如果我们采用了 <code>RDB</code>的方式，因为 <code>Bgsave</code> 的策略，可能会导致我们丢失大量的数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果我们采用了<code>AOF</code>的模式，通过 <code>AOF</code> 操作日志重放恢复，重放 <code>AOF</code>日志比<code>RDB</code>要长久很多。</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825173821.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis 4.0</code> 之后，为了解决这个问题，引入了新的持久化模式，混合持久化，将<code>RDB</code>的文件和局部增量的 <code>AOF</code> 文件相结合。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>RDB</code> 可以使用相隔较长的时间保存策略，<code>AOF</code> 不需要是全量日志，只需要保存前一次<code>RDB</code>存储开始到这段时间增量<code>AOF</code>日志即可</strong>，一般来说，这个日志量是非常小的。</p>
<h2 id="Pipeline有什么好处，为什么要用pipeline？"><a href="#Pipeline有什么好处，为什么要用pipeline？" class="headerlink" title="Pipeline有什么好处，为什么要用pipeline？"></a>Pipeline有什么好处，为什么要用pipeline？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以将<strong>多次<code>IO</code>往返的时间缩减为一次，前提是<code>pipeline</code>执行的指令之间没有因果相关性</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用<code>redis-benchmark</code>进行压测的时候可以发现影响<code>redis</code>的<code>QPS</code>峰值的一个重要因素是<code>pipeline</code>批次指令的数目。</p>
<h2 id="Redis的同步机制了解么？"><a href="#Redis的同步机制了解么？" class="headerlink" title="Redis的同步机制了解么？"></a>Redis的同步机制了解么？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis</code>可以使用主从同步，从从同步。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存<code>buffer</code>，待完成后将<code>rdb</code>文件全量同步到复制节点，复制节点接受完成后将<code>rdb</code>镜像加载到内存。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p>
<h2 id="Redis-是如何实现主从复制"><a href="#Redis-是如何实现主从复制" class="headerlink" title="Redis 是如何实现主从复制"></a>Redis 是如何实现主从复制</h2><p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825174147.jpg" alt="img"></p>
<p>几个定义：</p>
<ul>
<li><strong><code>runID</code>：服务器运行的 ID</strong>。</li>
<li><strong><code>Offset</code>：主服务器的复制偏移量和从服务器复制的偏移量</strong>。</li>
<li><strong><code>Replication backlog</code>：主服务器的复制积压缓冲区</strong>。</li>
</ul>
<p>在 <code>Redis 2.8</code>之后，使用 <code>Psync</code>命令代替<code>Sync</code>命令来执行复制的同步操作。</p>
<p><code>Psync</code>命令具有完整重同步和部分重同步两种模式：</p>
<ul>
<li><p><strong>完整同步用于处理初次复制情况</strong>：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完整重同步的执行步骤和 <code>Sync</code> 命令执行步骤一致，都是<strong>通过让主服务器创建并发送 <code>RDB</code> 文件，以及向从服务器发送保存在缓冲区的写命令来进行同步</strong>。</p>
</li>
<li><p><strong>部分重同步是用于处理断线后重复制情况</strong>：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当从服务器在断线后重新连接主服务器时，<strong>主服务可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令</strong>，就可以将数据库更新至主服务器当前所处的状态。</p>
</li>
</ul>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825174522.jpg" alt="img"></p>
<h3 id="完整重同步"><a href="#完整重同步" class="headerlink" title="完整重同步"></a>完整重同步</h3><p>完整重同步：</p>
<ul>
<li><code>Slave</code> 发送 <code>Psync</code> 给 <code>Master</code>，由于是第一次发送，不带上<code>runID</code> 和 <code>Offset</code>。</li>
<li><code>Master</code> 接收到请求，发送 <code>Master</code> 的<code>runID</code> 和 <code>Offset</code>给从节点。</li>
<li><code>Master</code> 生成保存 <code>RDB</code> 文件。</li>
<li><code>Master</code>发送 <code>RDB</code> 文件给 <code>Slave</code>。</li>
<li>在发送 <code>RDB</code>这个操作的同时，写操作会复制到缓冲区 <code>Replication Backlog Buffer</code> 中，并从 <code>Buffer</code>区发送到 <code>Slave</code>。</li>
<li><code>Slave</code>将 <code>RDB</code> 文件的数据装载，并更新自身数据。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果网络的抖动或者是短时间的断链也需要进行完整同步就会导致大量的开销，这些开销包括了，<code>Bgsave</code> 的时间，<code>RDB</code> 文件传输的时间，<code>Slave</code> 重新加载<code>RDB</code> 时间，如果 <code>Slave</code> 有 <code>AOF</code>，还会导致 <code>AOF</code> 重写。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些都是大量的开销，所以在<code>Redis 2.8</code> 之后也实现了<strong>部分重同步</strong>的机制。</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825175223.jpg" alt="img"></p>
<h3 id="部分重同步"><a href="#部分重同步" class="headerlink" title="部分重同步"></a>部分重同步</h3><p>部分重同步：</p>
<ul>
<li><p>网络发生错误，<code>Master</code> 和<code>Slave</code> 失去连接。</p>
</li>
<li><p><strong><code>Master</code> 依然向<code>Buffer</code>缓冲区写入数据</strong>。</p>
</li>
<li><p><code>Slave</code> 重新连接上 <code>Master</code>。</p>
</li>
<li><p><strong><code>Slave</code> 向 <code>Master</code> 发送自己目前的 <code>runID</code>和 <code>Offset</code></strong>。</p>
</li>
<li><p><strong><code>Master</code> 会判断 <code>Slave</code> 发送给自己的<code>Offset</code>是否存在 <code>Buffer</code>队列中</strong>。</p>
</li>
<li><p><strong>如果存在，则发送<code>Continue</code> 给<code>Slave</code></strong></p>
<p>如果不存在，意味着可能错误了太多的数据，缓冲区已经被清空，这个时候就需要重新进行全量的复制</p>
</li>
<li><p><strong><code>Master</code> 发送从 <code>Offset</code>偏移后的缓冲区数据给 <code>Slave</code></strong>。</p>
</li>
<li><p><code>Slave</code> 获取数据更新自身数据。</p>
</li>
</ul>
<h2 id="是否使用过Redis集群，集群的原理是什么？"><a href="#是否使用过Redis集群，集群的原理是什么？" class="headerlink" title="是否使用过Redis集群，集群的原理是什么？"></a>是否使用过Redis集群，集群的原理是什么？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Redis Sentinal</code>着眼于高可用</strong>，在<code>master</code>宕机时会自动将<code>slave</code>提升为<code>master</code>，继续提供服务。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Redis Cluster</code>着眼于扩展性</strong>，在单个<code>redis</code>内存不足时，使用<code>Cluster</code>进行分片存储。</p>
<h2 id="集群带来的问题与解决思路"><a href="#集群带来的问题与解决思路" class="headerlink" title="集群带来的问题与解决思路"></a>集群带来的问题与解决思路</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;集群带来的好处是显而易见的，比如容量增加、处理能力增强，还可以按需要进行动态的扩容、缩容。但同时也会引入一些新的问题，至少会有下面这两个：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一是<strong>数据分配：存数据时应该放到哪个节点上，取数据时应该去哪个节点上找</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二是<strong>数据移动：集群扩容，新增加节点时，该节点上的数据从何处来；集群缩容，要剔除节点时，该节点上的数据往何处去</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面这两个问题有一个共同点就是，<strong>如何去描述和存储数据与节点的映射关系</strong>。又因为数据的位置是由<code>key</code>决定的，所以问题就演变为<strong>如何建立起各个<code>key</code>和集群所有节点的关联关系</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;集群的节点是相对固定和少数的，虽然有增加节点和剔除节点。但集群里存储的<code>key</code>，则是完全随机、没有规律、不可预测、数量庞多，还非常琐碎。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这就好比一所大学和它的所有学生之间的关系。如果大学和学生直接挂钩的话，一定会比较混乱。现实是它们之间又加入了好几层，首先有院系，其次有专业，再者有年级，最后还有班级。经过这四层映射之后，关系就清爽很多了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这其实是一个非常重要的结论，这个世界上没有什么问题是不能通过加入一层来解决的。如果有，那就再加入一层。计算机里也是这样的。</p>
<h3 id="Redis-Cluster的原理"><a href="#Redis-Cluster的原理" class="headerlink" title="Redis Cluster的原理"></a>Redis Cluster的原理</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>redis</code>在数据和节点之间又加入了一层，把这层称为槽（<code>slot</code>），因该槽主要和哈希有关，又叫哈希槽</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后变成了，<strong>节点上放的是槽，槽里放的是数据</strong>。<strong>槽解决的是粒度问题，相当于把粒度变大了，这样便于数据移动</strong>。<strong>哈希解决的是映射问题，使用<code>key</code>的哈希值来计算所在的槽，便于数据分配</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以这样来理解，你的学习桌子上堆满了书，乱的很，想找到某本书非常困难。于是你买了几个大的收纳箱，把这些书按照书名的长度放入不同的收纳箱，然后把这些收纳箱放到桌子上。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样就变成了，桌子上是收纳箱，收纳箱里是书籍。这样书籍移动很方便，搬起一个箱子就走了。寻找书籍也很方便，只要数一数书名的长度，去对应的箱子里找就行了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实我们也没做什么，只是买了几个箱子，按照某种规则把书装入箱子。就这么简单的举动，就彻底改变了原来一盘散沙的状况。是不是有点小小的神奇呢。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>一个集群只能有<code>16384</code>个槽，编号<code>0-16383</code>。这些槽会分配给集群中的所有主节点，分配策略没有要求。可以指定哪些编号的槽分配给哪个主节点</strong>。<strong>集群会记录节点和槽的对应关系</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来就需要<strong>对key求哈希值，然后对16384取余，余数是几，key就落入对应的槽里。<code>slot = CRC16(key) % 16384</code></strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>以槽为单位移动数据，因为槽的数目是固定的，处理起来比较容易，这样数据移动问题就解决了</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用哈希函数计算出<code>key</code>的哈希值，这样就可以算出它对应的槽，然后利用集群存储的槽和节点的映射关系查询出槽所在的节点，于是数据和节点就映射起来了，这样数据分配问题就解决了。</p>
<h3 id="集群对命令操作的取舍"><a href="#集群对命令操作的取舍" class="headerlink" title="集群对命令操作的取舍"></a>集群对命令操作的取舍</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端只要和集群中的一个节点建立链接后，就可以获取到整个集群的所有节点信息。此外还会获取所有哈希槽和节点的对应关系信息，这些信息数据都会在客户端缓存起来，因为这些信息相当有用。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端可以向任何节点发送请求，那么拿到一个<code>key</code>后到底该向哪个节点发请求呢？其实就是z<strong>把集群里的那套<code>key</code>和节点的映射关系理论搬到客户端</strong>来就行了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以客户端需要实现一个和集群端一样的哈希函数，先计算出<code>key</code>的哈希值，然后再对<code>16384</code>取余，这样就找到了该<code>key</code>对应的哈希槽，利用客户端缓存的槽和节点的对应关系信息，就可以找到该<code>key</code>对应的节点了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接下来发送请求就可以了。还可以把<code>key</code>和节点的映射关系缓存起来，下次再请求该<code>key</code>时，直接就拿到了它对应的节点，不用再计算一遍了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;理论和现实总是有差距的，<strong>集群已经发生了变化，客户端的缓存还没来得及更新</strong>。肯定会出现拿到一个<code>key</code>向对应的节点发请求，其实这个<code>key</code>已经不在那个节点上了。此时这个节点应该怎么办？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个节点可以去<code>key</code>实际所在的节点上拿到数据再返回给客户端，也可以直接告诉客户端<code>key</code>已经不在我这里了，同时<strong>附上<code>key</code>现在所在的节点信息，让客户端再去请求一次，类似于<code>HTTP</code>的<code>302</code>重定向</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这其实是个选择问题，也是个哲学问题。结果就是<code>redis</code>集群选择了后者。因此，<strong>节点只处理自己拥有的<code>key</code>，对于不拥有的key将返回重定向错误，即-MOVED key 127.0.0.1:6381，客户端重新向这个新节点发送请求</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以说选择是一种哲学，也是个智慧。稍后再谈这个问题。先来看看另一个情况，和这个问题有些相同点。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>redis</code>有一种命令可以一次带多个<code>key</code>，如<code>MGET</code>，我把这些称为多<code>key</code>命令。这个多<code>key</code>命令的请求被发送到一个节点上，这里有一个潜在的问题，不知道大家有没有想到，就是这个命令里的多个<code>key</code>一定都位于那同一个节点上吗？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;就分为两种情况了，如果多个<code>key</code>不在同一个节点上，此时节点只能返回重定向错误了，但是多个<code>key</code>完全可能位于多个不同的节点上，此时返回的重定向错误就会非常乱，所以<code>redis</code>集群选择不支持此种情况。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果多个<code>key</code>位于同一个节点上呢，理论上是没有问题的，<code>redis</code>集群是否支持就和<code>redis</code>的版本有关系了，具体使用时自己测试一下就行了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这个过程中我们发现了一件颇有意义的事情，就是让一组相关的<code>key</code>映射到同一个节点上是非常有必要的，这样可以提高效率，通过多<code>key</code>命令一次获取多个值。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么问题来了，如何给这些<code>key</code>起名字才能让他们落到同一个节点上，难不成都要先计算个哈希值，再取个余数，太麻烦了吧。当然不是这样了，<code>redis</code>已经帮我们想好了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以来简单推理下，要想让两个<code>key</code>位于同一个节点上，它们的哈希值必须要一样。要想哈希值一样，传入哈希函数的字符串必须一样。那我们只能传进去两个一模一样的字符串了，那不就变成同一个<code>key</code>了，后面的会覆盖前面的数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的问题是我们都是拿整个<code>key</code>去计算哈希值，这就导致<code>key</code>和参与计算哈希值的字符串耦合了，需要将它们解耦才行，就是<code>key</code>和参与计算哈希值的字符串有关但是又不一样。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>redis</code>基于这个原理为我们提供了方案，叫做key哈希标签。先看例子，<code>{user1000}.following</code>，<code>{user1000}.followers</code>，相信你已经看出了门道，就是仅使用Key中的位于{和}间的字符串参与计算哈希值</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这样可以保证哈希值相同，落到相同的节点上。但是<code>key</code>又是不同的，不会互相覆盖。使用哈希标签把一组相关的<code>key</code>关联了起来，问题就这样被轻松愉快地解决了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相信你已经发现了，要解决问题靠的是巧妙的奇思妙想，而不是非要用牛逼的技术牛逼的算法。这就是小强，小而强大。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后再来谈选择的哲学。<code>redis</code>的核心就是以最快的速度进行常用数据结构的<code>key/value</code>存取，以及围绕这些数据结构的运算。对于与核心无关的或会拖累核心的都选择弱化处理或不处理，这样做是为了保证核心的简单、快速和稳定。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实就是在广度和深度面前，<code>redis</code>选择了深度。所以<strong>节点不去处理自己不拥有的<code>key</code>，集群不去支持多<code>key</code>命令</strong>。这样<strong>一方面可以快速地响应客户端，另一方面可以避免在集群内部有大量的数据传输与合并</strong>。</p>
<h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a><strong>单线程模型</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>redis</code>集群的每个节点里只有一个线程负责接受和执行所有客户端发送的请求。技术上使用多路复用<code>I/O</code>，使用<code>Linux</code>的<code>epoll</code>函数，这样一个线程就可以管理很多<code>socket</code>连接。</p>
<p>除此之外，选择单线程还有以下这些原因：</p>
<p>1、<strong><code>redis</code>都是对内存的操作</strong>，速度极快（10W+QPS）</p>
<p>2、<strong>整体的时间主要都是消耗在了网络的传输上</strong></p>
<p>3、如果使用了多线程，则需要<strong>多线程同步，这样实现起来会变的复杂</strong></p>
<p>4、<strong>线程的加锁时间甚至都超过了对内存操作的时间</strong></p>
<p>5、<strong>多线程上下文频繁的切换需要消耗更多的<code>CPU</code>时间</strong></p>
<p>6、还有就是<strong>单线程天然支持原子操作</strong>，而且单线程的代码写起来更简单  </p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务大家都知道，就是把多个操作捆绑在一起，要么都执行（成功了），要么一个也不执行（回滚了）。<code>redis</code>也是支持事务的，但可能和你想要的不太一样，一起来看看吧。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>redis</code>的事务可以分为两步，定义事务和执行事务。使用<code>multi</code>命令开启一个事务，然后把要执行的所有命令都依次排上去。这就定义好了一个事务。此时使用<code>exec</code>命令来执行这个事务，或使用<code>discard</code>命令来放弃这个事务。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你可能希望在你的事务开始前，你关心的<code>key</code>不想被别人操作，那么可以使用<code>watch</code>命令来监视这些<code>key</code>，如果开始执行前这些<code>key</code>被其它命令操作了则会取消事务的。也可以使用<code>unwatch</code>命令来取消对这些key的监视。</p>
<p><code>redis</code>事务具有以下特点：</p>
<p>1、<strong>如果开始执行事务前出错，则所有命令都不执行</strong></p>
<p>2、<strong>一旦开始，则保证所有命令一次性按顺序执行完而不被打断</strong></p>
<p>3、<strong>如果执行过程中遇到错误，会继续执行下去，不会停止的</strong></p>
<p>4、<strong>对于执行过程中遇到错误，是不会进行回滚的</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;看完这些，真想问一句话，你这能叫事务吗？很显然，这并不是我们通常认为的事务，因为它连原子性都保证不了。<strong>保证不了原子性是因为<code>redis</code>不支持回滚</strong>，不过它也给出了不支持的理由。</p>
<p>不支持回滚的理由：</p>
<p>1、<code>redis</code>认为，<strong>失败都是由命令使用不当造成</strong></p>
<p>2、<code>redis</code>这样做，是<strong>为了保持内部实现简单快速</strong></p>
<p>3、<code>redis</code>还认为，<strong>回滚并不能解决所有问题</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;哈哈，这就是霸王条款，因此，好像使用<code>redis</code>事务的不太多</p>
<h2 id="Redis-究竟有没有-ACID-事务"><a href="#Redis-究竟有没有-ACID-事务" class="headerlink" title="Redis 究竟有没有 ACID 事务"></a><strong>Redis 究竟有没有 ACID 事务</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要弄清楚 <code>Redis</code> 有没有事务，其实很简单，上 <code>Redis</code>的官网查看文档，发现：</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825161205.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis</code> 确实是有事务，不过按照传统的事务定义 <code>ACID</code>来看，<code>Redis</code>是不是都具备了 <code>ACID</code> 的特性。</p>
<p><code>ACID</code> 指的是：</p>
<ul>
<li><strong>原子性</strong></li>
<li><strong>一致性</strong></li>
<li><strong>隔离性</strong></li>
<li><strong>持久性</strong></li>
</ul>
<p>我们将使用以上 <code>Redis</code> 事务的命令来检验是否<code>Redis</code>都具备了 <code>ACID</code> 的各个特征。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务具备原子性指的是，数据库将事务中多个操作当作一个整体来执行，服务要么执行事务中所有的操作，要么一个操作也不会执行。</p>
<h4 id="事务队列"><a href="#事务队列" class="headerlink" title="事务队列"></a>事务队列</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先弄清楚 <code>Redis</code>开始事务<code>multi</code>命令后，<code>Redis</code> 会为这个事务生成一个队列，每次操作的命令都会按照顺序插入到这个队列中。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个队列里面的命令不会被马上执行，直到 <code>exec</code>命令提交事务，所有队列里面的命令会被一次性，并且排他的进行执行。</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825161236.jpg" alt="img"></p>
<p>对应如下图：</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825161309.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面的例子可以看出，当执行一个成功的事务，事务里面的命令都是按照队列里面顺序的并且排他的执行。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但<strong>原子性又一个特点就是要么全部成功，要么全部失败，也就是我们传统 DB 里面说的回滚</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们执行一个失败的事务：</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825161331.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以发现，就算中间出现了失败，<code>set abc x</code>这个操作也已经被执行了，并没有进行回滚，<strong>从严格的意义上来说<code>Redis</code> 并不具备原子性</strong>。</p>
<h4 id="为何-Redis-不支持回滚"><a href="#为何-Redis-不支持回滚" class="headerlink" title="为何 Redis 不支持回滚"></a>为何 Redis 不支持回滚</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个其实跟 <code>Redis</code> 的定位和设计有关系，先看看为何我们的 <code>MySQL</code> 可以支持回滚</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个还是跟写<code>Log</code> 有关系，<strong><code>Redis</code> 是完成操作之后才会进行<code>AOF</code> 日志记录，<code>AOF</code> 日志的定位只是记录操作的指令记录</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而 <code>MySQL</code> 有完善的 <code>Redo log</code>，并且是在事务进行 <code>Commit</code>之前就会写完成 <code>Redo log，Binlog</code>：</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825161353.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要知道 <code>MySQL</code> 为了能进行回滚是花了不少的代价，<code>Redis</code>应用的场景更多是对抗高并发具备高性能，所以 <code>Redis</code> 选择更简单，更快速无回滚的方式处理事务也是符合场景。</p>
<blockquote>
<p>1、<code>redis</code>认为，<strong>失败都是由命令使用不当造成</strong></p>
<p>2、<code>redis</code>这样做，是<strong>为了保持内部实现简单快速</strong></p>
<p>3、<code>redis</code>还认为，<strong>回滚并不能解决所有问题</strong></p>
</blockquote>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务具备一致性指的是，如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否成功，数据库也应该是一致的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从<code>Redis</code>来说可以从 2 个层面看，一个是执行错误是否有确保一致性，另一个是宕机时，<code>Redis</code>是否有确保一致性的机制。</p>
<h4 id="执行错误是否有确保一致性"><a href="#执行错误是否有确保一致性" class="headerlink" title="执行错误是否有确保一致性"></a>执行错误是否有确保一致性</h4><p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825163136.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依然去执行一个错误的事务，在事务执行的过程中会识别出来并进行错误处理，这些错误并不会对数据库作出修改，也不会对事务的一致性产生影响。</p>
<h4 id="宕机对一致性的影响"><a href="#宕机对一致性的影响" class="headerlink" title="宕机对一致性的影响"></a>宕机对一致性的影响</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;暂不考虑分布式高可用的 <code>Redis</code> 解决方案，先从单机看宕机恢复是否能满意数据完整性约束。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无论是 <code>RDB</code>还是 <code>AOF</code> 持久化方案，可以使用 <code>RDB</code> 文件或<code>AOF</code> 文件进行恢复数据，从而将数据库还原到一个一致的状态。</p>
<h4 id="再议一致性"><a href="#再议一致性" class="headerlink" title="再议一致性"></a>再议一致性</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面执行错误和宕机对一致性的影响的观点摘自黄健宏 《<code>Redis</code>设计与实现》。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当在读这章的时候还是有一些存疑的点，归根到底 <code>Redis</code> 并非关系型数据库。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果仅仅就<code>ACID</code> 的表述上来说，一致性就是从 A 状态经过事务到达 B 状态没有破坏各种约束性，仅就 <code>Redis</code> 而言不谈实现的业务，那显然就是满意一致性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但如果加上业务去谈一致性，例如，A 转账给 B，A 减少 10 块钱，B 增加 10 块钱，因为<code>Redis</code> 并不具备回滚，也就不具备传统意义上的原子性，所以<code>Redis</code>也应该不具备传统的一致性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其实，这里只是简单讨论下 <code>Redis</code> 在传统<code>ACID</code> 上的概念怎么进行对接，或许，有可能是我想多了，用传统关系型数据库的 <code>ACID</code>去审核<code>Redis</code>是没有意义的，<code>Redis</code>本来就没有意愿去实现<code>ACID</code> 的事务。</p>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;隔离性指的是，数据库中有多个事务并发的执行，各个事务之间不会相互影响，并且在并发状态下执行的事务和串行执行的事务产生的结果是完全相同的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Redis</code>因为是单线程操作，所以在隔离性上有天生的隔离机制</strong>，当<code>Redis</code>执行事务时，<code>Redis</code>的服务端保证在执行事务期间不会对事务进行中断，所以，<code>Redis</code>事务总是以串行的方式运行，事务也具备隔离性。</p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务的持久性指的是，当一个事务执行完毕，执行这个事务所得到的结果被保存在持久化的存储中，即使服务器在事务执行完成后停机了，执行的事务的结果也不会被丢失。</p>
<p><strong>Redis 是否具备持久化，这个取决于 Redis 的持久化模式</strong>：</p>
<ul>
<li>纯内存运行，不具备持久化，服务一旦停机，所有数据将丢失。</li>
<li><code>RDB</code> 模式，取决于 <code>RDB</code> 策略，只有在满足策略才会执行 <code>Bgsave</code>，异步执行并不能保证<code>Redis</code>具备持久化。</li>
<li><code>AOF</code> 模式，只有将 <code>appendfsync</code> 设置为<code>always</code>，程序才会在执行命令同步保存到磁盘，这个模式下，<code>Redis</code>具备持久化。(将 <code>appendfsync</code> 设置为<code>always</code>，只是在理论上持久化可行，但一般不会这么操作)</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong><code>Redis</code> 具备了一定的原子性，但不支持回滚</strong>。</li>
<li><strong><code>Redis</code> 不具备 <code>ACID</code> 中一致性的概念</strong>。(或者说<code>Redis</code>在设计时就无视这点)</li>
<li><code>Redis</code> 具备隔离性。</li>
<li><code>Redis</code> 通过一定策略可以保证持久性。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis</code>和 <code>ACID</code> 纯属站在使用者的角度去思想，<code>Redis</code>设计更多的是追求简单与高性能，不会受制于传统 ACID 的束缚。</p>
<h2 id="Redis-的乐观锁-Watch-是怎么实现的"><a href="#Redis-的乐观锁-Watch-是怎么实现的" class="headerlink" title="Redis 的乐观锁 Watch 是怎么实现的"></a>Redis 的乐观锁 Watch 是怎么实现的</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当我们一提到乐观锁就会想起 <code>CAS(Compare And Set)</code>，<code>CAS</code>操作包含三个操作数：</p>
<ul>
<li>内存位置的值(V)</li>
<li>预期原值(A)</li>
<li>新值(B)</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置更新为新值。否则，处理器不做任何操作。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>Redis</code> 的事务中使用 <code>Watch</code> 实现，<code>Watch</code>会在事务开始之前盯住 1 个或多个关键变量。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当事务执行时，也就是服务器收到了 <code>exec</code> 指令要顺序执行缓存的事务队列时，<code>Redis</code>会检查关键变量自 <code>Watch</code>之后，是否被修改了。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdaaD23JRv9Ekia9yACEasZN2u5KbESkSQOmlxK0vkBsib7nr49iaGVMfdvrrGlhJRV3LMMiavLLT4PxOA/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h3 id="Java-的-AtomicXXX-的乐观锁机制"><a href="#Java-的-AtomicXXX-的乐观锁机制" class="headerlink" title="Java 的 AtomicXXX 的乐观锁机制"></a>Java 的 AtomicXXX 的乐观锁机制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>Java</code> 中我们也经常的使用到一些乐观锁的参数，例如 <code>AtomicXXX</code>，这些机制的背后是怎么去实现的，是否 <code>Redis</code>也跟 <code>Java</code> 的<code>CAS</code> 实现机制一样?</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;先来看看<code>Java</code> 的 <code>Atomic</code> 类，我们追一下源码，可以看到它的背后其实是 <code>Unsafe_CompareAndSwapObject</code>：</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825164627.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以看见 <code>compareAndSwapObject</code>是 <code>Native</code>方法，需要在继续追查，可以下载源码或打开 ：<a href="http://hg.openjdk.java.net/jdk8u/。" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk8u/。</a></p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825164647.jpg" alt="img"></p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825164708.jpg" alt="img"></p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825164752.jpg" alt=""></p>
<p><strong>Cmpxchg</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以发现追查到最终<code>CAS</code>，“比较并修改”，本来是两个语意，但是最终确实一条 <code>CPU</code>指令 <code>Cmpxchg</code> 完成。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Cmpxchg</code>是<strong>一条<code>CPU</code> 指令的命令而不是多条 <code>CPU</code> 指令，所以它不会被多线程的调度所打断，所以能够保证 <code>CAS</code>的操作是一个原子操作</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然 <code>Cmpxchg</code>的机制其实<strong>存在 <code>ABA</code>还有多次重试的问题</strong>，这个不在这里讨论。</p>
<h3 id="Redis-的-Watch-机制"><a href="#Redis-的-Watch-机制" class="headerlink" title="Redis 的 Watch 机制"></a>Redis 的 Watch 机制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis</code> 的<code>Watch</code>也是使用<code>Cmpxchg</code> 吗，两者存在相似之处在用法上也有一些不同</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Redis</code> 的<code>Watch</code> 不存在 <code>ABA</code> 问题</strong>，也没有多次重试机制，其中有一个重大的不同是：<code>Redis</code>事务执行其实是串行的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;简单追一下源码：摘录出来的源码可能有些凌乱，不过可以简单总结出来数据结构图和简单的流程图，之后再看源码就会清晰很多。</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825164830.jpg" alt="img"></p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825164849.jpg" alt="img"></p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825164941.jpg" alt="img"></p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825165009.jpg" alt="img"></p>
<p>存储如下图：</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825165033.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>RedisDb</code>存放了一个<code>watched_keys</code> 的 <code>Dcit</code>结构，每个被<code>Watch</code>的<code>Key</code> 的值是一个链表结构，存放的是一组 <code>Redis</code> 客户端标志</strong>。</p>
<p>流程如下图：</p>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825165101.jpg" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每一次<code>Watch</code>，<code>Multi</code>，<code>Exec</code> 时都会去查询这个 <code>watched_keys</code>结构进行判断，<strong>每次<code>Touch</code> 到被 <code>Watch</code> 的 <code>Key</code>时都会标志为 <code>CLIENT_DIRTY_CAS</code></strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为在 <code>Redis</code> 中所有的事务都是串行的，假设有客户端 A 和客户端 B 都 <code>Watch</code> 同一个<code>Key</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>当客户端 A 进行 <code>Touch</code> 修改或者 A 率先执行完，会把客户端 A 从这个 <code>watched_keys</code> 的这个<code>Key</code> 的列表删除，然后把这个列表所有的客户端都设置成 <code>CLIENT_DIRTY_CAS</code></strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>当后面的客户端 B 开始执行时，判断到自己的状态是<code>CLIENT_DIRTY_CAS</code>，便 <code>discardTransaction</code>终止事务</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Redis</code> 的 <code>Watch</code> 机制，更多是利用了 <code>Redis</code> 本身单线程的机制，采用了 <code>watched_keys</code> 的数据结构和串行流程实现了乐观锁机制</strong>。</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端和集群的交互过程是<strong>串行化阻塞式</strong>的，即客户端发送了一个命令后必须等到响应回来后才能发第二个命令，这一来一回就是一个往返时间。如果你有很多的命令，都这样一个一个的来进行，会变得很慢。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>redis</code>提供了一种管道技术，可以<strong>让客户端一次发送多个命令，期间不需要等待服务器端的响应，等所有的命令都发完了，再依次接收这些命令的全部响应</strong>。这就极大地节省了许多时间，提升了效率。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;聪明的你是不是意识到了另外一个问题，多个命令就是多个<code>key</code>啊，这不就是上面提到的多<code>key</code>操作嘛，那么问题来了，你如何保证这多个<code>key</code>都是同一个节点上的啊，哈哈，<strong><code>redis</code>集群又放弃了对管道的支持</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过可以在客户端模拟实现，就是使用多个连接往多个节点同时发送命令，然后等待所有的节点都返回了响应，再把它们按照发送命令的顺序整理好，返回给用户代码。哎呀，好麻烦呀。</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>简单了解下<code>redis</code>的协议，知道<code>redis</code>的数据传输格式。</p>
<p>发送请求的协议：</p>
<p><code>*参数个数CRLF$参数1的字节数CRLF参数1的数据CRLF...$参数N的字节数CRLF参数N的数据CRLF</code></p>
<p>例如，<code>SET name lixinjie</code>，实际发送的数据是：</p>
<p><code>*3\r\n$3\r\nSET\r\n$4\r\nname\r\n$8\r\nlixinjie\r\n</code></p>
<p>接受响应的协议：</p>
<p>单行回复，第一个字节是+</p>
<p>错误消息，第一个字节是-</p>
<p>整型数字，第一个字节是:</p>
<p>批量回复，第一个字节是$</p>
<p>多个批量回复，第一个字节是*</p>
<p>例如，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+OK\r\n</span><br><span class="line"></span><br><span class="line">-ERR Operation against\r\n</span><br><span class="line"></span><br><span class="line">:1000\r\n</span><br><span class="line"></span><br><span class="line">$6\r\nfoobar\r\n</span><br><span class="line"></span><br><span class="line">*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n</span><br></pre></td></tr></table></figure>
<p>可见<code>redis</code>的协议设计的非常简单。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis</code>的通讯协议是<strong>文本协议</strong>，是的，<code>Redis</code> 服务器与客户端通过 <code>RESP(Redis Serialization Protocol)</code>协议通信。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;没错，文本协议确实是会<strong>浪费流量</strong>，不过它的优点在于<strong>直观，非常的简单，解析性能极其的好</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们不需要一个特殊的 <code>Redis</code> 客户端仅靠 <code>Telnet</code> 或者是文本流就可以跟 <code>Redis</code> 进行通讯。</p>
<p>客户端的命令格式：</p>
<ul>
<li>简单字符串 Simple Strings，以 “+”加号开头。</li>
<li>错误 Errors，以”-“减号开头。</li>
<li>整数型 Integer，以 “:” 冒号开头。</li>
<li>大字符串类型 Bulk Strings，以 “$”美元符号开头。</li>
<li>数组类型 Arrays，以 “*”星号开头。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set hello abc</span><br><span class="line">一个简单的文本流就可以是redis的客户端</span><br></pre></td></tr></table></figure>
<p><img src="//blog.com/2019/08/25/Redis面试经典问题集锦/微信图片_20190825155844.jpg" alt="img"></p>
<p>简单总结：具体可以见：</p>
<p><a href="https://redis.io/topics/protocol" target="_blank" rel="noopener">https://redis.io/topics/protocol</a> ，</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis</code>文档认为简单的实现，快速的解析，直观理解是采用 <code>RESP</code> 文本协议最重要的地方，有可能文本协议会造成一定量的流量浪费，但却在性能上和操作上快速简单，这中间也是一个权衡和协调的过程。</p>
<h2 id="Redis-是怎么制定过期删除策略的"><a href="#Redis-是怎么制定过期删除策略的" class="headerlink" title="Redis 是怎么制定过期删除策略的"></a>Redis 是怎么制定过期删除策略的</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当一个键处于过期的状态，其实在 <code>Redis</code> 中这个内存并不是实时就被从内存中进行摘除，而是<code>Redis</code>通过一定的机制去把一些处于过期键进行移除，进而达到内存的释放</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么当一个键处于过期，<code>Redis</code> 会在什么时候去删除?</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;几时被删除存在三种可能性，这三种可能性也代表了<code>Redis</code> 的三种不同的删除策略。</p>
<ul>
<li><strong>定时删除</strong>：在设置键过去的时间同时，创建一个定时器，让定时器在键过期时间来临，立即执行对键的删除操作。</li>
<li><strong>惰性删除</strong>：放任键过期不管，但是每次从键空间获取键时，都会检查该键是否过期，如果过期的话，就删除该键。</li>
<li><strong>定期删除</strong>：每隔一段时间，程序都要对数据库进行一次检查，删除里面的过期键，至于要删除多少过期键，由算法而定。</li>
</ul>
<h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;设置键的过期时间，创建定时器，一旦过期时间来临，就立即对键进行操作。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种<strong>对内存是友好的，但是对<code>CPU</code>的时间是最不友好的，特别是在业务繁忙，过期键很多的时候，删除过期键这个操作就会占据很大一部分<code>CPU</code> 的时间</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要知道 <code>Redis</code>是单线程操作，在内存不紧张而 <code>CPU</code>紧张的时候，将 <code>CPU</code> 的时间浪费在与业务无关的删除过期键上面，会对 <code>Redis</code>的服务器的响应时间和吞吐量造成影响。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外，创建一个定时器需要用到 <code>Redis</code>服务器中的时间事件，而当前时间事件的实现方式是无序链表，时间复杂度为 <code>O(n)</code>，让服务器大量创建定时器去实现定时删除策略，会产生较大的性能影响</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以，定时删除并不是一种好的删除策略。</p>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;定时删除相反，惰性删除策略对 <code>CPU</code> 来说是最友好的，<strong>程序只有在取出键的时候才会进行检查，是一种被动的过程</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与此同时，<strong>惰性删除对内存来说又是最不友好的</strong>，一个键过期，只要不再被取出，这个过期键就不会被删除，它占用的内存也不会被释放。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很明显，惰性删除也不是一个很好的策略，<code>Redis</code>是非常依赖内存和较好内存的，如果一些长期键长期没有被访问，就会造成大量的内存垃圾，甚至会操成内存的泄漏。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在对执行数据写入时，通过<code>expireIfNeeded</code> 函数对写入的 <code>Key</code>进行过期判断。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中<code>expireIfNeeded</code> 在内部做了三件事情，分别是：</p>
<ul>
<li>查看<code>Key</code> 是否过期。</li>
<li>向 <code>Slave</code>节点传播执行过去<code>Key</code> 的动作。</li>
<li>删除过期 <code>Key</code>。</li>
</ul>
<h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面两种删除策略，无论是定时删除和惰性删除，这两种删除方式在单一的使用上都存在明显的缺陷，要么占用太多 CPU 时间，要么浪费太多内存。</p>
<p>定期删除策略是前两种策略的一个整合和折中：</p>
<ul>
<li>定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时间和频率来减少删除操作对 <code>CPU</code> 时间的影响。</li>
<li>通过合理的删除执行的时长和频率，来达到合理的删除过期键。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>Redis</code>选择的是<strong>定期删除+惰性删除</strong>相结合的方式。</p>
<h2 id="Redis-在内存使用上是如何开源节流"><a href="#Redis-在内存使用上是如何开源节流" class="headerlink" title="Redis 在内存使用上是如何开源节流"></a>Redis 在内存使用上是如何开源节流</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis</code> 跟其他传统数据库不同，<code>Redis</code>是一个纯内存的数据库，并且存储了都是一些数据结构的数据</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果不对内存加以控制的话，<code>Redis</code>很可能会因为数据量过大导致系统的奔溃。</p>
<h3 id="Ziplist"><a href="#Ziplist" class="headerlink" title="Ziplist"></a>Ziplist</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdaaD23JRv9Ekia9yACEasZN2ic4WBOYib1gJ0aIVTzOtmYO4ialqY0gibgxqM36SpicbBp8wKqXKwe9bibjA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>当最开始尝试开启一个小数据量的 <code>Hash</code> 结构和一个<code>Zset</code> 结构时，发现他们在<code>Redis</code>里面的真正结构类型是一个 <code>Ziplist</code></strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Ziplist</code> 是一个紧凑的数据结构，每一个元素之间都是连续的内存，如果在 <code>Redis</code>中，<code>Redis</code>启用的数据结构数据量很小时，<code>Redis</code>就会切换到使用紧凑存储的形式来进行压缩存储。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdaaD23JRv9Ekia9yACEasZN2crrTA4ryGLQeZ7LjS9ibCFohrBFQakKIOMTYrbGXagQagaUOicLFCpJg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，上面的例子，我们采用了<code>Hash</code>结构进行存储，<code>Hash</code>结构是一个二维的结构，是一个典型的用空间换取时间的结构。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是如果使用的数据量很小，使用二维结构反而浪费了空间，在时间的性能上也并没有得到太大的提升，还不如直接使用一维结构进行存储。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在查找的时候，虽然复杂度是 <code>O(n)</code>，但是因为数据量少遍历也非常快，增至比<code>Hash</code> 结构本身的查询更快。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果当集合对象的元素不断的增加，或者某个 <code>Value</code> 的值过大，这种小对象存储也会升级生成标准的结构。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis</code> 也可以在配置中进行定义紧凑结构和标准结构的转换参数：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdaaD23JRv9Ekia9yACEasZN28tEgX78RooNTI4cw8SpoHWLYjFNFN1ROluUia69quEUtI4l4Y5pniatg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<h3 id="Quicklist"><a href="#Quicklist" class="headerlink" title="Quicklist"></a>Quicklist</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/UtWdDgynLdaaD23JRv9Ekia9yACEasZN2VKmER3ReJboExfFzO0V1RbZEB7gttwHoAZx61VjUrLu9icLqIN6jvCg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Quicklist</code>数据结构是 <code>Redis</code> 在<code>3.2</code>才引入的一个双向链表的数据结构，确实来说是一个 <code>Ziplist</code>的双向链表。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Quicklist</code> 的每一个数据节点是一个 <code>Ziplist</code>，<code>Ziplist</code>本身就是一个紧凑列表。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假使，<code>Quicklist</code> 包含了 5 个 Ziplist 的节点，每个 <code>Ziplist</code>列表又包含了 5 个数据，那么在外部看来，这个 <code>Quicklist</code> 就包含了 25 个数据项。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/UtWdDgynLdaaD23JRv9Ekia9yACEasZN2luG8JfOic61h6dytADBSiaRichm29fje6lTXiar0C7Q0zL06SaHQyKAXDQ/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p>
<p><code>Quicklist</code> 的结构设计简单总结起来，是一个空间和时间的折中方案：</p>
<ul>
<li>双向链表可以在两端进行 <code>Push</code>和<code>Pop</code> 操作，但是它在每一个节点除了保存自身的数据外，还要保存两个指针，增加额外的内存开销。</li>
</ul>
<p>其次是由于每个节点都是独立的，在内存地址上并不连续，节点多了容易产生内存碎片。</p>
<ul>
<li><code>Ziplist</code> 本身是一块连续的内存，存储和查询效率很高，但是，它不利于修改操作，每次数据变动时都会引发内存 <code>Realloc</code>，如果<code>Ziplist</code>长度很长时，一次 <code>Realloc</code>会导致大批量数据拷贝。</li>
</ul>
<p>所以，结合 <code>Ziplist</code> 和双向链表的优点，<code>Quciklist</code>就孕育而生。</p>
<h3 id="对象共享"><a href="#对象共享" class="headerlink" title="对象共享"></a>对象共享</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis</code>在自己的对象系统中构建了一个引用计数方法，通过这个方法程序可以跟踪对象的引用计数信息，除了可以在适当的时候进行对象释放，还可以用来作为对象共享。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举个例子，假使键 A 创建了一个整数值 100 的字符串作为值对象，这个时候键 B 也创建保存同样整数值 100 的字符串对象作为值对象。</p>
<p>那么在 <code>Redis</code> 的操作时：</p>
<ul>
<li>讲数据库键的指针指向一个现有的值对象。</li>
<li>讲被共享的值对象引用计数加一。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假使，我们的数据库中指向整数值 100 的键不止键 A 和键 B，而是有几百个，那么<code>Redis</code> 服务器中只需要一个字符串对象的内存就可以保存原本需要几百个字符串对象的内存才能保存的数据。</p>
<h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><p><a href="https://mp.weixin.qq.com/s/-6yesAyNmbYtXpnmp14UKA" target="_blank" rel="noopener">吃透了这些Redis知识点，面试官一定觉得你很NB</a></p>
<p><a href="https://mp.weixin.qq.com/s/pnK7-OtEZxncp8mnIz1IaQ" target="_blank" rel="noopener">当面试遇到 Redis，我作为一个面试官是这么“刁难”你的！</a></p>
<p><a href="https://mp.weixin.qq.com/s/LBCgGDFQr4_5KmLx0ytB2A" target="_blank" rel="noopener">你好 Redis，能回答我 7 个问题吗？</a></p>
<p><a href="https://mp.weixin.qq.com/s/mvAkPXBayAzT_RWFdsOt5A" target="_blank" rel="noopener">深圳 GIAC 技术大会 Redis 演讲文字稿</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/22/朋友圈微博feed流，推拉实践/" rel="next" title="朋友圈微博feed流，推拉实践">
                <i class="fa fa-chevron-left"></i> 朋友圈微博feed流，推拉实践
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/27/Git分支管理策略/" rel="prev" title="Git分支管理策略">
                Git分支管理策略 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis面试经典问题集锦"><span class="nav-number">1.</span> <span class="nav-text">Redis面试经典问题集锦</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis有哪些数据结构？"><span class="nav-number">1.1.</span> <span class="nav-text">Redis有哪些数据结构？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据结构而非类型"><span class="nav-number">1.2.</span> <span class="nav-text">数据结构而非类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis常见数据结构的用法"><span class="nav-number">1.3.</span> <span class="nav-text">Redis常见数据结构的用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用过Redis分布式锁么，它是什么回事？"><span class="nav-number">1.4.</span> <span class="nav-text">使用过Redis分布式锁么，它是什么回事？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><span class="nav-number">1.5.</span> <span class="nav-text">假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用过Redis做异步队列么，你是怎么用的？"><span class="nav-number">1.6.</span> <span class="nav-text">使用过Redis做异步队列么，你是怎么用的？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#list"><span class="nav-number">1.6.1.</span> <span class="nav-text">list</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pub-sub"><span class="nav-number">1.6.2.</span> <span class="nav-text">pub/sub</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sortedset"><span class="nav-number">1.6.3.</span> <span class="nav-text">sortedset</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？"><span class="nav-number">1.7.</span> <span class="nav-text">如果有大量的key需要设置同一时间过期，一般需要注意什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis如何做持久化的？"><span class="nav-number">1.8.</span> <span class="nav-text">Redis如何做持久化的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-是如何持久化的"><span class="nav-number">1.9.</span> <span class="nav-text">Redis 是如何持久化的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB"><span class="nav-number">1.9.1.</span> <span class="nav-text">RDB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Fork-机制"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">Fork 机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分裂"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">分裂</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF"><span class="nav-number">1.9.2.</span> <span class="nav-text">AOF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RDB-和-AOF-混合搭配模式"><span class="nav-number">1.9.3.</span> <span class="nav-text">RDB 和 AOF 混合搭配模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pipeline有什么好处，为什么要用pipeline？"><span class="nav-number">1.10.</span> <span class="nav-text">Pipeline有什么好处，为什么要用pipeline？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis的同步机制了解么？"><span class="nav-number">1.11.</span> <span class="nav-text">Redis的同步机制了解么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-是如何实现主从复制"><span class="nav-number">1.12.</span> <span class="nav-text">Redis 是如何实现主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#完整重同步"><span class="nav-number">1.12.1.</span> <span class="nav-text">完整重同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#部分重同步"><span class="nav-number">1.12.2.</span> <span class="nav-text">部分重同步</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#是否使用过Redis集群，集群的原理是什么？"><span class="nav-number">1.13.</span> <span class="nav-text">是否使用过Redis集群，集群的原理是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集群带来的问题与解决思路"><span class="nav-number">1.14.</span> <span class="nav-text">集群带来的问题与解决思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-Cluster的原理"><span class="nav-number">1.14.1.</span> <span class="nav-text">Redis Cluster的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集群对命令操作的取舍"><span class="nav-number">1.14.2.</span> <span class="nav-text">集群对命令操作的取舍</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单线程模型"><span class="nav-number">1.15.</span> <span class="nav-text">单线程模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务"><span class="nav-number">1.16.</span> <span class="nav-text">事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-究竟有没有-ACID-事务"><span class="nav-number">1.17.</span> <span class="nav-text">Redis 究竟有没有 ACID 事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原子性"><span class="nav-number">1.17.1.</span> <span class="nav-text">原子性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#事务队列"><span class="nav-number">1.17.1.1.</span> <span class="nav-text">事务队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为何-Redis-不支持回滚"><span class="nav-number">1.17.1.2.</span> <span class="nav-text">为何 Redis 不支持回滚</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一致性"><span class="nav-number">1.17.2.</span> <span class="nav-text">一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#执行错误是否有确保一致性"><span class="nav-number">1.17.2.1.</span> <span class="nav-text">执行错误是否有确保一致性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#宕机对一致性的影响"><span class="nav-number">1.17.2.2.</span> <span class="nav-text">宕机对一致性的影响</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#再议一致性"><span class="nav-number">1.17.2.3.</span> <span class="nav-text">再议一致性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隔离性"><span class="nav-number">1.17.3.</span> <span class="nav-text">隔离性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#持久性"><span class="nav-number">1.17.4.</span> <span class="nav-text">持久性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">1.17.5.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-的乐观锁-Watch-是怎么实现的"><span class="nav-number">1.18.</span> <span class="nav-text">Redis 的乐观锁 Watch 是怎么实现的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-的-AtomicXXX-的乐观锁机制"><span class="nav-number">1.18.1.</span> <span class="nav-text">Java 的 AtomicXXX 的乐观锁机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-的-Watch-机制"><span class="nav-number">1.18.2.</span> <span class="nav-text">Redis 的 Watch 机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管道"><span class="nav-number">1.19.</span> <span class="nav-text">管道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#协议"><span class="nav-number">1.20.</span> <span class="nav-text">协议</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-是怎么制定过期删除策略的"><span class="nav-number">1.21.</span> <span class="nav-text">Redis 是怎么制定过期删除策略的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定时删除"><span class="nav-number">1.21.1.</span> <span class="nav-text">定时删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#惰性删除"><span class="nav-number">1.21.2.</span> <span class="nav-text">惰性删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定期删除"><span class="nav-number">1.21.3.</span> <span class="nav-text">定期删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结-1"><span class="nav-number">1.21.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-在内存使用上是如何开源节流"><span class="nav-number">1.22.</span> <span class="nav-text">Redis 在内存使用上是如何开源节流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Ziplist"><span class="nav-number">1.22.1.</span> <span class="nav-text">Ziplist</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Quicklist"><span class="nav-number">1.22.2.</span> <span class="nav-text">Quicklist</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象共享"><span class="nav-number">1.22.3.</span> <span class="nav-text">对象共享</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考地址"><span class="nav-number">1.23.</span> <span class="nav-text">参考地址</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
