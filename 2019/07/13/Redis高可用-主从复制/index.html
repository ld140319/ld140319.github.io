<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Redis,">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="Redis高可用-主从复制  原文地址：https://www.cnblogs.com/kismetv/p/9236731.html   一、主从复制概述&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节">
<meta name="keywords" content="Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis高可用-主从复制">
<meta property="og:url" content="http://blog.com/2019/07/13/Redis高可用-主从复制/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="Redis高可用-主从复制  原文地址：https://www.cnblogs.com/kismetv/p/9236731.html   一、主从复制概述&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011219164-269585034.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011229205-1259881734.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011236215-1776355426.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011248863-775666084.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011255637-1820178900.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011302404-417931505.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011309069-1397319420.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011318424-343599365.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011330683-644091604.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011337649-815413808.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011353199-43354413.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011400533-833761023.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011408822-1702643515.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011456793-1960688528.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011502796-1951938935.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011537662-712436367.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011547892-692403928.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011609348-1802555230.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011615849-621207089.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011623772-1032753515.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011630326-1569443208.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011653835-25800141.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011700171-401488218.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011708219-1385546367.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628012000540-1190099498.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628012018427-1532559550.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628012051376-2011129261.png">
<meta property="og:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628012057112-2012438265.png">
<meta property="og:updated_time" content="2019-07-14T15:19:49.509Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis高可用-主从复制">
<meta name="twitter:description" content="Redis高可用-主从复制  原文地址：https://www.cnblogs.com/kismetv/p/9236731.html   一、主从复制概述&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节">
<meta name="twitter:image" content="http://blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011219164-269585034.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/2019/07/13/Redis高可用-主从复制/">





  <title>Redis高可用-主从复制 | 搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/07/13/Redis高可用-主从复制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Redis高可用-主从复制</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-13T12:12:57+08:00">
                2019-07-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Redis高可用-主从复制"><a href="#Redis高可用-主从复制" class="headerlink" title="Redis高可用-主从复制"></a>Redis高可用-主从复制</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://www.cnblogs.com/kismetv/p/9236731.html" target="_blank" rel="noopener">https://www.cnblogs.com/kismetv/p/9236731.html</a></p>
</blockquote>
<p><br></p>
<h2 id="一、主从复制概述"><a href="#一、主从复制概述" class="headerlink" title="一、主从复制概述"></a>一、主从复制概述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主从复制，是指将一台<code>Redis</code>服务器的数据，复制到其他的<code>Redis</code>服务器。前者称为主节点(<code>master</code>)，后者称为从节点(<code>slave</code>)；数据的复制是单向的，只能由主节点到从节点。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认情况下，每台<code>Redis</code>服务器都是主节点；且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点。</p>
<h3 id="主从复制的作用"><a href="#主从复制的作用" class="headerlink" title="主从复制的作用"></a>主从复制的作用</h3><ol>
<li><strong>数据冗余</strong>：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li><strong>故障恢复</strong>：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li>
<li><strong>负载均衡</strong>：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写<code>Redis</code>数据时应用连接主节点，读<code>Redis</code>数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高<code>Redis</code>服务器的并发量。</li>
<li><strong>高可用基石</strong>：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是<code>Redis</code>高可用的基础。</li>
</ol>
<h3 id="主从复制存在的问题"><a href="#主从复制存在的问题" class="headerlink" title="主从复制存在的问题"></a>主从复制存在的问题</h3><ol>
<li><strong>故障切换</strong>：一旦主节点出现故障，需要手动将一个从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令其它从节点去复制新的主节点，这个过程都需要人工干预。</li>
<li>主节点的<strong>写能力</strong>受到单机的限制。</li>
<li>主节点的<strong>存储能力</strong>受到单机的限制。</li>
</ol>
<h2 id="二、如何使用主从复制"><a href="#二、如何使用主从复制" class="headerlink" title="二、如何使用主从复制"></a>二、如何使用主从复制</h2><h3 id="1-建立复制"><a href="#1-建立复制" class="headerlink" title="1. 建立复制"></a>1. 建立复制</h3><p>需要注意，<strong>主从复制的开启，完全是在从节点发起的；不需要我们在主节点做任何事情。</strong></p>
<p>从节点开启主从复制，有3种方式：</p>
<p>（1）配置文件</p>
<p>在从服务器的配置文件中加入：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p>
<p>（2）启动命令</p>
<p><code>redis-server</code>启动命令后加入 <code>--slaveof &lt;masterip&gt; &lt;masterport&gt;</code></p>
<p>（3）客户端命令</p>
<p><code>Redis</code>服务器启动后，直接通过客户端执行命令：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code>，则该<code>Redis</code>实例成为从节点。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上述3种方式是等效的，下面以客户端命令的方式为例，看一下当执行了<code>slave of</code>后，<code>Redis</code>主节点和从节点的变化。</p>
<h3 id="2-实例"><a href="#2-实例" class="headerlink" title="2. 实例"></a>2. 实例</h3><h4 id="准备工作：启动两个节点"><a href="#准备工作：启动两个节点" class="headerlink" title="准备工作：启动两个节点"></a>准备工作：启动两个节点</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方便起见，实验所使用的主从节点是在一台机器上的不同<code>Redis</code>实例，其中主节点监听<code>6379</code>端口，从节点监听<code>6380</code>端口；从节点监听的端口号可以在配置文件中修改：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011219164-269585034.png" alt="img"></p>
<p>启动后可以看到：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011229205-1259881734.png" alt="img"></p>
<p>两个<code>Redis</code>节点启动后（分别称为6379节点和6380节点），默认都是主节点。</p>
<h4 id="建立复制"><a href="#建立复制" class="headerlink" title="建立复制"></a>建立复制</h4><p>此时在6380节点执行<code>slaveof</code>命令，使之变为从节点：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011236215-1776355426.png" alt="img"></p>
<h4 id="观察效果"><a href="#观察效果" class="headerlink" title="观察效果"></a>观察效果</h4><p>下面验证一下，在主从复制建立后，主节点的数据会复制到从节点中。</p>
<p>（1）首先在从节点查询一个不存在的<code>key</code>：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011248863-775666084.png" alt="img"></p>
<p>（2）然后在主节点中增加这个<code>key</code>：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011255637-1820178900.png" alt="img"></p>
<p>（3）此时在从节点中再次查询这个<code>key</code>，会发现主节点的操作已经同步至从节点：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011302404-417931505.png" alt="img"></p>
<p>（4）然后在主节点删除这个<code>key</code>：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011309069-1397319420.png" alt="img"></p>
<p>（5）此时在从节点中再次查询这个<code>key</code>，会发现主节点的操作已经同步至从节点：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011318424-343599365.png" alt="img"></p>
<h3 id="3-断开复制"><a href="#3-断开复制" class="headerlink" title="3. 断开复制"></a>3. 断开复制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code>命令建立主从复制关系以后，可以通过<code>slaveof no one</code>断开。需要注意的是，<strong>从节点断开复制后，不会删除已有的数据，只是不再接受主节点新的数据变化</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从节点执行<code>slaveof no one</code>后，打印日志如下所示；可以看出断开复制后，从节点又变回为主节点。</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011330683-644091604.png" alt="img"></p>
<p>主节点打印日志如下：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011337649-815413808.png" alt="img"></p>
<h2 id="三、主从复制的实现原理"><a href="#三、主从复制的实现原理" class="headerlink" title="三、主从复制的实现原理"></a>三、主从复制的实现原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主从复制过程大体可以分为3个阶段：<strong>连接建立阶段（即准备阶段）、数据同步阶段、命令传播阶段</strong>；下面分别进行介绍。</p>
<h3 id="1-连接建立阶段"><a href="#1-连接建立阶段" class="headerlink" title="1. 连接建立阶段"></a>1. 连接建立阶段</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该阶段的主要作用是在主从节点之间建立连接，为数据同步做好准备。</p>
<h4 id="步骤1：保存主节点信息"><a href="#步骤1：保存主节点信息" class="headerlink" title="步骤1：保存主节点信息"></a>步骤1：保存主节点信息</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从节点服务器内部维护了两个字段，即<code>master_host</code>和<code>master_port</code>字段，用于存储主节点的<code>ip</code>和<code>port</code>信息。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是，<code>slaveof</code>是<strong>异步命令</strong>，从节点完成主节点<code>ip</code>和<code>port</code>的保存后，向发送<code>slaveof</code>命令的客户端直接返回<code>OK</code>，实际的复制操作在这之后才开始进行。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个过程中，可以看到从节点打印日志如下：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011353199-43354413.png" alt="img"></p>
<h4 id="步骤2：建立socket连接"><a href="#步骤2：建立socket连接" class="headerlink" title="步骤2：建立socket连接"></a>步骤2：建立socket连接</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从节点每秒1次调用复制定时函数<code>replicationCron()</code>，如果发现了有主节点可以连接，便会根据主节点的<code>ip</code>和port，创建<code>socket</code>连接。如果连接成功，则：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从节点：为该<code>socket</code>建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收<code>RDB</code>文件、接收命令传播等。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主节点：接收到从节点的<code>socket</code>连接后（即<code>accept</code>之后），为该<code>socket</code>创建相应的客户端状态，<strong>并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行。</strong></p>
<p>这个过程中，从节点打印日志如下：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011400533-833761023.png" alt="img"></p>
<h4 id="步骤3：发送ping命令"><a href="#步骤3：发送ping命令" class="headerlink" title="步骤3：发送ping命令"></a>步骤3：发送ping命令</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从节点成为主节点的客户端之后，发送<code>ping</code>命令进行首次请求，目的是：检查<code>socket</code>连接是否可用，以及主节点当前是否能够处理请求。</p>
<p>从节点发送<code>ping</code>命令后，可能出现3种情况：</p>
<p>（1）返回<code>pong</code>：说明<code>socket</code>连接正常，且主节点当前可以处理请求，复制过程继续。</p>
<p>（2）超时：一定时间后从节点仍未收到主节点的回复，说明<code>socket</code>连接不可用，则从节点断开<code>socket</code>连接，并重连。</p>
<p>（3）返回<code>pong</code>以外的结果：如果主节点返回其他结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开<code>socket</code>连接，并重连。</p>
<p>在主节点返回<code>pong</code>情况下，从节点打印日志如下：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011408822-1702643515.png" alt="img"></p>
<h4 id="步骤4：身份验证"><a href="#步骤4：身份验证" class="headerlink" title="步骤4：身份验证"></a>步骤4：身份验证</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果从节点中设置了<code>masterauth</code>选项，则从节点需要向主节点进行身份验证；没有设置该选项，则不需要验证。从节点进行身份验证是通过向主节点发送<code>auth</code>命令进行的，<code>auth</code>命令的参数即为配置文件中的<code>masterauth</code>的值。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果主节点设置密码的状态，与从节点<code>masterauth</code>的状态一致（一致是指都存在，且密码相同，或者都不存在），则身份验证通过，复制过程继续；如果不一致，则从节点断开<code>socket</code>连接，并重连。</p>
<h4 id="步骤5：发送从节点端口信息"><a href="#步骤5：发送从节点端口信息" class="headerlink" title="步骤5：发送从节点端口信息"></a>步骤5：发送从节点端口信息</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;身份验证之后，从节点会向主节点发送其监听的端口号（前述例子中为6380），主节点将该信息保存到该从节点对应的客户端的<code>slave_listening_port</code>字段中；该端口信息除了在主节点中执行<code>info Replication</code>时显示以外，没有其他作用。</p>
<h3 id="2-数据同步阶段"><a href="#2-数据同步阶段" class="headerlink" title="2. 数据同步阶段"></a>2. 数据同步阶段</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。</p>
<p>具体执行的方式是：从节点向主节点发送<code>psync</code>命令（<code>Redis2.8</code>以前是<code>sync</code>命令），开始同步。</p>
<p>数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为全量复制和部分复制，下面会有一章专门讲解这两种复制方式以及<code>psync</code>命令的执行过程，这里不再详述。</p>
<p>需要注意的是，在数据同步阶段之前，从节点是主节点的客户端，主节点不是从节点的客户端；而到了这一阶段及以后，主从节点互为客户端。</p>
<p>原因在于：在此之前，主节点只需要响应从节点的请求即可，不需要主动发请求，而在数据同步阶段和后面的命令传播阶段，主节点需要主动向从节点发送请求（如推送缓冲区中的写命令），才能完成复制。</p>
<h3 id="3-命令传播阶段"><a href="#3-命令传播阶段" class="headerlink" title="3. 命令传播阶段"></a>3. 命令传播阶段</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段<strong>主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在命令传播阶段，除了发送写命令，<strong>主从节点还维持着心跳机制</strong>：<code>PING</code>和<code>REPLCONF ACK</code>。</p>
<p><strong>延迟与不一致</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要注意的是，<strong>命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复</strong>；因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的<code>repl-disable-tcp-nodelay</code>配置等有关。</p>
<blockquote>
<p><code>repl-disable-tcp-nodelay no</code>：该配置作用于命令传播阶段，控制主节点是否禁止与从节点的<code>TCP_NODELAY</code>；默认<code>no</code>，即不禁止<code>TCP_NODELAY</code>。当设置为<code>yes</code>时，<code>TCP</code>会对包进行合并从而减少带宽，但是发送的频率会降低，从节点数据延迟增加，一致性变差；具体发送频率与<code>Linux</code>内核的配置有关，默认配置为<code>40ms</code>。当设置为<code>no</code>时，<code>TCP</code>会立马将主节点的数据发送给从节点，带宽增加但延迟变小。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般来说，只有当应用对<code>Redis</code>数据不一致的容忍度较高，且主从节点之间网络状况不好时，才会设置为<code>yes</code>；多数情况使用默认值<code>no</code>。</p>
<h2 id="四、【数据同步阶段】全量复制和部分复制"><a href="#四、【数据同步阶段】全量复制和部分复制" class="headerlink" title="四、【数据同步阶段】全量复制和部分复制"></a>四、【数据同步阶段】全量复制和部分复制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>Redis2.8</code>以前，从节点向主节点发送<code>sync</code>命令请求同步数据，此时的同步方式是全量复制；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>Redis2.8</code>及以后，从节点可以发送<code>psync</code>命令请求同步数据，此时根据主从节点当前状态的不同，同步方式可能是全量复制或部分复制。</p>
<ol>
<li>全量复制：用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。</li>
<li>部分复制：<strong>用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点</strong>，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，导致主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。</li>
</ol>
<h3 id="1-全量复制"><a href="#1-全量复制" class="headerlink" title="1. 全量复制"></a>1. 全量复制</h3><p><code>Redis</code>通过<code>psync</code>命令进行全量复制的过程如下：</p>
<p>（1）从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行全量复制；</p>
<p>（2）<strong>主节点收到全量复制的命令后，执行<code>bgsave</code>，在后台生成<code>RDB</code>文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令</strong>；</p>
<p>（3）主节点的<code>bgsave</code>执行完成后，将<code>RDB</code>文件发送给从节点；<strong>从节点首先清除自己的旧数据，然后载入接收的RDB文件</strong>，将数据库状态更新至主节点执行<code>bgsave</code>时的数据库状态；</p>
<p>（4）<strong>主节点将复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态</strong>；</p>
<p>（5）如果从节点开启了<code>AOF</code>，则会触发<code>bgrewriteaof</code>的执行，从而保证<code>AOF</code>文件更新至主节点的最新状态；</p>
<p>下面是执行全量复制时，主从节点打印的日志；可以看出日志内容与上述步骤是完全对应的。</p>
<p>主节点的打印日志如下：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011456793-1960688528.png" alt="img"></p>
<p>从节点打印日志如下图所示：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011502796-1951938935.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其中，有几点需要注意：从节点接收了来自主节点的<code>89260</code>个字节的数据；从节点在载入主节点的数据之前要先将老数据清除；从节点在同步完数据后，调用了<code>bgrewriteaof</code>。</p>
<p>通过全量复制的过程可以看出，全量复制是非常重型的操作：</p>
<p>（1）主节点通过<code>bgsave</code>命令<code>fork</code>子进程进行<code>RDB</code>持久化，该过程是非常消耗<code>CPU</code>、内存(页表复制)、硬盘<code>IO</code>的；</p>
<p>（2）主节点通过网络将<code>RDB</code>文件发送给从节点，对主从节点的带宽都会带来很大的消耗；</p>
<p>（3）从节点清空老数据、载入新<code>RDB</code>文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行<code>bgrewriteaof</code>，也会带来额外的消耗；</p>
<h3 id="2-部分复制"><a href="#2-部分复制" class="headerlink" title="2. 部分复制"></a>2. 部分复制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于全量复制在主节点数据量较大时效率太低，因此<code>Redis2.8</code>开始提供部分复制，用于处理网络中断时的数据同步。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;部分复制的实现，依赖于三个重要的概念：</p>
<h4 id="（1）复制偏移量"><a href="#（1）复制偏移量" class="headerlink" title="（1）复制偏移量"></a>（1）复制偏移量</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主节点和从节点分别维护一个复制偏移量（<code>offset</code>），代表的是<strong>主节点向从节点传递的字节数</strong>；主节点每次向从节点传播N个字节数据时，主节点的<code>offset</code>增加N；从节点每次收到主节点传来的N个字节数据时，从节点的<code>offset</code>增加N。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>offset</code>用于判断主从节点的数据库状态是否一致</strong>，如果二者<code>offset</code>相同，则一致；如果<code>offset</code>不同，则不一致，此时可以根据两个<code>offset</code>找出从节点缺少的那部分数据。</p>
<blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，如果主节点的offset是1000，而从节点的offset是500，那么部分复制就需要将offset为501-1000的数据传递给从节点。而offset为501-1000的数据存储的位置，就是下面要介绍的复制积压缓冲区。</p>
</blockquote>
<h4 id="（2）复制积压缓冲区"><a href="#（2）复制积压缓冲区" class="headerlink" title="（2）复制积压缓冲区"></a>（2）复制积压缓冲区</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>复制积压缓冲区是由主节点维护的、固定长度的、先进先出(FIFO)队列，默认大小1MB；</strong>当主节点开始有从节点时创建，其作用是备份主节点最近发送给从节点的数据。注意，无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份；除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量（<code>offset</code>）。<strong>由于复制积压缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于该缓冲区长度固定且有限，因此可以备份的写命令也有限，<strong>当主从节点<code>offset</code>的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制</strong>。反过来说，为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置<code>repl-backlog-size</code>)；例如如果网络中断的平均时间是<code>60s</code>，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为<code>100KB</code>，则复制积压缓冲区的平均需求为<code>6MB</code>，保险起见，可以设置为<code>12MB</code>，来保证绝大多数断线情况都可以使用部分复制。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从节点将<code>offset</code>发送给主节点后，主节点根据<code>offset</code>和缓冲区大小决定能否执行部分复制：</p>
<ul>
<li><strong>如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制</strong>；</li>
<li><strong>如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制</strong>；</li>
</ul>
<h4 id="（3）服务器运行ID-runid"><a href="#（3）服务器运行ID-runid" class="headerlink" title="（3）服务器运行ID(runid)"></a>（3）服务器运行ID(runid)</h4><blockquote>
<p>单纯的通过ip和port无法判断主节点是否重启过，如果主节点整体重启替换了数据集（替换RDB/AOF文件），那么对于从节点再基于偏移量来复制数据是不安全的</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个<code>Redis</code>节点(无论主从)，<strong>在启动时都会自动生成一个随机ID(每次启动都不一样)，由40个随机的十六进制字符组成</strong>；<code>runid</code>用来唯一识别一个<code>Redis</code>节点。通过<code>info Server</code>命令，可以查看节点的<code>runid</code>：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011537662-712436367.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主从节点初次复制时，主节点将自己的<code>runid</code>发送给从节点，从节点将这个<code>runid</code>保存起来；当断线重连时，从节点会将这个<code>runid</code>发送给主节点；主节点根据<code>runid</code>判断能否进行部分复制：</p>
<ul>
<li><p>如果从节点保存的<code>runid</code>与主节点现在的<code>runid</code>相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</p>
</li>
<li><p>如果<strong>从节点保存的<code>runid</code>与主节点现在的<code>runid</code>不同</strong>，说明从节点在断线前同步的<code>Redis</code>节点并不是当前的主节点，<strong>只能进行全量复制</strong>。</p>
</li>
</ul>
<h3 id="3-psync命令的执行"><a href="#3-psync命令的执行" class="headerlink" title="3. psync命令的执行"></a>3. psync命令的执行</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在了解了复制偏移量、复制积压缓冲区、节点运行id之后，本节将介绍psync命令的参数和返回值，从而说明<code>psync</code>命令执行过程中，主从节点是如何确定使用全量复制还是部分复制的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>psync</code>命令的执行过程可以参见下图：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011547892-692403928.png" alt="img"> </p>
<p>（1）首先，从节点根据当前状态，决定如何调用<code>psync</code>命令：</p>
<ul>
<li>如果从节点之前未执行过<code>slaveof</code>或最近执行了<code>slaveof no one</code>，则从节点发送命令为<code>psync ? -1</code>，向主节点请求全量复制；</li>
<li>如果从节点之前执行了<code>slaveof</code>，则发送命令为<code>psync &lt;runid&gt; &lt;offset&gt;</code>，其中<code>runid</code>为上次复制的主节点的<code>runid</code>，<code>offset</code>为上次复制截止时从节点保存的复制偏移量。</li>
</ul>
<p>（2）主节点根据收到的<code>psync</code>命令，及当前服务器状态，决定执行全量复制还是部分复制：</p>
<ul>
<li>如果主节点版本低于<code>Redis2.8</code>，则返回<code>-ERR</code>回复，此时从节点重新发送<code>sync</code>命令执行全量复制；</li>
<li><strong>如果主节点版本够新，且<code>runid</code>与从节点发送的<code>runid</code>相同，且从节点发送的<code>offset</code>之后的数据在复制积压缓冲区中都存在，则回复<code>+CONTINUE</code>，表示将进行部分复制，从节点等待主节点发送其缺少的数据即可</strong>；</li>
<li>如果主节点版本够新，但是<code>runid</code>与从节点发送的<code>runid</code>不同，或从节点发送的<code>offset</code>之后的数据已不在复制积压缓冲区中(在队列中被挤出了)，则回复<code>+FULLRESYNC &lt;runid&gt; &lt;offset&gt;</code>，表示要进行全量复制，其中<code>runid</code>表示主节点当前的<code>runid</code>，<code>offset</code>表示主节点当前的<code>offset</code>，从节点保存这两个值，以备使用。</li>
</ul>
<h3 id="4-部分复制演示"><a href="#4-部分复制演示" class="headerlink" title="4. 部分复制演示"></a>4. 部分复制演示</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在下面的演示中，网络中断几分钟后恢复，断开连接的主从节点进行了部分复制；为了便于模拟网络中断，本例中的主从节点在局域网中的两台机器上。</p>
<p><strong>网络中断</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网络中断一段时间后，主节点和从节点都会发现失去了与对方的连接（关于主从节点对超时的判断机制，后面会有说明）；此后，从节点便开始执行对主节点的重连，由于此时网络还没有恢复，重连失败，从节点会一直尝试重连。</p>
<p>主节点日志如下：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011609348-1802555230.png" alt="img"></p>
<p>从节点日志如下：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011615849-621207089.png" alt="img"></p>
<p><strong>网络恢复</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;网络恢复后，从节点连接主节点成功，并请求进行部分复制，主节点接收请求后，二者进行部分复制以同步数据。</p>
<p>主节点日志如下：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011623772-1032753515.png" alt="img"></p>
<p>从节点日志如下：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011630326-1569443208.png" alt="img"></p>
<h2 id="五、【命令传播阶段】心跳机制"><a href="#五、【命令传播阶段】心跳机制" class="headerlink" title="五、【命令传播阶段】心跳机制"></a>五、【命令传播阶段】心跳机制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：<code>PING</code>和<code>REPLCONF ACK</code>。心跳机制对于主从复制的超时判断、数据安全等有作用。</p>
<h3 id="1-主-gt-从：PING"><a href="#1-主-gt-从：PING" class="headerlink" title="1.主-&gt;从：PING"></a>1.主-&gt;从：PING</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每隔指定的时间，<strong>主节点会向从节点发送PING命令</strong>，这个<code>PING</code>命令的作用，主要是为了<strong>让从节点进行超时判断</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>PING</code>发送的频率由<code>repl-ping-slave-period</code>参数控制，单位是秒，默认值是<code>10s</code></strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于该<code>PING</code>命令究竟是由主节点发给从节点，还是相反，有一些争议；因为在<code>Redis</code>的官方文档中，对该参数的注释中说明是从节点向主节点发送<code>PING</code>命令，如下图所示：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011653835-25800141.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是根据该参数的名称(含有<code>ping-slave</code>)，以及代码实现，我认为该<code>PING</code>命令是主节点发给从节点的。相关代码如下：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011700171-401488218.png" alt="img"></p>
<h3 id="2-从-gt-主：REPLCONF-ACK"><a href="#2-从-gt-主：REPLCONF-ACK" class="headerlink" title="2. 从-&gt;主：REPLCONF ACK"></a>2. 从-&gt;主：REPLCONF ACK</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在命令传播阶段，<strong>从节点会向主节点发送REPLCONF ACK命令，频率是每秒1次</strong>；命令格式为：<code>REPLCONF ACK {offset}</code>，其中<code>offset</code>指从节点保存的复制偏移量。<code>REPLCONF ACK</code>命令的作用包括：</p>
<p>（1）<strong>实时监测主从节点网络状态：该命令会被主节点用于复制超时的判断</strong>。此外，在主节点中使用<code>info Replication</code>，可以看到其从节点的状态中的<code>lag</code>值，代表的是主节点上次收到该<code>REPLCONF ACK</code>命令的时间间隔，在正常情况下，该值应该是0或1，如下图所示：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628011708219-1385546367.png" alt="img"></p>
<p>（2）<strong>检测命令丢失</strong>：从节点发送了自身的<code>offset</code>，主节点会与自己的<code>offset</code>对比，如果从节点数据缺失（如网络丢包），主节点会推送缺失的数据（这里也会利用复制积压缓冲区）。<strong>注意，offset和复制积压缓冲区，不仅可以用于部分复制，也可以用于处理命令丢失等情形</strong>；区别在于前者是在断线重连后进行的，而后者是在主从节点没有断线的情况下进行的。</p>
<p>（3）<strong>辅助保证从节点的数量和延迟</strong>：<code>Redis</code>主节点中使用<code>min-slaves-to-write</code>和<code>min-slaves-max-lag</code>参数，来<strong>保证主节点在不安全的情况下不会执行写命令；所谓不安全，是指从节点数量太少，或延迟过高</strong>。</p>
<blockquote>
<p>例如<code>min-slaves-to-write</code>和<code>min-slaves-max-lag</code>分别是3和10，含义是如果从节点数量小于3个，或所有从节点的延迟值都大于10s，则主节点拒绝执行写命令。而这里从节点延迟值的获取，就是通过主节点接收到<code>REPLCONF ACK</code>命令的时间来判断的，即前面所说的<code>info Replication</code>中的<code>lag</code>值。</p>
</blockquote>
<h2 id="六、应用中的问题"><a href="#六、应用中的问题" class="headerlink" title="六、应用中的问题"></a>六、应用中的问题</h2><h3 id="1-读写分离及其中的问题"><a href="#1-读写分离及其中的问题" class="headerlink" title="1. 读写分离及其中的问题"></a>1. 读写分离及其中的问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在主从复制基础上实现的读写分离，可以实现<code>Redis</code>的读负载均衡：由主节点提供写服务，由一个或多个从节点提供读服务（多个从节点既可以提高数据冗余程度，也可以最大化读负载能力）；在读负载较大的应用场景下，可以大大提高<code>Redis</code>服务器的并发量。下面介绍在使用<code>Redis</code>读写分离时，需要注意的问题。</p>
<h4 id="（1）延迟与不一致问题"><a href="#（1）延迟与不一致问题" class="headerlink" title="（1）延迟与不一致问题"></a>（1）延迟与不一致问题</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于主从复制的命令传播是异步的，延迟与数据的不一致不可避免。如果应用对数据不一致的接受程度程度较低，可能的优化措施包括：优化主从节点之间的网络环境（如在同机房部署）；监控主从节点延迟（通过<code>offset</code>）判断，如果从节点延迟过大，通知应用不再通过该从节点读取数据；使用集群同时扩展写负载和读负载等。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在命令传播阶段以外的其他情况下，从节点的数据不一致可能更加严重，例如连接在数据同步阶段，或从节点失去与主节点的连接时等。从节点的<code>slave-serve-stale-data</code>参数便与此有关：它控制这种情况下从节点的表现；如果为<code>yes</code>（默认值），则从节点仍能够响应客户端的命令，如果为<code>no</code>，则从节点只能响应<code>info</code>、<code>slaveof</code>等少数命令。该参数的设置与应用对数据一致性的要求有关；如果对数据一致性要求很高，则应设置为<code>no</code>。</p>
<h4 id="（2）数据过期问题"><a href="#（2）数据过期问题" class="headerlink" title="（2）数据过期问题"></a>（2）数据过期问题</h4><p>在单机版<code>Redis</code>中，存在两种删除策略：</p>
<ul>
<li>惰性删除：服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除。</li>
<li>定期删除：服务器执行定时任务删除过期数据，但是考虑到内存和CPU的折中（删除会释放内存，但是频繁的删除操作对CPU不友好），该删除的频率和执行时间都受到了限制。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在主从复制场景下，为了主从节点的数据一致性，从节点不会主动删除数据，而是由主节点控制从节点中过期数据的删除。由于主节点的惰性删除和定期删除策略，都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过<code>Redis</code>从节点读取数据时，很容易读取到已经过期的数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Redis 3.2</code>中，从节点在读取数据时，增加了对数据是否过期的判断：如果该数据已过期，则不返回给客户端；将<code>Redis</code>升级到<code>3.2</code>可以解决数据过期问题。</p>
<h4 id="（3）故障切换问题"><a href="#（3）故障切换问题" class="headerlink" title="（3）故障切换问题"></a>（3）故障切换问题</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在没有使用哨兵的读写分离场景下，应用针对读和写分别连接不同的<code>Redis</code>节点；当主节点或从节点出现问题而发生更改时，需要及时修改应用程序读写<code>Redis</code>数据的连接；连接的切换可以手动进行，或者自己写监控程序进行切换，但前者响应慢、容易出错，后者实现复杂，成本都不算低。</p>
<h4 id="（4）总结"><a href="#（4）总结" class="headerlink" title="（4）总结"></a>（4）总结</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用读写分离之前，可以考虑其他方法增加<code>Redis</code>的读负载能力：如尽量优化主节点（减少慢查询、减少持久化等其他情况带来的阻塞等）提高负载能力；使用<code>Redis</code>集群同时提高读负载能力和写负载能力等。如果使用读写分离，可以使用哨兵，使主从节点的故障切换尽可能自动化，并减少对应用程序的侵入。</p>
<h3 id="2-复制超时问题"><a href="#2-复制超时问题" class="headerlink" title="2. 复制超时问题"></a>2. 复制超时问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主从节点复制超时是导致复制中断的最重要的原因之一。</p>
<h4 id="超时判断意义"><a href="#超时判断意义" class="headerlink" title="超时判断意义"></a>超时判断意义</h4><p>在复制连接建立过程中及之后，主从节点都有机制判断连接是否超时，其意义在于：</p>
<p>（1）如果主节点判断连接超时，其会释放相应从节点的连接，从而<strong>释放各种资源</strong>，否则无效的从节点仍会占用主节点的各种资源（输出缓冲区、带宽、连接等）；</p>
<p>（2）连接超时的判断可以让主节点更准确的知道当前有效从节点的个数，<strong>有助于保证数据安全</strong>（配合前面讲到的<code>min-slaves-to-write</code>等参数）。</p>
<p>（2）如果从节点判断连接超时，则可以及时重新建立连接，<strong>避免与主节点数据长期的不一致</strong>。</p>
<h4 id="判断机制"><a href="#判断机制" class="headerlink" title="判断机制"></a>判断机制</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>主从复制超时判断的核心，在于<code>repl-timeout</code>参数，该参数规定了超时时间的阈值（默认60s），对于主节点和从节点同时有效</strong>；主从节点触发超时的条件分别如下：</p>
<p>（1）主节点：每秒1次调用复制定时函数<code>replicationCron()</code>，在其中判断当前时间距离上次收到各个从节点<code>REPLCONF ACK</code>的时间，是否超过了<code>repl-timeout</code>值，如果超过了则释放相应从节点的连接。</p>
<p>（2）从节点：从节点对超时的判断同样是在复制定时函数中判断，基本逻辑是：</p>
<ul>
<li>如果当前处于连接建立阶段，且距离上次收到主节点的信息的时间已超过<code>repl-timeout</code>，则释放与主节点的连接；</li>
<li>如果当前处于数据同步阶段，且收到主节点的<code>RDB</code>文件的时间超时，则停止数据同步，释放连接；</li>
<li>如果当前处于命令传播阶段，且距离上次收到主节点的<code>PING</code>命令或数据的时间已超过<code>repl-timeout</code>值，则释放与主节点的连接。</li>
</ul>
<p>主从节点判断连接超时的相关源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Replication cron function, called 1 time per second. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationCron</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span> replication_cron_loops = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Non blocking connection timeout? */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp;</span><br><span class="line">        (server.repl_state == REDIS_REPL_CONNECTING ||</span><br><span class="line">         slaveIsInHandshakeState()) &amp;&amp;</span><br><span class="line">         (time(<span class="literal">NULL</span>)-server.repl_transfer_lastio) &gt; server.repl_timeout)</span><br><span class="line">    &#123;</span><br><span class="line">        redisLog(REDIS_WARNING,<span class="string">"Timeout connecting to the MASTER..."</span>);</span><br><span class="line">        undoConnectWithMaster();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Bulk transfer I/O timeout? */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state == REDIS_REPL_TRANSFER &amp;&amp;</span><br><span class="line">        (time(<span class="literal">NULL</span>)-server.repl_transfer_lastio) &gt; server.repl_timeout)</span><br><span class="line">    &#123;</span><br><span class="line">        redisLog(REDIS_WARNING,<span class="string">"Timeout receiving bulk data from MASTER... If the problem persists try to set the 'repl-timeout' parameter in redis.conf to a larger value."</span>);</span><br><span class="line">        replicationAbortSyncTransfer();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Timed out master when we are an already connected slave? */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state == REDIS_REPL_CONNECTED &amp;&amp;</span><br><span class="line">        (time(<span class="literal">NULL</span>)-server.master-&gt;lastinteraction) &gt; server.repl_timeout)</span><br><span class="line">    &#123;</span><br><span class="line">        redisLog(REDIS_WARNING,<span class="string">"MASTER timeout: no data nor PING received..."</span>);</span><br><span class="line">        freeClient(server.master);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//此处省略无关代码……</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Disconnect timedout slaves. */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.slaves)) &#123;</span><br><span class="line">        listIter li;</span><br><span class="line">        listNode *ln;</span><br><span class="line">        listRewind(server.slaves,&amp;li);</span><br><span class="line">        <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            redisClient *slave = ln-&gt;value;</span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;replstate != REDIS_REPL_ONLINE) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;flags &amp; REDIS_PRE_PSYNC) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((server.unixtime - slave-&gt;repl_ack_time) &gt; server.repl_timeout)</span><br><span class="line">            &#123;</span><br><span class="line">                redisLog(REDIS_WARNING, <span class="string">"Disconnecting timedout slave: %s"</span>,</span><br><span class="line">                    replicationGetSlaveName(slave));</span><br><span class="line">                freeClient(slave);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//此处省略无关代码……</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　</p>
<h4 id="需要注意的坑"><a href="#需要注意的坑" class="headerlink" title="需要注意的坑"></a>需要注意的坑</h4><p>下面介绍与复制阶段连接超时有关的一些实际问题：</p>
<p>（1）<strong>数据同步阶段</strong>：在主从节点进行全量复制<code>bgsave</code>时，主节点需要首先<code>fork</code>子进程将当前数据保存到<code>RDB</code>文件中，然后再将<code>RDB</code>文件通过网络传输到从节点。如果<code>RDB</code>文件过大，主节点在<code>fork</code>子进程+保存<code>RDB</code>文件时耗时过多，可能会导致从节点长时间收不到数据而触发超时；此时从节点会重连主节点，然后再次全量复制，再次超时，再次重连……这是个悲伤的循环。为了避免这种情况的发生，除了<strong>注意<code>Redis</code>单机数据量不要过大，另一方面就是适当增大<code>repl-timeout</code>值，具体的大小可以根据<code>bgsave</code>耗时来调整</strong>。</p>
<p>（2）<strong>命令传播阶段</strong>：如前所述，在该阶段主节点会向从节点发送<code>PING</code>命令，频率由<code>repl-ping-slave-period</code>控制；该参数应明显小于<code>repl-timeout</code>值(后者至少是前者的几倍)。否则，<strong>如果两个参数相等或接近，网络抖动导致个别<code>PING</code>命令丢失，此时恰巧主节点也没有向从节点发送数据，则从节点很容易判断超时</strong>。</p>
<p>（3）<strong>慢查询导致的阻塞</strong>：如果主节点或从节点执行了一些慢查询（如<code>keys *</code>或者对大数据的<code>hgetall</code>等），导致服务器阻塞；<strong>阻塞期间无法响应复制连接中对方节点的请求，可能导致复制超时</strong>。</p>
<h3 id="3-复制中断问题"><a href="#3-复制中断问题" class="headerlink" title="3. 复制中断问题"></a>3. 复制中断问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主从节点超时是复制中断的原因之一，除此之外，还有其他情况可能导致复制中断，其中最主要的是复制缓冲区溢出问题。</p>
<h4 id="复制缓冲区溢出"><a href="#复制缓冲区溢出" class="headerlink" title="复制缓冲区溢出"></a>复制缓冲区溢出</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前面曾提到过，在全量复制阶段，主节点会将执行的写命令放到复制缓冲区中，该缓冲区存放的数据包括了以下几个时间段内主节点执行的写命令：<code>bgsave</code>生成<code>RDB</code>文件、<code>RDB</code>文件由主节点发往从节点、从节点清空老数据并载入<code>RDB</code>文件中的数据。当主节点数据量较大，或者主从节点之间网络延迟较大时，可能导致该缓冲区的大小超过了限制，此时主节点会断开与从节点之间的连接；这种情况可能引起全量复制-&gt;复制缓冲区溢出导致连接中断-&gt;重连-&gt;全量复制-&gt;复制缓冲区溢出导致连接中断……的循环。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;复制缓冲区的大小由<code>client-output-buffer-limit slave {hard limit} {soft limit} {soft seconds}</code>配置，默认值为<code>client-output-buffer-limit slave 256MB 64MB 60</code>，其含义是：如果<code>buffer</code>大于256MB，或者连续60s大于64MB，则主节点会断开与该从节点的连接。该参数是可以通过<code>config set</code>命令动态配置的（即不重启<code>Redis</code>也可以生效）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当复制缓冲区溢出时，主节点打印日志如下所示：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628012000540-1190099498.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>需要注意的是，复制缓冲区是客户端输出缓冲区的一种，主节点会为每一个从节点分别分配复制缓冲区；而复制积压缓冲区则是一个主节点只有一个，无论它有多少个从节点。</strong></p>
<h3 id="4-各场景下复制的选择及优化技巧"><a href="#4-各场景下复制的选择及优化技巧" class="headerlink" title="4. 各场景下复制的选择及优化技巧"></a>4. 各场景下复制的选择及优化技巧</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在介绍了<code>Redis</code>复制的种种细节之后，现在我们可以来总结一下，在下面常见的场景中，何时使用部分复制，以及需要注意哪些问题。</p>
<h4 id="（1）第一次建立复制"><a href="#（1）第一次建立复制" class="headerlink" title="（1）第一次建立复制"></a>（1）第一次建立复制</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此时全量复制不可避免，但仍有几点需要注意：</p>
<ol>
<li><strong>如果主节点的数据量较大，应该尽量避开流量的高峰期，避免造成阻塞</strong>；</li>
<li><strong>如果有多个从节点需要建立对主节点的复制，可以考虑将几个从节点错开，避免主节点带宽占用过大</strong>。</li>
<li><strong>如果从节点过多，也可以调整主从复制的拓扑结构，由一主多从结构变为树状结构</strong>（中间的节点既是其主节点的从节点，也是其从节点的主节点）；但使用树状结构应该谨慎：虽然主节点的直接从节点减少，降低了主节点的负担，但是多层从节点的延迟增大，数据一致性变差；且结构复杂，维护相当困难。</li>
</ol>
<h4 id="（2）主节点重启"><a href="#（2）主节点重启" class="headerlink" title="（2）主节点重启"></a>（2）主节点重启</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主节点重启可以分为两种情况来讨论，一种是故障导致宕机，另一种则是有计划的重启。</p>
<h5 id="主节点宕机"><a href="#主节点宕机" class="headerlink" title="主节点宕机"></a>主节点宕机</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主节点宕机重启后，<code>runid</code>会发生变化，因此不能进行部分复制，只能全量复制。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上<strong>在主节点宕机的情况下，应进行故障转移处理，将其中的一个从节点升级为主节点，其他从节点从新的主节点进行复制；且故障转移应尽量的自动化</strong>。</p>
<h5 id="安全重启：debug-reload"><a href="#安全重启：debug-reload" class="headerlink" title="安全重启：debug reload"></a>安全重启：debug reload</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一些场景下，可能希望对主节点进行重启，例如主节点内存碎片率过高，或者希望调整一些只能在启动时调整的参数。如果使用普通的手段重启主节点，会使得<code>runid</code>发生变化，可能导致不必要的全量复制。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解决这个问题，<code>Redis</code>提供了<code>debug reload</code>的重启方式：<strong>重启后，主节点的runid和offset都不受影响，</strong>避免了全量复制。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下图所示，<code>debug reload</code>重启后<code>runid</code>和<code>offset</code>都未受影响：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628012018427-1532559550.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但<code>debug reload</code>是一柄双刃剑：<strong>它会清空当前内存中的数据，重新从RDB文件中加载，这个过程会导致主节点的阻塞，因此也需要谨慎</strong>。</p>
<h4 id="（3）从节点重启"><a href="#（3）从节点重启" class="headerlink" title="（3）从节点重启"></a>（3）从节点重启</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从节点宕机重启后，其保存的主节点的<code>runid</code>会丢失，因此即使再次执行<code>slaveof</code>，也无法进行部分复制。</p>
<h4 id="（4）网络中断"><a href="#（4）网络中断" class="headerlink" title="（4）网络中断"></a>（4）网络中断</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果主从节点之间出现网络问题，造成短时间内网络中断，可以分为多种情况讨论。</p>
<p>第一种情况：网络问题时间极为短暂，只造成了短暂的丢包，主从节点都没有判定超时（未触发<code>repl-timeout</code>）；此时只需要通过<code>REPLCONF ACK</code>来补充丢失的数据即可。</p>
<p>第二种情况：网络问题时间很长，主从节点判断超时（触发了<code>repl-timeout</code>），且丢失的数据过多，超过了复制积压缓冲区所能存储的范围；此时主从节点无法进行部分复制，只能进行全量复制。为了尽可能避免这种情况的发生，应该<strong>根据实际情况适当调整复制积压缓冲区的大小；此外及时发现并修复网络中断，也可以减少全量复制</strong>。</p>
<p>第三种情况：介于前述两种情况之间，主从节点判断超时，且丢失的数据仍然都在复制积压缓冲区中；此时主从节点可以进行部分复制。</p>
<h3 id="5-复制相关的配置"><a href="#5-复制相关的配置" class="headerlink" title="5. 复制相关的配置"></a>5. 复制相关的配置</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这一节总结一下与复制有关的配置，说明这些配置的作用、起作用的阶段，以及配置方法等；通过了解这些配置，一方面加深对<code>Redis</code>复制的了解，另一方面掌握这些配置的方法，可以优化<code>Redis</code>的使用，少走坑。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;配置大致可以分为主节点相关配置、从节点相关配置以及与主从节点都有关的配置，下面分别说明。</p>
<h4 id="（1）与主从节点都有关的配置"><a href="#（1）与主从节点都有关的配置" class="headerlink" title="（1）与主从节点都有关的配置"></a>（1）与主从节点都有关的配置</h4><p>首先介绍最特殊的配置，它决定了该节点是主节点还是从节点：</p>
<p>1)   <code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code>：<code>Redis</code>启动时起作用；作用是建立复制关系，开启了该配置的<code>Redis</code>服务器在启动后成为从节点。该注释默认注释掉，即<code>Redis</code>服务器默认都是主节点。</p>
<p>2)   <code>repl-timeout 60</code>：与各个阶段主从节点连接超时判断有关。</p>
<h4 id="（2）主节点相关配置"><a href="#（2）主节点相关配置" class="headerlink" title="（2）主节点相关配置"></a>（2）主节点相关配置</h4><p>1)   <code>repl-diskless-sync no</code>：作用于全量复制阶段，控制主节点是否使用<code>diskless</code>复制（无盘复制）。所谓<code>diskless</code>复制，是指在全量复制时，主节点不再先把数据写入<code>RDB</code>文件，而是直接写入<code>slave</code>的<code>socket</code>中，整个过程中不涉及硬盘；<code>diskless</code>复制在磁盘<code>IO</code>很慢而网速很快时更有优势。需要注意的是，截至<code>Redis3.0</code>，<code>diskless</code>复制处于实验阶段，默认是关闭的。</p>
<p>2)   <code>repl-diskless-sync-delay 5</code>：该配置作用于全量复制阶段，当主节点使用<code>diskless</code>复制时，该配置决定主节点向从节点发送之前停顿的时间，单位是秒；只有当<code>diskless</code>复制打开时有效，默认<code>5s</code>。之所以设置停顿时间，是基于以下两个考虑：</p>
<p>​     (1) 向<code>slave</code>的<code>socket</code>的传输一旦开始，新连接的<code>slave</code>只能等待当前数据传输结束，才能开始新的数据传输 </p>
<p>​     (2)  多个从节点有较大的概率在短时间内建立主从复制</p>
<p>3)   <code>client-output-buffer-limit slave 256MB 64MB 60</code>：与全量复制阶段主节点的缓冲区大小有关。</p>
<p>4)   <code>repl-disable-tcp-nodelay no</code>：与命令传播阶段的延迟有关。</p>
<p>5)   <code>masterauth &lt;master-password&gt;</code>：与连接建立阶段的身份验证有关。</p>
<p>6)   <code>repl-ping-slave-period 10</code>：与命令传播阶段主从节点的超时判断有关。</p>
<p>7)  <code>repl-backlog-size 1mb</code>：复制积压缓冲区的大小。</p>
<p>8)  <code>repl-backlog-ttl 3600</code>：当主节点没有从节点时，复制积压缓冲区保留的时间，这样当断开的从节点重新连进来时，可以进行全量复制；默认3600s。如果设置为0，则永远不会释放复制积压缓冲区。</p>
<p>9) <code>min-slaves-to-write 3与min-slaves-max-lag 10</code>：规定了主节点的最小从节点数目，及对应的最大延迟。</p>
<h4 id="（3）从节点相关配置"><a href="#（3）从节点相关配置" class="headerlink" title="（3）从节点相关配置"></a>（3）从节点相关配置</h4><p>1)  <code>slave-serve-stale-data yes</code>：与从节点数据陈旧时是否响应客户端命令有关。</p>
<p>2)   <code>slave-read-only yes</code>：从节点是否只读；默认是只读的。由于从节点开启写操作容易导致主从节点的数据不一致，因此该配置尽量不要修改。</p>
<h3 id="6-单机内存大小限制"><a href="#6-单机内存大小限制" class="headerlink" title="6. 单机内存大小限制"></a>6. 单机内存大小限制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一文中，讲到了<code>fork</code>操作对<code>Redis</code>单机内存大小的限制。实际上在<code>Redis</code>的使用中，限制单机内存大小的因素非常之多，下面总结一下在主从复制中，单机内存过大可能造成的影响：</p>
<p>（1）<strong>切主</strong>：当主节点宕机时，一种常见的容灾策略是将其中一个从节点提升为主节点，并将其他从节点挂载到新的主节点上，此时这些从节点只能进行全量复制；如果<code>Redis</code>单机内存达到<code>10GB</code>，一个从节点的同步时间在几分钟的级别；如果从节点较多，恢复的速度会更慢。如果系统的读负载很高，而这段时间从节点无法提供服务，会对系统造成很大的压力。</p>
<p>（2）<strong>从库扩容</strong>：如果访问量突然增大，此时希望增加从节点分担读负载，如果数据量过大，从节点同步太慢，难以及时应对访问量的暴增。</p>
<p>（3）<strong>缓冲区溢出</strong>：（1）和（2）都是从节点可以正常同步的情形（虽然慢），但是如果数据量过大，导致全量复制阶段主节点的复制缓冲区溢出，从而导致复制中断，则主从节点的数据同步会全量复制-&gt;复制缓冲区溢出导致复制中断-&gt;重连-&gt;全量复制-&gt;复制缓冲区溢出导致复制中断……的循环。</p>
<p>（4）<strong>超时</strong>：如果数据量过大，全量复制阶段主节点<code>fork</code>+保存<code>RDB</code>文件耗时过大，从节点长时间接收不到数据触发超时，主从节点的数据同步同样可能陷入全量复制-&gt;超时导致复制中断-&gt;重连-&gt;全量复制-&gt;超时导致复制中断……的循环。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，<strong>主节点单机内存除了绝对量不能太大，其占用主机内存的比例也不应过大</strong>：最好只使用<code>50%-65%</code>的内存，留下<code>30%-45%</code>的内存用于执行<code>bgsave</code>命令和创建复制缓冲区等。</p>
<h3 id="7-info-Replication"><a href="#7-info-Replication" class="headerlink" title="7. info Replication"></a>7. info Replication</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>Redis</code>客户端通过<code>info Replication</code>可以查看与复制相关的状态，对于了解主从节点的当前状态，以及解决出现的问题都会有帮助。</p>
<p>主节点：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628012051376-2011129261.png" alt="img"></p>
<p>从节点：</p>
<p><img src="//blog.com/2019/07/13/Redis高可用-主从复制/1174710-20180628012057112-2012438265.png" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于从节点，上半部分展示的是其作为从节点的状态，从<code>connectd_slaves</code>开始，展示的是其作为潜在的主节点的状态。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>info Replication</code>中展示的大部分内容在文章中都已经讲述，这里不再详述。</p>
<h1 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h1><p>下面回顾一下本文的主要内容：</p>
<p>1、主从复制的作用：宏观的了解主从复制是为了解决什么样的问题，即数据冗余、故障恢复、读负载均衡等。</p>
<p>2、主从复制的操作：即slaveof命令。</p>
<p>3、主从复制的原理：主从复制包括了连接建立阶段、数据同步阶段、命令传播阶段；其中数据同步阶段，有全量复制和部分复制两种数据同步方式；命令传播阶段，主从节点之间有PING和REPLCONF ACK命令互相进行心跳检测。</p>
<p>4、应用中的问题：包括读写分离的问题（数据不一致问题、数据过期问题、故障切换问题等）、复制超时问题、复制中断问题等，然后总结了主从复制相关的配置，其中repl-timeout、client-output-buffer-limit slave等对解决Redis主从复制中出现的问题可能会有帮助。</p>
<p>主从复制虽然解决或缓解了数据冗余、故障恢复、读负载均衡等问题，但其缺陷仍很明显：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制；这些问题的解决，需要哨兵和集群的帮助，我将在后面的文章中介绍，欢迎关注。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>《Redis开发与运维》</p>
<p>《Redis设计与实现》</p>
<p>《Redis实战》</p>
<p><a href="http://mdba.cn/2015/03/16/redis复制中断问题-慢查询/" target="_blank" rel="noopener">http://mdba.cn/2015/03/16/redis复制中断问题-慢查询/</a></p>
<p><a href="https://redislabs.com/blog/top-redis-headaches-for-devops-replication-buffer/" target="_blank" rel="noopener">https://redislabs.com/blog/top-redis-headaches-for-devops-replication-buffer/</a></p>
<p><a href="http://mdba.cn/2015/03/17/redis主从复制（2）-replication-buffer与replication-backlog/" target="_blank" rel="noopener">http://mdba.cn/2015/03/17/redis主从复制（2）-replication-buffer与replication-backlog/</a></p>
<p><a href="https://github.com/antirez/redis/issues/918" target="_blank" rel="noopener">https://github.com/antirez/redis/issues/918</a></p>
<p><a href="https://blog.csdn.net/qbw2010/article/details/50496982" target="_blank" rel="noopener">https://blog.csdn.net/qbw2010/article/details/50496982</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMzEzMjM5NQ==&amp;mid=2651029484&amp;idx=1&amp;sn=5882f4c7c390a0a0e4f6dfd872e203b5&amp;chksm=8c4caae8bb3b23fe77909e307d45a071186f55069e5207602c61383eab573885615c1d835904&amp;mpshare=1&amp;scene=1&amp;srcid=0327SokqtxEY3WojWNDMHLYl#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzIxMzEzMjM5NQ==&amp;mid=2651029484&amp;idx=1&amp;sn=5882f4c7c390a0a0e4f6dfd872e203b5&amp;chksm=8c4caae8bb3b23fe77909e307d45a071186f55069e5207602c61383eab573885615c1d835904&amp;mpshare=1&amp;scene=1&amp;srcid=0327SokqtxEY3WojWNDMHLYl#rd</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Redis/" rel="tag"># Redis</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/13/Redis的Linux系统优化/" rel="next" title="Redis的Linux系统优化">
                <i class="fa fa-chevron-left"></i> Redis的Linux系统优化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/15/分布式队列编程优化篇/" rel="prev" title="分布式队列编程优化篇">
                分布式队列编程优化篇 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis高可用-主从复制"><span class="nav-number">1.</span> <span class="nav-text">Redis高可用-主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、主从复制概述"><span class="nav-number">1.1.</span> <span class="nav-text">一、主从复制概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#主从复制的作用"><span class="nav-number">1.1.1.</span> <span class="nav-text">主从复制的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主从复制存在的问题"><span class="nav-number">1.1.2.</span> <span class="nav-text">主从复制存在的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、如何使用主从复制"><span class="nav-number">1.2.</span> <span class="nav-text">二、如何使用主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-建立复制"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 建立复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-实例"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. 实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#准备工作：启动两个节点"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">准备工作：启动两个节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#建立复制"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">建立复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#观察效果"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">观察效果</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-断开复制"><span class="nav-number">1.2.3.</span> <span class="nav-text">3. 断开复制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、主从复制的实现原理"><span class="nav-number">1.3.</span> <span class="nav-text">三、主从复制的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-连接建立阶段"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 连接建立阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#步骤1：保存主节点信息"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">步骤1：保存主节点信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#步骤2：建立socket连接"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">步骤2：建立socket连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#步骤3：发送ping命令"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">步骤3：发送ping命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#步骤4：身份验证"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">步骤4：身份验证</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#步骤5：发送从节点端口信息"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">步骤5：发送从节点端口信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-数据同步阶段"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 数据同步阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-命令传播阶段"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. 命令传播阶段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、【数据同步阶段】全量复制和部分复制"><span class="nav-number">1.4.</span> <span class="nav-text">四、【数据同步阶段】全量复制和部分复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-全量复制"><span class="nav-number">1.4.1.</span> <span class="nav-text">1. 全量复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-部分复制"><span class="nav-number">1.4.2.</span> <span class="nav-text">2. 部分复制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）复制偏移量"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">（1）复制偏移量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）复制积压缓冲区"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">（2）复制积压缓冲区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）服务器运行ID-runid"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">（3）服务器运行ID(runid)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-psync命令的执行"><span class="nav-number">1.4.3.</span> <span class="nav-text">3. psync命令的执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-部分复制演示"><span class="nav-number">1.4.4.</span> <span class="nav-text">4. 部分复制演示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五、【命令传播阶段】心跳机制"><span class="nav-number">1.5.</span> <span class="nav-text">五、【命令传播阶段】心跳机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-主-gt-从：PING"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.主-&gt;从：PING</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-从-gt-主：REPLCONF-ACK"><span class="nav-number">1.5.2.</span> <span class="nav-text">2. 从-&gt;主：REPLCONF ACK</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#六、应用中的问题"><span class="nav-number">1.6.</span> <span class="nav-text">六、应用中的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-读写分离及其中的问题"><span class="nav-number">1.6.1.</span> <span class="nav-text">1. 读写分离及其中的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）延迟与不一致问题"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">（1）延迟与不一致问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）数据过期问题"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">（2）数据过期问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）故障切换问题"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">（3）故障切换问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（4）总结"><span class="nav-number">1.6.1.4.</span> <span class="nav-text">（4）总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-复制超时问题"><span class="nav-number">1.6.2.</span> <span class="nav-text">2. 复制超时问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#超时判断意义"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">超时判断意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断机制"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">判断机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#需要注意的坑"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">需要注意的坑</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-复制中断问题"><span class="nav-number">1.6.3.</span> <span class="nav-text">3. 复制中断问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#复制缓冲区溢出"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">复制缓冲区溢出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-各场景下复制的选择及优化技巧"><span class="nav-number">1.6.4.</span> <span class="nav-text">4. 各场景下复制的选择及优化技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）第一次建立复制"><span class="nav-number">1.6.4.1.</span> <span class="nav-text">（1）第一次建立复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）主节点重启"><span class="nav-number">1.6.4.2.</span> <span class="nav-text">（2）主节点重启</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#主节点宕机"><span class="nav-number">1.6.4.2.1.</span> <span class="nav-text">主节点宕机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#安全重启：debug-reload"><span class="nav-number">1.6.4.2.2.</span> <span class="nav-text">安全重启：debug reload</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）从节点重启"><span class="nav-number">1.6.4.3.</span> <span class="nav-text">（3）从节点重启</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（4）网络中断"><span class="nav-number">1.6.4.4.</span> <span class="nav-text">（4）网络中断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-复制相关的配置"><span class="nav-number">1.6.5.</span> <span class="nav-text">5. 复制相关的配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#（1）与主从节点都有关的配置"><span class="nav-number">1.6.5.1.</span> <span class="nav-text">（1）与主从节点都有关的配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（2）主节点相关配置"><span class="nav-number">1.6.5.2.</span> <span class="nav-text">（2）主节点相关配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#（3）从节点相关配置"><span class="nav-number">1.6.5.3.</span> <span class="nav-text">（3）从节点相关配置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-单机内存大小限制"><span class="nav-number">1.6.6.</span> <span class="nav-text">6. 单机内存大小限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-info-Replication"><span class="nav-number">1.6.7.</span> <span class="nav-text">7. info Replication</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#七、总结"><span class="nav-number">2.</span> <span class="nav-text">七、总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考文献"><span class="nav-number">3.</span> <span class="nav-text">参考文献</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
