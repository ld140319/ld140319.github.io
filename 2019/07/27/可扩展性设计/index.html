<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="架构,微服务,分布式系统,高可用,扩展性,">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="可扩展性设计&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可扩展性的重要程度在很多系统中往往被低估，扩展性是衡量系统架构优劣的一个非常重要的判断指标，但是也不能盲目追求扩展性，还要兼顾成本，以下的示例将会告诉我们可扩展性设计的重要程度。  Facebook在2009年每天产生3千万张照片；2013年每天产生3.5亿张照片；2015年产生20亿张照片。 阿里巴巴2009年首">
<meta name="keywords" content="架构,微服务,分布式系统,高可用,扩展性">
<meta property="og:type" content="article">
<meta property="og:title" content="可扩展性设计">
<meta property="og:url" content="http://blog.com/2019/07/27/可扩展性设计/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="可扩展性设计&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可扩展性的重要程度在很多系统中往往被低估，扩展性是衡量系统架构优劣的一个非常重要的判断指标，但是也不能盲目追求扩展性，还要兼顾成本，以下的示例将会告诉我们可扩展性设计的重要程度。  Facebook在2009年每天产生3千万张照片；2013年每天产生3.5亿张照片；2015年产生20亿张照片。 阿里巴巴2009年首">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/1.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/2.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/3.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/4.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/5.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/6.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/7.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/8.png">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/9.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/10.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/11.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/12.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/13.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/14.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/15.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/16.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/17.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/18.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/19.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/20.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/21.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/22.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/23.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/24.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/25.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/26.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/27.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/28.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/29.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/30.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/31.webp">
<meta property="og:image" content="http://blog.com/2019/07/27/可扩展性设计/32.webp">
<meta property="og:updated_time" content="2019-07-27T15:58:03.400Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="可扩展性设计">
<meta name="twitter:description" content="可扩展性设计&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可扩展性的重要程度在很多系统中往往被低估，扩展性是衡量系统架构优劣的一个非常重要的判断指标，但是也不能盲目追求扩展性，还要兼顾成本，以下的示例将会告诉我们可扩展性设计的重要程度。  Facebook在2009年每天产生3千万张照片；2013年每天产生3.5亿张照片；2015年产生20亿张照片。 阿里巴巴2009年首">
<meta name="twitter:image" content="http://blog.com/2019/07/27/可扩展性设计/1.webp">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/2019/07/27/可扩展性设计/">





  <title>可扩展性设计 | 搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/07/27/可扩展性设计/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">可扩展性设计</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-27T12:12:57+08:00">
                2019-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/微服务/" itemprop="url" rel="index">
                    <span itemprop="name">微服务</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/微服务/分布式系统/" itemprop="url" rel="index">
                    <span itemprop="name">分布式系统</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/微服务/分布式系统/高可用/" itemprop="url" rel="index">
                    <span itemprop="name">高可用</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/微服务/分布式系统/高可用/扩展性/" itemprop="url" rel="index">
                    <span itemprop="name">扩展性</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="可扩展性设计"><a href="#可扩展性设计" class="headerlink" title="可扩展性设计"></a>可扩展性设计</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可扩展性的重要程度在很多系统中往往被低估，扩展性是衡量系统架构优劣的一个非常重要的判断指标，但是也不能盲目追求扩展性，还要兼顾成本，以下的示例将会告诉我们可扩展性设计的重要程度。</p>
<blockquote>
<p>Facebook在2009年每天产生3千万张照片；2013年每天产生3.5亿张照片；2015年产生20亿张照片。</p>
<p>阿里巴巴2009年首个双十一一天内销售额为5000万；2012年双十一一天内销售额为191亿；2017年双十一一天内销售额为1682亿元，11秒内即破亿。</p>
</blockquote>
<h2 id="加机器能解决问题吗"><a href="#加机器能解决问题吗" class="headerlink" title="加机器能解决问题吗"></a>加机器能解决问题吗</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;任何一个系统，随着业务的快速发展，都需要考虑或解决扩展性的问题。系统是否可以做到流量来临的时候通过扩展避免宕机，甚至不降低用户体验，很多互联网公司在用户规模增长速度比较快，技术积累不足的阶段都发生过宕机事件。比较典型的例子是聚美优品为了庆祝三周年，做了大量宣传、广告，受到了大量关注。为了应对流量的爆发聚美方面多次为服务器扩容，并制定了详细的技术应对方案，老板陈欧在微博中写道：“我们的后台已经准备好了宕机出现，如果真的出现宕机就给技术人员每人发一把刀切腹”。 但是当促销真正开始的时候，出现了大量宕机事故，网页无法打开、永远都在排队中，用户戏称：“我终于明白了聚美优品三周年，打破低价你想不到的折扣这句广告词的真谛，就是价格多低我也进不去看不见”，甚至有的用户认为宕机是阴谋，为了“少赔点儿”，对于用户来说宕机是难以理解的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外一个例子，京东初期，和当当网、苏宁、国美频频发生“价格战”，京东商城CEO刘强东通过微博宣称：“京东商城所有大家电将在未来三年内保持零毛利，并保证比国美、苏宁连锁店便宜至少10%以上。”苏宁易购立即开始进行反击，苏宁易购执行副总裁李斌通过微博宣称：“包括家电在内的所有产品价格必然低于京东。”活动开始不到10分钟，由于服务器瞬间流量暴增，苏宁官网和苏宁易购就出现访问困难和无法登录的情况，整个促销伴随的是服务器频频宕机、网站打不开。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从上面的两个例子能够看出，扩展性是多么重要。到了关键时刻绝不仅仅是加机器这么简单。</p>
<h2 id="横向扩展与纵向扩展介绍"><a href="#横向扩展与纵向扩展介绍" class="headerlink" title="横向扩展与纵向扩展介绍"></a>横向扩展与纵向扩展介绍</h2><p>我们也可以<strong>把加机器得到的性能提升叫做横向扩展</strong>。</p>
<p><strong>横向扩展（scale out）</strong>也叫水平扩展，指用更多的节点支撑更大量的请求。例如1台机器支撑<code>10000TPS</code>，两台机器是否能支撑<code>20000TPS</code>？</p>
<p><strong>纵向扩展（scale up）</strong>也叫垂直扩展，扩展一个点的能力支撑更大的请求。通常通过提升硬件实现，例如把磁盘升级为<code>SSD</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>横向扩展通常是为了提升吞吐量，响应时间一般要求不受吞吐量影响即可</strong>。因为本身在访问量比较小的时候，响应时间就是可接受的范围，例如去分布式缓存<code>get</code>一条数据的响应时间在毫秒级，理想情况如图所示，只要在吞吐量不断提升的情况下保持这个响应时间就可以。当然，<strong>响应时间和吞吐量在资源一定的情况下，通常是互斥关系，如果要降低响应时间，可以通过纵向扩展，提升单机能力，或者改变数据存储结构，压缩等方式</strong>。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/1.webp" alt="img"></p>
<p><em>响应时间和吞吐量随节点数变化关系图</em></p>
<h2 id="AKF扩展立方体"><a href="#AKF扩展立方体" class="headerlink" title="AKF扩展立方体"></a>AKF扩展立方体</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提到可扩展性，就不得不提著名的<code>AKF</code>扩展立方体（<code>Scalability Cube</code>），<code>AKF</code>是<code>ebay</code>前副总裁<code>Martin Abbott</code>在<code>《The Art of Scalability》</code>一书中的经典理论，作者把系统在架构上的扩展性按照三个维度进行说明，如图所示。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/2.webp" alt="img"></p>
<p><em>AKF扩展立方体</em></p>
<p>下面我们通过表格简单说明一下三个轴适用的场景、优势及挑战。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/3.webp" alt="img"></p>
<p><em>AKF扩展立方体</em></p>
<p>下面我们可以用一个例子来说明，系统是如何从初期一步步扩展的。假设，我们现在要开发一个微博系统。</p>
<p><strong>第一阶段。</strong>产品初期，可能我们只有十人左右的团队，还没有用户，需求也不确定。如图所示，此时我们只需要通过单体架构实现，为了容灾，我们可以在前端放置一个负载均衡服务，后端采用两个服务。数据库为了容灾也可以采用<code>Master-Slave</code>的架构。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/4.webp" alt="img"></p>
<p><em>单体架构，按X轴扩展</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随着用户访问的快速增长，当系统出现性能瓶颈的时候，我们此时采用的是X轴的扩展方式，通过不断的克隆<code>service</code>，增加<code>service</code>的数量来应对。当数据库出现瓶颈的时候，我们可以做读写分离。这就是按照X轴扩展的思路。</p>
<p><strong>第二阶段。</strong>用户快速增长，产品需求快速增加，研发团队可能会接近百人，沟通效率越来越低，数据库主从延迟问题开始暴漏，磁盘压力逐步加大。为了缓解这些问题，首先，作为过渡阶段，可以再增加业务服务实例的数量，数据库可以通过提升硬件的性能暂时抵抗压力。另一方面，我们开始按照业务领域拆分服务，如图所示，每个服务独享一个数据库，接口是服务与外部联系的唯一通道。这样既降低了耦合度，提升了沟通效率，又可以缓解数据库的压力，实现分库操作。但是，在数据库中，单表的数据量持续增长，假设我们用<code>MySQL</code>，随着数据量的增加，响应时间变长，吞吐量下降，此时我们首先会进行垂直分表，例如用户表有100个字段，但是我们常用的可能是10个字段，我们会按照一对一的方式拆分为两张表。可以参考微服务架构拆分的相关内容。这就是按照Y轴扩展的思路。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/5.webp" alt="img"></p>
<p><em>微服务架构，按Y轴扩展</em></p>
<p><strong>第三阶段。</strong>随着用户规模的快速增长，数据库成为了性能瓶颈，如图所示，我们会通过<code>MQ</code>削峰填谷，解决写的性能瓶颈，通过分布式缓存解决读的性能瓶颈。在数据库一侧，我们会对表进行水平拆分，例如，我们有3千万用户数据，可以根据用户ID拆分为4张表，每张表750万条数据。为了解决拆分带来的复杂性，可以通过数据库中间件屏蔽底层分表细节。当然，这时候很可能会遇到数据中心的容量瓶颈，促使我们去建立多数据中心，按照用户的地域去切分数据，让数据离用户更近一些。这就是按照Z轴扩展的思路。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/6.webp" alt="img"></p>
<p><em>Z轴扩展</em></p>
<h2 id="如何扩展长连接"><a href="#如何扩展长连接" class="headerlink" title="如何扩展长连接"></a>如何扩展长连接</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，应该尽量减少长连接，实际上并不是每个应用都需要那么及时。大部分都可以通过短连接搞定。例如电商的App，所有的浏览、下单都可以基于短连接实现，极少需要长连接。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图所示，我们假设要设计一个微博App客户端和服务端的交互。当我关注的人发了一条微博，此时如果我不在线，并不需要马上收到，完全可以当我上线的时候通过短连接去拉取消息。但是，如果我正在看微博，应该提醒我有几条新消息，这个通知是需要及时性的。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/7.webp" alt="img"></p>
<p><em>微博App客户端和服务端的交互</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然，及时性消息也不一定非得是长连接，也可以采用定时轮询的方式。实际上，在真实的生产环境，为了保证到达率，通常需要长连接和短连接配合，因为长连接在网络条件不好的情况下，经常会出现各种各样的问题，导致不能及时到达，通过轮询心跳的方式可以定时拉取消息，缓解长连接推送失败的问题。</p>
<h3 id="当其中一个push服务挂掉的时候，客户端应该作何反应"><a href="#当其中一个push服务挂掉的时候，客户端应该作何反应" class="headerlink" title="当其中一个push服务挂掉的时候，客户端应该作何反应"></a>当其中一个<code>push</code>服务挂掉的时候，客户端应该作何反应</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;那么，问题来了，当其中一个<code>push</code>服务挂掉的时候，客户端应该作何反应？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常用的方案有两种：反向代理和注册中心。</p>
<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图所示，可以在<code>client</code>和<code>push</code>之间增加一层反向代理服务，<code>client</code>并不知道具体的<code>push</code>服务，通过反向代理服务转发，另外反向代理也兼具负载均衡的作用。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/8.png" alt="img"></p>
<p><em>反向代理</em></p>
<h4 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图所示，如果现在存在一个注册中心，就可以<code>client</code>在连接<code>push</code>服务的时候，先到注册中心获取可以连接的列表，然后再根据<code>push</code>服务的地址去连接<code>push</code>服务，这样，如果一个<code>push</code>服务挂掉，就可以让<code>client</code>连到另外一个<code>push</code>服务了。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/9.webp" alt="img"></p>
<p><em>注册中心</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要推送的消息量太大，可能会导致雪崩，我们需要限流，业界普遍会在推送服务前增加<code>MQ</code>以削峰填谷。</p>
<h3 id="如何记录client和push的对应关系"><a href="#如何记录client和push的对应关系" class="headerlink" title="如何记录client和push的对应关系"></a>如何记录client和push的对应关系</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有另外一个问题，当推送消息的时候，肯定要知道通过哪个<code>push</code>服务去推送，因为<code>client</code>不可能和所有的<code>push</code>服务建立长连接，单机的连接数是有限的，如何记录<code>client</code>和<code>push</code>的对应关系呢？</p>
<h4 id="将映射关系数据放入缓存"><a href="#将映射关系数据放入缓存" class="headerlink" title="将映射关系数据放入缓存"></a>将映射关系数据放入缓存</h4><p><strong>方法一、</strong>记录<code>client</code>和<code>pushserver</code>的映射关系。如图所示，将关系数据放入缓存。</p>
<p>优势：扩容可以不用影响现有节点连接。假设现在有两个节点，扛不住压力了，扩容到3个节点，此时我们只需要把新的连接连到新的节点，已经存在的连接可以不用断开重连。</p>
<p>劣势：需要维护<code>client</code>和<code>pushserver</code>的映射关系。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/10.webp" alt="img"></p>
<p><em>消息推送映射关系</em></p>
<h4 id="根据节点总数计算映射关系"><a href="#根据节点总数计算映射关系" class="headerlink" title="根据节点总数计算映射关系"></a>根据节点总数计算映射关系</h4><p><strong>方法二、</strong>根据节点总数计算映射关系。</p>
<p>优势：简单。只需要知道现在一共有几个<code>pushserver</code>，根据<code>ClientID</code>对总节点求余、一致性哈希或者根据用户ID的范围，就应该知道应该推送到哪个节点。</p>
<p>劣势：首先，<strong>如果扩容需要断开一批连接，重新连到新的<code>pushserver</code>节点，有中断的可能</strong>。其次，如果根据范围计算，有可能存在热点，某个<code>pushserver</code>压力很大，而其他节点比较轻松。最后，如果一旦<code>push</code>节点挂掉，就要重新建立连接。有时成本是比较高的，假设我们一共有4个节点，监控到一个节点故障，此时要把这个节点的连接转移到其他三个节点，一旦故障节点恢复，因为三个节点压力较大，我们又要再让客户断开连接，连到新的节点。如图所示，如果我们建立几个冗余节点，一旦发生故障，迅速把<code>back</code>节点顶上来，后面故障节点恢复后可以作为<code>back</code>节点。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/11.webp" alt="img"></p>
<p><em>备份节点</em></p>
<h2 id="如何扩展数据库"><a href="#如何扩展数据库" class="headerlink" title="如何扩展数据库"></a>如何扩展数据库</h2><h3 id="X轴扩展—主从复制集群"><a href="#X轴扩展—主从复制集群" class="headerlink" title="X轴扩展—主从复制集群"></a>X轴扩展—主从复制集群</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们的<code>service</code>访问数据库的吞吐量在4500TPS，其中写为500TPS，这种典型的读多写少的场景，我们通常会采用读写分离，如图所示，将所有的读请求分发到<code>Slave</code>上，<code>Master</code>只负责写，<code>Master</code>和<code>Slave</code>之间通过数据库自带同步机制复制数据。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/12.webp" alt="img"></p>
<p><em>Master-Slave结构</em></p>
<p>在这种方案中，多个<code>Slave</code>服务器异步的复制<code>Master</code>的数据，复制步骤如下。</p>
<ol>
<li><p><code>Master</code>将更新记录到二进制日志(<code>binary log</code>)中。</p>
</li>
<li><p><code>Slave</code>将<code>Master</code>的日志(<code>binary log</code>)拷贝到它的中继日志(<code>relay log</code>)。</p>
</li>
<li><p><code>Slave</code>重做中继日志中的事件。</p>
</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于很多业务都符合读多写少的特点，使得这种扩展方式简单有效，可以很容易的缓解读负载。采用主从复制还可以将服务进行隔离，例如，终端用户访问<code>Slave-01</code>，系统内部统计工具访问<code>Slave-02</code>，当运营人员做系统内部统计的时候会使<code>Slave-02</code>压力骤增，这种隔离方式将起到保护<code>Slave-01</code>不受影响。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个方案的问题在于当<code>Slave</code>增加到一定数量时，<code>Slave</code>对<code>Master</code>的负载以及网络带宽都会成为严重的问题。本身单库承受不了可能是因为磁盘<code>IO</code>达到上限，而同步数据同样需要消耗<code>Master</code>服务器的性能。</p>
<p>使用新版本有助于解决部分问题，如MySQL5.7在主从复制方面提供了几个比较实用的功能。</p>
<ol>
<li><p>多源复制（多主一从）。</p>
</li>
<li><p>半同步复制改进。</p>
</li>
<li><p>基于组提交（<code>LOGICAL_CLOCK</code>）的并行复制。</p>
</li>
</ol>
<h3 id="Y轴扩展—分库、垂直分表"><a href="#Y轴扩展—分库、垂直分表" class="headerlink" title="Y轴扩展—分库、垂直分表"></a>Y轴扩展—分库、垂直分表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Master-Slave</code>集群适合读多写少的场景，只能通过不断增加<code>Slave</code>的实例个数解决读的性能问题，但是毕竟<strong>只能通过<code>Master</code>写入，单节点的写入能力有限</strong>，况且，如果要满足写后读一致性，就需要让读也访问<code>Master</code>，当系统规模不断增大时，如果写成为了瓶颈点，就需要考虑Y轴的扩展了。首先要考虑的是分库，分库是指把原来一个数据库中的多张表根据数据量、访问量、关联程度分解到多个数据库中。通常<strong>分库操作是和微服务拆分同步进行的，可以根据微服务划分的原则进行划分，划分后每个服务独享一个数据库</strong>。<strong>分库的最大特点就是相对简单，尤其适合各业务之间的耦合度比较低，业务逻辑非常清晰的系统</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分库相对于<code>Master-Slave</code>集群付出的成本更高，<strong>需要处理分布式事务问题、关联查询问题</strong>。但是相对于下面的方案更简单一些。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;垂直分表是分库的一种特殊形式。有的业务中，单表字段数非常多，一些电商中的用户表可能超过200个字段。虽然表内的字段确实是一对一的关系，但是实际上，并不是所有的字段都是常用的，通常这200个字段可能只有十几个字段是常用的。如果我们已经进行了分库，将用户表独立出来了，仍然存在性能问题，此时我们可以尝试进行垂直分表。也就是把单表的字段垂直拆分为多张表。初期可以放到一个数据库中，查询的时候更简单。如果仍然存在性能问题，可以分到不同的数据库，放到不同的物理机上。</p>
<h3 id="Z轴扩展—分片（sharding）"><a href="#Z轴扩展—分片（sharding）" class="headerlink" title="Z轴扩展—分片（sharding）"></a>Z轴扩展—分片（sharding）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果采用分库、垂直分表还是不能解决问题，此时只能通过Z轴的扩展方式，进行分片了。什么时候开始考虑分片呢？由于采用分片会导致架构的复杂度大幅上升，所以如果能避免应该尽量避免。一般按照经验值，<code>MySQL</code>在单表十个字段以下，<strong>数据量达到1千万左右</strong>时，如果采用<code>SATA</code>磁盘，性能会遇到比较大的瓶颈。如果此时数据量还是大幅增长，就应该考虑分片了。</p>
<h4 id="分片目标"><a href="#分片目标" class="headerlink" title="分片目标"></a>分片目标</h4><p>数据库分片的目标如下：</p>
<ol>
<li><p><strong>数据量尽可能分布均匀</strong>。因为数据量会对数据库造成压力，影响性能指标。在100条数据里搜索一条数据和在一亿条数据里搜索一条数据完全不一样。</p>
</li>
<li><p><strong>访问量尽可能分布均匀</strong>。例如微博某大V，如果发布一条“介绍女朋友”的信息，可能会有几千万的的转发评论。最好不要存在某个点特别热，因为扩缩容通常是整体架构的行为，当然也可以通过缓存的方式，让热点数据尽量命中缓存，缓解热点问题。</p>
</li>
<li><p><strong>一次访问尽可能落到一个分片</strong>。在分片的时候，按照哪个<code>key</code>进行切分可以决定一次请求会访问几个分片。例如，如果订单表按照订单ID进行切分，以买家维度进行查询时，势必造成要遍历所有的表，这样通过分片提升的性能就大打折扣。系统的扩展性受到挑战。</p>
</li>
<li><p><strong>数据迁移量尽可能少</strong>。当需要扩容的时候，为了不中断服务，数据迁移的过程是比较复杂的，需要迁移的数据量越少，对系统整体的压力就会越小。</p>
</li>
</ol>
<h4 id="分片算法"><a href="#分片算法" class="headerlink" title="分片算法"></a>分片算法</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数据库分片对原有的架构破坏性很大，需要考虑的地方很多，因此分片的算法至关重要，以下我们就来了解一下几种常用的分片算法。</p>
<h5 id="区间法（Range-Based）"><a href="#区间法（Range-Based）" class="headerlink" title="区间法（Range-Based）"></a>区间法（Range-Based）</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图所示，假设现在一共有2000万条记录，此时，我们可以按照ID的范围分成四张表，每张表独占一个数据库。当然也可以根据时间、地域、组织进行切分，例如一个月一张表、一个省一张表、一个租户一张表等等。电信级的应用很多是基于省份分片，这样做的另一个好处是隔离性。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/13.webp" alt="img"></p>
<p><em>区间法</em></p>
<p>区间法的优势：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;利于排序，这几种分区算法中，只有区间法可以配合分区算法更容易排序。</p>
<p>区间法的缺点：</p>
<ol>
<li><p><strong>容易导致热点问题</strong>。假设上图中<code>500w-1000w</code>压力较大，此时如何分裂？如何迁移数据？</p>
</li>
<li><p><strong>需要额外的元数据记录</strong>。</p>
</li>
</ol>
<p>适用场景如下：</p>
<ol>
<li><p><strong>历史数据严重低于最近的数据访问，历史数据可以归档</strong>。例如电商中订单的物流信息，可能保留三个月就可以了。</p>
</li>
<li><p><strong>数据分布相对比较均匀的场景</strong>。</p>
</li>
<li><p><strong>数据按照区域需要隔离的场景</strong>。</p>
</li>
</ol>
<h5 id="轮流法（Round-Robin）"><a href="#轮流法（Round-Robin）" class="headerlink" title="轮流法（Round-Robin）"></a>轮流法（Round-Robin）</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;轮流法是<strong>根据关键字对分片总量求余以实现均匀分布</strong>。给定一个数据K，应该放到哪个分区？可以按照这个公式<code>n= K mod N</code>，N代表分片总数，K代表分片关键字，n就是我们要放的节点位置。如图所示，如果把用户ID作为key，userID=1的数据对4求余等于1，应该放到第二个数据库。如果key是自增长的int或long，数据分布均匀，不容易出现热点问题。如果key是规律的字母或数字组成，则很容易出现问题，此时我们可以对key计算hash值缓解。公式变为<code>n= Hash(K)mod N</code>。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/14.webp" alt="img"></p>
<p><em>轮流法</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>采用轮询法，当进行扩容的时候，最好是成倍扩容，迁移的数据量少</strong>。例如从两个节点扩容为四个节点，需要迁移一半的数据。我们举例说明一下，如果现在有两个库，采用轮询法分库，现在由两个库扩展为三个库，发生移动的数据量为三分之二。但是如果是从两个分片变为四个分片，只有一半的数据发生了移动，迁移的数据量更少，并且达成了扩容的效果。</p>
<p>轮询法的优势如下：</p>
<ol>
<li><p>简单，开发运维人员看到<code>Key</code>的时候，很容易知道这条数据应该在哪个分片。</p>
</li>
<li><p>不需要维护元数据。</p>
</li>
</ol>
<p>轮询法的缺点如下：</p>
<ol>
<li><p><strong>当进行扩缩容的时候，迁移的数据量较大</strong>。</p>
</li>
<li><p>不容易排序。</p>
</li>
</ol>
<p>轮询法的适用场景如下：</p>
<ol>
<li><p><strong>不经常扩缩容的场景</strong>。</p>
</li>
<li><p>不需要排序或者可以用其他方式代替的场景。</p>
</li>
</ol>
<h5 id="一致性哈希法（Consistent-Hashing）"><a href="#一致性哈希法（Consistent-Hashing）" class="headerlink" title="一致性哈希法（Consistent Hashing）"></a>一致性哈希法（Consistent Hashing）</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设现在我们有一张用户表，水平切分为两张表。用户ID是自增长的。现在我们计算一下用户ID是<code>1、2、3、4、5、6、7、8、9</code>的数据应该如何分布？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;按照轮流法进行<code>MOD</code>，结果应该如图所示，<code>DB-0</code>储<code>2/4/6/8</code>，<code>DB-1</code>存储<code>1/3/5/7/9</code>。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/15.webp" alt="img"></p>
<p><em>一致性哈希法</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果现在进行扩容，扩展到3个数据库。如图所示，DB-0中的2要迁移到DB-2，4要迁移到DB-1，DB-1中的3要迁移到DB-0，DB-1中的5要迁移到DB-2。只剩下框内的数据没有发生移动。实际上，DB-2只是存储了3条数据，却移动了5条数据（所以，<strong>一般基于<code>MOD</code>算法的数据扩容，通常是基于倍数进行，原因就是为了减少数据迁移量</strong>）。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/16.webp" alt="img"></p>
<p><em>数据迁移</em></p>
<p>那么，有没有办法只移动3条数据呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一致性哈希就是为了解决这个问题而生的。一致性哈希算法（<code>Consistent Hashing</code>）是在1997年由麻省理工学院提出的一种分布式哈希（<code>DHT</code>）实现算法，设计目标是为了解决因特网中的热点(<code>Hot Spot</code>)问题，一致性哈希相比其他算法可以减少数据的迁移量。一致性哈希的架构如图所示：</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/17.webp" alt="img"></p>
<p><em>一致性哈希</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先将<code>key</code>按照常用的<code>hash</code>算法对应到一个具有<code>2^32</code>次方个桶的空间中，即<code>0~(2^32)-1</code>的数字空间中。我们可以将这些数字头尾相连，想象成一个闭合的环形，如图所示，2的32次方是42亿，这相当于有了42亿个节点，当然这些节点不必真的对应一个数据库，可以认为是一个虚拟节点。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/18.webp" alt="img"></p>
<p><em>哈希环（一）</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在假设将两个数据库的IP、HostName加上端口计算出一个<code>hash code</code>值，如果DB-0是1201（虚拟的），DB-1是13465456，将这两个节点分布在这个环上，那么所有的数据如果通过<code>hash code</code>后取模计算出的结果落在0-1201范围，就放到<code>DB-0</code>上，如果在<code>1201-13465456</code>或者大于<code>13465456</code>就放到DB-1上。如图所示，<strong>一致性哈希是按照顺时针分布数据的</strong>。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/19.webp" alt="img"></p>
<p><em>哈希环（二）</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;继续用上面的例子，将用户ID（1-9）也用同样的方法算出<code>hashcode</code>并对42亿取模将其存放到环形节点上。假设（1/4/6/7）落在了DB-0，（2/3/5/8/9）落在了DB-1，如果现在新增一个节点，假设按照IP、HostName加上端口计算出一个<code>hash code</code>值是23123，只有落在DB-1的数据（2/3/5/8/9）涉及到迁移，DB-0可以保持不变，可能3/8迁移到了新的节点。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们简单介绍了一致性哈希大致原理，到这里大家应该大致明白<strong>一致性哈希为什么迁移的数据量比较小，因为一致性哈希最终是基于范围迁移的</strong>。相对于直接通过范围分片，一致性哈希做了一次哈希值计算，分散了热点。当然，这里存在一个比较大的问题，<strong>当节点比较少的时候，数据分布不均匀。会导致热点的存在，为了解决这个问题。又引入了虚拟节点（<code>virtual node</code>）的机制</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图所示，可以针对每个节点虚拟出N个节点，因为虚拟出的节点是按照<code>hash code</code>并对42亿取模结果放到哈希环上的，所以，不会像很多初学者认为的那样排好序的，结果是散落在环上的，也就是说DB-0对应的是DB-0-1和DB-0-2。他们在环上并不是一定会挨在一起的，<strong>当虚拟节点足够多的时候，是平均散落在环上的</strong>。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/20.webp" alt="img"></p>
<p><em>哈希环（三）</em></p>
<p>假设现在<code>DB-0</code>发生故障，按照顺时针，<code>DB-0-1</code>的数据会落到<code>DB-2-0</code>上，<code>DB-0-2</code>的数据会落在<code>DB-1-1</code>上。</p>
<p>一致性哈希的优势：</p>
<ol>
<li><strong>扩缩容数据迁移量较少</strong>。【增加节点只影响顺时针前一个节点，减少节点只影响顺时针后一个节点】</li>
</ol>
<p>一致性哈希的缺点：</p>
<ol>
<li>算法复杂，不容易调试。</li>
<li>不容易排序。</li>
</ol>
<p>一致性哈希的适用场景：</p>
<ol>
<li>不需要排序或者可以用其他方式代替的场景。</li>
</ol>
<h4 id="如何避免重新均衡数据"><a href="#如何避免重新均衡数据" class="headerlink" title="如何避免重新均衡数据"></a>如何避免重新均衡数据</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为重新均衡是昂贵的。<strong>需要重新均衡的原因是分片是静态的，但是数据是动态的，业务是动态的，也就是说，可能现在是均衡的，过了一段时间，变成不均衡的了</strong>。也有可能某段时间是均衡的，另外一段时间是不均衡的。如很多<code>SNS</code>类的网站，初始阶段，活跃用户可能集中在1千万以下的区间，过了几年，活跃用户可能会集中在1亿到2亿之间，这是一个动态变化的过程。所以，在分片的时候，要用发展的眼光看问题。</p>
<h4 id="管理分片"><a href="#管理分片" class="headerlink" title="管理分片"></a>管理分片</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;管理分片是一个复杂的问题。我们很难实现数据的强一致性，如果采用分布式事务，会使性能、扩展性受到很大影响。如何进行<strong>分页、排序</strong>等查询？以前一条<code>SQL</code>就搞定了，如果使用了分片，当进行分页、排序的时候，就会变的非常复杂了。如为了避免热点，根据哈希分了64张表，查询出按时间排序后的第10000条到100010条数据，这就需要去所有分片取数据，在内存中进行计算。当然，也可以建立另一维度的数据去解决。但是这增加了架构的复杂度，有可能还要为此引入其他的服务。因此，水平分表应该作为最后一个选择。</p>
<h4 id="为什么要带拆分键"><a href="#为什么要带拆分键" class="headerlink" title="为什么要带拆分键"></a>为什么要带拆分键</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们都知道当数据库进行水平分表的时候，需要通过拆分键路由进行查询。这是为什么呢？<strong>因为如果你不带拆分键，就要到所有的表去查询，数据库中间件不知道去哪查。虽然可以通过并行的方式查询所有表，但是这会导致数据库的压力提升</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图所示，如果带上拆分键<code>uid</code>，则很容易定位到<code>DB2</code>，如果不带拆分键<code>uid</code>，数据库中间件不知道去哪查，只能查询所有的数据库。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/21.webp" alt="img"></p>
<p><em>是否带拆分键对比</em></p>
<h4 id="分片后的关联查询问题"><a href="#分片后的关联查询问题" class="headerlink" title="分片后的关联查询问题"></a>分片后的关联查询问题</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们通过一个例子来了解这个问题。例如，一个库中包含两张表，一个用户表，一个订单表，如果查询“北京的订单金额大于100的数量”，在一个库中可以通过关联查询完成。如果用户和订单被划分到了不同的服务，再进行关联查询，就非常麻烦了。</p>
<h5 id="方案一：建立多维度数据库"><a href="#方案一：建立多维度数据库" class="headerlink" title="方案一：建立多维度数据库"></a>方案一：建立多维度数据库</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以尝试建立另外一个综合数据库，相当于为了进行关联查询多冗余了一份数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图所示，电商中比较典型的例子。实施微服务架构后，商品、价格、库存垂直划分为多个独立的数据库。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/22.webp" alt="img"></p>
<p><em>建立多维度数据库</em></p>
<p>更新时，通过消息中间件异步更新到综合数据库内。</p>
<p>查询时，直接从综合数据库查询。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然综合表有可能变得臃肿，但是综合表的查询一般是后台管理人员使用，查询频率较低。当然，综合表可以替换为<code>Mongodb</code>，因为<code>Mongodb</code>可以自动伸缩。运维的工作量要更简单。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个类似的做法是在大数据平台建立综合数据查询系统，问题是有可能存在延迟。需要根据具体业务场景决定。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;建立多维度数据库方案的优势是架构简单，问题主要包含如下两方面：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1. 可能存在不一致的风险。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.  综合表有可能变的庞大无比，如果查询量比较大，可能会成为性能瓶颈。</p>
<h5 id="方案二：建立外部搜索引擎"><a href="#方案二：建立外部搜索引擎" class="headerlink" title="方案二：建立外部搜索引擎"></a>方案二：建立外部搜索引擎</h5><p>如图所示，可以通过分布式的搜索引擎，建立倒排索引，进行全文检索。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/23.webp" alt="img"></p>
<p><em>建立外部搜索引擎</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;全文检索目前有很多开源的方案，最为流行的莫过于<code>apache solr</code>和<code>elasticsearch</code>。很多互联网公司的全文检索解决方案都是用这两个框架或者基于这两个框架进行开发。他们的共同点是底层都采用了<code>lucene</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方案目前应用比较广泛，在电商场景中比较常见。</p>
<h5 id="方案三：通过分布式缓存"><a href="#方案三：通过分布式缓存" class="headerlink" title="方案三：通过分布式缓存"></a>方案三：通过分布式缓存</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过分布式缓存，冗余数据。如果存在一份数据相对比较小，占用空间并不是特别大，可以用这种方案存储结果性数据。特别适合于多对多的场景。这种方案常用在<code>SNS</code>类系统的综合查询。</p>
<h4 id="分片扩容（re-sharding）"><a href="#分片扩容（re-sharding）" class="headerlink" title="分片扩容（re-sharding）"></a>分片扩容（re-sharding）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;分片的时候，应该从长期考虑，避免频繁的进行重新分片（<code>re-sharding</code>），因为重新分片会导致大量的数据迁移。可以根据未来数据量的增长速度、架构调整的可能性进行规划，如果预留太多会导致成本增加，预留太少会导致频繁迁移，根据经验值，可以预留未来1-2年的空间，<strong>如果害怕资源浪费，可以把多个实例部署到一台服务器</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设现在有两个分片，采用<code>MOD</code>的分片算法，如果存在（0-9）的用户ID，进行<code>MOD</code>后的分布情况是DB-0（0/2/4/6/8）, DB-1（1/3/5/7/9）。按照前面我们的建议，最好是<strong>按照倍数扩容，此时迁移的比例最少</strong>，因为当数据量较大的时候，迁移会对系统压力造成很大的影响，应该尽量减少迁移。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以<code>MySQL</code>为例，应该选择流量较小的时段进行扩容。禁止在高峰期扩容。</p>
<h5 id="停服扩容"><a href="#停服扩容" class="headerlink" title="停服扩容"></a>停服扩容</h5><p>如图所示，停服扩容步骤如下。</p>
<ol>
<li><p>选择好升级的时间段，评估升级所需时长，对外沟通，挂出公告。</p>
</li>
<li><p>到时间后，所有流量在前端负载均衡处转发到停服公告页面，观察数据库状态，没有流量后先对数据库进行备份，然后开始升级。</p>
</li>
<li><p>新建两个数据库，分别命名为DB-2、DB-3。可以通过一些开源的迁移工具，也可以自己开发一个迁移服务，或者利用存储过程进行迁移数据。</p>
</li>
<li><p>迁移完成后，删除DB-0、DB-1冗余的数据。验证数据完整性、一致性。</p>
</li>
<li><p>如果有数据库中间件，修改中间件分片策略；如果没有数据库中间件，修改<code>service</code>的分片策略。</p>
</li>
<li><p>验证。如果没有问题流量切回。如果发现问题，再挂出公告利用前面的备份进行回滚。</p>
</li>
</ol>
<p><img src="//blog.com/2019/07/27/可扩展性设计/24.webp" alt="img"></p>
<p><em>停服扩容</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种做法比较简单，容易操作。但是需要停止服务，要求一次性作对，否则回滚比较麻烦。这在产品初期，访问量不是特别高，技术实力较差时可以选择停服扩容。但是通常需要扩容的情况，一般数据量都比较大了。技术人员的水平、熟练程度、前期的准备工作对于这种方案的成败起到了决定性的作用，包括中断的时长也会受到以上因素影响。</p>
<h5 id="基于数据库的0中断扩容"><a href="#基于数据库的0中断扩容" class="headerlink" title="基于数据库的0中断扩容"></a>基于数据库的0中断扩容</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先需要说的是，0中断并非不能有中断，而是<strong>中断的时间足够短，可以忽略，不需要通知用户，或者对用户体验影响不大</strong>。以下案例假设存在数据库中间件，如果没有，则需要基于业务服务进行操作。</p>
<ol>
<li><p>选择好升级的时间段，先对数据库备份。</p>
</li>
<li><p>通常为了容灾，提升读性能，此时应该已经有了<code>Slave</code>节点。如果没有<code>Slave</code>，如图所示，需要先分别为两个数据库建立<code>Slave</code>实例DB-2、DB-3。</p>
</li>
</ol>
<p><img src="//blog.com/2019/07/27/可扩展性设计/25.webp" alt="img"></p>
<p><em>建立Slave</em></p>
<ol start="3">
<li>当<code>Master</code>和<code>Slave</code>之间延迟较小时，修改数据库中间件配置，停止写入，只能读取。如图所示，将<code>Slave</code>提升为<code>Master</code>。</li>
</ol>
<p><img src="//blog.com/2019/07/27/可扩展性设计/26.webp" alt="img"></p>
<p><em>将Slave提升为Master</em></p>
<ol start="4">
<li>如图所示，修改数据库中间件配置，分片规则改为四个库。</li>
</ol>
<p><img src="//blog.com/2019/07/27/可扩展性设计/27.webp" alt="img"></p>
<p><em>修改数据库中间件配置</em></p>
<ol start="5">
<li><p>修改数据库中间件配置，允许正常读写。注意，<strong>此时存在冗余数据，必须要求数据库中间件具备排重功能</strong>。</p>
</li>
<li><p><strong>删除冗余数据</strong>。</p>
</li>
</ol>
<p>注意，从3到5，读取不受影响。写入是中断的，中断的时长取决于前期的准备工作和操作的熟练程度，一般可以控制到分钟级。如果希望中断时间更短，可以把主从同步修改为主主同步或者半同步复制，会缩短中断时间。但是，这需要提前做好准备。</p>
<p>另外，也可以把所有的写入数据暂时记录日志或者写入<code>MQ</code>，等到主从完全一致之后，先写入日志或者<code>MQ</code>的数据。</p>
<h5 id="基于数据库中间件的0中断扩容"><a href="#基于数据库中间件的0中断扩容" class="headerlink" title="基于数据库中间件的0中断扩容"></a>基于数据库中间件的0中断扩容</h5><p>还有一种方案和上一种方案类似，只不过是通过数据库中间件完成的。大致步骤如下。</p>
<ol>
<li><p>备份数据。</p>
</li>
<li><p>建立另外两个数据库实例DB-2、DB-3，分别作为DB-0、DB-1的副本。可以通过迁移工具（基于状态机模式读取<code>binlog</code>）让数据尽量接近。</p>
</li>
<li><p>修改数据库中间件配置，停止<code>update</code>和<code>delete</code>，只能<code>insert</code>和读取，<code>insert</code>的时候需要通过数据库中间件进行双写，将DB-0的数据同步写入到DB-2，将DB-1的数据同步写入到DB-3。</p>
</li>
<li><p>比对数据，当DB-0和DB-2的数据完全一致，DB-1和DB-3的数据完全一致的时候，修改数据库中间件配置，开始<code>update</code>和<code>delete</code>。</p>
</li>
<li><p>修改数据库中间件配置，修改分片规则，切换为4个库进行读写。</p>
</li>
<li><p>删除冗余数据。如图所示，扩容结束。</p>
</li>
</ol>
<p><img src="//blog.com/2019/07/27/可扩展性设计/28.webp" alt="img"></p>
<p><em>基于数据库中间件的0中断扩容</em></p>
<p>这个方案中断的只有<code>update</code>和<code>delete</code>，如果业务场景这两个操作比较少，比较适合这个方案。</p>
<p>在实际的业务中，如果复杂度较高，会混合使用以上的分片算法，例如微信红包的规则为<code>db_xx.t_y_dd</code>，<code>xx/y</code>代表红包ID的<code>hash</code>值后三位，<code>dd的</code>代表天数，实际上混用了一致性哈希和区间法，通过这种混合的分片算法，既避免了区间法导致的热点数据的问题，又利于迁移数据，可以按照天为单位整张表进行迁移。</p>
<h4 id="精选案例"><a href="#精选案例" class="headerlink" title="精选案例"></a>精选案例</h4><h5 id="活动平台数据表水平切分"><a href="#活动平台数据表水平切分" class="headerlink" title="活动平台数据表水平切分"></a>活动平台数据表水平切分</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图所示，假设现在有一个活动平台，管理员可以创建活动，为活动添加用户，针对一个活动给用户发送促销短信或邮件提醒。按照场景，正常的操作逻辑是，查询关注某活动的所有用户，并且发送消息。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/29.webp" alt="img"></p>
<p><em>活动平台需求关系</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是一个典型的多对多，通常当用户数据量比较大的时候，会先选择分库，也就是把用户表独立到一个数据库，活动和活动关系表放到一个数据库。活动一般不会特别多，或者说活跃的活动不会特别多，但是活动用户关系表会非常大。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果活动库变的非常大，此时该如何切分？一般不会选择直接把活动用户关系表独立到一个库，由于活动的数据量不是特别大，分库的效果不好，避免不了水平分表。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果按照活动进行分片，当查询关注活动的所有用户时，可以在一个分片内查出所有数据，但是按照活动进行分片会产生热点数据，因为有的活动可能用户比较多，而有的活动用户比较少。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果按照用户进行切分，虽然不会有热点数据问题。但是当查询关注活动的所有用户时，需要遍历所有分片。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，关系数据只是两个id而已，数据条数可能比较多，但是占用的存储空间并不会特别大，可以优先考虑通过缓存缓解数据库的压力，不做分区。活动有明显的时效性，一旦活动结束，数据就可以归档到历史数据库了。因为关系数据一般不会更新，可以将缓存的过期时间设置的长一点。</p>
<h5 id="SNS数据表水平切分"><a href="#SNS数据表水平切分" class="headerlink" title="SNS数据表水平切分"></a>SNS数据表水平切分</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很多人用过微博或者微信，主要的表结构包括用户表、用户关系表（谁关注了谁）、消息表（发的微博、朋友圈），关系如图所示。用户之间是有关系的，通常发布出去的内容按照用户的查询方式有多个维度。例如在微博中，首页通常是<code>timeline[1]</code>，是自己看的比较多的页面，还有一个页面是<code>profile[2]</code>，关注者会经常访问。当消息的量比较大时，需要进行水平分表，如何切分保证不去遍历所有的分片呢？</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/30.webp" alt="img"></p>
<p><em>SNS需求关系</em></p>
<blockquote>
<p>[1]Timeline是指你可以看到的你关注的所有人发布的消息流，通常按照时间排序形成。</p>
<p>[2]Profile是指自己或者单个人发布的所有信息的流，通常按照时间排序形成。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果按照发布消息的用户ID去切分数据，在查询<code>profile</code>的时候，可以在一个分片取到所有数据，但是，在查看<code>timeline</code>的时候，就面临着遍历所有的分片数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如以下表格所示，根据需求有两张表，分别是消息表和用户关注表，如果消息表被分为8张表，根据求余的算法，用户ID为1的消息会落入第一个分片，用户ID为2的消息会落入第二个分片，如果查询用户ID为1的<code>profile</code>页面，可以直接在第一个分片取到所有数据，但是在用户关注表中我们不难发现，用户ID为10001的用户关注了用户ID为1和2的两个用户，如果用户10001查询自己的<code>timeline</code>页面，需要遍历所有分片。而<code>timeline</code>才是读取量比较大的页面，这样性能会非常低。</p>
<p>表格 5‑1 消息表分片1</p>
<table>
<thead>
<tr>
<th><strong>消息ID</strong></th>
<th><strong>发布消息的用户ID</strong></th>
<th><strong>消息内容</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1000</td>
<td>1</td>
<td>……</td>
</tr>
<tr>
<td>1001</td>
<td>1</td>
<td>……</td>
</tr>
</tbody>
</table>
<p>表格 5‑2 消息表分片2</p>
<table>
<thead>
<tr>
<th><strong>消息ID</strong></th>
<th><strong>发布消息的用户ID</strong></th>
<th><strong>消息内容</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1005</td>
<td>2</td>
<td>……</td>
</tr>
<tr>
<td>1006</td>
<td>2</td>
<td>……</td>
</tr>
</tbody>
</table>
<p>表格 5‑3 用户关注表</p>
<table>
<thead>
<tr>
<th><strong>用户ID</strong></th>
<th><strong>关注的用户ID</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>10001</td>
<td>1</td>
</tr>
<tr>
<td>10001</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>提升读性能的关键方案之一就是冗余，除了上面的消息内容表，可以再增加一张表，让<code>timeline</code>数据可以在一个分片内取到，一次来兼顾两个维度的查询性能，带来的问题是可能会比较浪费资源</strong>。这也是目前<code>Twitter</code>的方案，由于国内的<code>SNS</code>存在大量僵尸用户，一般都采用推拉结合的方式兼顾。</p>
<h5 id="电商数据表水平切分"><a href="#电商数据表水平切分" class="headerlink" title="电商数据表水平切分"></a>电商数据表水平切分</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;电商中以订单为典型，一个订单包含订单id，买家id，卖家id，三个比较重要的查询关键字。为了简化，我们先不考虑订单和子订单相关的内容。</p>
<p>那么，该如何选择水平切分键呢？</p>
<p><strong>如果按照订单id切分，则按照卖家id和买家id查询会遍历所有的表</strong>；</p>
<p><strong>如果按照买家id切分，则按照订单id和卖家id查询会遍历所有的表</strong>；</p>
<p><strong>如果按照卖家id切分，则按照订单id和买家id查询会遍历所有的表</strong>；</p>
<p>现在我们先来分析一下业务场景。</p>
<ol>
<li><p>80%以上的查询是通过订单id进行查询。</p>
</li>
<li><p>15%左右通过买家id查询已购买商品列表。</p>
</li>
<li><p>5%左右通过卖家id查询已卖出商品列表。</p>
</li>
</ol>
<p>以上数据各个电商平台业务场景不一，比例会有浮动。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;很明显，根据业务场景，如果只能选一个，我们最好是选择订单id进行切分。那么，如果按照卖家id和买家id查询如何解决？</p>
<p>一种方法，我们可以为<strong>卖家和买家分别存储一个维度的冗余数据，以供查询</strong>。但是这样就是三倍冗余，比较浪费。</p>
<blockquote>
<p>订单id=》卖家id</p>
<p>订单id=》买家id</p>
</blockquote>
<p>另外一种方法是<strong>通过外置搜索引擎建立索引进行查询</strong>。相比上一种更好。因为用户买家id或者卖家id进行查询的时候，通常还有其他过滤条件。</p>
<p>还有一种比较讨巧的做法，就是<strong>让订单id和买家id建立联系</strong>。<strong>我们在水平切分表的时候，可以截取买家id的后几位，生成订单id时在末尾加上截取出来的买家id</strong>。如果在生成订单id的时候能够保持后几位和买家id一致，那订单id和买家id就相当于建立了联系。通过订单id和买家id查询都不用遍历所有表了。</p>
<h2 id="如何扩展数据中心"><a href="#如何扩展数据中心" class="headerlink" title="如何扩展数据中心"></a>如何扩展数据中心</h2><h3 id="两地三中心和同城多活"><a href="#两地三中心和同城多活" class="headerlink" title="两地三中心和同城多活"></a>两地三中心和同城多活</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常，为了容灾，大型企业系统会采用灾备的部署方式，也就是说，一个主机房，一个备份机房，主机房承载所有的流量，而备份机房平时处于休眠状态，没有流量，只有当发生灾难，主机房不可用的时候才会启用备份机房。而通常主备之间的延迟比较大，只能采用异步复制数据的方式。但是这仅仅作为灾备，如果一个机房的容量达到瓶颈，是无法扩展的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了解决这个问题，通常会采用两地三中心的方案，这也是很多银行系统在使用的方案。如图所示，<strong>其中两个机房需要离的比较近，延迟非常小，某些场景下可以看成一个机房，所以，需要专线连接，所有的流量都由这两个机房承载，另外一个则作为灾备，平时处于休眠状态</strong>。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/31.webp" alt="img"></p>
<p><em>两地三中心</em></p>
<p>对于两地三中心，问题如下：</p>
<ul>
<li><p>由于需要低延迟，专线比较贵，“两地”通常离的比较近，真正的灾难来临，例如地震，还是跟主备一样。</p>
</li>
<li><p>备份节点处于休眠状态，比较浪费资源。</p>
</li>
<li><p>备份节点处于休眠状态，真正切换的时候，需要的时间较长。</p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们需要明确的是，在两地三中心这种数据中心架构中，首先需要梳理出核心业务流程，对服务进行分级，规划哪些业务需要部署到多个数据中心，并不是所有的应用都需要做到那么高的可用性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其次，<strong>往备份节点同步数据一定是异步的复制方式，否则性能会受到非常大的影响，异步意味着可能会丢失部分数据，这是不可避免的，如果真的发生地震，只要磁盘不坏，还是可以恢复的，尽管恢复的时间比较长</strong>。</p>
<h3 id="同城多活"><a href="#同城多活" class="headerlink" title="同城多活"></a>同城多活</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微信采用的是一地三园区的部署方式，三个园区是对等并且物理隔离的，也就是说，无论是服务层，还是存储层，都部署在三个园区，流量被负载均衡到三个园区，不存在资源浪费。当其中一个园区发生故障时，流量会被均分到另外两个园区，另外两个园区流量上升百分之五十。这是由微信的底层存储决定的，微信底层存储采用的是<code>KVSvr</code>，可以实现强一致性、高可用、高性能，实际上，是利用W+R&gt;N原理，只要写数据时写两份成功才返回，就能保证，如果一个节点挂掉，读取两个节点一定能读到一份最新的数据。当然，一地决定了时延较低，但是也无法做到跨城区的容灾。</p>
<p>我们来总结一下上面的方案。</p>
<ul>
<li><strong>如果跨城区，能跨城市容灾，但是成本高，利用率低，一致性低</strong>。</li>
<li><strong>如果同城，成本低，利用率高，可以保证核心业务强一致，但不能跨城市容灾，且扩展性受限</strong>。</li>
</ul>
<p>那么有没有其他的方案呢？当然是有，不过，系统架构将变的越来越复杂，成本越来越高。</p>
<h3 id="异地多活"><a href="#异地多活" class="headerlink" title="异地多活"></a>异地多活</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;异地多活是指在两个以上的城市建立机房，流量被平均分配，当一个城市出现故障的时候，可以将发生故障的城市的流量快速切换到其他城市。异地多活就像以城市为单位的分片，如，IP为北京的访问北京机房，IP为上海的访问上海机房。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果做到异地多活，首先要分析业务，实际上，有的业务要实现多活是比较容易的，而有的业务是很难实现多活的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如手机通讯录，用户之间是没有关系的，也就是说A的通讯录里面存的数据不需要和其他人有任何关系。这种数据结构非常简单，可以以用户所在城市为切分键，这样就不存在一行数据在多个数据中心同时修改的情况。假设将中国分为三个数据中心，分别为北京、上海、广州，当用户属于北京数据中心时，所有请求都访问北京。新增数据时，只要北京写入成功就返回，然后同步组件订阅数据库<code>binlog</code>信息，同步到其他机房汇总、备份。如图所示。</p>
<p><img src="//blog.com/2019/07/27/可扩展性设计/32.webp" alt="img"></p>
<p><em>异地多活</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果是微博、电商这种数据，选择切分键就比较麻烦。在电商中，有买家和卖家两个维度读写数据，当买家下订单后，卖家维度要及时扣减库存，生成订单。而买家和卖家很可能不在一个城市。由于一般电商都是微服务架构，一次下单操作，在后台可能是几百次请求调用，如果这些请求要在多个数据中心来回传递10次，假设每次跨数据中心要延迟50毫秒，那一次下单操作在采用异地多活架构之后就要比以前响应时间降低500毫秒，这是不能接受的。所以，我们最好能保证一次请求可以在一个机房内完成。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于异地多活的成本比较高，不只是物理成本，还有设计、开发、维护的成本，因此，应该尽量让核心业务实现异地多活，而不是所有业务一视同仁。这个思路和数据库的扩展是一致的，<strong>如果能将一个独立的业务拆分到另外一个机房，应该优先选择这种方案，如果依赖太多，解决不了，再选择异地多活</strong>。另外一个原因是有些业务很难实现拆分，特别是一些对一致性要求特别高的服务，比如库存，异步将是致命的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>在考虑异地多活的时候，还要考虑一致性问题</strong>，前面我提到了一行数据的一致性问题，如果是整张表的一致性呢？如注册手机号，需要唯一键约束，如果分布到多张表中，无法实现一致性约束，虽然前端在写入前做了很充分的校验，但是如果一个用户进入多个注册页面，填写了校验信息，瞬间提交所有注册请求，由于异步的问题，可能导致全部成功。这时候有两种解决方案，一种是从业务的角度，这种毕竟是少数，如果前端已经做了防重复提交，那就可能存在恶意行为，应该由另外的定时任务去补偿处理。另外一种从技术角度，<strong>如果认为业务不允许出现任何不一致，此业务可以不做异地多活，可以做到多个数据中心读取，一个数据中心写入</strong>。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/架构/" rel="tag"># 架构</a>
          
            <a href="/tags/微服务/" rel="tag"># 微服务</a>
          
            <a href="/tags/分布式系统/" rel="tag"># 分布式系统</a>
          
            <a href="/tags/高可用/" rel="tag"># 高可用</a>
          
            <a href="/tags/扩展性/" rel="tag"># 扩展性</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/27/RPC 框架的可靠性设计/" rel="next" title="RPC 框架的可靠性设计">
                <i class="fa fa-chevron-left"></i> RPC 框架的可靠性设计
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/07/28/如何做一个靠谱的发号器/" rel="prev" title="如何做一个靠谱的发号器">
                如何做一个靠谱的发号器 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#可扩展性设计"><span class="nav-number">1.</span> <span class="nav-text">可扩展性设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#加机器能解决问题吗"><span class="nav-number">1.1.</span> <span class="nav-text">加机器能解决问题吗</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#横向扩展与纵向扩展介绍"><span class="nav-number">1.2.</span> <span class="nav-text">横向扩展与纵向扩展介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AKF扩展立方体"><span class="nav-number">1.3.</span> <span class="nav-text">AKF扩展立方体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何扩展长连接"><span class="nav-number">1.4.</span> <span class="nav-text">如何扩展长连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#当其中一个push服务挂掉的时候，客户端应该作何反应"><span class="nav-number">1.4.1.</span> <span class="nav-text">当其中一个push服务挂掉的时候，客户端应该作何反应</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#反向代理"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">反向代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注册中心"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">注册中心</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何记录client和push的对应关系"><span class="nav-number">1.4.2.</span> <span class="nav-text">如何记录client和push的对应关系</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将映射关系数据放入缓存"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">将映射关系数据放入缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#根据节点总数计算映射关系"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">根据节点总数计算映射关系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何扩展数据库"><span class="nav-number">1.5.</span> <span class="nav-text">如何扩展数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#X轴扩展—主从复制集群"><span class="nav-number">1.5.1.</span> <span class="nav-text">X轴扩展—主从复制集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Y轴扩展—分库、垂直分表"><span class="nav-number">1.5.2.</span> <span class="nav-text">Y轴扩展—分库、垂直分表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Z轴扩展—分片（sharding）"><span class="nav-number">1.5.3.</span> <span class="nav-text">Z轴扩展—分片（sharding）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分片目标"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">分片目标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分片算法"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">分片算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#区间法（Range-Based）"><span class="nav-number">1.5.3.2.1.</span> <span class="nav-text">区间法（Range-Based）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#轮流法（Round-Robin）"><span class="nav-number">1.5.3.2.2.</span> <span class="nav-text">轮流法（Round-Robin）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#一致性哈希法（Consistent-Hashing）"><span class="nav-number">1.5.3.2.3.</span> <span class="nav-text">一致性哈希法（Consistent Hashing）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何避免重新均衡数据"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">如何避免重新均衡数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管理分片"><span class="nav-number">1.5.3.4.</span> <span class="nav-text">管理分片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么要带拆分键"><span class="nav-number">1.5.3.5.</span> <span class="nav-text">为什么要带拆分键</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分片后的关联查询问题"><span class="nav-number">1.5.3.6.</span> <span class="nav-text">分片后的关联查询问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#方案一：建立多维度数据库"><span class="nav-number">1.5.3.6.1.</span> <span class="nav-text">方案一：建立多维度数据库</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方案二：建立外部搜索引擎"><span class="nav-number">1.5.3.6.2.</span> <span class="nav-text">方案二：建立外部搜索引擎</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#方案三：通过分布式缓存"><span class="nav-number">1.5.3.6.3.</span> <span class="nav-text">方案三：通过分布式缓存</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分片扩容（re-sharding）"><span class="nav-number">1.5.3.7.</span> <span class="nav-text">分片扩容（re-sharding）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#停服扩容"><span class="nav-number">1.5.3.7.1.</span> <span class="nav-text">停服扩容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#基于数据库的0中断扩容"><span class="nav-number">1.5.3.7.2.</span> <span class="nav-text">基于数据库的0中断扩容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#基于数据库中间件的0中断扩容"><span class="nav-number">1.5.3.7.3.</span> <span class="nav-text">基于数据库中间件的0中断扩容</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#精选案例"><span class="nav-number">1.5.3.8.</span> <span class="nav-text">精选案例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#活动平台数据表水平切分"><span class="nav-number">1.5.3.8.1.</span> <span class="nav-text">活动平台数据表水平切分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SNS数据表水平切分"><span class="nav-number">1.5.3.8.2.</span> <span class="nav-text">SNS数据表水平切分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#电商数据表水平切分"><span class="nav-number">1.5.3.8.3.</span> <span class="nav-text">电商数据表水平切分</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何扩展数据中心"><span class="nav-number">1.6.</span> <span class="nav-text">如何扩展数据中心</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#两地三中心和同城多活"><span class="nav-number">1.6.1.</span> <span class="nav-text">两地三中心和同城多活</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同城多活"><span class="nav-number">1.6.2.</span> <span class="nav-text">同城多活</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异地多活"><span class="nav-number">1.6.3.</span> <span class="nav-text">异地多活</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
