<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="架构,用户身份验证,token认证,OAuth 2.0,">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="细说API - 认证、授权和凭证  原文地址：https://mp.weixin.qq.com/s/oOjplJXjcA3lzo65nV0aQw   在一些互联网公司的面试中，面试官往往会问这样一个问题： “如果禁用浏览器 cookie，如何实现用户追踪和认证？” &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;遗憾的是依然有大量候选人答非所问，无法搞清楚 cookie 和">
<meta name="keywords" content="架构,用户身份验证,token认证,OAuth 2.0">
<meta property="og:type" content="article">
<meta property="og:title" content="细说API - 认证、授权和凭证">
<meta property="og:url" content="http://blog.com/2019/05/12/细说API - 认证、授权和凭证/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="细说API - 认证、授权和凭证  原文地址：https://mp.weixin.qq.com/s/oOjplJXjcA3lzo65nV0aQw   在一些互联网公司的面试中，面试官往往会问这样一个问题： “如果禁用浏览器 cookie，如何实现用户追踪和认证？” &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;遗憾的是依然有大量候选人答非所问，无法搞清楚 cookie 和">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://blog.com/2019/05/12/细说API%20-%20认证、授权和凭证/1.webp">
<meta property="og:image" content="http://blog.com/2019/05/12/细说API%20-%20认证、授权和凭证/2.webp">
<meta property="og:image" content="http://blog.com/2019/05/12/细说API%20-%20认证、授权和凭证/3.webp">
<meta property="og:image" content="http://blog.com/2019/05/12/细说API%20-%20认证、授权和凭证/4.webp">
<meta property="og:image" content="http://blog.com/2019/05/12/细说API%20-%20认证、授权和凭证/5.webp">
<meta property="og:image" content="http://blog.com/2019/05/12/细说API%20-%20认证、授权和凭证/6.webp">
<meta property="og:image" content="http://blog.com/2019/05/12/细说API%20-%20认证、授权和凭证/7.webp">
<meta property="og:image" content="http://blog.com/2019/05/12/细说API%20-%20认证、授权和凭证/8.webp">
<meta property="og:image" content="http://blog.com/2019/05/12/细说API%20-%20认证、授权和凭证/9.webp">
<meta property="og:image" content="http://blog.com/2019/05/12/细说API%20-%20认证、授权和凭证/10.webp">
<meta property="og:image" content="http://blog.com/2019/05/12/细说API%20-%20认证、授权和凭证/11.webp">
<meta property="og:image" content="http://blog.com/2019/05/12/细说API%20-%20认证、授权和凭证/13.webp">
<meta property="og:updated_time" content="2019-05-12T15:00:58.455Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="细说API - 认证、授权和凭证">
<meta name="twitter:description" content="细说API - 认证、授权和凭证  原文地址：https://mp.weixin.qq.com/s/oOjplJXjcA3lzo65nV0aQw   在一些互联网公司的面试中，面试官往往会问这样一个问题： “如果禁用浏览器 cookie，如何实现用户追踪和认证？” &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;遗憾的是依然有大量候选人答非所问，无法搞清楚 cookie 和">
<meta name="twitter:image" content="http://blog.com/2019/05/12/细说API%20-%20认证、授权和凭证/1.webp">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/2019/05/12/细说API - 认证、授权和凭证/">





  <title>细说API - 认证、授权和凭证 | 搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/12/细说API - 认证、授权和凭证/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">细说API - 认证、授权和凭证</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-12T22:12:57+08:00">
                2019-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/用户身份验证/" itemprop="url" rel="index">
                    <span itemprop="name">用户身份验证</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/用户身份验证/token认证/" itemprop="url" rel="index">
                    <span itemprop="name">token认证</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/用户身份验证/token认证/OAuth-2-0/" itemprop="url" rel="index">
                    <span itemprop="name">OAuth 2.0</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="细说API-认证、授权和凭证"><a href="#细说API-认证、授权和凭证" class="headerlink" title="细说API - 认证、授权和凭证"></a>细说API - 认证、授权和凭证</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s/oOjplJXjcA3lzo65nV0aQw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/oOjplJXjcA3lzo65nV0aQw</a></p>
</blockquote>
<p><br></p>
<p>在一些互联网公司的面试中，面试官往往会问这样一个问题：</p>
<p><strong>“如果禁用浏览器 <code>cookie</code>，如何实现用户追踪和认证？”</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;遗憾的是依然有大量候选人答非所问，无法搞清楚 <code>cookie</code> 和 <code>session</code>之间的区别。而在工作中也有让人惊讶的真实案例：把 <code>user ID</code> 存储到<code>local storage</code>中当做 <code>token</code>使用，原因是他们声称弃用了 <code>cookie</code> 这种落后的东西；一个移动端项目，服务器给出的 <code>API</code>中需要客户端模拟一个 <code>cookie</code>，从而像浏览器中 <code>ajax</code>那样消费 API。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;互联网是基于<code>HTTP</code>协议构建的，而 <code>HTTP</code>协议因为简单流行开来，但是<code>HTTP</code> 协议是无状态（通信层面上虚电路比数据报昂贵太多）的，为此人们为了追踪用户想出了各种办法，包括<code>cookie/session</code> 机制、<code>token、flash</code> 跨浏览器 <code>cookie</code> 甚至浏览器指纹等。</p>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/1.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;把用户身份藏在每一个地方（浏览器指纹技术甚至不需要存储介质）</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;讲使用<code>spring security</code>等具体技术的资料已经很多了，这篇文章不打算写框架和代码的具体实现。我们会讨论认证和授权的区别，然后会介绍一些被业界广泛采用的技术，最后会聊聊怎么为 <code>API</code> 构建选择合适的认证方式。</p>
<hr>
<h2 id="认证、授权、凭证"><a href="#认证、授权、凭证" class="headerlink" title="认证、授权、凭证"></a><strong>认证、授权、凭证</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先，认证和授权是两个不同的概念，为了让我们的 <code>API</code> 更加安全和具有清晰的设计，理解认证和授权的不同就非常有必要了，它们在英文中也是不同的单词。</p>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/2.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>认证是 <code>authentication</code>，指的是当前用户的身份，当用户登陆过后系统便能追踪到他的身份做出符合相应业务逻辑的操作</strong>。即使用户没有登录，大多数系统也会追踪他的身份，只是当做来宾或者匿名用户来处理。认证技术解决的是 <code>“我是谁？”</code>的问题。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;授权则不同，<strong>授权是 <code>authorization</code>，指的是什么样的身份被允许访问某些资源，在获取到用户身份后继续检查用户的权限</strong>。单一的系统授权往往是伴随认证来完成的，但是在开放<code>API</code>的多系统结构下，授权可以由不同的系统来完成，例如<code>OAuth</code>。授权技术是解决<code>“我能做什么？”</code>的问题。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>实现认证和授权的基础是需要一种媒介（<code>credentials</code>）来标记访问者的身份或权利</strong>，在现实生活中每个人都需要一张身份证才能访问自己的银行账户、结婚和办理养老保险等，这就是认证的凭证；在古代军事活动中，皇帝会给出战的将军颁发兵符，下级将领不关心持有兵符的人，只需要执行兵符对应的命令即可。在互联网世界中，服务器为每一个访问者颁发 <code>session ID</code> 存放到 <code>cookie</code>，这就是一种凭证技术。数字凭证还表现在方方面面，<code>SSH</code>登录的密匙、<code>JWT</code> 令牌、一次性密码等。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用户账户也不一定是存放在数据库中的一张表，在一些<code>企业 IT</code>系统中，对账户管理和权限有了更多的要求。所以账户技术 （<code>accounting</code>）可以帮助我们使用不同的方式管理用户账户，同时具有不同系统之间共享账户的能力。例如微软的活动目录（<code>AD</code>），以及简单目录访问协议（<code>LDAP</code>），甚至区块链技术。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;还有一个重要的概念是访问控制策略（<code>AC</code>）。如果我们需要把资源的权限划分到一个很细的粒度，就不得不考虑用户以何种身份来访问受限的资源，选择基于访问控制列表（<code>ACL</code>）还是基于用户角色的访问控制（<code>RBAC</code>）或者其他访问控制策略。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在流行的技术和框架中，这些概念都无法孤立的被实现，因此在现实中使用这些技术时，大家往往为一个<code>OAuth2</code>是认证还是授权这种概念争论不休。为了容易理解，我在文末附上了一份常见技术和概念的术语表。下面我会介绍在API开发中常常使用的几种认证和授权技术：<code>HTTP Basic AUthentication、HAMC、OAuth2</code>，以及凭证技术<code>JWT token</code>。</p>
<hr>
<h2 id="认证和授权技术"><a href="#认证和授权技术" class="headerlink" title="认证和授权技术"></a>认证和授权技术</h2><h3 id="HTTP-Basic-Authentication"><a href="#HTTP-Basic-Authentication" class="headerlink" title="HTTP Basic Authentication"></a><strong>HTTP Basic Authentication</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;你一定用过这种方式，但不一定知道它是什么，在不久之前，当你访问一台家用路由器的管理界面，往往会看到一个浏览器弹出表单，要求你输入用户密码。</p>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/3.webp" alt="img"></p>
<p>在这背后，当用户输入完用户名密码后，浏览器帮你做了一个非常简单的操作:</p>
<ol>
<li>组合用户名和密码然后 <code>Base64</code>编码</li>
<li>给编码后的字符串添加 Basic 前缀，然后设置名称为 <code>Authorization</code>的<code>header</code>头部</li>
</ol>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/4.webp" alt="img"></p>
<p><code>API</code> 也可以非常简单的提供 <code>HTTP Basic Authentication</code>认证方式，那么客户端可以很简单通过<code>Base64</code>传输用户名和密码即可:</p>
<ol>
<li>将用户名和密码使用冒号连接，例如 <code>username:abc123456</code></li>
<li>为了防止用户名或者密码中存在超出 <code>ASCII</code>码范围的字符，推荐使用<code>UTF-8</code>编码</li>
<li>将上面的字符串使用<code>Base 64</code>编码，例如： <code>dXNlcm5hbWU6YWJjMTIzNDU2</code></li>
<li>在 <code>HTTP</code>请求头中加入 “<code>Basic</code> + 编码后的字符串”，即：<code>Authorization: Basic</code> <code>QWxhZGRpbjpPcGVuU2VzYW1l</code></li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种方式实现起来非常简单，在大量场景下被采用。当然缺点也很明显，<code>Base64</code> 只能称为编码，而不是加密 (实际上无需配置密匙的客户端并没有任何可靠地加密方式，我们都依赖 <code>TSL</code> 协议)。这种方式的致命弱点是编码后的密码如果明文传输则容易在网络传输中泄露，在密码不会过期的情况下，密码一旦泄露，只能通过修改密码的方式。</p>
<hr>
<h3 id="HMAC（AK-SK）认证"><a href="#HMAC（AK-SK）认证" class="headerlink" title="HMAC（AK/SK）认证"></a>HMAC（AK/SK）认证</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们对接一些 <code>PASS</code> 平台和支付平台时，会要求我们预先生成一个 <code>access key（AK）</code>和 <code>secure key（SK）</code>，然后通过签名的方式完成认证请求，这种方式可以避免传输<code>secure key</code>，且大多数情况下签名只允许使用一次，避免了重放攻击。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种基于 <code>AK/SK</code> 的认证方式主要是利用散列的消息认证码 (<code>Hash-based MessageAuthentication Code</code>) 来实现的，因此有很多地方叫 <code>HMAC</code>认证，实际上不是非常准确。<code>HMAC</code> 只是利用带有 <code>key</code>值的哈希算法生成消息摘要，在设计 <code>API</code>时有具体不同的实现。</p>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/5.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>HMAC</code> 在作为网络通信的认证设计中作为凭证生成算法使用，避免了口令等敏感信息在网络中传输。基本过程如下：</p>
<ol>
<li>客户端需要在认证服务器中预先设置 <code>access key</code>（<code>AK 或叫 app ID</code>） 和 <code>secure key</code>（SK）</li>
<li>在调用 <code>API</code>时，客户端需要对参数和 <code>access key</code> 进行自然排序后并使用 <code>secure key</code>进行签名生成一个额外的参数 <code>digest</code></li>
<li>服务器根据预先设置的<code>secure key</code>进行同样的摘要计算，并要求结果完全一致</li>
<li><strong>注意 secure key 不能在网络中传输，以及在不受信任的位置存放（浏览器等）</strong></li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了让每一次请求的签名变得独一无二，从而实现重放攻击，我们需要在签名时放入一些干扰信息。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在业界标准中有两种典型的做法，质疑/应答算法（<code>OCRA: OATH Challenge-Response Algorithm</code>）、基于时间的一次性密码算法（<code>TOTP：Time-based One-time Password Algorithm</code>）。</p>
<h4 id="质疑-应答算法"><a href="#质疑-应答算法" class="headerlink" title="质疑/应答算法"></a>质疑/应答算法</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;质疑/应答算法需要客户端先请求一次服务器，获得一个<code>401</code>未认证的返回，并得到一个随机字符串（<code>nonce</code>）。将 <code>nonce</code> 附加到按照上面说到的方法进行<code>HMAC</code>签名，<strong>服务器使用预先分配的<code>nonce</code>同样进行签名校验，这个 <code>nonce</code>在服务器只会被使用一次，因此可以提供唯一的摘要</strong>。</p>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/6.webp" alt="img"></p>
<h4 id="基于时间的一次性密码认证"><a href="#基于时间的一次性密码认证" class="headerlink" title="基于时间的一次性密码认证"></a>基于时间的一次性密码认证</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了避免额外的请求来获取 <code>nonce</code>，还有一种算法是使用时间戳，并且<strong>通过同步时间的方式协商到一致，在一定的时间窗口内有效（1分钟左右）</strong>。</p>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/7.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里的只是利用时间戳作为验证的时间窗口，并不能严格的算作基于时间的一次性密码算法。标准的基于时间的一次性密码算法在两步验证中被大量使用，例如<code>Google</code>身份验证器不需要网络通信也能实现验证（但依赖准确的授时服务）。<strong>原理是客户端服务器共享密钥然后根据时间窗口能通过 <code>HMAC</code> 算法计算出一个相同的验证码</strong>。</p>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/8.webp" alt="img"></p>
<hr>
<h3 id="OAuth2-和-Open-ID"><a href="#OAuth2-和-Open-ID" class="headerlink" title="OAuth2 和 Open ID"></a><strong>OAuth2 和 Open ID</strong></h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>OAuth</code>（开放授权）是一个<strong>开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>OAuth</code> 是一个授权标准，而不是认证标准。提供资源的服务器不需要知道确切的用户身份（<code>session</code>），只需要验证授权服务器授予的权限（<code>token</code>）即可。</p>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/9.webp" alt="img"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图只是 <code>OAuth</code> 的一个简化流程，<code>OAuth</code>的基本思路就是通过授权服务器获取 <code>access token</code> 和 <code>refresh token</code>（<code>refresh token</code> 用于重新刷新<code>access token</code>），然后通过<code>access token</code>从资源服务器获取数据 。在特定的场景下还有下面几种模式：</p>
<ol>
<li>授权码模式（<code>authorization code</code>）</li>
<li>简化模式（<code>implicit</code>）</li>
<li>密码模式（<code>resource owner password credentials</code>）</li>
<li>客户端模式（<code>client credentials</code>）</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要获取用户的认证信息，<code>OAuth</code> 本身没有定义这部分内容，如果需要识别用户信息，则需要借助另外的认证层，例如<code>OpenID Connect</code>。</p>
<h4 id="验证-access-token"><a href="#验证-access-token" class="headerlink" title="验证 access token"></a>验证 access token</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一些介绍<code>OAuth</code>的博客中很少讲到资源服务器是怎么验证 <code>access token</code> 的。<code>OAuth core</code> 标准并没有定义这部分，不过在<code>OAuth</code> 其他标准文件中提到两种验证<code>access token</code>的方式。</p>
<ol>
<li>在完成授权流程后，资源服务器可以使用 <code>OAuth</code> 服务器提供的<code>Introspection</code>接口来验证<code>access token</code>，<code>OAuth</code>服务器会返回<code>access token</code> 的状态以及过期时间。在<code>OAuth</code>标准中验证<code>token</code>的术语是 <code>Introspection</code>。同时也需要注意 <code>access token</code>是用户和资源服务器之间的凭证，不是资源服务器和授权服务器之间的凭证。资源服务器和授权服务器之间应该使用额外的认证（例如 <code>Basic</code>认证）。</li>
</ol>
<ol start="2">
<li>使用<code>JWT</code> 验证。授权服务器使用私钥签发<code>JWT</code>形式的<code>access token</code>，资源服务器需要使用预先配置的公钥校验<code>JWT token</code>，并得到<code>token</code>状态和一些被包含在<code>access token</code>中信息。因此在<code>JWT</code> 的方案下，资源服务器和授权服务器不再需要通信，在一些场景下带来巨大的优势。同时<code>JWT</code>也有一些弱点，我会在<code>JWT</code>的部分解释。</li>
</ol>
<h4 id="refresh-token-和-access-token"><a href="#refresh-token-和-access-token" class="headerlink" title="refresh token 和 access token"></a>refresh token 和 access token</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;几乎所有人刚开始了解<code>OAuth</code> 时都有一个一疑问，为什么已经有了<code>access token</code>还需要 <code>refresh token</code>呢？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;授权服务器会在第一次授权请求时一起返回 <code>access token</code> 和<code>refresh token</code>，在后面刷新 <code>access token</code>时只需要 <code>refresh token</code>。<strong><code>access token</code> 和 <code>refresh token</code> 的设计意图是不一样的，<code>access token</code> 被设计用来客户端和资源服务器之间交互，而 <code>refresh token</code> 是被设计用来客户端和授权服务器之间交互</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;某些授权模式下 <code>access token</code>需要暴露给浏览器，充当一个资源服务器和浏览器之间的临时会话，浏览器和资源服务器之间不存在签名机制，<code>access token</code> 成为唯一凭证，因此 <code>access token</code> 的过期时间（<code>TTL</code>）应该尽量短，从而避免用户的 <code>access token</code> 被嗅探攻击。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于要求 <code>access token</code> 时间很短，<code>refresh token</code> 可以帮助用户维护一个较长时间的状态，避免频繁重新授权。大家会觉得让 <code>access token</code>保持一个长的过期时间不就可以了吗？实际上 <code>refresh token</code> 和 <code>access token</code>的不同之处在于即使<code>refresh token</code> 被截获，系统依然是安全的，客户端拿着 <code>refresh token</code>去获取<code>access token</code>时同时需要预先配置的 <code>secure key</code>，客户端和授权服务器之前始终存在安全的认证。</p>
<hr>
<h2 id="OAuth、Open-ID、OpenID-Connect"><a href="#OAuth、Open-ID、OpenID-Connect" class="headerlink" title="OAuth、Open ID、OpenID Connect"></a><strong>OAuth、Open ID、OpenID Connect</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>OAuth</code> 负责解决分布式系统之间的授权问题，即使有时候客户端和资源服务器或者认证服务器存在同一台机器上。<code>OAuth</code> 没有解决认证的问题，但提供了良好的设计利于和现有的认证系统对接。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Open ID</code>解决的问题是分布式系统之间身份认证问题，使用<code>Open ID token</code>能在多个系统之间验证用户，以及返回用户信息，可以独立使用，与 <code>OAuth</code>没有关联。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>OpenID Connect</code> 解决的是在 <code>OAuth</code> 这套体系下的用户认证问题，实现的基本原理是将用户的认证信息（<code>ID token</code>）当做资源处理。在<code>OAuth</code> 框架下完成授权后，再通过 <code>access token</code> 获取用户的身份。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这三个概念之间的关系有点难以理解，用现实场景来说，如果系统中需要一套独立的认证系统，并不需要多系统之间的授权可以直接采用<code>Open ID</code>。如果使用了<code>OAuth</code>作为授权标准，可以再通过 <code>OpenID Connect</code>来完成用户的认证。</p>
<hr>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>OAuth</code> 等分布式的认证、授权体系下，对凭证技术有了更多的要求，比如包含用户 ID、过期等信息，不需要再外部存储中关联。因此业界对<code>token</code> 做了进一步优化，设计了一种<strong>自包含令牌，令牌签发后无需从服务器存储中检查是否合法，通过解析令牌就能获取令牌的过期、有效等信息</strong>，这就是<code>JWT （JSON Web Token）</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JWT</code>是一种包含令牌（<code>self-contained token</code>），或者叫值令牌 （<code>value token</code>），我们以前使用关联到 <code>session</code> 上的<code>hash</code> 值被叫做引用令牌（<code>reference token</code>）。</p>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/10.webp" alt="img"></p>
<p>简而言之，一个基本的JWT令牌为一段点分3段式结构。</p>
<p><em><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</code></em></p>
<p>生成JWT 令牌的流程为</p>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/11.webp" alt="img"></p>
<ol>
<li><code>header json</code> 的<code>base64</code>编码为令牌第一部分</li>
<li><code>payload json</code> 的<code>base64</code> 编码为令牌第二部分</li>
<li>拼装第一、第二部分编码后的<code>json</code>以及 <code>secret</code> 进行签名的令牌的第三部分</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此只需要签名的 <code>secret key</code> 就能校验 <code>JWT</code>令牌，如果在消息体中加入用户 ID、过期信息就可以实现验证令牌是否有效、过期了，无需从数据库/缓存中读取信息。因为使用了加密算法，所以第一、二部分即使被修改（包括过期信息）也无法通过验证。<strong><code>JWT</code>优点是不仅可以作为<code>token</code> 使用，同时也可以承载一些必要信息，省去多次查询</strong>。</p>
<p>注意：</p>
<ol>
<li><code>JWT token</code> 的第一、二部分只是 <code>base64</code>编码，肉眼不可读，不应当存放敏感信息</li>
<li><code>JWT token</code>的自包含特性，导致了无法被撤回</li>
<li><code>JWT</code>的签名算法可以自己拟定，为了便于调试，本地环境可以使用对称加密算法，生产环境建议使用非对称加密算法</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JWT token</code> 在微服务的系统中优势特别突出。多层调用的<code>API</code> 中可以直接传递<code>JWT token</code>，利用自包含的能力，可以减少用户信息查询次数；更重要的是，使用非对称的加密方式可以通过在系统中分发密匙的方式验证 <code>JWT token</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当然 <code>OAuth</code> 对<code>access token</code>等凭证所选用的技术并没有做出限制，<code>OAuth</code>并不强制使用<code>JWT</code>，在使用<code>JWT</code> 自包含特性的优势时，必须考虑到<code>JWT</code>撤回困难的问题。在一些对撤回 <code>token</code>要求很高的项目中不适合使用<code>JWT</code>，即使采用了一些方案实现（<code>whitelist 和 blacklist</code>）也违背了设计<code>JWT</code> 的初衷。</p>
<hr>
<h2 id="Cookie-、Token-in-Cookie、Session-Token-依然被使用"><a href="#Cookie-、Token-in-Cookie、Session-Token-依然被使用" class="headerlink" title="Cookie 、Token in Cookie、Session Token 依然被使用"></a><strong>Cookie 、Token in Cookie、Session Token 依然被使用</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在构建<code>API</code>时，开发者会发现我们的认证方式和网页应用有一些不同，除了像<code>ajax</code> 这种典型的 <code>web</code> 技术外，如果我们希望 <code>API</code>是无状态的，不推荐使用 <code>Cookie</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 <code>Cookie</code> 的本质是用户第一次访问时服务器会分配一个 <code>Session ID</code>，后面的请求中客户端都会带上这个 ID 作为当前用户的标志，因为 <code>HTTP</code> 本身是无状态的，<code>Cookie</code> 属于一种内建于浏览器中实现状态的方式。如果我们的 <code>API</code> 是用来给客户端使用的，强行要求 <code>API</code> 的调用者管理<code>Cookie</code> 也可以完成任务。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一些遗留或者不是标准的认证实现的项目中，我们依然可以看到这些做法，快速地实现认证。</p>
<ol>
<li>使用<code>cookie</code>，例如 <code>web</code> 项目中 <code>ajax</code> 的方式</li>
<li>使用 <code>session ID</code> 或 <code>hash</code> 作为<code>token</code>，但将<code>token</code> 放入 <code>header</code>中传递</li>
<li>将生成的<code>token</code> （可能是<code>JWT</code>）放入<code>cookie</code> 传递，利用 <code>HTTPonly</code> 和 <code>Secure</code> 标签保护 <code>token</code></li>
</ol>
<hr>
<h2 id="选择合适的认证方式"><a href="#选择合适的认证方式" class="headerlink" title="选择合适的认证方式"></a><strong>选择合适的认证方式</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;随着微服务的发展，<code>API</code>的设计不仅仅是面向<code>WEB</code>或者 <code>Mobile APP</code>，还有<code>BFF（Backend for Frontend）</code>和 <code>Domain API</code>的认证，以及第三方服务的集成。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端到服务器之间认证和服务器到服务器之间认证是不同的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>我们把终端用户（<code>Human</code>）参与的通信，叫做 <code>Human-to-machine (H2M)</code>，服务器与服务器之间的通信叫做 <code>Machine-to-machine (M2M)</code></strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>H2M</code> 的通信需要更高的安全性，<code>M2M</code>的通信天然比<code>H2M</code> 安全，因此更多的强调性能，在不同的场合下选择合适的认证技术就显得特别重要。例如 <code>HTTP Basic Authentication</code>用来作为 <code>H2M</code>认证显得有些落后，但是在 <code>M2M</code> 中被大量使用。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>另外值得一提的是，H2M 这种通信方式下，客户端不受控制，由于无法自主分发密匙，认证通信的安全高度依赖 HTTPS。</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从一个宏观的角度看待他们的关系，对我们技术选型非常有帮助。</p>
<p><img src="//blog.com/2019/05/12/细说API - 认证、授权和凭证/13.webp" alt="img"></p>
<h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><ol>
<li><code>Browser fingerprinting</code> 通过查询浏览器的代理字符串，屏幕色深，语言等，然后这些值通过散列函数传递产生指纹，不需要通过 <code>Cookie</code> 就可以识别浏览器</li>
<li><code>MAC（Message authentication code）</code> 在密码学中，讯息鉴别码，是经过特定算法后产生的一小段资讯，检查某段讯息的完整性</li>
<li><code>HOTP（HMAC-based One-time Password algorithm）</code>基于散列消息验证码的一次性密码算法</li>
<li><code>Two-step verification</code> 是一种认证方法，使用两种不同的元素，合并在一起，来确认使用者的身份，是多因素验证中的一个特例</li>
<li><code>OTP （One time password ）</code>一次性密码，例如注册邮件和短信中的认证码</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/架构/" rel="tag"># 架构</a>
          
            <a href="/tags/用户身份验证/" rel="tag"># 用户身份验证</a>
          
            <a href="/tags/token认证/" rel="tag"># token认证</a>
          
            <a href="/tags/OAuth-2-0/" rel="tag"># OAuth 2.0</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/11/消息的顺序性保障/如何保证消费者接收消息的顺序/" rel="next" title="">
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/12/JSON Web Token入门教程/" rel="prev" title="JSON Web Token入门教程">
                JSON Web Token入门教程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#细说API-认证、授权和凭证"><span class="nav-number">1.</span> <span class="nav-text">细说API - 认证、授权和凭证</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#认证、授权、凭证"><span class="nav-number">1.1.</span> <span class="nav-text">认证、授权、凭证</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#认证和授权技术"><span class="nav-number">1.2.</span> <span class="nav-text">认证和授权技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-Basic-Authentication"><span class="nav-number">1.2.1.</span> <span class="nav-text">HTTP Basic Authentication</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HMAC（AK-SK）认证"><span class="nav-number">1.2.2.</span> <span class="nav-text">HMAC（AK/SK）认证</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#质疑-应答算法"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">质疑/应答算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于时间的一次性密码认证"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">基于时间的一次性密码认证</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OAuth2-和-Open-ID"><span class="nav-number">1.2.3.</span> <span class="nav-text">OAuth2 和 Open ID</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#验证-access-token"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">验证 access token</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#refresh-token-和-access-token"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">refresh token 和 access token</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OAuth、Open-ID、OpenID-Connect"><span class="nav-number">1.3.</span> <span class="nav-text">OAuth、Open ID、OpenID Connect</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JWT"><span class="nav-number">1.4.</span> <span class="nav-text">JWT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cookie-、Token-in-Cookie、Session-Token-依然被使用"><span class="nav-number">1.5.</span> <span class="nav-text">Cookie 、Token in Cookie、Session Token 依然被使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择合适的认证方式"><span class="nav-number">1.6.</span> <span class="nav-text">选择合适的认证方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#术语表"><span class="nav-number">1.7.</span> <span class="nav-text">术语表</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
