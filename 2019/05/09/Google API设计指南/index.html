<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="架构,API设计,">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="Google API设计指南面向资源的设计&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本设计指南的目标是帮助开发者设计简单、一致且易用的网络 API。同时，它还有助于将 RPC API（基于套接字）与 REST API（基于 HTTP）的设计融合起来。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC API通常根据接口和方法设计。随着时间">
<meta name="keywords" content="架构,API设计">
<meta property="og:type" content="article">
<meta property="og:title" content="Google API设计指南">
<meta property="og:url" content="http://blog.com/2019/05/09/Google API设计指南/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="Google API设计指南面向资源的设计&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本设计指南的目标是帮助开发者设计简单、一致且易用的网络 API。同时，它还有助于将 RPC API（基于套接字）与 REST API（基于 HTTP）的设计融合起来。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC API通常根据接口和方法设计。随着时间">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-05-14T01:09:54.039Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Google API设计指南">
<meta name="twitter:description" content="Google API设计指南面向资源的设计&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;本设计指南的目标是帮助开发者设计简单、一致且易用的网络 API。同时，它还有助于将 RPC API（基于套接字）与 REST API（基于 HTTP）的设计融合起来。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC API通常根据接口和方法设计。随着时间">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/2019/05/09/Google API设计指南/">





  <title>Google API设计指南 | 搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/05/09/Google API设计指南/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Google API设计指南</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-09T12:12:57+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/API设计/" itemprop="url" rel="index">
                    <span itemprop="name">API设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Google-API设计指南"><a href="#Google-API设计指南" class="headerlink" title="Google API设计指南"></a>Google API设计指南</h1><h2 id="面向资源的设计"><a href="#面向资源的设计" class="headerlink" title="面向资源的设计"></a>面向资源的设计</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本设计指南的目标是帮助开发者设计<strong>简单、一致且易用</strong>的网络 <code>API</code>。同时，它还有助于将 <code>RPC API</code>（基于套接字）与 <code>REST API</code>（基于 <code>HTTP</code>）的设计融合起来。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RPC API</code>通常根据接口和方法设计。随着时间的推移，接口和方法越来越多，最终结果可能是形成一个庞大而混乱的<code>API</code>接口，因为开发者必须单独学习每种方法。显然，这既耗时又容易出错。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>引入 <a href="http://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="noopener">REST</a> 架构风格主要是为了与 HTTP/1.1 配合使用，但也有助于解决这个问题。其核心原则是定义可以用少量方法控制的命名资源</strong>。资源和方法被称为 API 的“名词”和“动词”。使用 HTTP 协议时，资源名称自然映射到网址，方法自然映射到 HTTP 的 <code>POST</code>、<code>GET</code>、<code>PUT</code>、<code>PATCH</code> 和 <code>DELETE</code> 方法。这使得开发者可以假定资源拥有相同数量的少量标准方法，他们只需要学习较少的东西并专注于资源及其关系。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;近来，<code>HTTP REST API</code> 在互联网上取得了巨大成功。2010 年，大约 74％ 的公共网络<code>API</code> 是<code>HTTP REST API</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然<code>HTTP REST API</code> 在互联网上非常流行，但它们承载的流量比传统的 <code>RPC API</code>要小。例如，美国高峰时段大约一半的互联网流量是视频内容，显然出于性能考虑，很少有人会使用 <code>REST API</code>来传送此类内容。在数据中心内，许多公司使用基于套接字的 <code>RPC API</code>来承载大多数网络流量，这可能涉及比公共 <code>REST API</code>高几个数量级的数据（以字节为单位）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实际使用中，人们会出于不同目的选择 <code>RPC API</code>和 <code>HTTP REST API</code>，理想情况下，<code>API</code>平台应该为所有类型的<code>API</code> 提供最佳支持。本设计指南可帮助您设计和构建符合此原则的 <code>API</code>。它将面向资源的设计原则应用于通用<code>API</code>设计并定义了许多常见的设计模式，从而提高可用性并降低复杂性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>注意</strong>：本设计指南介绍了如何将 <code>REST</code> 原则应用于 <code>API</code> 设计，与编程语言、操作系统或网络协议无关。这不仅仅是一个创建 <code>REST API</code>的指南。</p>
<h3 id="什么是-REST-API？"><a href="#什么是-REST-API？" class="headerlink" title="什么是 REST API？"></a>什么是 REST API？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>REST API</code>是可单独寻址的“资源”（<code>API</code>中的“名词”）的“集合”。资源通过<a href="https://cloud.google.com/apis/design/resource_names" target="_blank" rel="noopener">资源名称</a>被引用，并通过一组“方法”（也称为“动词”或“操作”）进行控制。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>REST Google API</code> 的“标准方法”（也称为“REST 方法”）包括 <code>List</code>、<code>Get</code>、<code>Create</code>、<code>Update</code> 和 <code>Delete</code>。<code>API</code> 设计者还可以使用“自定义方法”（也称为“自定义动词”或“自定义操作”）来实现无法轻易映射到标准方法的功能（例如数据库事务）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>注意</strong>：自定义动词并不意味着创建自定义 <code>HTTP</code> 动词来支持自定义方法。对基于<code>HTTP</code> 的 <code>API</code> 而言，它们只是映射到最合适的 <code>HTTP</code> 动词。</p>
<h3 id="设计流程"><a href="#设计流程" class="headerlink" title="设计流程"></a>设计流程</h3><p>设计指南建议在设计面向资源的 <code>API</code> 时采取以下步骤（更多细节将在下面的特定部分中介绍）：</p>
<ul>
<li>确定 <code>API</code>提供的资源类型。</li>
<li>确定资源之间的关系。</li>
<li>根据类型和关系确定资源名称方案。</li>
<li>确定资源架构。</li>
<li>将最小的方法集附加到资源。</li>
</ul>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>面向资源的 API 通常被构建为资源层次结构，其中每个节点是一个“简单资源”或“集合资源”</strong>。为方便起见，它们通常被分别称为资源和集合。</p>
<ul>
<li>一个集合包含<strong>相同类型</strong>的资源列表。例如，一个用户拥有一组联系人。</li>
<li>资源具有一些状态和零个或多个子资源。每个子资源可以是一个简单资源或一个集合资源。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，<code>Gmail API</code> 有一组用户，每个用户都有一组消息、一组线程、一组标签、一个个人资料资源和若干设置资源。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然存储系统和<code>REST API</code>之间存在一些概念上的对应，但具有面向资源<code>API</code>的服务不一定是数据库，并且在解释资源和方法方面具有极大的灵活性。例如，创建日历事件（资源）可以为参与者创建附加事件、向参与者发送电子邮件邀请、预约会议室以及更新视频会议时间安排。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>面向资源的 API 的关键特性是，强调资源（数据模型）甚于资源上执行的方法（功能）</strong>。典型的面向资源的 <code>API</code> 使用少量方法公开大量资源。方法可以是标准方法或自定义方法。在本指南中，标准方法是：<code>List</code>、<code>Get</code>、<code>Create</code>、<code>Update</code>和 <code>Delete</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>如果<code>API</code> 功能能够自然映射到标准方法，则应该在 <code>API</code> 设计中使用该方法</strong>。<strong>如果功能不能自然映射到标准方法，则可以使用“自定义方法”</strong>。<a href="https://cloud.google.com/apis/design/custom_methods" target="_blank" rel="noopener">自定义方法</a>提供与传统 <code>RPC API</code> 相同的设计自由度，可用于实现常见的编程模式，例如数据库事务或数据分析。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下部分介绍了如何将面向资源的 <code>API</code>设计应用于大规模服务的一些实际示例。您可以在 <a href="https://github.com/googleapis/googleapis" target="_blank" rel="noopener">Google API</a> 代码库中找到更多示例。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这些示例中，星号表示列表中的一个特定资源。</p>
<h4 id="Gmail-API"><a href="#Gmail-API" class="headerlink" title="Gmail API"></a>Gmail API</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Gmail API</code> 服务实现了 <code>Gmail API</code> 并公开了大多数<code>Gmail</code>功能。它具有以下资源模型：</p>
<ul>
<li><p>API 服务：<code>gmail.googleapis.com</code></p>
</li>
<li><p>用户集合：<code>users/*</code></p>
<p>每个用户都拥有以下资源。</p>
<ul>
<li>消息集合：<code>users/*/messages/*</code></li>
<li>线程集合：<code>users/*/threads/*</code></li>
<li>标签集合：<code>users/*/labels/*</code></li>
<li>更改历史记录的集合：<code>users/*/history/*</code></li>
<li>表示用户个人资料的资源：<code>users/*/profile</code></li>
<li>表示用户设置的资源：<code>users/*/settings</code></li>
</ul>
</li>
</ul>
<h4 id="Cloud-Pub-Sub-API"><a href="#Cloud-Pub-Sub-API" class="headerlink" title="Cloud Pub/Sub API"></a>Cloud Pub/Sub API</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>pubsub.googleapis.com</code> 服务实现了 <a href="https://cloud.google.com/pubsub" target="_blank" rel="noopener">Cloud Pub/Sub API</a>，它定义了以下资源模型：</p>
<ul>
<li>API 服务：<code>pubsub.googleapis.com</code></li>
<li>主题集合：<code>projects/*/topics/*</code></li>
<li>订阅集合：<code>projects/*/subscriptions/*</code></li>
</ul>
<p><strong>注意</strong>：<code>Pub/Sub API</code> 的其他实现可以选择不同的资源命名方案。</p>
<h4 id="Cloud-Spanner-API"><a href="#Cloud-Spanner-API" class="headerlink" title="Cloud Spanner API"></a>Cloud Spanner API</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>spanner.googleapis.com</code> 服务实现了 <a href="https://cloud.google.com/spanner" target="_blank" rel="noopener">Cloud Spanner API</a>，它定义了以下资源模型：</p>
<ul>
<li>API 服务：<code>spanner.googleapis.com</code></li>
<li>实例集合：<code>projects/*/instances/*</code></li>
<li>实例操作的集合：<code>projects/*/instances/*/operations/*</code></li>
<li>数据库的集合：<code>projects/*/instances/*/databases/*</code></li>
<li>数据库操作的集合：<code>projects/*/instances/*/databases/*/operations/*</code></li>
<li>数据库会话的集合：<code>projects/*/instances/*/databases/*/sessions/*</code></li>
</ul>
<h2 id="资源名称"><a href="#资源名称" class="headerlink" title="资源名称"></a>资源名称</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在面向资源的 <code>API</code>中，“资源”是被命名的实体，“资源名称”是它们的标识符。<strong>每个资源都必须具有自己唯一的资源名称</strong>。<strong>资源名称由资源自身的 ID、任何父资源的 ID 及其 API 服务名称组成</strong>。在下文中，我们将查看资源 ID 以及如何构建资源名称。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>gRPC API</code>应使用无传输协议的 <a href="http://tools.ietf.org/html/rfc3986" target="_blank" rel="noopener">URI</a> 作为资源名称。它们通常遵循 <code>REST</code>网址规则，其行为与网络文件路径非常相似。它们可以轻松映射到 REST 网址：如需了解详情，请参阅<a href="https://cloud.google.com/apis/design/standard_methods" target="_blank" rel="noopener">标准方法</a>部分。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>“集合”是一种特殊的资源，包含相同类型的子资源列表</strong>。例如，目录是文件资源的集合。集合的资源 ID 称为集合 ID。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>资源名称由集合 ID 和资源 ID 构成，按分层方式组织并以正斜杠分隔</strong>。如果资源包含子资源，则子资源的名称由父资源名称后跟子资源的 ID 组成，也以正斜杠分隔。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例 1：存储服务具有一组 <code>buckets</code>，其中每个存储分区都有一组 <code>objects</code>：</p>
<table>
<thead>
<tr>
<th style="text-align:left">API 服务名称</th>
<th style="text-align:left">集合 ID</th>
<th style="text-align:left">资源 ID</th>
<th style="text-align:left">集合 ID</th>
<th style="text-align:left">资源 ID</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">//storage.googleapis.com</td>
<td style="text-align:left">/buckets</td>
<td style="text-align:left">/bucket-id</td>
<td style="text-align:left">/objects</td>
<td style="text-align:left">/object-id</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;示例 2：电子邮件服务具有一组 <code>users</code>。每个用户都有一个 <code>settings</code> 子资源，而 <code>settings</code> 子资源拥有包括 <code>customFrom</code> 在内的许多其他子资源：</p>
<table>
<thead>
<tr>
<th style="text-align:left">API 服务名称</th>
<th style="text-align:left">集合 ID</th>
<th style="text-align:left">资源 ID</th>
<th style="text-align:left">资源 ID</th>
<th style="text-align:left">资源 ID</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">//mail.googleapis.com</td>
<td style="text-align:left">/users</td>
<td style="text-align:left"><a href="mailto:/name@example.com" target="_blank" rel="noopener">/name@example.com</a></td>
<td style="text-align:left">/settings</td>
<td style="text-align:left">/customFrom</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>API 生产者可以为资源和集合 ID 选择任何可接受的值，只要它们在资源层次结构中是唯一的</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过拆分资源名称（例如 <code>name.split(&quot;/&quot;)[n]</code>），可以获得单个集合 ID 和资源 ID（假设任何段都不包含正斜杠）。</p>
<h3 id="完整资源名称"><a href="#完整资源名称" class="headerlink" title="完整资源名称"></a>完整资源名称</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无传输协议的 <a href="http://tools.ietf.org/html/rfc3986" target="_blank" rel="noopener">URI</a> 由 <a href="http://tools.ietf.org/html/rfc1035" target="_blank" rel="noopener">DNS 兼容的</a> API 服务名称和资源路径组成。资源路径也称为“相对资源名称”。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;//library.googleapis.com/shelves/shelf1/books/book2&quot;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>API</code>服务名称供客户端定位<code>API</code>服务端点；它<strong>可以</strong>是仅限内部服务的虚构 DNS 名称。如果 API 服务名称在上下文中很明显，则通常使用相对资源名称。</p>
<h3 id="相对资源名称"><a href="#相对资源名称" class="headerlink" title="相对资源名称"></a>相对资源名称</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开头没有“/”的 URI 路径 (<a href="http://tools.ietf.org/html/rfc3986#appendix-A" target="_blank" rel="noopener">path-noscheme</a>)。它标识 API 服务中的资源。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;shelves/shelf1/books/book2&quot;</span><br></pre></td></tr></table></figure>
<h3 id="资源-ID"><a href="#资源-ID" class="headerlink" title="资源 ID"></a>资源 ID</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标识其父资源中资源的非空<code>URI</code>段 (<a href="http://tools.ietf.org/html/rfc3986#appendix-A" target="_blank" rel="noopener">segment-nz-nc</a>)，请参见上文的示例。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;资源名称末尾的资源 ID <strong>可以</strong>具有多个 <code>URI 段</code>。例如：</p>
<table>
<thead>
<tr>
<th style="text-align:left">集合 ID</th>
<th style="text-align:left">资源 ID</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">files</td>
<td style="text-align:left">/source/py/parser.py</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;API 服务<strong>应该</strong>尽可能使用网址友好的资源 ID。资源 ID <strong>必须</strong>被清楚地记录，无论它们是由客户端、服务器还是其中一个分配的。例如，文件名通常由客户端分配，而电子邮件消息 ID 通常由服务器分配。</p>
<h3 id="集合-ID"><a href="#集合-ID" class="headerlink" title="集合 ID"></a>集合 ID</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;标识其父资源中集合资源的非空 <code>URI</code>段 (<a href="http://tools.ietf.org/html/rfc3986#appendix-A" target="_blank" rel="noopener">segment-nz-nc</a>)，请参见上文的示例。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于集合 ID 通常出现在生成的客户端库中，因此它们<strong>必须</strong>符合以下要求：</p>
<ul>
<li><p><strong>必须</strong>是有效的 <code>C/C++</code> 标识符。</p>
</li>
<li><p><strong>必须</strong>是复数形式的首字母小写驼峰体。如果该词语没有合适的复数形式，例如“evidence（证据）”和“weather（天气）”，则<strong>应该</strong>使用单数形式。</p>
</li>
<li><p><strong>必须</strong>使用简明扼要的英文词语。</p>
</li>
<li><p><strong>应该</strong>避免过于笼统的词语，或对其进行限定后再使用。例如，<code>rowValues</code> 好于<code>values</code></p>
<p><strong>应该</strong>避免在不加以限定的情况下使用以下词语：</p>
<ul>
<li>elements</li>
<li>entries</li>
<li>instances</li>
<li>items</li>
<li>objects</li>
<li>resources</li>
<li>types</li>
<li>values</li>
</ul>
</li>
</ul>
<h3 id="资源名称和网址"><a href="#资源名称和网址" class="headerlink" title="资源名称和网址"></a>资源名称和网址</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然完整的资源名称类似于普通网址，但两者并不相同。<strong>单个资源可以由不同的 API 版本、API 协议或 API 网络端点公开</strong>。完整资源名称未指明此类信息，因此在实际使用中必须将其映射到特定的 API 版本和 API 协议。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要通过 <code>REST API</code>使用完整资源名称，<strong>必须</strong>将其转换为 REST 网址，实现方法为<strong>在服务名称之前添加 HTTPS 传输协议、在资源路径之前添加 API 主要版本以及对资源路径进行网址转义</strong>。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// This is a calendar event resource name.</span><br><span class="line">&quot;//calendar.googleapis.com/users/john smith/events/123&quot;</span><br><span class="line"></span><br><span class="line">// This is the corresponding HTTP URL.</span><br><span class="line">&quot;https://calendar.googleapis.com/v3/users/john%20smith/events/123&quot;</span><br></pre></td></tr></table></figure>
<h3 id="资源名称为字符串"><a href="#资源名称为字符串" class="headerlink" title="资源名称为字符串"></a>资源名称为字符串</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除非存在向后兼容问题，否则 <code>Google API</code><strong>必须</strong>使用纯字符串来表示资源名称。资源名称<strong>应该</strong>像普通文件路径一样处理，并且它们不支持 <code>％</code>编码。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于资源定义，第一个字段<strong>应该</strong>是资源名称的字符串字段，并且<strong>应该</strong>称为 <code>name</code>。</p>
<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意</strong>：以下代码示例使用 <a href="https://github.com/googleapis/googleapis/blob/master/google/api/http.proto" target="_blank" rel="noopener"><em>gRPC 转码</em></a>语法。请点击链接以查看详细信息。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">service LibraryService &#123;</span><br><span class="line">  rpc GetBook(GetBookRequest) returns (Book) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      get: &quot;/v1/&#123;name=shelves/*/books/*&#125;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  rpc CreateBook(CreateBookRequest) returns (Book) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      post: &quot;/v1/&#123;parent=shelves/*&#125;/books&quot;</span><br><span class="line">      body: &quot;book&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Book &#123;</span><br><span class="line">  // Resource name of the book. It must have the format of &quot;shelves/*/books/*&quot;.</span><br><span class="line">  // For example: &quot;shelves/shelf1/books/book2&quot;.</span><br><span class="line">  string name = 1;</span><br><span class="line"></span><br><span class="line">  // ... other properties</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message GetBookRequest &#123;</span><br><span class="line">  // Resource name of a book. For example: &quot;shelves/shelf1/books/book2&quot;.</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message CreateBookRequest &#123;</span><br><span class="line">  // Resource name of the parent resource where to create the book.</span><br><span class="line">  // For example: &quot;shelves/shelf1&quot;.</span><br><span class="line">  string parent = 1;</span><br><span class="line">  // The Book resource to be created. Client must not set the `Book.name` field.</span><br><span class="line">  Book book = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>注意</strong>：为了保证资源名称的一致性，前导正斜杠<strong>不得</strong>被任何网址模板变量捕获。例如，<strong>必须</strong>使用 <code>&quot;/v1/{name=shelves/*/books/*}&quot;</code> 网址模板，而不能使用 <code>&quot;/v1{name=/shelves/*/books/*}&quot;</code>。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="问：为什么不使用资源-ID-来标识资源？"><a href="#问：为什么不使用资源-ID-来标识资源？" class="headerlink" title="问：为什么不使用资源 ID 来标识资源？"></a>问：为什么不使用资源 ID 来标识资源？</h4><p>答：任何大型系统都有很多种资源。在使用资源 ID 来标识资源的时候，我们实际上是使用特定于资源的元组来标识资源，例如 <code>(bucket, object)</code> 或 <code>(user, album, photo)</code>。这会带来几个主要问题：</p>
<ul>
<li>开发者必须了解并记住这些匿名元组。</li>
<li>传递元组通常比传递字符串更难。</li>
<li>集中式基础架构（例如日志记录和访问控制系统）不理解专用元组。</li>
<li>专用元组限制了 API 设计的灵活性，例如提供可重复使用的 API 接口。例如，<a href="https://github.com/googleapis/googleapis/tree/master/google/longrunning" target="_blank" rel="noopener">长时间运行的操作</a>可以与许多其他 API 接口一起使用，因为它们使用灵活的资源名称。</li>
</ul>
<h4 id="问：为什么特殊字段名为-name-而不是-id？"><a href="#问：为什么特殊字段名为-name-而不是-id？" class="headerlink" title="问：为什么特殊字段名为 name 而不是 id？"></a>问：为什么特殊字段名为 <code>name</code> 而不是 <code>id</code>？</h4><p>答：特殊字段以资源“名称”的概念命名。一般来说，我们发现 <code>name</code> 的概念让开发者感到困惑。例如，文件名实际上只是名称还是完整路径？通过预留标准字段 <code>name</code>，开发人员不得不选择更合适的词语，例如 <code>display_name</code>、<code>title</code> 或 <code>full_name</code>。</p>
<h2 id="标准方法"><a href="#标准方法" class="headerlink" title="标准方法"></a>标准方法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本章定义了标准方法的概念，即 <code>List</code>、<code>Get</code>、<code>Create</code>、<code>Update</code> 和 <code>Delete</code>。标准方法可降低复杂性并提高一致性。<a href="https://github.com/googleapis/googleapis" target="_blank" rel="noopener">Google API</a> 代码库中超过 70％ 的 API 方法都是标准方法，这使得它们更易于学习和使用。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下表描述了如何将标准方法映射到 HTTP 方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">标准方法</th>
<th style="text-align:left">HTTP 映射</th>
<th style="text-align:left">HTTP 请求正文</th>
<th style="text-align:left">HTTP 响应正文</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">List</td>
<td style="text-align:left"><code>GET &lt;collection URL&gt;</code></td>
<td style="text-align:left">无</td>
<td style="text-align:left">资源*列表</td>
</tr>
<tr>
<td style="text-align:left">Get</td>
<td style="text-align:left"><code>GET &lt;resource URL&gt;</code></td>
<td style="text-align:left">无</td>
<td style="text-align:left">资源*</td>
</tr>
<tr>
<td style="text-align:left">Create</td>
<td style="text-align:left"><code>POST &lt;collection URL&gt;</code></td>
<td style="text-align:left">资源</td>
<td style="text-align:left">资源*</td>
</tr>
<tr>
<td style="text-align:left">Update</td>
<td style="text-align:left"><code>PUT or PATCH &lt;resource URL&gt;</code></td>
<td style="text-align:left">资源</td>
<td style="text-align:left">资源*</td>
</tr>
<tr>
<td style="text-align:left">Delete</td>
<td style="text-align:left"><code>DELETE &lt;resource URL&gt;</code></td>
<td style="text-align:left">无</td>
<td style="text-align:left"><code>google.protobuf.Empty</code>**</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*如果方法支持响应字段掩码以指定要返回的字段子集，则 <code>List</code>、<code>Get</code>、<code>Create</code> 和 <code>Update</code> 方法返回的资源<strong>可以</strong>包含部分数据。在某些情况下，API 平台对所有方法的字段掩码提供原生支持。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;**从不立即移除资源的 <code>Delete</code> 方法（例如更新标志或创建长时间运行的删除操作）返回的响应<strong>应该</strong>包含长时间运行的操作或修改后的资源。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于在单个 <code>API</code>调用的时间跨度内未完成的请求，标准方法还<strong>可以</strong>返回<a href="https://github.com/googleapis/googleapis/blob/master/google/longrunning/operations.proto" target="_blank" rel="noopener">长时间运行的操作</a>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下部分详细描述了每种标准方法。这些示例显示了<code>.proto</code> 文件中定义的方法和 <code>HTTP</code> 映射的特殊注释。您可以在 <a href="https://github.com/googleapis/googleapis" target="_blank" rel="noopener">Google API</a> 代码库中找到许多使用标准方法的示例。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>List</code> 方法将一个集合名称和零个或多个参数作为输入，并返回与输入匹配的资源列表。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>List</code> 通常用于搜索资源。<code>List</code> 适用于来自单个集合的数据，该集合的<strong>大小有限且不进行缓存</strong>。对于更广泛的情况，<strong>应该</strong>使用<a href="https://cloud.google.com/apis/design/custom_methods" target="_blank" rel="noopener">自定义方法</a> <code>Search</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;批量 get（例如，获取多个资源 ID 并为每个 ID 返回对象的方法）<strong>应该</strong>被实现为自定义 <code>BatchGet</code> 方法，而不是 <code>List</code> 方法。但是，如果您有一个已经存在的可提供相同功能的 <code>List</code> 方法，则<strong>可以</strong>出于此目的重复使用 <code>List</code> 方法。如果您使用的是自定义 <code>BatchGet</code> 方法，则<strong>应该</strong>将其映射到 <code>HTTP GET</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;适用的常见模式：<code>分页、结果排序</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;适用的命名规则：<code>过滤字段、结果字段</code>。</p>
<p>HTTP 映射：</p>
<ul>
<li><code>List</code> 方法<strong>必须</strong>使用 HTTP <code>GET</code> 动词。</li>
<li>接收其资源正在列出的集合名称的请求消息字段<strong>应该</strong>映射到网址路径。如果集合名称映射到网址路径，则网址模板的最后一段（<a href="https://cloud.google.com/apis/design/resource_names#CollectionId" target="_blank" rel="noopener">集合 ID</a>）<strong>必须</strong>是字面量。</li>
<li>所有剩余的请求消息字段<strong>应该</strong>映射到网址查询参数。</li>
<li>没有请求正文，API 配置<strong>不得</strong>声明 <code>body</code> 子句。</li>
<li>响应正文<strong>应该</strong>包含资源列表以及可选元数据。</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// Lists books in a shelf.</span><br><span class="line">rpc ListBooks(ListBooksRequest) returns (ListBooksResponse) &#123;</span><br><span class="line">  // List method maps to HTTP GET.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // The `parent` captures the parent resource name, such as &quot;shelves/shelf1&quot;.</span><br><span class="line">    get: &quot;/v1/&#123;parent=shelves/*&#125;/books&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListBooksRequest &#123;</span><br><span class="line">  // The parent resource name, for example, &quot;shelves/shelf1&quot;.</span><br><span class="line">  string parent = 1;</span><br><span class="line"></span><br><span class="line">  // The maximum number of items to return.</span><br><span class="line">  int32 page_size = 2;</span><br><span class="line"></span><br><span class="line">  // The next_page_token value returned from a previous List request, if any.</span><br><span class="line">  string page_token = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListBooksResponse &#123;</span><br><span class="line">  // The field name should match the noun &quot;books&quot; in the method name.  There</span><br><span class="line">  // will be a maximum number of items returned based on the page_size field</span><br><span class="line">  // in the request.</span><br><span class="line">  repeated Book books = 1;</span><br><span class="line"></span><br><span class="line">  // Token to retrieve the next page of results, or empty if there are no</span><br><span class="line">  // more results in the list.</span><br><span class="line">  string next_page_token = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Get</code> 方法需要一个资源名称和零个或多个参数作为输入，并返回指定的资源。</p>
<p>HTTP 映射：</p>
<ul>
<li><code>Get</code> 方法<strong>必须</strong>使用 HTTP <code>GET</code> 动词。</li>
<li>接收资源名称的请求消息字段<strong>应该</strong>映射到网址路径。</li>
<li>所有剩余的请求消息字段<strong>应该</strong>映射到网址查询参数。</li>
<li>没有请求正文，API 配置<strong>不得</strong>声明 <code>body</code> 子句。</li>
<li>返回的资源<strong>应该</strong>映射到整个响应正文。</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Gets a book.</span><br><span class="line">rpc GetBook(GetBookRequest) returns (Book) &#123;</span><br><span class="line">  // Get maps to HTTP GET. Resource name is mapped to the URL. No body.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // Note the URL template variable which captures the multi-segment resource</span><br><span class="line">    // name of the requested book, such as &quot;shelves/shelf1/books/book2&quot;</span><br><span class="line">    get: &quot;/v1/&#123;name=shelves/*/books/*&#125;&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message GetBookRequest &#123;</span><br><span class="line">  // The field will contain name of the resource requested, for example:</span><br><span class="line">  // &quot;shelves/shelf1/books/book2&quot;</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Create</code> 方法需要一个父资源名称、一个资源以及零个或多个参数作为输入。它在指定的父资源下创建新资源，并返回新建的资源。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 API 支持创建资源，则<strong>应该</strong>为每一个可以创建的资源类型设置 <code>Create</code> 方法。</p>
<p>HTTP 映射：</p>
<ul>
<li><code>Create</code> 方法<strong>必须</strong>使用 HTTP <code>POST</code> 动词。</li>
<li>请求消息<strong>应该</strong>具有字段 <code>parent</code>，以指定要在其中创建资源的父资源名称。</li>
<li>包含资源的请求消息字段<strong>必须</strong>映射到请求正文。如果将 <code>google.api.http</code> 注释用于 <code>Create</code> 方法，则<strong>必须</strong>使用 <code>body: &quot;&lt;resource_field&gt;&quot;</code> 表单。</li>
<li>该请求<strong>可以</strong>包含名为 <code>&lt;resource&gt;_id</code> 的字段，以允许调用者选择客户端分配的 ID。该字段<strong>可以</strong>在资源内。</li>
<li>所有剩余的请求消息字段<strong>应该</strong>映射到网址查询参数。</li>
<li>返回的资源<strong>应该</strong>映射到整个 HTTP 响应正文。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 <code>Create</code> 方法支持客户端分配的资源名称并且资源已存在，则请求<strong>应该</strong>失败并显示错误代码 <code>ALREADY_EXISTS</code> 或使用服务器分配的不同的资源名称，并且文档应该清楚地记录创建的资源名称可能与传入的不同。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Create</code> 方法<strong>必须</strong>使用输入资源，以便在资源架构更改时，无需同时更新请求架构和资源架构。对于客户端无法设置的资源字段，<strong>必须</strong>将它们记录为“仅限输出”字段。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// Creates a book in a shelf.</span><br><span class="line">rpc CreateBook(CreateBookRequest) returns (Book) &#123;</span><br><span class="line">  // Create maps to HTTP POST. URL path as the collection name.</span><br><span class="line">  // HTTP request body contains the resource.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // The `parent` captures the parent resource name, such as &quot;shelves/1&quot;.</span><br><span class="line">    post: &quot;/v1/&#123;parent=shelves/*&#125;/books&quot;</span><br><span class="line">    body: &quot;book&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message CreateBookRequest &#123;</span><br><span class="line">  // The parent resource name where the book is to be created.</span><br><span class="line">  string parent = 1;</span><br><span class="line"></span><br><span class="line">  // The book id to use for this book.</span><br><span class="line">  string book_id = 3;</span><br><span class="line"></span><br><span class="line">  // The book resource to create.</span><br><span class="line">  // The field name should match the Noun in the method name.</span><br><span class="line">  Book book = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rpc CreateShelf(CreateShelfRequest) returns (Shelf) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v1/shelves&quot;</span><br><span class="line">    body: &quot;shelf&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message CreateShelfRequest &#123;</span><br><span class="line">  Shelf shelf = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Update</code> 方法需要一条包含一个资源的请求消息和零个或多个参数作为输入。它更新指定的资源及其属性，并返回更新后的资源。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了包含资源<a href="https://cloud.google.com/apis/design/resource_names#Definitions" target="_blank" rel="noopener">名称或父资源</a>的属性之外，<code>Update</code> 方法<strong>应该</strong>可以改变可变资源的属性。<code>Update</code> 方法<strong>不得</strong>包含任何“重命名”或“移动”资源的功能，这些功能<strong>应该</strong>由自定义方法来处理。</p>
<p>HTTP 映射：</p>
<ul>
<li>标准 <code>Update</code> 方法<strong>应该</strong>支持部分资源更新，并将 HTTP 动词 <code>PATCH</code> 与名为 <code>update_mask</code> 的 <code>FieldMask</code> 字段一起使用。 应忽略客户端提供的作为输入的<a href="https://cloud.google.com/apis/design/design_patterns#output_fields" target="_blank" rel="noopener">输出字段</a>。</li>
<li>需要更高级修补语义的 <code>Update</code> 方法（例如附加到重复字段）<strong>应该</strong>由<a href="https://cloud.google.com/apis/design/custom_methods" target="_blank" rel="noopener">自定义方法</a>提供。</li>
<li>如果 <code>Update</code> 方法仅支持完整资源更新，则<strong>必须</strong>使用 HTTP 动词 <code>PUT</code>。但是，强烈建议不要进行完整更新，因为在添加新资源字段时会出现向后兼容性问题。</li>
<li>接收资源名称的消息字段<strong>必须</strong>映射到网址路径。该字段<strong>可以</strong>位于资源消息本身中。</li>
<li>包含资源的请求消息字段<strong>必须</strong>映射到请求正文。</li>
<li>所有剩余的请求消息字段<strong>必须</strong>映射到网址查询参数。</li>
<li>响应消息<strong>必须</strong>是更新的资源本身。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果 API 接受客户端分配的资源名称，则服务器<strong>可以</strong>允许客户端指定不存在的资源名称并创建新资源。否则，使用不存在的资源名称的 <code>Update</code> 方法<strong>应该</strong>失败。如果这是唯一的错误条件，则<strong>应该</strong>使用错误代码 <code>NOT_FOUND</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;具有支持资源创建的 <code>Update</code> 方法的 API 还<strong>应该</strong>提供 <code>Create</code> 方法。原因是，如果 <code>Update</code> 方法是唯一的方法，则它将不知道如何创建资源。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Updates a book.</span><br><span class="line">rpc UpdateBook(UpdateBookRequest) returns (Book) &#123;</span><br><span class="line">  // Update maps to HTTP PATCH. Resource name is mapped to a URL path.</span><br><span class="line">  // Resource is contained in the HTTP request body.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // Note the URL template variable which captures the resource name of the</span><br><span class="line">    // book to update.</span><br><span class="line">    patch: &quot;/v1/&#123;book.name=shelves/*/books/*&#125;&quot;</span><br><span class="line">    body: &quot;book&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message UpdateBookRequest &#123;</span><br><span class="line">  // The book resource which replaces the resource on the server.</span><br><span class="line">  Book book = 1;</span><br><span class="line"></span><br><span class="line">  // The update mask applies to the resource. For the `FieldMask` definition,</span><br><span class="line">  // see https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask</span><br><span class="line">  FieldMask update_mask = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Delete</code> 方法需要一个资源名称和零个或多个参数作为输入，并删除或计划删除指定的资源。<code>Delete</code> 方法<strong>应该</strong>返回 <code>google.protobuf.Empty</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;API <strong>不应该</strong>依赖 <code>Delete</code> 方法返回的任何信息，因为它<strong>不能</strong>重复调用。</p>
<p>HTTP 映射：</p>
<ul>
<li><p><code>Delete</code> 方法<strong>必须</strong>使用 HTTP <code>DELETE</code> 动词。</p>
</li>
<li><p>接收资源名称的请求消息字段<strong>应该</strong>映射到网址路径。</p>
</li>
<li><p>所有剩余的请求消息字段<strong>应该</strong>映射到网址查询参数。</p>
</li>
<li><p>没有请求正文，API 配置<strong>不得</strong>声明 <code>body</code> 子句。</p>
</li>
<li><p>如果 <code>Delete</code> 方法立即移除资源，则<strong>应该</strong>返回空响应。</p>
</li>
<li><p>如果 <code>Delete</code> 方法启动长时间运行的操作，则<strong>应该</strong>返回长时间运行的操作。</p>
</li>
<li><p>如果 <code>Delete</code> 方法仅将资源标记为已删除，则<strong>应该</strong>返回更新后的资源。</p>
</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对 <code>Delete</code> 方法的调用在效果上应该是幂等的，但不需要产生相同的响应。任何数量的 <code>Delete</code> 请求都<strong>应该</strong>导致资源（最终）被删除，但只有第一个请求会产生成功代码。后续请求应生成 <code>google.rpc.Code.NOT_FOUND</code>。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Deletes a book.</span><br><span class="line">rpc DeleteBook(DeleteBookRequest) returns (google.protobuf.Empty) &#123;</span><br><span class="line">  // Delete maps to HTTP DELETE. Resource name maps to the URL path.</span><br><span class="line">  // There is no request body.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    // Note the URL template variable capturing the multi-segment name of the</span><br><span class="line">    // book resource to be deleted, such as &quot;shelves/shelf1/books/book2&quot;</span><br><span class="line">    delete: &quot;/v1/&#123;name=shelves/*/books/*&#125;&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message DeleteBookRequest &#123;</span><br><span class="line">  // The resource name of the book to be deleted, for example:</span><br><span class="line">  // &quot;shelves/shelf1/books/book2&quot;</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本章将讨论如何在 API 设计中使用自定义方法。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自定义方法是指 5 个标准方法之外的 API 方法。这些方法<strong>应该</strong>仅用于标准方法不易表达的功能。通常情况下，API 设计者<strong>应该</strong>尽可能优先考虑使用标准方法，而不是自定义方法。标准方法具有大多数开发者熟悉的更简单且定义明确的语义，因此更易于使用且不易出错。另一项优势是 API 平台更加了解和支持标准方法，例如计费、错误处理、日志记录、监控。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自定义方法可以与资源、集合或服务关联。它<strong>可以</strong>接受任意请求和返回任意响应，并且还支持流式请求和响应。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;自定义方法名称<strong>必须</strong>遵循方法命名惯例。</p>
<h3 id="HTTP-映射"><a href="#HTTP-映射" class="headerlink" title="HTTP 映射"></a>HTTP 映射</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于自定义方法，它们<strong>应该</strong>使用以下通用 HTTP 映射：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://service.name/v1/some/resource/name:customVerb</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>使用 <code>:</code> 而不是 <code>/</code> 将自定义动词与资源名称分开以便支持任意路径</strong>。例如，恢复删除文件可以映射到 <code>POST /files/a/long/file/name:undelete</code></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选择 HTTP 映射时，<strong>应</strong>遵循以下准则：</p>
<ul>
<li>自定义方法<strong>应该</strong>使用 HTTP <code>POST</code> 动词，因为该动词具有最灵活的语义，但作为替代 get 或 list 的方法（如有可能，<strong>可以</strong>使用 <code>GET</code>）除外。（详情请参阅第三条。）</li>
<li>自定义方法<strong>不应该</strong>使用 HTTP <code>PATCH</code>，但<strong>可以</strong>使用其他 HTTP 动词。在这种情况下，方法<strong>必须</strong>遵循该动词的标准 <a href="https://tools.ietf.org/html/rfc2616#section-9" target="_blank" rel="noopener">HTTP 语义</a>。</li>
<li>请注意，使用 HTTP <code>GET</code> 的自定义方法<strong>必须</strong>具有幂等性并且无负面影响。例如，在资源上实现特殊视图的自定义方法<strong>应该</strong>使用 HTTP <code>GET</code>。</li>
<li>接收与自定义方法关联的资源或集合的资源名称的请求消息字段<strong>应该</strong>映射到网址路径。</li>
<li>网址路径<strong>必须</strong>以包含冒号（后跟自定义动词）的后缀结尾。</li>
<li>如果用于自定义方法的 HTTP 动词允许 HTTP 请求正文（<code>POST</code>、<code>PUT</code>、<code>PATCH</code> 或自定义 HTTP 动词），则此自定义方法的 HTTP 配置<strong>必须</strong>使用 <code>body: &quot;*&quot;</code> 子句，所有其他请求消息字段都<strong>应</strong>映射到 HTTP 请求正文。</li>
<li>如果用于自定义方法的 HTTP 动词不接受 HTTP 请求正文（<code>GET</code>、<code>DELETE</code>），则此方法的 HTTP 配置<strong>不得</strong>使用 <code>body</code> 子句，并且所有其他请求消息字段都<strong>应</strong>映射到网址查询参数。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>警告</strong>：如果一个服务会实现多个 API，API 生产者<strong>必须</strong>仔细创建服务配置，以避免 API 之间的自定义动词发生冲突。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// This is a service level custom method.</span><br><span class="line">rpc Watch(WatchRequest) returns (WatchResponse) &#123;</span><br><span class="line">  // Custom method maps to HTTP POST. All request parameters go into body.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v1:watch&quot;</span><br><span class="line">    body: &quot;*&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This is a collection level custom method.</span><br><span class="line">rpc ClearEvents(ClearEventsRequest) returns (ClearEventsResponse) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v3/events:clear&quot;</span><br><span class="line">    body: &quot;*&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This is a resource level custom method.</span><br><span class="line">rpc CancelEvent(CancelEventRequest) returns (CancelEventResponse) &#123;</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    post: &quot;/v3/&#123;name=events/*&#125;:cancel&quot;</span><br><span class="line">    body: &quot;*&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// This is a batch get custom method.</span><br><span class="line">rpc BatchGetEvents(BatchGetEventsRequest) returns (BatchGetEventsResponse) &#123;</span><br><span class="line">  // The batch get method maps to HTTP GET verb.</span><br><span class="line">  option (google.api.http) = &#123;</span><br><span class="line">    get: &quot;/v3/events:batchGet&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><p>自定义方法适用于以下场景：</p>
<ul>
<li><strong>重启虚拟机。</strong> 设计备选方案可能是“在重启集合中创建一个重启资源”，这会让人感觉过于复杂，或者“虚拟机具有可变状态，客户端可以将状态从 RUNNING 更新到 RESTARTING”，这会产生可能存在哪些其他状态转换的问题。此外，重启是一个常见概念，可以合理转化为一个自定义方法，从直观上来说符合开发者的预期。</li>
<li><strong>发送邮件。</strong> 创建一个电子邮件消息不一定意味着要发送它（草稿）。与设计备选方案（将消息移动到“发件箱”集合）相比，自定义方法更容易被 API 用户发现，并且可以更直接地对概念进行建模。</li>
<li><strong>提拔员工。</strong> 如果作为标准 <code>update</code> 方法实现，客户端需要复制企业提拔流程管理政策，以确保提拔发生在正确的级别，并属于同一职业阶梯等等。</li>
<li><strong>批处理方法。</strong> 对于对性能要求苛刻的方法，提供自定义批处理方法<strong>可以</strong>有助于减少每个请求的开销。例如，<a href="https://developers.google.com/my-business/reference/rest/v4/accounts.locations/batchGet" target="_blank" rel="noopener">accounts.locations.batchGet</a>。</li>
</ul>
<p>以下是标准方法比自定义方法更适用的示例：</p>
<ul>
<li>使用不同查询参数的查询资源（使用带有标准列表过滤的标准 <code>list</code> 方法）。</li>
<li>简单的资源属性更改（使用带有字段掩码的标准 <code>update</code> 方法）。</li>
<li>关闭一个通知（使用标准 <code>delete</code> 方法）。</li>
</ul>
<h3 id="常用自定义方法"><a href="#常用自定义方法" class="headerlink" title="常用自定义方法"></a>常用自定义方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以下是常用或有用的自定义方法名称的精选列表。API 设计者在引入自己的名称之前<strong>应该</strong>考虑使用这些名称，以提高 API 之间的一致性。</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法名称</th>
<th style="text-align:left">自定义动词</th>
<th style="text-align:left">HTTP 动词</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">取消</td>
<td style="text-align:left"><code>:cancel</code></td>
<td style="text-align:left"><code>POST</code></td>
<td style="text-align:left">取消一个未完成的操作（构建、计算等）</td>
</tr>
<tr>
<td style="text-align:left">BatchGet &lt;复数名词&gt;</td>
<td style="text-align:left"><code>:batchGet</code></td>
<td style="text-align:left"><code>GET</code></td>
<td style="text-align:left">批量获取多个资源。（详情请参阅<a href="https://cloud.google.com/apis/design/standard_methods#list" target="_blank" rel="noopener">列表描述</a>）</td>
</tr>
<tr>
<td style="text-align:left">移动</td>
<td style="text-align:left"><code>:move</code></td>
<td style="text-align:left"><code>POST</code></td>
<td style="text-align:left">将资源从一个父级移动到另一个父级。</td>
</tr>
<tr>
<td style="text-align:left">搜索</td>
<td style="text-align:left"><code>:search</code></td>
<td style="text-align:left"><code>GET</code></td>
<td style="text-align:left">List 的替代方法，用于获取不符合 List 语义的数据。</td>
</tr>
<tr>
<td style="text-align:left">恢复删除</td>
<td style="text-align:left"><code>:undelete</code></td>
<td style="text-align:left"><code>POST</code></td>
<td style="text-align:left">恢复之前删除的资源。建议的保留期限为 30 天。</td>
</tr>
</tbody>
</table>
<h2 id="标准字段"><a href="#标准字段" class="headerlink" title="标准字段"></a>标准字段</h2><table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>name</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left"><code>name</code> 字段应包含<a href="https://cloud.google.com/apis/design/resource_names#relative_resource_name" target="_blank" rel="noopener">相对资源名称</a>。</td>
</tr>
<tr>
<td style="text-align:left"><code>parent</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">对于资源定义和 List/Create 请求，<code>parent</code> 字段应包含父级<a href="https://cloud.google.com/apis/design/resource_names#relative_resource_name" target="_blank" rel="noopener">相对资源名称</a>。</td>
</tr>
<tr>
<td style="text-align:left"><code>create_time</code></td>
<td style="text-align:left"><code>Timestamp</code></td>
<td style="text-align:left">创建实体的时间戳。</td>
</tr>
<tr>
<td style="text-align:left"><code>update_time</code></td>
<td style="text-align:left"><code>Timestamp</code></td>
<td style="text-align:left">最后更新实体的时间戳。注意：执行 create/patch/delete 操作时会更新 update_time。</td>
</tr>
<tr>
<td style="text-align:left"><code>delete_time</code></td>
<td style="text-align:left"><code>Timestamp</code></td>
<td style="text-align:left">删除实体的时间戳，仅当它支持保留时才适用。</td>
</tr>
<tr>
<td style="text-align:left"><code>expire_time</code></td>
<td style="text-align:left"><code>Timestamp</code></td>
<td style="text-align:left">实体到期时的到期时间戳。</td>
</tr>
<tr>
<td style="text-align:left"><code>start_time</code></td>
<td style="text-align:left"><code>Timestamp</code></td>
<td style="text-align:left">标记某个时间段开始的时间戳。</td>
</tr>
<tr>
<td style="text-align:left"><code>end_time</code></td>
<td style="text-align:left"><code>Timestamp</code></td>
<td style="text-align:left">标记某个时间段或操作结束的时间戳（无论其成功与否）。</td>
</tr>
<tr>
<td style="text-align:left"><code>read_time</code></td>
<td style="text-align:left"><code>Timestamp</code></td>
<td style="text-align:left">应读取（如果在请求中使用）或已读取（如果在响应中使用）特定实体的时间戳。</td>
</tr>
<tr>
<td style="text-align:left"><code>time_zone</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">时区名称。它应该是 <a href="http://www.iana.org/time-zones" target="_blank" rel="noopener">IANA TZ</a> 名称，例如“America/Los_Angeles”。如需了解详情，请参阅 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones。" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/List_of_tz_database_time_zones。</a></td>
</tr>
<tr>
<td style="text-align:left"><code>region_code</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">位置的 Unicode 国家/地区代码 (CLDR)，例如“US”和“419”。如需了解详情，请访问 <a href="http://www.unicode.org/reports/tr35/#unicode_region_subtag。" target="_blank" rel="noopener">http://www.unicode.org/reports/tr35/#unicode_region_subtag。</a></td>
</tr>
<tr>
<td style="text-align:left"><code>language_code</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">BCP-47 语言代码，例如“en-US”或“sr-Latn”。如需了解详情，请参阅 <a href="http://www.unicode.org/reports/tr35/#Unicode_locale_identifier。" target="_blank" rel="noopener">http://www.unicode.org/reports/tr35/#Unicode_locale_identifier。</a></td>
</tr>
<tr>
<td style="text-align:left"><code>mime_type</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">IANA 发布的 MIME 类型（也称为媒体类型）。如需了解详情，请参阅 <a href="https://www.iana.org/assignments/media-types/media-types.xhtml。" target="_blank" rel="noopener">https://www.iana.org/assignments/media-types/media-types.xhtml。</a></td>
</tr>
<tr>
<td style="text-align:left"><code>display_name</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">实体的显示名称。</td>
</tr>
<tr>
<td style="text-align:left"><code>title</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">实体的官方名称，例如公司名称。它应被视为 <code>display_name</code> 的正式版本。</td>
</tr>
<tr>
<td style="text-align:left"><code>description</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">实体的一个或多个文本描述段落。</td>
</tr>
<tr>
<td style="text-align:left"><code>filter</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">List 方法的标准过滤器参数。</td>
</tr>
<tr>
<td style="text-align:left"><code>query</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">如果应用于搜索方法（即 <a href="https://cloud.google.com/apis/design/custom_methods#common_custom_methods" target="_blank" rel="noopener"><code>:search</code></a>），则与 <code>filter</code> 相同</td>
</tr>
<tr>
<td style="text-align:left"><code>page_token</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">List 请求中的分页令牌。</td>
</tr>
<tr>
<td style="text-align:left"><code>page_size</code></td>
<td style="text-align:left"><code>int32</code></td>
<td style="text-align:left">List 请求中的分页大小。</td>
</tr>
<tr>
<td style="text-align:left"><code>total_size</code></td>
<td style="text-align:left"><code>int32</code></td>
<td style="text-align:left">列表中与分页无关的项目总数。</td>
</tr>
<tr>
<td style="text-align:left"><code>next_page_token</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">List 响应中的下一个分页令牌。它应该用作后续请求的 <code>page_token</code>。空值表示不再有结果。</td>
</tr>
<tr>
<td style="text-align:left"><code>order_by</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">指定 List 请求的结果排序。</td>
</tr>
<tr>
<td style="text-align:left"><code>request_id</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">用于检测重复请求的唯一字符串 ID。</td>
</tr>
<tr>
<td style="text-align:left"><code>resume_token</code></td>
<td style="text-align:left"><code>string</code></td>
<td style="text-align:left">用于恢复流式传输请求的不透明令牌。</td>
</tr>
<tr>
<td style="text-align:left"><code>labels</code></td>
<td style="text-align:left"><code>map&lt;string,string&gt;</code></td>
<td style="text-align:left">表示 Cloud 资源标签。</td>
</tr>
<tr>
<td style="text-align:left"><code>deleted</code></td>
<td style="text-align:left"><code>bool</code></td>
<td style="text-align:left">如果资源允许恢复删除行为，则必须具有 <code>deleted</code> 字段，该字段指示资源已删除。</td>
</tr>
<tr>
<td style="text-align:left"><code>show_deleted</code></td>
<td style="text-align:left"><code>bool</code></td>
<td style="text-align:left">如果资源允许恢复删除行为，相应的 List 方法必须具有 <code>show_deleted</code> 字段，以便客户端可以发现已删除的资源。</td>
</tr>
<tr>
<td style="text-align:left"><code>update_mask</code></td>
<td style="text-align:left"><a href="https://github.com/google/protobuf/blob/master/src/google/protobuf/field_mask.proto" target="_blank" rel="noopener"><code>FieldMask</code></a></td>
<td style="text-align:left">它用于 <code>Update</code> 请求消息，该消息用于对资源执行部分更新。此掩码与资源相关，而不是与请求消息相关。</td>
</tr>
<tr>
<td style="text-align:left"><code>validate_only</code></td>
<td style="text-align:left"><code>bool</code></td>
<td style="text-align:left">如果为 true，则表示仅应验证给定请求，而不执行该请求。</td>
</tr>
</tbody>
</table>
<h2 id="系统参数"><a href="#系统参数" class="headerlink" title="系统参数"></a>系统参数</h2><table>
<thead>
<tr>
<th style="text-align:left">网址查询参数</th>
<th style="text-align:left">HTTP/gRPC 标头</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>access_token</code>, <code>oauth_token</code></td>
<td style="text-align:left">授权</td>
<td style="text-align:left">OAuth 2.0 访问令牌。如需了解详细信息，请参阅 Cloud Platform<a href="https://cloud.google.com/docs/authentication/" target="_blank" rel="noopener"> 身份验证指南</a>。</td>
</tr>
<tr>
<td style="text-align:left"><code>$alt</code>, <code>alt</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">其他响应格式。支持的值为 <code>json</code>（默认）、<code>media</code>、<code>proto</code>（二进制 protobuf）。</td>
</tr>
<tr>
<td style="text-align:left"><code>$.xgafv</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">JSON 错误格式。支持的值为 <code>1</code>、<code>2</code>（默认）。错误格式 <code>1</code> 只应该由旧版客户端使用。</td>
</tr>
<tr>
<td style="text-align:left"><code>$callback</code>, <code>callback</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">JSONP 回调参数。</td>
</tr>
<tr>
<td style="text-align:left"><code>$ct</code></td>
<td style="text-align:left">Content-Type</td>
<td style="text-align:left">HTTP Content-Type 标头覆盖。</td>
</tr>
<tr>
<td style="text-align:left"><code>$fields</code>, <code>fields</code></td>
<td style="text-align:left">X-goog-FieldMask</td>
<td style="text-align:left">用于响应过滤的 FieldMask (google.protobufFieldMask)。如果为空，则返回所有字段。</td>
</tr>
<tr>
<td style="text-align:left"><code>$httpMethod</code></td>
<td style="text-align:left">X-HTTP-Method-Override</td>
<td style="text-align:left">请求的预期 HTTP 方法。部分网络代理不接受所有 HTTP 方法。</td>
</tr>
<tr>
<td style="text-align:left"><code>$key</code>, <code>key</code></td>
<td style="text-align:left">X-Goog-Api-Key</td>
<td style="text-align:left">如需了解 Google API 密钥的详情，请访问 <a href="https://developers.google.com/console/help/#generatingdevkeys。" target="_blank" rel="noopener">https://developers.google.com/console/help/#generatingdevkeys。</a></td>
</tr>
<tr>
<td style="text-align:left"><code>passwd</code>, <code>password</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">预留以防止将密码放入网址中。</td>
</tr>
<tr>
<td style="text-align:left"><code>$prettyPrint</code>, <code>prettyPrint</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">整齐打印 JSON 响应。支持的值为 <code>true</code>、<code>false</code>。</td>
</tr>
<tr>
<td style="text-align:left"><code>$outputDefaults</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">强制输出 JSON 响应的原始默认值。</td>
</tr>
<tr>
<td style="text-align:left"><code>$unique</code></td>
<td style="text-align:left"></td>
<td style="text-align:left">用于停用请求缓存的唯一查询参数。</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">X-Goog-Api-Client</td>
<td style="text-align:left">API 客户端标识。该值是以空格分隔的 <code>NAME &quot;/&quot; SEMVER</code> 字符串列表，其中 <code>NAME</code> 只能包含小写字母、数字和“ - ”，并且 <code>SEMVER</code> 应为语义版本字符串。例如：X-Goog-Api-Client: python/3.5.0 grpc-google-pubsub-v1/0.1.0-beta2 linux/2.7.0。</td>
</tr>
<tr>
<td style="text-align:left"><code>$userProject</code></td>
<td style="text-align:left">X-Goog-User-Project</td>
<td style="text-align:left">负责配额计算和结算的调用者指定项目。调用者必须具有项目的 <code>serviceusage.services.use</code> 权限。</td>
</tr>
</tbody>
</table>
<h2 id="命名惯例"><a href="#命名惯例" class="headerlink" title="命名惯例"></a>命名惯例</h2><p>为了能够长时间在众多 API 中为开发者提供一致的体验，API 使用的所有名称都<strong>应该具有以下特点</strong>：</p>
<ul>
<li>简单</li>
<li>直观</li>
<li>一致</li>
</ul>
<p>这包括接口、资源、集合、方法和消息的名称。</p>
<p>由于很多开发者不是以英语为母语，所以这些命名惯例的目标之一是确保大多数开发者可以轻松理解 API。对于方法和资源，我们鼓励使用简单、直观和少量的词汇来命名。</p>
<ul>
<li>API 名称<strong>应该</strong>使用正确的美式英语。例如，使用美式英语的 license、color，而非英式英语的 licence、colour。</li>
<li>为了简化命名，<strong>可以</strong>使用已被广泛接受的简写形式或缩写。例如，API 优于 Application Programming Interface。</li>
<li>尽量使用直观、熟悉的术语。例如，如果描述移除（和销毁）一个资源，则删除优于擦除。</li>
<li>使用相同的名称或术语命名同样的概念，包括跨 API 共享的概念。</li>
<li>避免名称过载。使用不同的名称命名不同的概念。</li>
<li>避免在 API 的上下文以及更大的 Google API 生态系统中使用含糊不清且过于笼统的名称。这些名称可能导致对 API 概念的误解。相反，应选择能准确描述 API 概念的名称。这对定义一阶 API 元素（例如资源）的名称尤其重要。没有要避免使用的名称的明确列表，因为每个名称都必须放在其他名称的上下文中进行评估。实例、信息和服务是过去有问题的名称的示例。所选择的名称应该能清楚地描述 API 概念（例如：什么的实例？）并将其与其他相关概念区分开（例如：“alert”是指规则、信号还是通知？）。</li>
<li>仔细考虑是否使用可能与常用编程语言中的关键字相冲突的名称。您<strong>可以</strong>使用这些名称，但在 API 审核期间可能会触发额外的审查。因此应谨慎使用。</li>
</ul>
<h3 id="产品名称"><a href="#产品名称" class="headerlink" title="产品名称"></a>产品名称</h3><p>产品名称是指 API 的产品营销名称，例如 Google Calendar API。API、界面、文档、服务条款、对帐单以及商业合同等都<strong>必须</strong>使用统一的产品名称。Google API <strong>必须</strong>使用产品团队和营销团队批准的产品名称。</p>
<p>下表显示了所有相关 API 名称及其一致性的示例。如需详细了解各自名称及其命名惯例，请参阅本页面下方的详细信息。</p>
<table>
<thead>
<tr>
<th style="text-align:left">API 名称</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>产品名称</strong></td>
<td style="text-align:left">Google <strong>Calendar</strong> API</td>
</tr>
<tr>
<td style="text-align:left"><strong>服务名称</strong></td>
<td style="text-align:left"><code>calendar.googleapis.com</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>包名称</strong></td>
<td style="text-align:left"><code>google.calendar.v3</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>接口名称</strong></td>
<td style="text-align:left"><code>google.calendar.v3.CalendarService</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>源代码目录</strong></td>
<td style="text-align:left"><code>//google/calendar/v3</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>API 名称</strong></td>
<td style="text-align:left"><code>calendar</code></td>
</tr>
</tbody>
</table>
<h3 id="服务名称"><a href="#服务名称" class="headerlink" title="服务名称"></a>服务名称</h3><p>服务名称<strong>应该</strong>是语法上有效的 DNS 名称（遵循 <a href="http://www.ietf.org/rfc/rfc1035.txt" target="_blank" rel="noopener">RFC 1035</a>），可以解析为一个或多个网络地址。公开的 Google API 的服务名称采用 <code>xxx.googleapis.com</code> 格式。例如，Google Calendar 的服务名称是 <code>calendar.googleapis.com</code>。</p>
<p>如果一个 API 是由多个服务组成，则其名称<strong>应该</strong>更容易被发现。要做到这点，一种方法是使服务名称共享一个通用前缀。例如，<code>build.googleapis.com</code> 和 <code>buildresults.googleapis.com</code> 服务都是 Google Build API 的一部分。</p>
<h3 id="包名称"><a href="#包名称" class="headerlink" title="包名称"></a>包名称</h3><p>API .proto 文件中声明的包名称<strong>应该</strong>与产品和服务名称保持一致。某个版本的 API 的包名称<strong>必须</strong>以此版本结尾。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Google Calendar API</span><br><span class="line">package google.calendar.v3;</span><br></pre></td></tr></table></figure>
<p>与服务无直接关联的抽象 API（例如 Google Watcher API）<strong>应该</strong>使用与产品名称一致的 proto 包名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Google Watcher API</span><br><span class="line">package google.watcher.v1;</span><br></pre></td></tr></table></figure>
<p>API .proto 文件中指定的 Java 包名称<strong>必须</strong>与带有标准 Java 包名称前缀（<code>com.</code>、<code>edu.</code>、<code>net.</code> 等）的 proto 包名称相匹配。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">package google.calendar.v3;</span><br><span class="line"></span><br><span class="line">// Specifies Java package name, using the standard prefix &quot;com.&quot;</span><br><span class="line">option java_package = &quot;com.google.calendar.v3&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="集合-ID-1"><a href="#集合-ID-1" class="headerlink" title="集合 ID"></a>集合 ID</h3><p><a href="https://cloud.google.com/apis/design/resource_names#collection_id" target="_blank" rel="noopener">集合 ID</a> <strong>应该</strong>使用复数形式并遵循 <code>lowerCamelCase</code>（小驼峰式命名法）格式，以及美式英语拼写和语义。例如：<code>events</code>、<code>children</code> 或 <code>deletedEvents</code>。</p>
<h3 id="接口名称"><a href="#接口名称" class="headerlink" title="接口名称"></a>接口名称</h3><p>为了避免与<a href="https://cloud.google.com/apis/design/naming_convention#service_names" target="_blank" rel="noopener">服务名称</a>（例如 <code>pubsub.googleapis.com</code>）混淆，术语“接口名称”是指在 .proto 文件中定义 <code>service</code> 时使用的名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Library is the interface name.</span><br><span class="line">service Library &#123;</span><br><span class="line">  rpc ListBooks(...) returns (...);</span><br><span class="line">  rpc ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>您可以将服务名称视为对一组 API 实际实现的引用，而接口名称则是 API 的抽象定义。</p>
<p>接口名称<strong>应该</strong>使用直观的名词，例如 Calendar 或 Blob。该名称<strong>不应该</strong>与编程语言及其运行时库中的成熟概念（例如 File）相冲突。</p>
<p>在极少数情况下，接口名称会与 API 中的其他名称相冲突，此时<strong>应该</strong>使用后缀（例如 <code>Api</code> 或 <code>Service</code>）来消除歧义。</p>
<h3 id="方法名称"><a href="#方法名称" class="headerlink" title="方法名称"></a>方法名称</h3><p>服务<strong>可以</strong>在其 IDL 规范中定义一个或多个与集合和资源上的方法相对应的 RPC 方法。方法名称<strong>应该</strong>采用大驼峰式命名格式、遵循 <code>VerbNoun</code> 的命名惯例，其中 Noun（名词）通常是资源类型。</p>
<table>
<thead>
<tr>
<th style="text-align:left">动词</th>
<th style="text-align:left">名词</th>
<th style="text-align:left">方法名称</th>
<th style="text-align:left">请求消息</th>
<th style="text-align:left">响应消息</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>List</code></td>
<td style="text-align:left"><code>Book</code></td>
<td style="text-align:left"><code>ListBooks</code></td>
<td style="text-align:left"><code>ListBooksRequest</code></td>
<td style="text-align:left"><code>ListBooksResponse</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Get</code></td>
<td style="text-align:left"><code>Book</code></td>
<td style="text-align:left"><code>GetBook</code></td>
<td style="text-align:left"><code>GetBookRequest</code></td>
<td style="text-align:left"><code>Book</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Create</code></td>
<td style="text-align:left"><code>Book</code></td>
<td style="text-align:left"><code>CreateBook</code></td>
<td style="text-align:left"><code>CreateBookRequest</code></td>
<td style="text-align:left"><code>Book</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Update</code></td>
<td style="text-align:left"><code>Book</code></td>
<td style="text-align:left"><code>UpdateBook</code></td>
<td style="text-align:left"><code>UpdateBookRequest</code></td>
<td style="text-align:left"><code>Book</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Rename</code></td>
<td style="text-align:left"><code>Book</code></td>
<td style="text-align:left"><code>RenameBook</code></td>
<td style="text-align:left"><code>RenameBookRequest</code></td>
<td style="text-align:left"><code>RenameBookResponse</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Delete</code></td>
<td style="text-align:left"><code>Book</code></td>
<td style="text-align:left"><code>DeleteBook</code></td>
<td style="text-align:left"><code>DeleteBookRequest</code></td>
<td style="text-align:left"><code>google.protobuf.Empty</code></td>
</tr>
</tbody>
</table>
<p>方法名称的动词部分<strong>应该</strong>使用用于要求或命令的<a href="https://en.wikipedia.org/wiki/Imperative_mood#English" target="_blank" rel="noopener">祈使语气</a>，而不是用于提问的陈述语气。</p>
<p>如果动词提出关于 API 中的子资源的问题（经常使用陈述语气表示），则容易让人混淆。例如，要求 API 创建一本书，这显然是 <code>CreateBook</code>（祈使语气），但是询问 API 关于图书发行商的状态可能会使用陈述语气，例如 <code>IsBookPublisherApproved</code> 或 <code>NeedsPublisherApproval</code>。要在这种情况下保持祈使语气，请使用命令词（例如“check”(<code>CheckBookPublisherApproved</code>) 和“validate”(<code>ValidateBookPublisher</code>)。</p>
<p>方法名称<strong>不应</strong>包含介词（例如“For”、“With”、“At”、“To”）。通常，带有介词的方法名称表示正在使用新方法，应将一个字段添加到现有方法中，或者该方法应使用不同的动词。</p>
<p>例如，如果 <code>CreateBook</code> 消息已存在且您正在考虑添加 <code>CreateBookFromDictation</code>，请考虑使用 <code>TranscribeBook</code> 方法。</p>
<h3 id="消息名称"><a href="#消息名称" class="headerlink" title="消息名称"></a>消息名称</h3><p>消息名称<strong>应该</strong>简洁明了。避免不必要或多余的字词。如果相应的消息中没有形容词，则通常可以省略形容词。例如，如果没有非共享代理设置，则 <code>SharedProxySettings</code> 中的 <code>Shared</code> 是多余的。</p>
<p>消息名称<strong>不应</strong>包含介词（例如“With”、“For”）。通常，带有介词的消息名称可以通过消息上的可选字段来更好地表示。</p>
<h3 id="请求和响应消息"><a href="#请求和响应消息" class="headerlink" title="请求和响应消息"></a>请求和响应消息</h3><p>RPC 方法的请求和响应消息<strong>应该</strong>分别以带有后缀 <code>Request</code> 和 <code>Response</code> 的方法名称命名，除非方法请求或响应类型为以下类型：</p>
<ul>
<li>空消息（使用 <code>google.protobuf.Empty</code>)，</li>
<li>一个资源类型，或</li>
<li>一个表示操作的资源</li>
</ul>
<p>这通常适用于在标准方法 <code>Get</code>、<code>Create</code>、<code>Update</code> 或 <code>Delete</code> 中使用的请求或响应。</p>
<h3 id="枚举名称"><a href="#枚举名称" class="headerlink" title="枚举名称"></a>枚举名称</h3><p>枚举类型<strong>必须</strong>使用 UpperCamelCase 格式的名称。</p>
<p>枚举值<strong>必须</strong>使用 CAPITALIZED_NAMES_WITH_UNDERSCORES 格式。每个枚举值<strong>必须</strong>以分号（而不是逗号）结尾。第一个值<strong>应该</strong>命名为 ENUM_TYPE_UNSPECIFIED，因为在枚举值未明确指定时系统会返回此值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum FooBar &#123;</span><br><span class="line">  // The first value represents the default and must be == 0.</span><br><span class="line">  FOO_BAR_UNSPECIFIED = 0;</span><br><span class="line">  FIRST_VALUE = 1;</span><br><span class="line">  SECOND_VALUE = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="封装容器"><a href="#封装容器" class="headerlink" title="封装容器"></a>封装容器</h3><p>封装 proto2 枚举类型（其中 <code>0</code> 值具有非 <code>UNSPECIFIED</code> 的含义）的消息<strong>应该</strong>以后缀 <code>Value</code> 来命名，并具有名为 <code>value</code>的单个字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum OldEnum &#123;</span><br><span class="line">  VALID = 0;</span><br><span class="line">  OTHER_VALID = 1;</span><br><span class="line">&#125;</span><br><span class="line">message OldEnumValue &#123;</span><br><span class="line">  OldEnum value = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字段名称"><a href="#字段名称" class="headerlink" title="字段名称"></a>字段名称</h3><p>.proto 文件中的字段定义<strong>必须</strong>使用 lower_case_underscore_separated_names 格式。这些名称将映射到每种编程语言的生成代码中的原生命名惯例。</p>
<p>字段名称<strong>不应</strong>包含介词（例如“for”、“during”、“at”），例如：</p>
<ul>
<li><code>reason_for_error</code> 应该改成 <code>error_reason</code></li>
<li><code>cpu_usage_at_time_of_failure</code> 应该改成 <code>failure_time_cpu_usage</code></li>
</ul>
<p>字段名称<strong>不应</strong>使用后置形容词（名词后面的修饰符），例如：</p>
<ul>
<li><code>items_collected</code> 应该改成 <code>collected_items</code></li>
<li><code>objects_imported</code> 应该改成 <code>imported_objects</code></li>
</ul>
<h3 id="重复的字段名称"><a href="#重复的字段名称" class="headerlink" title="重复的字段名称"></a>重复的字段名称</h3><p>API 中的重复字段<strong>必须</strong>使用正确的复数形式。这符合现有 Google API 的命名惯例和外部开发者的共同预期。</p>
<h3 id="时间和时间段"><a href="#时间和时间段" class="headerlink" title="时间和时间段"></a>时间和时间段</h3><p>要表示一个与任何时区或日历无关的时间点，<strong>应该</strong>使用 <code>google.protobuf.Timestamp</code>，并且字段名称<strong>应该</strong>以 <code>time</code>（例如 <code>start_time</code> 和 <code>end_time</code>）结尾。</p>
<p>如果时间指向一个活动，则字段名称<strong>应该</strong>采用 <code>verb_time</code> 的形式，例如 <code>create_time</code> 和 <code>update_time</code>。请勿使用动词的过去时态，例如 <code>created_time</code> 或 <code>last_updated_time</code>。</p>
<p>要表示与任何日历和概念（如“天”或“月”）无关的两个时间点之间的时间跨度，<strong>应该</strong>使用 <code>google.protobuf.Duration</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message FlightRecord &#123;</span><br><span class="line">  google.protobuf.Timestamp takeoff_time = 1;</span><br><span class="line">  google.protobuf.Duration flight_duration = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果由于旧版或兼容性原因（包括系统时间、时长、推迟和延迟），您必须使用整数类型表示与时间相关的字段，那么字段名称<strong>必须</strong>采用以下格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xxx_&#123;time|duration|delay|latency&#125;_&#123;seconds|millis|micros|nanos&#125;</span><br><span class="line">message Email &#123;</span><br><span class="line">  int64 send_time_millis = 1;</span><br><span class="line">  int64 receive_time_millis = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果由于旧版或兼容性原因，不得不使用字符串类型表示时间戳，则字段名称<strong>不应该</strong>包含任何单位后缀。字符串表示形式<strong>应该</strong>使用 RFC 3339 格式，例如“2014-07-30T10:43:17Z”。</p>
<h3 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h3><p>对于与时区和时段无关的日期，<strong>应该</strong>使用 <code>google.type.Date</code>，并且该名称应具有后缀 <code>_date</code>。如果日期必须表示为字符串，则应采用 ISO 8601 日期格式 YYYY-MM-DD，例如 2014-07-30。</p>
<p>对于与时区和日期无关的时间，<strong>应该</strong>使用 <code>google.type.TimeOfDay</code>，并且该名称应具有后缀 <code>_time</code>。如果时间必须表示为字符串，则应采用 ISO 8601 24 小时制格式 HH:MM:SS[FFF]，例如 14:55:01.672。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message StoreOpening &#123;</span><br><span class="line">  google.type.Date opening_date = 1;</span><br><span class="line">  google.type.TimeOfDay opening_time = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数量"><a href="#数量" class="headerlink" title="数量"></a>数量</h3><p>由整数类型表示的数量<strong>必须</strong>包含度量单位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx_&#123;bytes|width_pixels|meters&#125;</span><br></pre></td></tr></table></figure>
<p>如果数量是条目计数，则该字段<strong>应该</strong>具有后缀 <code>_count</code>，例如 <code>node_count</code>。</p>
<h3 id="列表过滤器字段"><a href="#列表过滤器字段" class="headerlink" title="列表过滤器字段"></a>列表过滤器字段</h3><p>如果 API 支持对 <code>List</code> 方法返回的资源进行过滤，则包含过滤器表达式的字段<strong>应该</strong>命名为 <code>filter</code>。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message ListBooksRequest &#123;</span><br><span class="line">  // The parent resource name.</span><br><span class="line">  string parent = 1;</span><br><span class="line"></span><br><span class="line">  // The filter expression.</span><br><span class="line">  string filter = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="列表响应"><a href="#列表响应" class="headerlink" title="列表响应"></a>列表响应</h3><p><code>List</code> 方法的响应消息（包含资源列表）中的字段名称<strong>必须</strong>是资源名称本身的复数形式。例如，<code>CalendarApi.ListEvents()</code> 方法<strong>必须</strong>为返回的资源列表定义一个响应消息 <code>ListEventsResponse</code>，其中包含一个名为 <code>events</code> 的重复字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">service CalendarApi &#123;</span><br><span class="line">  rpc ListEvents(ListEventsRequest) returns (ListEventsResponse) &#123;</span><br><span class="line">    option (google.api.http) = &#123;</span><br><span class="line">      get: &quot;/v3/&#123;parent=calendars/*&#125;/events&quot;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListEventsRequest &#123;</span><br><span class="line">  string parent = 1;</span><br><span class="line">  int32 page_size = 2;</span><br><span class="line">  string page_token = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ListEventsResponse &#123;</span><br><span class="line">  repeated Event events = 1;</span><br><span class="line">  string next_page_token = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="驼峰式命名法"><a href="#驼峰式命名法" class="headerlink" title="驼峰式命名法"></a>驼峰式命名法</h3><p>除了字段名称和枚举值之外，<code>.proto</code> 文件内的所有定义<strong>必须</strong>使用由 <a href="https://google.github.io/styleguide/javaguide.html#s5.3-camel-case" target="_blank" rel="noopener">Google Java 样式</a>定义的 UpperCamelCase（大驼峰式命名法）格式的名称。</p>
<h3 id="名称缩写"><a href="#名称缩写" class="headerlink" title="名称缩写"></a>名称缩写</h3><p>对于软件开发者熟知的名称缩写，例如 <code>config</code> 和 <code>spec</code>，<strong>应该</strong>在 API 定义中使用这些缩写，而不是完整拼写。这将使源代码易于读写。而在正式文档中，<strong>应该</strong>使用完整的名称。示例：</p>
<ul>
<li>config (configuration)</li>
<li>id (identifier)</li>
<li>spec (specification)</li>
<li>stats (statistics)</li>
</ul>
<h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于一个 API 服务<strong>可以</strong>提供多个 <a href="https://cloud.google.com/apis/design/glossary#api_interface" target="_blank" rel="noopener">API 接口</a>，因此 <a href="https://cloud.google.com/apis/design/glossary#api_version" target="_blank" rel="noopener">API 版本控制</a>策略适用于 API 接口级层，而不是 <a href="https://cloud.google.com/apis/design/glossary#api_service" target="_blank" rel="noopener">API 服务</a>级层。为方便起见，此 API 术语是指以下部分中的 API 接口。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;联网 API <strong>应该</strong>使用<a href="http://semver.org/" target="_blank" rel="noopener">语义版本控制</a>。如果版本号为 <code>MAJOR.MINOR.PATCH</code>，请增加：</p>
<ol>
<li><code>MAJOR</code> 版本（如果进行不兼容的 API 更改），</li>
<li><code>MINOR</code> 版本（如果以向后兼容的方式添加功能），</li>
<li><code>PATCH</code> 版本（如果进行向后兼容的错误修复）。</li>
</ol>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定主要版本号的规则因 API 的版本而异，具体规则如下：</p>
<ul>
<li>对于 API 的版本 1 (v1)，主要版本号<strong>应该</strong>编码为 proto 包名称的最后一个组件，例如 <code>google.pubsub.v1</code>。在极少数情况下（即包中包含明显稳定且不会发生重大更改的类型和接口），主要版本号<strong>可以</strong>从 proto 包名称中省略，例如 <code>google.protobuf</code> 和 <code>google.longrunning</code>。</li>
<li>对于除 v1 之外的所有 API 版本，主要版本号<strong>必须</strong>编码为 proto 包名称的最后一个组件。例如 <code>google.pubsub.v2</code>。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于正式发布之前的版本（例如 alpha 和 beta 版本），建议为版本号附加后缀。后缀<strong>应该</strong>包含预发布版本名称（例如 alpha、beta）和可选的预发布版本号。</p>
<p>版本升级的示例：</p>
<table>
<thead>
<tr>
<th style="text-align:left">版本</th>
<th style="text-align:left">Proto 包</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">v1alpha</td>
<td style="text-align:left">v1alpha1</td>
<td style="text-align:left">v1 alpha 版本。</td>
</tr>
<tr>
<td style="text-align:left">v1beta1</td>
<td style="text-align:left">v1beta1</td>
<td style="text-align:left">v1 beta 1 版本。</td>
</tr>
<tr>
<td style="text-align:left">v1beta2</td>
<td style="text-align:left">v1beta2</td>
<td style="text-align:left">v1 的第二个 beta 版本。</td>
</tr>
<tr>
<td style="text-align:left">v1test</td>
<td style="text-align:left">v1test</td>
<td style="text-align:left">带有虚拟数据的内部测试版本。</td>
</tr>
<tr>
<td style="text-align:left">v1</td>
<td style="text-align:left">v1</td>
<td style="text-align:left">v1 主要版本，正式版。</td>
</tr>
<tr>
<td style="text-align:left">v1.1beta1</td>
<td style="text-align:left">v1p1beta1</td>
<td style="text-align:left">对 v1 进行细微更改的第一个 beta 版本。</td>
</tr>
<tr>
<td style="text-align:left">v1.1</td>
<td style="text-align:left">v1</td>
<td style="text-align:left">v1.1 版本的次要更新。</td>
</tr>
<tr>
<td style="text-align:left">v2beta1</td>
<td style="text-align:left">v2beta1</td>
<td style="text-align:left">v2 beta 1 版本。</td>
</tr>
<tr>
<td style="text-align:left">v2</td>
<td style="text-align:left">v2</td>
<td style="text-align:left">v2 主要版本，正式版。</td>
</tr>
</tbody>
</table>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;次要和修补版本号<strong>应该</strong>反映在 API 配置和文档中。这些版本号<strong>不得</strong>在 proto 包名称中进行编码。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>注意</strong>：Google API 平台目前本身不支持次要和修补版本。对于每个主要 API 版本，只有一组文档和客户端库。API 所有者需要通过 API 文档和版本说明进行手动记录。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;新的 API 主要版本<strong>不得</strong>依赖于<strong>同一 API</strong> 的先前主要版本。某一个 API <strong>可以</strong>依赖于其他 API，前提是了解这些 API 的依赖项和稳定性风险。稳定的 API 版本<strong>必须</strong>只依赖于其他 API 的最新稳定版本。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一段时间内，同一 API 的不同版本<strong>必须</strong>能够在单个客户端应用中同时工作。这是为了帮助客户端从 API 的旧版本顺利过渡到新版本。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;API 的旧版本只<strong>应该</strong>在其弃用期结束后移除。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由许多 API 共享的常见且稳定的数据类型（如日期和时间）<strong>应该</strong>在单独的 proto 包中定义。如果需要进行重大更改，则<strong>必须</strong>引入新的类型名称或带有新的主要版本的包名称。</p>
<h3 id="向后兼容性"><a href="#向后兼容性" class="headerlink" title="向后兼容性"></a>向后兼容性</h3><p>确定向后兼容的更改可能很困难。</p>
<p>以下列表是一份快速参考，但如果您有任何疑问，请参阅<a href="https://cloud.google.com/apis/design/compatibility" target="_blank" rel="noopener">设计兼容性页面</a>以获取更多详细信息。</p>
<h3 id="向后兼容的（非重大）更改"><a href="#向后兼容的（非重大）更改" class="headerlink" title="向后兼容的（非重大）更改"></a>向后兼容的（非重大）更改</h3><ul>
<li><p>向 API 服务添加 API 接口</p>
</li>
<li><p>向 API 接口添加方法</p>
</li>
<li><p>向方法添加 HTTP 绑定</p>
</li>
<li><p>向请求消息添加字段</p>
</li>
<li><p>向响应消息添加字段</p>
</li>
<li><p>向枚举添加值</p>
</li>
<li><p>添加仅限输出的资源字段</p>
</li>
</ul>
<h3 id="向后不兼容的（重大）更改"><a href="#向后不兼容的（重大）更改" class="headerlink" title="向后不兼容的（重大）更改"></a>向后不兼容的（重大）更改</h3><ul>
<li>移除或重命名服务、接口、字段、方法或枚举值</li>
<li>更改 HTTP 绑定</li>
<li>更改字段的类型</li>
<li>更改 proto 字段编号</li>
<li>更改资源名称格式</li>
<li>更改现有请求的可见行为</li>
<li>更改 HTTP 定义中的网址格式</li>
<li>向资源消息添加读取/写入字段</li>
</ul>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本页面详细介绍了<a href="https://cloud.google.com/apis/design/versioning" target="_blank" rel="noopener">版本控制</a>部分提供的重大更改和非重大更改的列表。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;何为重大（不兼容）更改，这个问题的答案并不完全明确。此处的指导说明<strong>应</strong>被视为每个可能更改的指示性列表而非完整列表。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此处列出的规则仅涉及客户端兼容性。API 提供方应该了解自己在部署方面的要求，包括实现详细信息的更改。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;总体目标是将服务更新到新的次要版本或应用补丁时客户端不应该受影响。尚在研究的影响类型包括：</p>
<ul>
<li>源兼容性：针对 1.0 编写的代码无法针对 1.1 进行编译</li>
<li>二进制兼容性：针对 1.0 编译的代码无法针对 1.1 客户端库来链接/运行。（详细情况取决于客户端平台；这个问题在不同情况下有所不同。）</li>
<li>线路兼容性：针对 1.0 构建的应用程序无法与 1.1 服务器通信</li>
<li>语义兼容性：一切都在运行，但产生了意想不到的或出乎意料的结果</li>
<li></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从另一个角度说：旧客户端应该能与使用同一主要版本号的较新服务器结合使用，当其要更新到新的次要版本时（例如利用新功能），应该可以轻松做到。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了从基于协议的理论方面来考虑，由于存在涉及生成代码和手写代码的客户端库，因此存在实际考虑因素。测试您正在研究的更改时，应尽可能通过生成新版本的客户端库来测试，并确保其测试仍能通过。</p>
<p>下面的讨论内容将原型消息分为三类：</p>
<ul>
<li>请求消息（例如 <code>GetBookRequest</code>）</li>
<li>响应消息（例如 <code>ListBooksResponse</code>）</li>
<li>资源消息（例如 <code>Book</code>，包括其他资源消息中使用的任何消息）</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这些类别的消息具有不同的规则，因为请求消息仅从客户端发送到服务器，响应消息仅从服务器发送到客户端，但资源消息通常可以双向传输。特别是，可以更新的资源需要从读取/修改/写入周期方面来考虑。</p>
<h3 id="向后兼容的（非重大）更改-1"><a href="#向后兼容的（非重大）更改-1" class="headerlink" title="向后兼容的（非重大）更改"></a>向后兼容的（非重大）更改</h3><h4 id="向-API-服务定义添加-API-接口"><a href="#向-API-服务定义添加-API-接口" class="headerlink" title="向 API 服务定义添加 API 接口"></a>向 API 服务定义添加 API 接口</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从协议的角度来看，这始终比较安全。唯一需要注意的是，客户端库可能已经使用了手写代码中的新 API 接口名称。如果您的新接口与现有接口完全正交，则不太可能实现；如果它是现有接口的简化版本，则更有可能导致冲突。</p>
<h4 id="向-API-接口添加方法"><a href="#向-API-接口添加方法" class="headerlink" title="向 API 接口添加方法"></a>向 API 接口添加方法</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除非您添加的方法与客户端库中已生成的方法发生冲突，否则这应该没问题。</p>
<p>（可能造成重大后果的例子：如果您有 <code>GetFoo</code> 方法，C# 代码生成器已经创建了 <code>GetFoo</code> 和 <code>GetFooAsync</code> 方法。因此，从客户端库的角度来看，在 API 接口中添加 <code>GetFooAsync</code> 方法将是一个重大更改。）</p>
<h4 id="向方法添加-HTTP-绑定"><a href="#向方法添加-HTTP-绑定" class="headerlink" title="向方法添加 HTTP 绑定"></a>向方法添加 HTTP 绑定</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设绑定没有引入任何歧义，让服务器响应之前拒绝的网址就是安全的。将现有操作应用于新资源名称模式时，<strong>可以</strong>执行此操作。</p>
<h4 id="向请求消息添加字段"><a href="#向请求消息添加字段" class="headerlink" title="向请求消息添加字段"></a>向请求消息添加字段</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;添加请求字段可以是非重大更改，前提是未指定该字段的客户端将在新版本中采用与旧版本相同的处理方式。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能错误地执行此操作的最明显示例是使用分页：如果 API 的 v1.0 不包含集合的分页，则无法在 v1.1 中添加它，除非将默认的 <code>page_size</code> 视为无限（这通常是一个坏主意）。否则，希望通过单个请求获得完整结果的 v1.0 客户端可能只收到部分结果，而且不会意识到该集合包含更多资源。</p>
<h4 id="向响应消息添加字段"><a href="#向响应消息添加字段" class="headerlink" title="向响应消息添加字段"></a>向响应消息添加字段</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;并非资源（例如 <code>ListBooksResponse</code>）的响应消息可在不影响客户端的情况下进行扩展，前提是这样不会改变其他响应字段的行为。之前在响应中填充的任何字段都应继续使用相同的语义填充，即使这会引入冗余也如此。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，在 1.0 版中的查询响应可能包含 <code>contained_duplicates</code> 的布尔字段，这表示某些结果由于复制而省略。在 1.1 版中，我们可能会在 <code>duplicate_count</code> 字段提供更详细的信息。尽管它在 1.1 版本中是多余的，但仍<strong>必须</strong>填充 <code>contained_duplicates</code> 字段。</p>
<h4 id="向枚举添加值"><a href="#向枚举添加值" class="headerlink" title="向枚举添加值"></a>向枚举添加值</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只能在请求消息中使用的枚举可以自由扩展以包含新元素。例如，使用<a href="https://cloud.google.com/apis/design/design_patterns#resource_view" target="_blank" rel="noopener">资源视图</a>模式可在新的次要版本中添加新视图。客户永远不需要接收这个枚举，因此他们不必知道他们不关心的值。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于资源消息和响应消息，默认假设客户端应该处理他们不知道的枚举值。但是，API 提供方应该知道编写应用来正确处理新的枚举元素可能很困难。API 所有者<strong>应该</strong>在遇到未知枚举值时记录预期的客户端行为。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;借助 Proto3，客户端可以接收它们不知道的值并重新序列化保持相同值的消息，这样才不会影响读取/修改/写入周期。使用 JSON 格式可在值“名称”未知的情况下发送数值，但服务器通常不知道客户端是否真的知道特定值。因此，JSON 客户端可能知道它们已收到以前未知的值，但它们只会看到名称或数字 - 他们不会同时知道这两者。在读取/修改/写入循环中将相同的值返回到服务器，此时不应修改该字段，因为服务器应该理解这两种形式。</p>
<h4 id="添加仅限输出的资源字段"><a href="#添加仅限输出的资源字段" class="headerlink" title="添加仅限输出的资源字段"></a>添加仅限输出的资源字段</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>可以</strong>添加只能由服务器提供的资源实体中的字段。服务器<strong>可以</strong>验证请求中任何客户端提供的值是否有效，但<strong>不能</strong>在该值省略时失败。</p>
<h3 id="向后不兼容的（重大）的更改"><a href="#向后不兼容的（重大）的更改" class="headerlink" title="向后不兼容的（重大）的更改"></a>向后不兼容的（重大）的更改</h3><h4 id="移除或重命名服务、字段、方法或枚举值"><a href="#移除或重命名服务、字段、方法或枚举值" class="headerlink" title="移除或重命名服务、字段、方法或枚举值"></a>移除或重命名服务、字段、方法或枚举值</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从根本上看，如果客户端代码可能引用某些内容，对其执行移除或重命名操作就是重大更改，<strong>必须</strong>通过新的主要版本进行。引用旧名称的代码，对于有些语言（例如 C＃和 Java）会导致编译失败，对于其他语言则可能导致执行失败或数据丢失。传输格式兼容性与此无关。</p>
<h4 id="更改-HTTP-绑定"><a href="#更改-HTTP-绑定" class="headerlink" title="更改 HTTP 绑定"></a>更改 HTTP 绑定</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此处的“更改”实际上是“删除和添加”。例如，如果您确定确实要支持 <code>PATCH</code>，但您发布的版本支持 <code>PUT</code>，或者您使用了错误的自定义动词名称，则<strong>可以</strong>添加新绑定，但<strong>不能</strong>因为相同原因而删除旧绑定，因为移除服务方法是一个重大更改。</p>
<h4 id="更改字段的类型"><a href="#更改字段的类型" class="headerlink" title="更改字段的类型"></a>更改字段的类型</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;即使新类型与传输格式兼容，这也可能更改客户端库生成的代码，因此<strong>必须</strong>通过新的主要版本进行。对于已编译的静态类型语言，这很容易引入编译时错误。</p>
<h4 id="更改资源名称格式"><a href="#更改资源名称格式" class="headerlink" title="更改资源名称格式"></a>更改资源名称格式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;资源<strong>不得</strong>更改其名称 - 这意味着不能更改集合名称。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与大多数重大更改不同，这也会影响主要版本：如果客户端可以使用 v2.0 访问在 v1.0 中创建的资源（反之亦然），则应在两个版本中使用相同的资源名称。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;较容易忽略的是，由于以下原因，有效资源名称集<strong>也不应</strong>更改：</p>
<ul>
<li>如果它的限制变得更严格，之前成功的请求现在将失败。</li>
<li>如果它没有之前记录的限制严格，基于先前文档做出假设的客户端可能无法正常工作。客户很可能采用对允许的字符集和名称长度敏感的方式，将资源名称存储在其他位置。或者，客户很可能执行自己的资源名称验证以遵循文档说明。（例如，在开始支持更长的 EC2 资源 ID 之前，<a href="https://aws.amazon.com/blogs/aws/theyre-here-longer-ec2-resource-ids-now-available/" target="_blank" rel="noopener">亚马逊为客户提供了大量警告并且有一个迁移期</a>。）</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意，此类更改可能仅在原型文档中可见。因此，在审核 CL 是否损坏时，仅查看非评论更改并不够。</p>
<h4 id="更改现有请求的可见行为"><a href="#更改现有请求的可见行为" class="headerlink" title="更改现有请求的可见行为"></a>更改现有请求的可见行为</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户通常依赖 API 行为和语义，<strong>即使此类行为没有得到明确支持或记录</strong>。因此，在大多数情况下，更改 API 数据的行为或语义造成的影响将被视为使用者的责任。如果行为未以加密方式隐藏，则<strong>应</strong>假设用户已发现并将依赖此行为。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于这个原因（即使数据很无趣），对分页令牌加密也是一个好主意，可以防止用户创建自己的令牌，以及在令牌行为发生更改时影响令牌。</p>
<h4 id="更改-HTTP-定义中的网址格式"><a href="#更改-HTTP-定义中的网址格式" class="headerlink" title="更改 HTTP 定义中的网址格式"></a>更改 HTTP 定义中的网址格式</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了上面列出的资源名称更改之外，此处需要考虑两种更改：</p>
<ul>
<li>自定义方法名称：虽然并非资源名称的一部分，但自定义方法名称是 REST 客户端发布到的网址的一部分。更改自定义方法名称不应该影响 gRPC 客户端，但公共 API 必须假定它们具有 REST 客户端。</li>
<li>资源参数名称：从 <code>v1/shelves/{shelf}/books/{book}</code> 更改为 <code>v1/shelves/{shelf_id}/books/{book_id}</code> 不会影响已替代的资源名称，但可能会影响代码生成。</li>
</ul>
<h4 id="向资源消息添加读取-写入字段"><a href="#向资源消息添加读取-写入字段" class="headerlink" title="向资源消息添加读取/写入字段"></a>向资源消息添加读取/写入字段</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端通常会执行读取/修改/写入操作。大多数客户端不会为它们不知道的字段提供值，特别是 proto3，它不支持此操作。您可以指定消息类型（而不是原始类型）的任何缺失字段都表示更新未应用于这些字段，但这使得从实体中显式移除此类字段值变得更加困难。原始类型（包括 <code>string</code> 和 <code>bytes</code>）根本无法采用这种方式处理，因为在 proto3 中，将 <code>int32</code> 字段明确指定为 0 与完全不指定没有区别。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果使用字段掩码执行所有更新，这就不是问题，因为客户端不会隐式覆盖它不知道的字段。但是，这个 API 决策并不寻常：大多数 API 都支持“整个资源”更新。</p>
<h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本章简要介绍了<code>Google API</code>错误模型并为开发人员提供了正确生成和处理错误的通用指南。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Google API</code> 使用简单的协议无关错误模型，以便我们在不同的 <code>API</code>、<code>API</code> 协议（如 <code>gRPC 或 HTTP</code>）和错误上下文（例如异步、批处理或工作流错误）中能够有一致的体验。</p>
<h3 id="错误模型"><a href="#错误模型" class="headerlink" title="错误模型"></a>错误模型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;错误模型由 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto" target="_blank" rel="noopener"><code>google.rpc.Status</code></a> 在逻辑上定义，该实例将在 <code>API</code>错误发生时返回给客户端。以下代码段显示了错误模型的总体设计：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package google.rpc;</span><br><span class="line"></span><br><span class="line">message Status &#123;</span><br><span class="line">  // A simple error code that can be easily handled by the client. The</span><br><span class="line">  // actual error code is defined by `google.rpc.Code`.</span><br><span class="line">  int32 code = 1;</span><br><span class="line"></span><br><span class="line">  // A developer-facing human-readable error message in English. It should</span><br><span class="line">  // both explain the error and offer an actionable resolution to it.</span><br><span class="line">  string message = 2;</span><br><span class="line"></span><br><span class="line">  // Additional error information that the client code can use to handle</span><br><span class="line">  // the error, such as retry delay or a help link.</span><br><span class="line">  repeated google.protobuf.Any details = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于大多数 <code>Google API</code> 采用面向资源的 <code>API</code> 设计，因此错误处理遵循相同的设计原则，使用一小组标准错误配合大量资源。例如，服务器没有定义不同类型的“找不到”错误，而是使用一个标准 <code>google.rpc.Code.NOT_FOUND</code> 错误代码并告诉客户端找不到哪个特定资源。状态空间变小降低了文档的复杂性，在客户端库中提供了更好的惯用映射，并降低了客户端的逻辑复杂性，同时不限制是否包含可操作信息。</p>
<h3 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Google API</code> <strong>必须</strong>使用 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto" target="_blank" rel="noopener"><code>google.rpc.Code</code></a> 定义的规范错误代码。单个 API <strong>应</strong>避免定义其他错误代码，因为开发人员不太可能编写用于处理大量错误代码的逻辑。作为参考，每个 API 调用平均处理 3 个错误代码意味着大多数应用的逻辑只是用于错误处理，这对开发人员而言并非好体验。</p>
<h3 id="错误消息"><a href="#错误消息" class="headerlink" title="错误消息"></a>错误消息</h3><p>错误消息应该可以帮助用户轻松快捷地<strong>理解和解决</strong> API 错误。通常，在编写错误消息时请考虑以下准则：</p>
<ul>
<li>不要假设用户是您 API 的专家用户。用户可能是客户端开发人员、操作人员、IT 人员或应用的最终用户。</li>
<li>不要假设用户了解有关服务实现的任何信息，或者熟悉错误的上下文（例如日志分析）。</li>
<li>如果可能，应构建错误消息，以便技术用户（但不一定是 API 开发人员）可以响应错误并改正。</li>
<li>确保错误消息内容简洁。如果需要，请提供一个链接，便于有疑问的读者提问、提供反馈或详细了解错误消息中不方便说明的信息。此外，可使用详细信息字段来提供更多信息。</li>
</ul>
<h3 id="错误详情"><a href="#错误详情" class="headerlink" title="错误详情"></a>错误详情</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Google API</code>为错误详细信息定义了一组标准错误负载，您可在 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto" target="_blank" rel="noopener">google/rpc/error_details.proto</a> 中找到这些错误负载。它们涵盖了对于<code>API</code>错误的最常见需求，例如配额失败和无效参数。与错误代码一样，错误详细信息应尽可能使用这些标准负载。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只有在可以帮助应用代码处理错误的情况下，才应引入其他错误详细信息类型。如果错误信息只能由人工处理，则应根据错误消息内容，让开发人员手动处理，而不是引入新的错误详细信息类型。</p>
<p>以下是一些 <code>error_details</code> 负载示例：</p>
<ul>
<li><code>RetryInfo</code>：描述客户端何时可以重试失败的请求，这些内容可能在以下方法中返回：<code>Code.UNAVAILABLE</code> 或 <code>Code.ABORTED</code></li>
<li><code>QuotaFailure</code>：描述配额检查失败的方式，这些内容可能在以下方法中返回：<code>Code.RESOURCE_EXHAUSTED</code></li>
<li><code>BadRequest</code>：描述客户端请求中的违规行为，这些内容可能在以下方法中返回：<code>Code.INVALID_ARGUMENT</code></li>
</ul>
<h3 id="HTTP-映射-1"><a href="#HTTP-映射-1" class="headerlink" title="HTTP 映射"></a>HTTP 映射</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;虽然 <code>proto3</code> 消息具有原生<code>JSON</code>编码，但<code>Google</code> 的 <code>API</code>平台对 <code>Google JSON REST API</code> 使用了不同的错误架构，以实现向后兼容性。</p>
<p>架构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// The error schema for Google REST APIs. NOTE: this schema is not used for</span><br><span class="line">// other wire protocols.</span><br><span class="line">message Error &#123;</span><br><span class="line">  // This message has the same semantics as `google.rpc.Status`. It has an extra</span><br><span class="line">  // field `status` for backward compatibility with Google API Client Library.</span><br><span class="line">  message Status &#123;</span><br><span class="line">    // This corresponds to `google.rpc.Status.code`.</span><br><span class="line">    int32 code = 1;</span><br><span class="line">    // This corresponds to `google.rpc.Status.message`.</span><br><span class="line">    string message = 2;</span><br><span class="line">    // This is the enum version for `google.rpc.Status.code`.</span><br><span class="line">    google.rpc.Code status = 4;</span><br><span class="line">    // This corresponds to `google.rpc.Status.details`.</span><br><span class="line">    repeated google.protobuf.Any details = 5;</span><br><span class="line">  &#125;</span><br><span class="line">  // The actual error payload. The nested message structure is for backward</span><br><span class="line">  // compatibility with Google API client libraries. It also makes the error</span><br><span class="line">  // more readable to developers.</span><br><span class="line">  Status error = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"error"</span>: &#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">401</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"Request had invalid credentials."</span>,</span><br><span class="line">    <span class="attr">"status"</span>: <span class="string">"UNAUTHENTICATED"</span>,</span><br><span class="line">    <span class="attr">"details"</span>: [&#123;</span><br><span class="line">      <span class="attr">"@type"</span>: <span class="string">"type.googleapis.com/google.rpc.RetryInfo"</span>,</span><br><span class="line">      ...</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RPC-映射"><a href="#RPC-映射" class="headerlink" title="RPC 映射"></a>RPC 映射</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不同的 <code>RPC</code>协议采用不同方式映射错误模型。对于 <a href="http://grpc.io/" target="_blank" rel="noopener">gRPC</a>，生成的代码和每种支持语言的运行时库为错误模型提供原生支持。您可在 gRPC 的 API 文档中找到更多信息（例如，可参阅 gRPC Java 的 <a href="https://github.com/grpc/grpc-java/blob/master/core/src/main/java/io/grpc/Status.java" target="_blank" rel="noopener"><code>io.grpc.Status</code></a>）。</p>
<h3 id="客户端库映射"><a href="#客户端库映射" class="headerlink" title="客户端库映射"></a>客户端库映射</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Google</code>客户端库可能会根据语言选择采用不同方式表达错误，以与既定习语保持一致。例如，<a href="https://github.com/GoogleCloudPlatform/google-cloud-go" target="_blank" rel="noopener">google-cloud-go</a> 库将返回一个错误，该错误会实现与 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto" target="_blank" rel="noopener"><code>google.rpc.Status</code></a> 相同的接口，而 <a href="https://github.com/googleapis/google-cloud-java" target="_blank" rel="noopener">google-cloud-java</a> 将引发异常。</p>
<h3 id="错误本地化"><a href="#错误本地化" class="headerlink" title="错误本地化"></a>错误本地化</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto" target="_blank" rel="noopener"><code>google.rpc.Status</code></a> 中的 <code>message</code> 字段面向开发人员，<strong>必须</strong>使用英语。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要面向用户的错误消息，请使用 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto" target="_blank" rel="noopener"><code>google.rpc.LocalizedMessage</code></a> 作为您的详细信息字段。如果 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto" target="_blank" rel="noopener"><code>google.rpc.LocalizedMessage</code></a> 中的消息字段可以进行本地化，请确保 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto" target="_blank" rel="noopener"><code>google.rpc.Status</code></a> 中的消息字段使用英文。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认情况下，API 服务应使用经过身份验证的用户的语言区域设置或 HTTP <code>Accept-Language</code> 标头来确定本地化的语言。</p>
<h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下面的表格包含在 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto" target="_blank" rel="noopener"><code>google.rpc.Code</code></a> 中定义的所有 gRPC 错误代码及其原因的简短描述。要处理错误，您可以检查返回状态代码的说明并相应地修改您的调用。</p>
<table>
<thead>
<tr>
<th style="text-align:left">HTTP</th>
<th style="text-align:left">RPC</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">200</td>
<td style="text-align:left"><code>OK</code></td>
<td style="text-align:left">无错误。</td>
</tr>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left"><code>INVALID_ARGUMENT</code></td>
<td style="text-align:left">客户端指定了无效参数。如需了解详情，请查看错误消息和错误详细信息。</td>
</tr>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left"><code>FAILED_PRECONDITION</code></td>
<td style="text-align:left">请求无法在当前系统状态下执行，例如删除非空目录。</td>
</tr>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left"><code>OUT_OF_RANGE</code></td>
<td style="text-align:left">客户端指定了无效范围。</td>
</tr>
<tr>
<td style="text-align:left">401</td>
<td style="text-align:left"><code>UNAUTHENTICATED</code></td>
<td style="text-align:left">由于 OAuth 令牌丢失、无效或过期，请求未通过身份验证。</td>
</tr>
<tr>
<td style="text-align:left">403</td>
<td style="text-align:left"><code>PERMISSION_DENIED</code></td>
<td style="text-align:left">客户端权限不足。可能的原因包括 OAuth 令牌的覆盖范围不正确、客户端没有权限或者尚未为客户端项目启用 API。</td>
</tr>
<tr>
<td style="text-align:left">404</td>
<td style="text-align:left"><code>NOT_FOUND</code></td>
<td style="text-align:left">找不到指定的资源，或者请求由于未公开的原因（例如白名单）而被拒绝。</td>
</tr>
<tr>
<td style="text-align:left">409</td>
<td style="text-align:left"><code>ABORTED</code></td>
<td style="text-align:left">并发冲突，例如读取/修改/写入冲突。</td>
</tr>
<tr>
<td style="text-align:left">409</td>
<td style="text-align:left"><code>ALREADY_EXISTS</code></td>
<td style="text-align:left">客户端尝试创建的资源已存在。</td>
</tr>
<tr>
<td style="text-align:left">429</td>
<td style="text-align:left"><code>RESOURCE_EXHAUSTED</code></td>
<td style="text-align:left">资源配额不足或达到速率限制。如需了解详情，客户端应该查找 google.rpc.QuotaFailure 错误详细信息。</td>
</tr>
<tr>
<td style="text-align:left">499</td>
<td style="text-align:left"><code>CANCELLED</code></td>
<td style="text-align:left">请求被客户端取消。</td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left"><code>DATA_LOSS</code></td>
<td style="text-align:left">出现不可恢复的数据丢失或数据损坏。客户端应该向用户报告错误。</td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left"><code>UNKNOWN</code></td>
<td style="text-align:left">出现未知的服务器错误。通常是服务器错误。</td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left"><code>INTERNAL</code></td>
<td style="text-align:left">出现内部服务器错误。通常是服务器错误。</td>
</tr>
<tr>
<td style="text-align:left">501</td>
<td style="text-align:left"><code>NOT_IMPLEMENTED</code></td>
<td style="text-align:left">API 方法未通过服务器实现。</td>
</tr>
<tr>
<td style="text-align:left">503</td>
<td style="text-align:left"><code>UNAVAILABLE</code></td>
<td style="text-align:left">服务不可用。通常是服务器已关闭。</td>
</tr>
<tr>
<td style="text-align:left">504</td>
<td style="text-align:left"><code>DEADLINE_EXCEEDED</code></td>
<td style="text-align:left">超出请求时限。仅当调用者设置的时限比方法的默认时限短（即请求的时限不足以让服务器处理请求）并且请求未在时限范围内完成时，才会发生这种情况。</td>
</tr>
</tbody>
</table>
<h3 id="错误重试"><a href="#错误重试" class="headerlink" title="错误重试"></a>错误重试</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端<strong>应</strong>使用指数退避算法重试 500 和 503 错误。除非另有说明，否则最小延迟应为 1 秒。对于 429 错误，客户端可能会以最少 30 秒的延迟重试。对于所有其他错误，重试可能不适用 - 首先确保您的请求具有幂等性，并查看错误消息以获取指导。</p>
<h3 id="错误传播"><a href="#错误传播" class="headerlink" title="错误传播"></a>错误传播</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您的 API 服务依赖于其他服务，则不应盲目地将这些服务的错误传播到您的客户端。在翻译错误时，我们建议执行以下操作：</p>
<ul>
<li>隐藏实现详细信息和机密信息。</li>
<li>调整负责该错误的一方。例如，从另一个服务接收 <code>INVALID_ARGUMENT</code> 错误的服务器应该将 <code>INTERNAL</code> 传播给它自己的调用者。</li>
</ul>
<h3 id="生成错误"><a href="#生成错误" class="headerlink" title="生成错误"></a>生成错误</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果您是服务器开发人员，则应该生成包含足够信息的错误，以帮助客户端开发人员理解并解决问题。同时，您必须重视用户数据的安全性和隐私性，避免在错误消息和错误详细信息中披露敏感信息，因为错误通常会被记录下来并且可能被其他人访问。例如，诸如“客户端 IP 地址不在白名单 <code>128.0.0.0/8</code>上”之类的错误消息会披露服务器端政策的相关信息，这些信息可能是用户无法访问的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要生成正确的错误，首先需要熟悉 <a href="https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto" target="_blank" rel="noopener"><code>google.rpc.Code</code></a>，然后才能为每个错误条件选择最合适的错误代码。服务器应用可以并行检查多个错误条件，并返回第一个错误条件。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下表列出了每个错误代码和恰当的错误消息示例。</p>
<table>
<thead>
<tr>
<th style="text-align:left">HTTP</th>
<th style="text-align:left">RPC</th>
<th style="text-align:left">错误消息示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left"><code>INVALID_ARGUMENT</code></td>
<td style="text-align:left">请求字段 x.y.z 是 xxx，预期为 [yyy, zzz] 内的一个。</td>
</tr>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left"><code>FAILED_PRECONDITION</code></td>
<td style="text-align:left">资源 xxx 是非空目录，因此无法删除。</td>
</tr>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left"><code>OUT_OF_RANGE</code></td>
<td style="text-align:left">参数“age”超出范围 [0,125]。</td>
</tr>
<tr>
<td style="text-align:left">401</td>
<td style="text-align:left"><code>UNAUTHENTICATED</code></td>
<td style="text-align:left">身份验证凭据无效。</td>
</tr>
<tr>
<td style="text-align:left">403</td>
<td style="text-align:left"><code>PERMISSION_DENIED</code></td>
<td style="text-align:left">使用权限“xxx”处理文件“yyy”被拒绝。</td>
</tr>
<tr>
<td style="text-align:left">404</td>
<td style="text-align:left"><code>NOT_FOUND</code></td>
<td style="text-align:left">找不到资源“xxx”。</td>
</tr>
<tr>
<td style="text-align:left">409</td>
<td style="text-align:left"><code>ABORTED</code></td>
<td style="text-align:left">无法锁定资源“xxx”。</td>
</tr>
<tr>
<td style="text-align:left">409</td>
<td style="text-align:left"><code>ALREADY_EXISTS</code></td>
<td style="text-align:left">资源“xxx”已经存在。</td>
</tr>
<tr>
<td style="text-align:left">429</td>
<td style="text-align:left"><code>RESOURCE_EXHAUSTED</code></td>
<td style="text-align:left">超出配额限制“xxx”。</td>
</tr>
<tr>
<td style="text-align:left">499</td>
<td style="text-align:left"><code>CANCELLED</code></td>
<td style="text-align:left">请求被客户端取消。</td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left"><code>DATA_LOSS</code></td>
<td style="text-align:left">请参阅注释。</td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left"><code>UNKNOWN</code></td>
<td style="text-align:left">请参阅注释。</td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left"><code>INTERNAL</code></td>
<td style="text-align:left">请参阅注释。</td>
</tr>
<tr>
<td style="text-align:left">501</td>
<td style="text-align:left"><code>NOT_IMPLEMENTED</code></td>
<td style="text-align:left">方法“xxx”未实现。</td>
</tr>
<tr>
<td style="text-align:left">503</td>
<td style="text-align:left"><code>UNAVAILABLE</code></td>
<td style="text-align:left">请参阅注释。</td>
</tr>
<tr>
<td style="text-align:left">504</td>
<td style="text-align:left"><code>DEADLINE_EXCEEDED</code></td>
<td style="text-align:left">请参阅注释。</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：由于客户端无法修复服务器错误，因此生成其他错误详细信息没有任何用处。为避免在错误条件下泄露敏感信息，建议不要生成任何错误消息，而仅生成 <code>google.rpc.DebugInfo</code> 错误详细信息。<code>DebugInfo</code> 专为服务器端的日志记录而设计，<strong>不得</strong>发送到客户端。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>google.rpc</code> 软件包定义了一组标准错误负载，它们优先于自定义错误负载。下表列出了每个错误代码及其匹配的标准错误负载（如果适用）。</p>
<table>
<thead>
<tr>
<th style="text-align:left">HTTP</th>
<th style="text-align:left">RPC</th>
<th style="text-align:left">建议的错误详细信息</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left"><code>INVALID_ARGUMENT</code></td>
<td style="text-align:left"><code>google.rpc.BadRequest</code></td>
</tr>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left"><code>FAILED_PRECONDITION</code></td>
<td style="text-align:left"><code>google.rpc.PreconditionFailure</code></td>
</tr>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left"><code>OUT_OF_RANGE</code></td>
<td style="text-align:left"><code>google.rpc.BadRequest</code></td>
</tr>
<tr>
<td style="text-align:left">401</td>
<td style="text-align:left"><code>UNAUTHENTICATED</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">403</td>
<td style="text-align:left"><code>PERMISSION_DENIED</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">404</td>
<td style="text-align:left"><code>NOT_FOUND</code></td>
<td style="text-align:left"><code>google.rpc.ResourceInfo</code></td>
</tr>
<tr>
<td style="text-align:left">409</td>
<td style="text-align:left"><code>ABORTED</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">409</td>
<td style="text-align:left"><code>ALREADY_EXISTS</code></td>
<td style="text-align:left"><code>google.rpc.ResourceInfo</code></td>
</tr>
<tr>
<td style="text-align:left">429</td>
<td style="text-align:left"><code>RESOURCE_EXHAUSTED</code></td>
<td style="text-align:left"><code>google.rpc.QuotaFailure</code></td>
</tr>
<tr>
<td style="text-align:left">499</td>
<td style="text-align:left"><code>CANCELLED</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left"><code>DATA_LOSS</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left"><code>UNKNOWN</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left"><code>INTERNAL</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">501</td>
<td style="text-align:left"><code>NOT_IMPLEMENTED</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">503</td>
<td style="text-align:left"><code>UNAVAILABLE</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">504</td>
<td style="text-align:left"><code>DEADLINE_EXCEEDED</code></td>
</tr>
</tbody>
</table>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>API 服务通常使用 <code>.proto</code> 文件来定义 API 接口，并使用 <code>.yaml</code> 文件来配置 API 服务。每个 API 服务<strong>必须</strong>在 API 代码库中有一个 API 目录，其中包含定义文件和构建脚本。</p>
<p>每个 API 目录<strong>应该</strong>具有以下标准布局：</p>
<ul>
<li>API 目录<ul>
<li>代码库必要条件<ul>
<li><code>BUILD</code>：构建文件。</li>
<li><code>METADATA</code>：构建元数据文件。</li>
<li><code>OWNERS</code>：API 目录所有者。</li>
</ul>
</li>
<li>配置文件<ul>
<li><code>{service}.yaml</code>：基准服务配置文件，<code>google.api.Service</code> proto 消息的 YAML 表示法。</li>
<li><code>prod.yaml</code>：生产环境增量服务配置文件。</li>
<li><code>staging.yaml</code>：模拟环境增量服务配置文件。</li>
<li><code>test.yaml</code>：测试环境增量服务配置文件。</li>
<li><code>local.yaml</code>：本地环境增量服务配置文件。</li>
</ul>
</li>
<li>文档文件<ul>
<li><code>README.md</code>：主要 readme 文件。它应包含一般生产概览和技术说明等。</li>
<li><code>doc/*</code>：技术文档文件。它们应采用 Markdown 格式。</li>
</ul>
</li>
<li>接口定义<ul>
<li><code>v[0-9]*/*</code>：每个这样的目录都包含 API 的主要版本，主要是 proto 文件和构建脚本。</li>
<li><code>{subapi}/v[0-9]*/*</code>：每个 <code>{subapi}</code> 目录包含子 API 的接口定义。每个子 API 可以有自己的独立主要版本。</li>
<li><code>type/*</code>：proto 文件，包含在不同 API 之间、同一 API 的不同版本之间或 API 与服务实现之间共享的类型。<code>type/*</code> 下的类型定义一旦发布就不<strong>应该</strong>有重大更改。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>gRPC API <strong>应</strong>使用 <a href="https://cloud.google.com/apis/design/proto3" target="_blank" rel="noopener">proto3</a> IDL 在 <code>.proto</code> 文件中定义。</p>
<p>文件结构<strong>必须</strong>将更高级别和更重要的定义置于较低级别和较不重要的项目之前。在每个 proto 文件中，适用的部分<strong>应</strong>按以下顺序排列：</p>
<ul>
<li>版权和许可声明（如果需要）。</li>
<li>采用该顺序的 Proto <code>syntax</code>、<code>package</code>、<code>import</code> 和 <code>option</code> 语句。</li>
<li>API 概览文档，为读取器准备文件的其余部分。</li>
<li>按重要性降序排列的 API proto <code>service</code> 定义。</li>
<li>与相应方法采用相同顺序的 RPC 请求和响应 <code>message</code> 定义。每个请求消息<strong>必须</strong>在其相应的响应消息之前（如果有）。</li>
<li>资源 <code>message</code> 定义。父资源<strong>必须</strong>在其子资源之前定义。</li>
</ul>
<p>如果单个 proto 文件包含整个 API 接口，<strong>应</strong>在 API 之后命名：</p>
<table>
<thead>
<tr>
<th style="text-align:left">API</th>
<th style="text-align:left">Proto</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>Library</code></td>
<td style="text-align:left"><code>library.proto</code></td>
</tr>
<tr>
<td style="text-align:left"><code>Calendar</code></td>
<td style="text-align:left"><code>calendar.proto</code></td>
</tr>
</tbody>
</table>
<p>大 .proto 文件可能会拆分为多个文件。应根据需要将服务、资源消息和请求/响应消息移到单独的文件中。</p>
<p>我们建议每个服务及其相应的请求和响应使用一个文件。考虑将此文件命名为 <code>&lt;enclosed service name&gt;.proto</code>。对于仅包含资源的 proto 文件，请考虑将此文件简单命名为 <code>resources.proto</code>。</p>
<h3 id="Proto-文件名"><a href="#Proto-文件名" class="headerlink" title="Proto 文件名"></a>Proto 文件名</h3><p>Proto 文件名<strong>应</strong>使用 lower_case_underscore_separated_names，并且<strong>必须</strong>使用扩展名 <code>.proto</code>。例如：<code>service_controller.proto</code>。</p>
<h3 id="Proto-选项"><a href="#Proto-选项" class="headerlink" title="Proto 选项"></a>Proto 选项</h3><p>为了在不同 API 中生成一致的客户端库，API 开发人员<strong>必须</strong>在其 <code>.proto</code> 文件中使用一致的 proto 选项。符合本指南的 API 定义<strong>必须</strong>使用以下文件级 proto 选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">// The package name should start with the company name and end with</span><br><span class="line">// the major version.</span><br><span class="line">package google.abc.xyz.v1;</span><br><span class="line"></span><br><span class="line">// This option specifies the namespace to be used in C# code. This defaults</span><br><span class="line">// to the PascalCased version of the proto package, which is fine if the</span><br><span class="line">// package name consists of single-word segments.</span><br><span class="line">// For example, a package name of &quot;google.shopping.pets.v1&quot; would use a C#</span><br><span class="line">// namespace of &quot;Google.Shopping.Pets.V1&quot;.</span><br><span class="line">// However, if any segment of a package name consists of multiple words,</span><br><span class="line">// this option needs to be specified to avoid only the first word being</span><br><span class="line">// capitalized. For example, a Google Pet Store API might have a package name of</span><br><span class="line">// &quot;google.shopping.petstore.v1&quot;, which would mean a C# namespace of</span><br><span class="line">// &quot;Google.Shopping.Petstore.V1&quot;. Instead, the option should be used to</span><br><span class="line">// capitalize it properly as &quot;Google.Shopping.PetStore.V1&quot;.</span><br><span class="line">//</span><br><span class="line">// For more detail on C#/.NET capitalization rules, see the [Framework Design</span><br><span class="line">// Guidelines](https://msdn.microsoft.com/en-us/library/ms229043).</span><br><span class="line">//</span><br><span class="line">// One corner-case of capitalization: while acronyms are generally</span><br><span class="line">// PascalCased (e.g. Http), two-letter acronyms are normally all in capitals,</span><br><span class="line">// e.g. `IOStream` and `OSVersion`, not `IoStream` and `OsVersion`. However,</span><br><span class="line">// in APIs this should be used carefully, as protoc doesn&apos;t know which words</span><br><span class="line">// are abbreviations and which aren&apos;t: it would introduce inconsistency to have</span><br><span class="line">// a namespace of (say) `OSLogin` but then a class called `OsDetails` generated</span><br><span class="line">// from a message of the same name. Unless you can be certain that the acronym</span><br><span class="line">// won&apos;t crop up in a message or field name, it&apos;s safest to stick to regular</span><br><span class="line">// PascalCase.</span><br><span class="line">//</span><br><span class="line">// For pre-releases, the Alpha/Beta should also be capitalized, so &quot;V1Beta1&quot;</span><br><span class="line">// rather than &quot;V1beta1&quot; for example.</span><br><span class="line">option csharp_namespace = &quot;Google.Abc.Xyz.V1&quot;;</span><br><span class="line"></span><br><span class="line">// This option lets the proto compiler generate Java code inside the package</span><br><span class="line">// name (see below) instead of inside an outer class. It creates a simpler</span><br><span class="line">// developer experience by reducing one-level of name nesting and be</span><br><span class="line">// consistent with most programming languages that don&apos;t support outer classes.</span><br><span class="line">option java_multiple_files = true;</span><br><span class="line"></span><br><span class="line">// The Java outer classname should be the filename in UpperCamelCase. This</span><br><span class="line">// class is only used to hold proto descriptor, so developers don&apos;t need to</span><br><span class="line">// work with it directly.</span><br><span class="line">option java_outer_classname = &quot;XyzProto&quot;;</span><br><span class="line"></span><br><span class="line">// The Java package name must be proto package name with proper prefix.</span><br><span class="line">option java_package = &quot;com.google.abc.xyz.v1&quot;;</span><br><span class="line"></span><br><span class="line">// A reasonable prefix for the Objective-C symbols generated from the package.</span><br><span class="line">// It should at a minimum be 3 characters long, all uppercase, and convention</span><br><span class="line">// is to use an abbreviation of the package name. Something short, but</span><br><span class="line">// hopefully unique enough to not conflict with things that may come along in</span><br><span class="line">// the future. &apos;GPB&apos; is reserved for the protocol buffer implementation itself.</span><br><span class="line">option objc_class_prefix = &quot;GABCX&quot;;</span><br><span class="line"></span><br><span class="line">// This option specifies the namespace to be used in PHP code. This defaults</span><br><span class="line">// to the PascalCased version of the proto package, which is fine if the</span><br><span class="line">// package name consists of single-word segments.</span><br><span class="line">// For example, a package name of &quot;google.shopping.pets.v1&quot; would use a PHP</span><br><span class="line">// namespace of &quot;Google\\Shopping\\Pets\\V1&quot;.</span><br><span class="line">// However, if any segment of a package name consists of multiple words,</span><br><span class="line">// this option needs to be specified to avoid only the first word being</span><br><span class="line">// capitalized. For example, a Google Pet Store API might have a package name of</span><br><span class="line">// &quot;google.shopping.petstore.v1&quot;, which would mean a PHP namespace of</span><br><span class="line">// &quot;Google\\Shopping\\Petstore\\V1&quot;. Instead, the option should be used to</span><br><span class="line">// capitalize it properly as &quot;Google\\Shopping\\PetStore\\V1&quot;.</span><br><span class="line">//</span><br><span class="line">// For pre-releases, the Alpha/Beta should not be capitalized, so &quot;V1beta1&quot;</span><br><span class="line">// rather than &quot;V1Beta1&quot; for example. Note that this is different from the</span><br><span class="line">// capitalization used in the csharp_namespace option for pre-releases.</span><br><span class="line">option php_namespace = &quot;Google\\Abc\\Xyz\\V1&quot;;</span><br></pre></td></tr></table></figure>
<h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><h4 id="联网-API"><a href="#联网-API" class="headerlink" title="联网 API"></a>联网 API</h4><ul>
<li>跨计算机网络运行的应用编程接口。它们使用包括 HTTP 在内的各种网络协议进行通信，并且由不同的组织生成，通常供大于求。</li>
</ul>
<h4 id="Google-API"><a href="#Google-API" class="headerlink" title="Google API"></a>Google API</h4><ul>
<li>Google 服务公开的联网 API。其中大多数都托管在 <code>googleapis.com</code> 域名上。不包括其他类型的 API，例如客户端库和 SDK。</li>
</ul>
<h4 id="API-接口"><a href="#API-接口" class="headerlink" title="API 接口"></a>API 接口</h4><ul>
<li>一个 Protocol Buffers 服务定义。它通常映射到大多数编程语言中的某一个接口。API 接口可以由任意数量的 API 服务实现。</li>
</ul>
<h4 id="API-版本"><a href="#API-版本" class="headerlink" title="API 版本"></a>API 版本</h4><ul>
<li>一个 API 接口或一组 API 接口（如果一起定义）的版本。API 版本通常由字符串（例如“v1”）表示，并显示在 API 请求和 Protocol Buffers 包名称中。</li>
</ul>
<h4 id="API-方法"><a href="#API-方法" class="headerlink" title="API 方法"></a>API 方法</h4><ul>
<li>API 接口中的单个操作。它在 Protocol Buffers 中由 <code>rpc</code> 定义表示，并且通常映射到大多数编程语言的 API 接口中的一个函数。</li>
</ul>
<h4 id="API-请求"><a href="#API-请求" class="headerlink" title="API 请求"></a>API 请求</h4><ul>
<li>API 方法的单个调用。它通常用作计费、日志记录、监控和速率限制的单位。</li>
</ul>
<h4 id="API-服务"><a href="#API-服务" class="headerlink" title="API 服务"></a>API 服务</h4><ul>
<li>在一个或多个网络端点上公开的一个或多个 API 接口的部署实现。API 服务由其与 <a href="https://www.ietf.org/rfc/rfc1035.txt" target="_blank" rel="noopener">RFC 1035 DNS</a> 兼容的服务名称（例如 <code>calendar.googleapis.com</code>）标识。</li>
</ul>
<h4 id="API-端点"><a href="#API-端点" class="headerlink" title="API 端点"></a>API 端点</h4><ul>
<li>是指 API 服务用于响应实际 API 请求的网络地址，如 <code>pubsub.googleapis.com</code> 和 <code>content-pubsub.googleapis.com</code>。</li>
</ul>
<h4 id="API-产品"><a href="#API-产品" class="headerlink" title="API 产品"></a>API 产品</h4><ul>
<li>API 服务及相关组件（如服务条款、文档、客户端库和服务支持）将作为一个产品统一呈现给客户。例如 Google Calendar API。注意：人们有时将 API 产品简称为 API。</li>
</ul>
<h4 id="API-服务定义"><a href="#API-服务定义" class="headerlink" title="API 服务定义"></a>API 服务定义</h4><ul>
<li>用于定义 API 服务的 API 接口定义（.proto 文件）和 API 服务配置（.yaml 文件）的组合。Google API 服务定义的架构为 <a href="https://github.com/googleapis/googleapis/blob/master/google/api/service.proto" target="_blank" rel="noopener"><code>google.api.Service</code></a>。</li>
</ul>
<h4 id="API-使用者"><a href="#API-使用者" class="headerlink" title="API 使用者"></a>API 使用者</h4><ul>
<li>使用 API 服务的实体。对于 Google API，使用者通常是拥有客户端应用或服务器资源的 Google 项目。</li>
</ul>
<h4 id="API-生产者"><a href="#API-生产者" class="headerlink" title="API 生产者"></a>API 生产者</h4><ul>
<li>生产 API 服务的实体。对于 Google API，生产者通常是拥有 API 服务的 Google 项目。</li>
</ul>
<h4 id="API-后端"><a href="#API-后端" class="headerlink" title="API 后端"></a>API 后端</h4><ul>
<li>实现 API 服务业务逻辑的一组服务器及相关基础架构。单个 API 后端服务器通常称为 API 服务器。</li>
</ul>
<h4 id="API-前端"><a href="#API-前端" class="headerlink" title="API 前端"></a>API 前端</h4><ul>
<li><p>跨 API 服务提供通用功能（例如负载平衡和身份验证）的一组服务器及相关基础架构。单个 API 前端服务器通常称为 API 代理。</p>
<p>注意：API 前端和 API 后端运行时可以彼此相邻，也可以离得很远。在某些情况下，它们可以编译为单个应用二进制文件，并在单个进程中运行。</p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/架构/" rel="tag"># 架构</a>
          
            <a href="/tags/API设计/" rel="tag"># API设计</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/09/13 个设计 REST API 的最佳实践/" rel="next" title="13 个设计 REST API 的最佳实践">
                <i class="fa fa-chevron-left"></i> 13 个设计 REST API 的最佳实践
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/09/微软-API 设计指导/" rel="prev" title="微软-API 设计指导">
                微软-API 设计指导 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Google-API设计指南"><span class="nav-number">1.</span> <span class="nav-text">Google API设计指南</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#面向资源的设计"><span class="nav-number">1.1.</span> <span class="nav-text">面向资源的设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是-REST-API？"><span class="nav-number">1.1.1.</span> <span class="nav-text">什么是 REST API？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设计流程"><span class="nav-number">1.1.2.</span> <span class="nav-text">设计流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#资源"><span class="nav-number">1.1.3.</span> <span class="nav-text">资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法"><span class="nav-number">1.1.4.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例"><span class="nav-number">1.1.5.</span> <span class="nav-text">示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Gmail-API"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">Gmail API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cloud-Pub-Sub-API"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">Cloud Pub/Sub API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cloud-Spanner-API"><span class="nav-number">1.1.5.3.</span> <span class="nav-text">Cloud Spanner API</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#资源名称"><span class="nav-number">1.2.</span> <span class="nav-text">资源名称</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#完整资源名称"><span class="nav-number">1.2.1.</span> <span class="nav-text">完整资源名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相对资源名称"><span class="nav-number">1.2.2.</span> <span class="nav-text">相对资源名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#资源-ID"><span class="nav-number">1.2.3.</span> <span class="nav-text">资源 ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合-ID"><span class="nav-number">1.2.4.</span> <span class="nav-text">集合 ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#资源名称和网址"><span class="nav-number">1.2.5.</span> <span class="nav-text">资源名称和网址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#资源名称为字符串"><span class="nav-number">1.2.6.</span> <span class="nav-text">资源名称为字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题"><span class="nav-number">1.2.7.</span> <span class="nav-text">问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问：为什么不使用资源-ID-来标识资源？"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">问：为什么不使用资源 ID 来标识资源？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#问：为什么特殊字段名为-name-而不是-id？"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">问：为什么特殊字段名为 name 而不是 id？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准方法"><span class="nav-number">1.3.</span> <span class="nav-text">标准方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#List"><span class="nav-number">1.3.1.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Get"><span class="nav-number">1.3.2.</span> <span class="nav-text">Get</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Create"><span class="nav-number">1.3.3.</span> <span class="nav-text">Create</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更新"><span class="nav-number">1.3.4.</span> <span class="nav-text">更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除"><span class="nav-number">1.3.5.</span> <span class="nav-text">删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义方法"><span class="nav-number">1.4.</span> <span class="nav-text">自定义方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-映射"><span class="nav-number">1.4.1.</span> <span class="nav-text">HTTP 映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用例"><span class="nav-number">1.4.2.</span> <span class="nav-text">用例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用自定义方法"><span class="nav-number">1.4.3.</span> <span class="nav-text">常用自定义方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标准字段"><span class="nav-number">1.5.</span> <span class="nav-text">标准字段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#系统参数"><span class="nav-number">1.6.</span> <span class="nav-text">系统参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命名惯例"><span class="nav-number">1.7.</span> <span class="nav-text">命名惯例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#产品名称"><span class="nav-number">1.7.1.</span> <span class="nav-text">产品名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务名称"><span class="nav-number">1.7.2.</span> <span class="nav-text">服务名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包名称"><span class="nav-number">1.7.3.</span> <span class="nav-text">包名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#集合-ID-1"><span class="nav-number">1.7.4.</span> <span class="nav-text">集合 ID</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口名称"><span class="nav-number">1.7.5.</span> <span class="nav-text">接口名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法名称"><span class="nav-number">1.7.6.</span> <span class="nav-text">方法名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息名称"><span class="nav-number">1.7.7.</span> <span class="nav-text">消息名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#请求和响应消息"><span class="nav-number">1.7.8.</span> <span class="nav-text">请求和响应消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举名称"><span class="nav-number">1.7.9.</span> <span class="nav-text">枚举名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#封装容器"><span class="nav-number">1.7.10.</span> <span class="nav-text">封装容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字段名称"><span class="nav-number">1.7.11.</span> <span class="nav-text">字段名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重复的字段名称"><span class="nav-number">1.7.12.</span> <span class="nav-text">重复的字段名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时间和时间段"><span class="nav-number">1.7.13.</span> <span class="nav-text">时间和时间段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日期和时间"><span class="nav-number">1.7.14.</span> <span class="nav-text">日期和时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数量"><span class="nav-number">1.7.15.</span> <span class="nav-text">数量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列表过滤器字段"><span class="nav-number">1.7.16.</span> <span class="nav-text">列表过滤器字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#列表响应"><span class="nav-number">1.7.17.</span> <span class="nav-text">列表响应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#驼峰式命名法"><span class="nav-number">1.7.18.</span> <span class="nav-text">驼峰式命名法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#名称缩写"><span class="nav-number">1.7.19.</span> <span class="nav-text">名称缩写</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#版本控制"><span class="nav-number">1.8.</span> <span class="nav-text">版本控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#向后兼容性"><span class="nav-number">1.8.1.</span> <span class="nav-text">向后兼容性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向后兼容的（非重大）更改"><span class="nav-number">1.8.2.</span> <span class="nav-text">向后兼容的（非重大）更改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向后不兼容的（重大）更改"><span class="nav-number">1.8.3.</span> <span class="nav-text">向后不兼容的（重大）更改</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#兼容性"><span class="nav-number">1.9.</span> <span class="nav-text">兼容性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#向后兼容的（非重大）更改-1"><span class="nav-number">1.9.1.</span> <span class="nav-text">向后兼容的（非重大）更改</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#向-API-服务定义添加-API-接口"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">向 API 服务定义添加 API 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#向-API-接口添加方法"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">向 API 接口添加方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#向方法添加-HTTP-绑定"><span class="nav-number">1.9.1.3.</span> <span class="nav-text">向方法添加 HTTP 绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#向请求消息添加字段"><span class="nav-number">1.9.1.4.</span> <span class="nav-text">向请求消息添加字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#向响应消息添加字段"><span class="nav-number">1.9.1.5.</span> <span class="nav-text">向响应消息添加字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#向枚举添加值"><span class="nav-number">1.9.1.6.</span> <span class="nav-text">向枚举添加值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#添加仅限输出的资源字段"><span class="nav-number">1.9.1.7.</span> <span class="nav-text">添加仅限输出的资源字段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向后不兼容的（重大）的更改"><span class="nav-number">1.9.2.</span> <span class="nav-text">向后不兼容的（重大）的更改</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#移除或重命名服务、字段、方法或枚举值"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">移除或重命名服务、字段、方法或枚举值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更改-HTTP-绑定"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">更改 HTTP 绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更改字段的类型"><span class="nav-number">1.9.2.3.</span> <span class="nav-text">更改字段的类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更改资源名称格式"><span class="nav-number">1.9.2.4.</span> <span class="nav-text">更改资源名称格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更改现有请求的可见行为"><span class="nav-number">1.9.2.5.</span> <span class="nav-text">更改现有请求的可见行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#更改-HTTP-定义中的网址格式"><span class="nav-number">1.9.2.6.</span> <span class="nav-text">更改 HTTP 定义中的网址格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#向资源消息添加读取-写入字段"><span class="nav-number">1.9.2.7.</span> <span class="nav-text">向资源消息添加读取/写入字段</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#错误"><span class="nav-number">1.10.</span> <span class="nav-text">错误</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#错误模型"><span class="nav-number">1.10.1.</span> <span class="nav-text">错误模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误代码"><span class="nav-number">1.10.2.</span> <span class="nav-text">错误代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误消息"><span class="nav-number">1.10.3.</span> <span class="nav-text">错误消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误详情"><span class="nav-number">1.10.4.</span> <span class="nav-text">错误详情</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-映射-1"><span class="nav-number">1.10.5.</span> <span class="nav-text">HTTP 映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RPC-映射"><span class="nav-number">1.10.6.</span> <span class="nav-text">RPC 映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端库映射"><span class="nav-number">1.10.7.</span> <span class="nav-text">客户端库映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误本地化"><span class="nav-number">1.10.8.</span> <span class="nav-text">错误本地化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理错误"><span class="nav-number">1.10.9.</span> <span class="nav-text">处理错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误重试"><span class="nav-number">1.10.10.</span> <span class="nav-text">错误重试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误传播"><span class="nav-number">1.10.11.</span> <span class="nav-text">错误传播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成错误"><span class="nav-number">1.10.12.</span> <span class="nav-text">生成错误</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#目录结构"><span class="nav-number">1.11.</span> <span class="nav-text">目录结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件结构"><span class="nav-number">1.12.</span> <span class="nav-text">文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Proto-文件名"><span class="nav-number">1.12.1.</span> <span class="nav-text">Proto 文件名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proto-选项"><span class="nav-number">1.12.2.</span> <span class="nav-text">Proto 选项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#术语表"><span class="nav-number">1.13.</span> <span class="nav-text">术语表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#联网-API"><span class="nav-number">1.13.0.1.</span> <span class="nav-text">联网 API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Google-API"><span class="nav-number">1.13.0.2.</span> <span class="nav-text">Google API</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#API-接口"><span class="nav-number">1.13.0.3.</span> <span class="nav-text">API 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#API-版本"><span class="nav-number">1.13.0.4.</span> <span class="nav-text">API 版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#API-方法"><span class="nav-number">1.13.0.5.</span> <span class="nav-text">API 方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#API-请求"><span class="nav-number">1.13.0.6.</span> <span class="nav-text">API 请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#API-服务"><span class="nav-number">1.13.0.7.</span> <span class="nav-text">API 服务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#API-端点"><span class="nav-number">1.13.0.8.</span> <span class="nav-text">API 端点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#API-产品"><span class="nav-number">1.13.0.9.</span> <span class="nav-text">API 产品</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#API-服务定义"><span class="nav-number">1.13.0.10.</span> <span class="nav-text">API 服务定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#API-使用者"><span class="nav-number">1.13.0.11.</span> <span class="nav-text">API 使用者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#API-生产者"><span class="nav-number">1.13.0.12.</span> <span class="nav-text">API 生产者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#API-后端"><span class="nav-number">1.13.0.13.</span> <span class="nav-text">API 后端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#API-前端"><span class="nav-number">1.13.0.14.</span> <span class="nav-text">API 前端</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
