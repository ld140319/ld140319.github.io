<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="数据库,MySql,主从复制,">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="MySQL主从复制原理以及架构详解 原文地址：https://www.2cto.com/database/201804/736764.html  复制概述&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Mysql内建的复制功能是构建大型，高性能应用程序的基础。将Mysql的数据分布到多个系统上去，这种分布的机制，是通过将Mysql的某一台主机的 数据复制到其它主机(slav">
<meta name="keywords" content="数据库,MySql,主从复制">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL主从复制原理以及架构详解">
<meta property="og:url" content="http://blog.com/2019/01/24/MySQL主从复制原理以及架构详解/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="MySQL主从复制原理以及架构详解 原文地址：https://www.2cto.com/database/201804/736764.html  复制概述&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Mysql内建的复制功能是构建大型，高性能应用程序的基础。将Mysql的数据分布到多个系统上去，这种分布的机制，是通过将Mysql的某一台主机的 数据复制到其它主机(slav">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231155.gif">
<meta property="og:image" content="http://blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231157.jpg">
<meta property="og:image" content="http://blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231158.jpg">
<meta property="og:image" content="http://blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231159.jpg">
<meta property="og:image" content="http://blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231161.jpg">
<meta property="og:image" content="http://blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231162.jpg">
<meta property="og:image" content="http://blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231164.jpg">
<meta property="og:image" content="http://blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231166.jpg">
<meta property="og:image" content="http://blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231167.jpg">
<meta property="og:image" content="http://blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231169.jpg">
<meta property="og:image" content="http://blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231170.jpg">
<meta property="og:updated_time" content="2019-01-24T14:41:00.585Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MySQL主从复制原理以及架构详解">
<meta name="twitter:description" content="MySQL主从复制原理以及架构详解 原文地址：https://www.2cto.com/database/201804/736764.html  复制概述&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Mysql内建的复制功能是构建大型，高性能应用程序的基础。将Mysql的数据分布到多个系统上去，这种分布的机制，是通过将Mysql的某一台主机的 数据复制到其它主机(slav">
<meta name="twitter:image" content="http://blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231155.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/2019/01/24/MySQL主从复制原理以及架构详解/">





  <title>MySQL主从复制原理以及架构详解 | 搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/01/24/MySQL主从复制原理以及架构详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">MySQL主从复制原理以及架构详解</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-24T12:12:57+08:00">
                2019-01-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/MySql/" itemprop="url" rel="index">
                    <span itemprop="name">MySql</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库/MySql/主从复制/" itemprop="url" rel="index">
                    <span itemprop="name">主从复制</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="MySQL主从复制原理以及架构详解"><a href="#MySQL主从复制原理以及架构详解" class="headerlink" title="MySQL主从复制原理以及架构详解"></a>MySQL主从复制原理以及架构详解</h1><blockquote>
<p>原文地址：<a href="https://www.2cto.com/database/201804/736764.html" target="_blank" rel="noopener">https://www.2cto.com/database/201804/736764.html</a></p>
</blockquote>
<h2 id="复制概述"><a href="#复制概述" class="headerlink" title="复制概述"></a>复制概述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mysql内建的复制功能是构建大型，高性能应用程序的基础。将Mysql的数据分布到多个系统上去，这种分布的机制，是通过将Mysql的某一台主机的 数据复制到其它主机(slaves)上，并重新执行一遍来实现的。复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。主服务器将更 新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环。这些日志可以记录发送到从服务器的更新。当一个从服务器连接主服务器时，它通知主服务器从服 务器在日志中读取的最后一次成功更新的位置。从服务器接收从那时起发生的任何更新，然后封锁并等待主服务器通知新的更新。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;请注意<strong>当你进行复制时，所有对复制中的表的更新必须在主服务器上进行</strong>。否则，你必须要小心，以避免用户对主服务器上的表进行的更新与对从服务器上的表所进行的更新之间的<strong>冲突</strong>。</p>
<h3 id="支持的复制类型"><a href="#支持的复制类型" class="headerlink" title="支持的复制类型"></a>支持的复制类型</h3><p>(1)基于语句的复制： 在主服务器上执行的SQL语句，在从服务器上执行同样的语句。MySQL默认采用基于语句的复制，效率比较高。  <strong>涉及到一些函数、存储过程、触发器时，可能数据存在差异</strong></p>
<p>一旦发现没法精确复制时， 会自动选着基于行的复制。</p>
<p>(2)基于行的复制：把改变的内容复制过去，而不是把命令在从服务器上执行一遍. 从mysql5.0开始支持   <strong>占据空间</strong></p>
<p>(3)混合类型的复制: 默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。</p>
<h3 id="复制解决的问题"><a href="#复制解决的问题" class="headerlink" title="复制解决的问题"></a>复制解决的问题</h3><p>MySQL复制技术有以下一些特点：</p>
<p>(1) 数据分布 (Data distribution )</p>
<p>(2) 负载平衡(load balancing)</p>
<p>(3) 备份(Backups)</p>
<p>(4) 高可用性和容错行 High availability and failover</p>
<h3 id="复制如何工作"><a href="#复制如何工作" class="headerlink" title="复制如何工作"></a>复制如何工作</h3><p>整体上来说，复制有3个步骤：</p>
<p>(1) master将改变记录到二进制日志(binary log)中(这些记录叫做<strong>二进制日志</strong>事件，binary log events);</p>
<p>(2) slave将master的binary log events拷贝到它的<strong>中继日志(relay log)</strong>;</p>
<p>(3) slave<strong>重做</strong>中继日志中的事件，将改变反映它自己的数据。</p>
<p>下图描述了复制的过程：</p>
<p><img src="//blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231155.gif" alt="MySQL主从复制原理以及架构 "></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;master记录二进制日志。在每个事务更新数据完成之前，master在二日志记录这些改变。MySQL将事务串行的写入二进制日 志，即使事务中的语句都是交叉执行的。在事件写入二进制日志完成后，master通知存储引擎提交事务。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slave将master的binary log拷贝到它自己的中继日志。首先，slave开始一个工作线程——<strong>I/O线程</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I/O线程在master上打开一个普通的连接，然后开始binlog dump process。Binlog dump process从master的二进制日志中读取事件，如果已经跟上master，它会睡眠并等待master产生新的事件。I/O线程将这些事件写入中 继日志。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SQL slave thread(SQL从线程)处理该过程的最后一步。<strong>SQL线程</strong>从中继日志读取事件，并重放其中的事件而更新slave的数据，使其与master中的数 据一致。只要该线程与I/O线程保持一致，中继日志通常会位于OS的缓存中，所以中继日志的开销很小。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;此外，<strong>在master中也有一个工作线程</strong>：和其它MySQL的连接一样，slave在master中打开一个连接也会使得master开始一个线程。复制 过程有一个很重要的限制——<strong>复制在slave上是串行化的，也就是说master上的并行更新操作不能在slave上并行操作</strong>。</p>
<h2 id="复制配置"><a href="#复制配置" class="headerlink" title="复制配置"></a>复制配置</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有两台MySQL数据库服 务器Master和slave，Master为主服务器，slave为从服务器，初始状态时，Master和slave中的数据信息相同，当Master 中的数据发生变化时，slave也跟着发生相应的变化，使得master和slave的数据信息同步，达到备份的目的。</p>
<p>要点：</p>
<p>负责在主、从服务器传输各种修改动作的媒介是主服务器的二进制变更日志，这个日志记载着需要传输给从服务器的各种修改动作。因此，主服务器必须激活二进制日志功能。从服务器必须具备足以让它连接主服务器并请求主服务器把二进制变更日志传输给它的权限。</p>
<p>环境：</p>
<p>Master和slave的MySQL数据库版本同为5.0.18</p>
<p>操作系统：unbuntu 11.10</p>
<p>IP地址：10.100.0.100</p>
<p>2.1、创建复制帐号</p>
<p>1、在Master的数据库中建立一个备份帐户：每个slave使用标准的MySQL用户名和密码连接master。进行复制操作的用户会授予REPLICATION SLAVE权限。用户名的密码都会存储在文本文件master.info中</p>
<p>命令如下：</p>
<p>mysql &gt; GRANT REPLICATION SLAVE,RELOAD,SUPER ON <em>.</em></p>
<p>TO backup@’10.100.0.200’</p>
<p>IDENTIFIED BY ‘1234’;</p>
<p>建立一个帐户backup，并且只能允许从10.100.0.200这个地址上来登陆，密码是1234。</p>
<p>(如果因为mysql版本新旧密码算法不同，可以设置：set password for ‘backup’@’10.100.0.200’=old_password(‘1234’))</p>
<p>2.2、拷贝数据</p>
<p>(假如是你完全新安装mysql主从服务器，这个一步就不需要。因为新安装的master和slave有相同的数据)</p>
<p>关停Master服务器，将Master中的数据拷贝到B服务器中，使得Master和slave中的数据同步，并且确保在全部设置操作结束前，禁止在Master和slave服务器中进行写操作，使得两数据库中的数据一定要相同!</p>
<p>2.3、配置master</p>
<p>接下来对master进行配置，包括打开二进制日志，指定唯一的servr ID。例如，在配置文件加入如下值：</p>
<p>server-id=1</p>
<p>log-bin=mysql-bin</p>
<p>server-id：为主服务器A的ID值</p>
<p>log-bin：二进制变更日值</p>
<p>重启master，运行SHOW MASTER STATUS，输出如下：</p>
<p><img src="//blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231157.jpg" alt="MySQL主从复制原理以及架构 "></p>
<p>2.4、配置slave</p>
<p>Slave的配置与master类似，你同样需要重启slave的MySQL。如下：</p>
<p>log_bin = mysql-bin</p>
<p>server_id = 2</p>
<p>relay_log = mysql-relay-bin</p>
<p>log_slave_updates = 1</p>
<p>read_only = 1</p>
<p>server_id 是必须的，而且唯一。slave没有必要开启二进制日志，但是在一些情况下，必须设置，例如，如果slave为其它slave的master，必须设置 bin_log。在这里，我们开启了二进制日志，而且显示的命名(默认名称为hostname，但是，如果hostname改变则会出现问题)。</p>
<p>relay_log配置中继日志，log_slave_updates表示slave将复制事件写进自己的二进制日志(后面会看到它的用处)。</p>
<p>有 些人开启了slave的二进制日志，却没有设置log_slave_updates，然后查看slave的数据是否改变，这是一种错误的配置。所以，尽量 使用read_only，它防止改变数据(除了特殊的线程)。但是，read_only并是很实用，特别是那些需要在slave上创建表的应用。</p>
<p>2.5、启动slave</p>
<p>接 下来就是让slave连接master，并开始重做master二进制日志中的事件。你不应该用配置文件进行该操作，而应该使用CHANGE MASTER TO语句，该语句可以完全取代对配置文件的修改，而且它可以为slave指定不同的master，而不需要停止服务器。如下：</p>
<p>mysql&gt; CHANGE MASTER TO MASTER_HOST=’server1’,</p>
<p>-&gt; MASTER_USER=’repl’,</p>
<p>-&gt; MASTER_PASSWORD=’p4ssword’,</p>
<p>-&gt; MASTER_LOG_FILE=’mysql-bin.000001’,</p>
<p>-&gt; MASTER_LOG_POS=0;</p>
<p>MASTER_LOG_POS的值为0，因为它是日志的开始位置。</p>
<p>你可以用SHOW SLAVE STATUS语句查看slave的设置是否正确：</p>
<p>mysql&gt; SHOW SLAVE STATUS\G</p>
<p><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></p>
<p>Slave_IO_State:</p>
<p>Master_Host: server1</p>
<p>Master_User: repl</p>
<p>Master_Port: 3306</p>
<p>Connect_Retry: 60</p>
<p>Master_Log_File: mysql-bin.000001</p>
<p>Read_Master_Log_Pos: 4</p>
<p>Relay_Log_File: mysql-relay-bin.000001</p>
<p>Relay_Log_Pos: 4</p>
<p>Relay_Master_Log_File: mysql-bin.000001</p>
<p>Slave_IO_Running: No</p>
<p>Slave_SQL_Running: No</p>
<p>…omitted…</p>
<p>Seconds_Behind_Master: NULL</p>
<p>Slave_IO_State, Slave_IO_Running, 和Slave_SQL_Running是No</p>
<p>表明slave还没有开始复制过程。日志的位置为4而不是0，这是因为0只是日志文件的开始位置，并不是日志位置。实际上，MySQL知道的第一个事件的位置是4。</p>
<p>为了开始复制，你可以运行：</p>
<p>mysql&gt; START SLAVE;</p>
<p>运行SHOW SLAVE STATUS查看输出结果：</p>
<p>mysql&gt; SHOW SLAVE STATUS\G</p>
<p><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></p>
<p>Slave_IO_State: Waiting for master to send event</p>
<p>Master_Host: server1</p>
<p>Master_User: repl</p>
<p>Master_Port: 3306</p>
<p>Connect_Retry: 60</p>
<p>Master_Log_File: mysql-bin.000001</p>
<p>Read_Master_Log_Pos: 164</p>
<p>Relay_Log_File: mysql-relay-bin.000001</p>
<p>Relay_Log_Pos: 164</p>
<p>Relay_Master_Log_File: mysql-bin.000001</p>
<p>Slave_IO_Running: Yes</p>
<p>Slave_SQL_Running: Yes</p>
<p>…omitted…</p>
<p>Seconds_Behind_Master: 0</p>
<p>在这里主要是看:</p>
<p>Slave_IO_Running=Yes</p>
<p>Slave_SQL_Running=Yes</p>
<p>slave的I/O和SQL线程都已经开始运行，而且Seconds_Behind_Master不再是NULL。日志的位置增加了，意味着一些事件被获取并执行了。如果你在master上进行修改，你可以在slave上看到各种日志文件的位置的变化，同样，你也可以看到数据库中数据的变化。</p>
<p>你可查看master和slave上线程的状态。在master上，你可以看到slave的I/O线程创建的连接：</p>
<p>在master上输入show processlist\G;mysql&gt; show processlist \G</p>
<p><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></p>
<p>Id: 1</p>
<p>User: root</p>
<p>Host: localhost:2096</p>
<p>db: test</p>
<p>Command: Query</p>
<p>Time: 0</p>
<p>State: NULL</p>
<p>Info: show processlist</p>
<p><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 2. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></p>
<p>Id: 2</p>
<p>User: repl</p>
<p>Host: localhost:2144</p>
<p>db: NULL</p>
<p>Command: Binlog Dump</p>
<p>Time: 1838</p>
<p>State: Has sent all binlog to slave; waiting for binlog to be updated</p>
<p>Info: NULL</p>
<p>2 rows in set (0.00 sec)</p>
<p>行2为处理slave的I/O线程的连接。</p>
<p>在slave服务器上运行该语句：</p>
<p>mysql&gt; show processlist \G</p>
<p><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></p>
<p>Id: 1</p>
<p>User: system user</p>
<p>Host:</p>
<p>db: NULL</p>
<p>Command: Connect</p>
<p>Time: 2291</p>
<p>State: Waiting for master to send event</p>
<p>Info: NULL</p>
<p><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 2. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></p>
<p>Id: 2</p>
<p>User: system user</p>
<p>Host:</p>
<p>db: NULL</p>
<p>Command: Connect</p>
<p>Time: 1852</p>
<p>State: Has read all relay log; waiting for the slave I/O thread to update it</p>
<p>Info: NULL</p>
<p><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 3. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></p>
<p>Id: 5</p>
<p>User: root</p>
<p>Host: localhost:2152</p>
<p>db: test</p>
<p>Command: Query</p>
<p>Time: 0</p>
<p>State: NULL</p>
<p>Info: show processlist</p>
<p>3 rows in set (0.00 sec)</p>
<p>行1为I/O线程状态，行2为SQL线程状态。</p>
<p>2.5、添加新slave服务器</p>
<p>假如master已经运行很久了，想对新安装的slave进行数据同步，甚至它没有master的数据。</p>
<p>此时，有几种方法可以使slave从另一个服务开始，例如，从master拷贝数据，从另一个slave克隆，从最近的备份开始一个slave。Slave与master同步时，需要三样东西：</p>
<p>(1)master的某个时刻的数据快照;</p>
<p>(2)master当前的日志文件、以及生成快照时的字节偏移。这两个值可以叫做日志文件坐标(log file coordinate)，因为它们确定了一个二进制日志的位置，你可以用SHOW MASTER STATUS命令找到日志文件的坐标;</p>
<p>(3)master的二进制日志文件。</p>
<p>可以通过以下几中方法来克隆一个slave：</p>
<p>(1) 冷拷贝(cold copy)</p>
<p>停止master，将master的文件拷贝到slave;然后重启master。缺点很明显。</p>
<p>(2) 热拷贝(warm copy)</p>
<p>如果你仅使用MyISAM表，你可以使用mysqlhotcopy拷贝，即使服务器正在运行。</p>
<p>(3) 使用mysqldump</p>
<p>使用mysqldump来得到一个数据快照可分为以下几步：</p>
<p><1>锁表：如果你还没有锁表，你应该对表加锁，防止其它连接修改数据库，否则，你得到的数据可以是不一致的。如下：</1></p>
<p>mysql&gt; FLUSH TABLES WITH READ LOCK;</p>
<p><2>在另一个连接用mysqldump创建一个你想进行复制的数据库的转储：</2></p>
<p>shell&gt; mysqldump –all-databases –lock-all-tables &gt;dbdump.db</p>
<p><3>对表释放锁。</3></p>
<p>mysql&gt; UNLOCK TABLES;</p>
<h2 id="深入了解复制"><a href="#深入了解复制" class="headerlink" title="深入了解复制"></a>深入了解复制</h2><h3 id="基于语句的复制-Statement-Based-Replication"><a href="#基于语句的复制-Statement-Based-Replication" class="headerlink" title="基于语句的复制(Statement-Based Replication)"></a>基于语句的复制(Statement-Based Replication)</h3><p>MySQL 5.0及之前的版本仅支持基于语句的复制(也叫做逻辑复制，logical replication)，这在数据库并不常见。master记录下改变数据的查询，然后，slave从中继日志中读取事件，并执行它，这些SQL语句与 master执行的语句一样。</p>
<p>这种方式的优点就是实现简单。此外，基于语句的复制的二进制日志可以很好的进行压缩，而且日志的数据量也较小，占用带宽少——例如，一个更新GB的数据的查询仅需要几十个字节的二进制日志。而mysqlbinlog对于基于语句的日志处理十分方便。</p>
<p>但是，<strong>基于语句的复制并不是像它看起来那么简单，因为一些查询语句依赖于master的特定条件，例如，master与slave可能有不同的时间</strong>。所 以，MySQL的二进制日志的格式不仅仅是查询语句，还包括一些元数据信息，例如，当前的时间戳。即使如此，还是有一些语句，比如，CURRENT USER函数，不能正确的进行复制。此外，存储过程和触发器也是一个问题。</p>
<p>另外一个问题就是<strong>基于语句的复制必须是串行化的</strong>。这要求大量特殊的代码，配置，例如<strong>InnoDB的next-key锁等</strong>。并不是所有的存储引擎都支持基于语句的复制。</p>
<h3 id="基于记录的复制-Row-Based-Replication"><a href="#基于记录的复制-Row-Based-Replication" class="headerlink" title="基于记录的复制(Row-Based Replication)"></a>基于记录的复制(Row-Based Replication)</h3><p>MySQL增加基于记录的复制，在二进制日志中记录下实际数据的改变，这与其它一些DBMS的实现方式类似。这种方式有优点，也有缺点。优点就是可以对任 何语句都能正确工作，一些语句的效率更高。主要的缺点就是<strong>二进制日志可能会很大，而且不直观，所以，你不能使用mysqlbinlog来查看二进制日志</strong>。</p>
<p>对于一些语句，基于记录的复制能够更有效的工作，如：</p>
<p>mysql&gt; INSERT INTO summary_table(col1, col2, sum_col3)</p>
<p>-&gt; SELECT col1, col2, sum(col3)</p>
<p>-&gt; FROM enormous_table</p>
<p>-&gt; GROUP BY col1, col2;</p>
<p>假设，只有三种唯一的col1和col2的组合，但是，该查询会扫描原表的许多行，却仅返回三条记录。此时，基于记录的复制效率更高。</p>
<p>另一方面，下面的语句，基于语句的复制更有效：</p>
<p>mysql&gt; UPDATE enormous_table SET col1 = 0;</p>
<p>此时使用基于记录的复制代价会非常高。由于两种方式不能对所有情况都能很好的处理，所以，MySQL 5.1支持在基于语句的复制和基于记录的复制之前动态交换。你可以通过设置session变量binlog_format来进行控制。</p>
<h3 id="复制相关的文件"><a href="#复制相关的文件" class="headerlink" title="复制相关的文件"></a>复制相关的文件</h3><p>除了二进制日志和中继日志文件外，还有其它一些与复制相关的文件。如下：</p>
<h4 id="1-mysql-bin-index"><a href="#1-mysql-bin-index" class="headerlink" title="(1)mysql-bin.index"></a>(1)mysql-bin.index</h4><p>服务器一旦开启二进制日志，会产生一个与二日志文件同名，但是以.index结尾的文件。它用于跟踪磁盘上存在哪些二进制日志文件。MySQL用它来定位二进制日志文件。它的内容如下(我的机器上)：</p>
<p><img src="//blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231158.jpg" alt="MySQL主从复制原理以及架构 "></p>
<h4 id="2-mysql-relay-bin-index"><a href="#2-mysql-relay-bin-index" class="headerlink" title="(2)mysql-relay-bin.index"></a>(2)mysql-relay-bin.index</h4><p>该文件的功能与mysql-bin.index类似，但是它是针对中继日志，而不是二进制日志。内容如下：</p>
<p>.\mysql-02-relay-bin.000017</p>
<p>.\mysql-02-relay-bin.000018</p>
<h4 id="3-master-info"><a href="#3-master-info" class="headerlink" title="(3)master.info"></a>(3)master.info</h4><p>保存master的相关信息。不要删除它，否则，slave重启后不能连接master。内容如下(我的机器上)：</p>
<p><img src="//blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231159.jpg" alt="MySQL主从复制原理以及架构 "></p>
<p>I/O线程更新master.info文件，内容如下(我的机器上)：</p>
<p>.\mysql-02-relay-bin.000019</p>
<p>254</p>
<p>mysql-01-bin.000010</p>
<p>286</p>
<p>0</p>
<p>52813</p>
<h4 id="4-relay-log-info"><a href="#4-relay-log-info" class="headerlink" title="(4)relay-log.info"></a>(4)relay-log.info</h4><p>包含slave中当前二进制日志和中继日志的信息。</p>
<h3 id="发送复制事件到其它slave"><a href="#发送复制事件到其它slave" class="headerlink" title="发送复制事件到其它slave"></a>发送复制事件到其它slave</h3><p>当设置log_slave_updates时，你可以让slave扮演其它slave的master。此时，slave把SQL线程执行的事件写进行自己的二进制日志(binary log)，然后，它的slave可以获取这些事件并执行它。如下：</p>
<p><img src="//blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231161.jpg" alt="MySQL主从复制原理以及架构 "></p>
<h3 id="复制过滤-Replication-Filters"><a href="#复制过滤-Replication-Filters" class="headerlink" title="复制过滤(Replication Filters)"></a>复制过滤(Replication Filters)</h3><p>复制过滤可以让你只复制服务器中的一部分数据，有两种复制过滤：在master上过滤二进制日志中的事件;在slave上过滤中继日志中的事件。如下：</p>
<p><img src="//blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231162.jpg" alt="MySQL主从复制原理以及架构 "></p>
<h2 id="复制的常用拓扑结构"><a href="#复制的常用拓扑结构" class="headerlink" title="复制的常用拓扑结构"></a>复制的常用拓扑结构</h2><p>复制的体系结构有以下一些基本原则：</p>
<p>(1) 每个slave只能有一个master;</p>
<p>(2) <strong>每个slave只能有一个唯一的服务器ID</strong>;</p>
<p>(3) 每个master可以有很多slave;</p>
<p>(4) 如果你设置log_slave_updates，slave可以是其它slave的master，从而扩散master的更新。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MySQL不支持多主服务器复制(Multimaster Replication)——即一个slave可以有多个master。但是，通过一些简单的组合，我们却可以建立灵活而强大的复制体系结构。</p>
<h3 id="单一master和多slave"><a href="#单一master和多slave" class="headerlink" title="单一master和多slave"></a>单一master和多slave</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由一个master和一个slave组成复制系统是最简单的情况。Slave之间并不相互通信，只能与master进行通信。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在实际应用场景中，MySQL复制90%以上都是一个Master复制到一个或者多个Slave的架构模式，<strong>主要用于读压力比较大的应用的数据库端 廉价扩展解决方案</strong>。因为只要Master和Slave的压力不是太大(尤其是Slave端压力)的话，异步复制的延时一般都很少很少。尤其是自从 Slave端的复制方式改成两个线程处理之后，更是减小了Slave端的延时问题。而带来的效益是，对于数据实时性要求不是特别Critical的应用， 只需要通过廉价的pcserver来扩展Slave的数量，将读压力分散到多台Slave的机器上面，即可通过分散单台数据库服务器的读压力来解决数据库 端的<strong>读性能瓶颈</strong>，毕竟在大多数数据库应用系统中的读压力还是要比写压力大很多。这在很大程度上解决了目前很多中小型网站的数据库压力瓶颈问题，甚至有些大型网站也在使用类似方案解决数据库瓶颈。</p>
<p>如下：</p>
<p><img src="//blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231164.jpg" alt="MySQL主从复制原理以及架构 "></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果写操作较少，而读操作很时，可以采取这种结构。你可以将读操作分布到其它的slave，从而减小master的压力。但是，<strong>当slave增加到一定数量时，slave对master的负载以及网络带宽都会成为一个严重的问题</strong>。</p>
<p>这种结构虽然简单，但是，它却非常灵活，足够满足大多数应用需求。一些建议：</p>
<p>(1) 不同的slave扮演不同的作用(例如使用不同的索引，或者不同的存储引擎);</p>
<p>(2) 用一个slave作为备用master，只进行复制;</p>
<p>(3) 用一个远程的slave，用于灾难恢复;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大家应该都比较清楚，从一个Master节点可以复制出多个Slave节点，可能有人会想，那一个Slave节点是否可以从多个Master节点上面进行复制呢至少在目前来看，MySQL是做不到的，以后是否会支持就不清楚了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MySQL不支持一个Slave节点从多个Master节点来进行复制的架构，主要是为了避免冲突的问题，防止多个数据源之间的数据出现冲突，而造 成最后数据的不一致性。不过听说已经有人开发了相关的patch，让MySQL支持一个Slave节点从多个Master结点作为数据源来进行复制，这也 正是MySQL开源的性质所带来的好处。</p>
<h3 id="主动模式的Master-Master-Master-Master-in-Active-Active-Mode"><a href="#主动模式的Master-Master-Master-Master-in-Active-Active-Mode" class="headerlink" title="主动模式的Master-Master(Master-Master in Active-Active Mode)"></a>主动模式的Master-Master(Master-Master in Active-Active Mode)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Master-Master复制的两台服务器，既是master，又是另一台服务器的slave</strong>。 这样，任何一方所做的变更，都会通过复制应用到另外一方的数据库中。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可能有些读者朋友会有一个担心，这样搭建复制环境之后，难道不会造成两台MySQL之间的循环复制么实际上MySQL自己早就想到了这一点，所以 在MySQL的BinaryLog中记录了当前MySQL的server-id，而且这个参数也是我们搭建MySQLReplication的时候必须明 确指定，而且Master和Slave的server-id参数值比需要不一致才能使MySQLReplication搭建成功。一旦有了server- id的值之后，MySQL就很容易判断某个变更是从哪一个MySQLServer最初产生的，所以就很容易避免出现循环复制的情况。而且，如果我们不打开 记录Slave的BinaryLog的选项(–log-slave-update)的时候，MySQL根本就不会记录复制过程中的变更到 BinaryLog中，就更不用担心可能会出现循环复制的情形了。</p>
<p>如图：</p>
<p><img src="//blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231166.jpg" alt="MySQL主从复制原理以及架构 "></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主动的Master-Master复制有一些特殊的用处。例如，<strong>地理上分布的两个部分都需要自己的可写的数据副本</strong>。这种结构<strong>最大的问题就是更新冲突</strong>。假设一个表只有一行(一列)的数据，其值为1，如果两个服务器分别同时执行如下语句：</p>
<p>在第一个服务器上执行：</p>
<p>mysql&gt; UPDATE tbl SET col=col + 1;</p>
<p>在第二个服务器上执行：</p>
<p>mysql&gt; UPDATE tbl SET col=col * 2;</p>
<p>那么结果是多少呢？一台服务器是4，另一个服务器是3，但是，这并不会产生错误。</p>
<p><strong>1.server_id不同</strong></p>
<p><strong>2.自增步长不同</strong></p>
<blockquote>
<p>机器1：    </p>
<p>auto-increment-offset=1</p>
<p>auto_increment_increment=1</p>
</blockquote>
<blockquote>
<p>机器2：    </p>
<p>auto-increment-offset=2</p>
<p>auto_increment_increment=1</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，MySQL并不支持其它一些DBMS支持的多主服务器复制(Multimaster Replication)，这是MySQL的复制功能很大的一个限制(多主服务器的难点在于解决更新冲突)，但是，如果你实在有这种需求，你可以采用MySQL Cluster，以及将Cluster和Replication结合起来，可以建立强大的高性能的数据库平台。但是，可以通过其它一些方式来模拟这种多主服务器的复制。</p>
<h3 id="主动-被动模式的Master-Master-Master-Master-in-Active-Passive-Mode"><a href="#主动-被动模式的Master-Master-Master-Master-in-Active-Passive-Mode" class="headerlink" title="主动-被动模式的Master-Master(Master-Master in Active-Passive Mode)"></a>主动-被动模式的Master-Master(Master-Master in Active-Passive Mode)</h3><p>这是master-master结构变化而来的，它避免了M-M的缺点，实际上，这是一种具有容错和高可用性的系统。它的不同点在于其中一个服务只能进行只读操作。如图：</p>
<p><img src="//blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231167.jpg" alt="MySQL主从复制原理以及架构 "></p>
<h3 id="级联复制架构-Master-–Slaves-Slaves"><a href="#级联复制架构-Master-–Slaves-Slaves" class="headerlink" title="级联复制架构 Master –Slaves - Slaves"></a>级联复制架构 Master –Slaves - Slaves</h3><p>在有些应用场景中，可能读写压力差别比较大，读压力特别的大，一个Master可能需要上10台甚至更多的Slave才能够支撑注读的压力。这时 候，Master就会比较吃力了，因为仅仅连上来的SlaveIO线程就比较多了，这样写的压力稍微大一点的时候，<strong>Master端因为复制就会消耗较多的 资源，很容易造成复制的延时</strong>。</p>
<p>遇到这种情况如何解决呢这时候我们就可以利用MySQL可以在Slave端记录复制所产生变更的BinaryLog信息的功能，也就是<strong>打开— log-slave-update选项</strong>。然后，通过二级(或者是更多级别)复制来减少Master端因为复制所带来的压力。也就是说，我们首先通过少数几 台MySQL从Master来进行复制，这几台机器我们姑且称之为第一级Slave集群，然后其他的Slave再从第一级Slave集群来进行复制。从第 一级Slave进行复制的Slave，我称之为第二级Slave集群。如果有需要，我们可以继续往下增加更多层次的复制。这样，我们很容易就控制了每一台 MySQL上面所附属Slave的数量。这种架构我称之为Master-Slaves-Slaves架构</p>
<p>这种多层级联复制的架构，很容易就解决了Master端因为附属Slave太多而成为瓶颈的风险。下图展示了多层级联复制的Replication架构。</p>
<p><img src="//blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231169.jpg" alt="MySQL主从复制原理以及架构 "></p>
<p>当然，如果条件允许，我更倾向于建议大家通过拆分成多个Replication集群来解决</p>
<p>上述瓶颈问题。毕竟<strong>Slave并没有减少写的量</strong>，所有Slave实际上仍然还是应用了所有的数据变更操作，没有减少任何写IO。相反，Slave越多，整个集群的写IO总量也就会越多，我们没有非常明显的感觉，仅仅只是因为分散到了多台机器上面，所以不是很容易表现出来。</p>
<p>此外，增加复制的级联层次，同一个变更传到最底层的Slave所需要经过的MySQL也会更多，同样可能造成<strong>延时较长的风险</strong>。</p>
<p>而如果我们通过分拆集群的方式来解决的话，可能就会要好很多了，当然，分拆集群也需要更复杂的技术和更复杂的应用系统架构。</p>
<h3 id="带从服务器的Master-Master结构-Master-Master-with-Slaves"><a href="#带从服务器的Master-Master结构-Master-Master-with-Slaves" class="headerlink" title="带从服务器的Master-Master结构(Master-Master with Slaves)"></a>带从服务器的Master-Master结构(Master-Master with Slaves)</h3><p>这种结构的优点就是提供了冗余。在地理上分布的复制结构，它不存在单一节点故障问题，而且还可以将读密集型的请求放到slave上。</p>
<p><img src="//blog.com/2019/01/24/MySQL主从复制原理以及架构详解/20180411091231170.jpg" alt="MySQL主从复制原理以及架构 "></p>
<p>级联复制在一定程度上面确实<strong>解决了Master因为所附属的Slave过多而成为瓶颈的问题，但是他并不能解决人工维护和出现异常需要切换后可能存 在重新搭建Replication的问题</strong>。这样就很自然的引申出了DualMaster与级联复制结合的Replication架构，我称之为 Master-Master-Slaves架构</p>
<p>和Master-Slaves-Slaves架构相比，区别仅仅只是将第一级Slave集群换成了一台单独的Master，<strong>作为备用Master，然后再从这个备用的Master进行复制到一个Slave集群</strong>。</p>
<p>这种DualMaster与级联复制结合的架构，最大的好处就是既可以 避免主Master的写入操作不会受到Slave集群的复制所带来的影响，同时主Master需要切换的时候也基本上不会出现重搭Replication 的情况。但是，这个架构也有一个弊端，那就是备用的Master有可能成为瓶颈，因为如果后面的Slave集群比较大的话，备用Master可能会因为过 多的SlaveIO线程请求而成为瓶颈。当然，该备用Master不提供任何的读服务的时候，瓶颈出现的可能性并不是特 别高，如果出现瓶颈，也可以在备用Master后面再次进行级联复制，架设多层Slave集群。当然，级联复制的级别越多，Slave集群可能出现的数据 延时也会更为明显，所以考虑使用多层级联复制之前，也需要评估数据延时对应用系统的影响。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据库/" rel="tag"># 数据库</a>
          
            <a href="/tags/MySql/" rel="tag"># MySql</a>
          
            <a href="/tags/主从复制/" rel="tag"># 主从复制</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/24/MySQL 数据库锁定机制/" rel="next" title="MySQL 数据库锁定机制">
                <i class="fa fa-chevron-left"></i> MySQL 数据库锁定机制
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/24/MySQL命令行导入和导出数据/" rel="prev" title="MySQL命令行导入和导出数据">
                MySQL命令行导入和导出数据 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#MySQL主从复制原理以及架构详解"><span class="nav-number">1.</span> <span class="nav-text">MySQL主从复制原理以及架构详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#复制概述"><span class="nav-number">1.1.</span> <span class="nav-text">复制概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#支持的复制类型"><span class="nav-number">1.1.1.</span> <span class="nav-text">支持的复制类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制解决的问题"><span class="nav-number">1.1.2.</span> <span class="nav-text">复制解决的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制如何工作"><span class="nav-number">1.1.3.</span> <span class="nav-text">复制如何工作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复制配置"><span class="nav-number">1.2.</span> <span class="nav-text">复制配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深入了解复制"><span class="nav-number">1.3.</span> <span class="nav-text">深入了解复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基于语句的复制-Statement-Based-Replication"><span class="nav-number">1.3.1.</span> <span class="nav-text">基于语句的复制(Statement-Based Replication)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于记录的复制-Row-Based-Replication"><span class="nav-number">1.3.2.</span> <span class="nav-text">基于记录的复制(Row-Based Replication)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制相关的文件"><span class="nav-number">1.3.3.</span> <span class="nav-text">复制相关的文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-mysql-bin-index"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">(1)mysql-bin.index</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-mysql-relay-bin-index"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">(2)mysql-relay-bin.index</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-master-info"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">(3)master.info</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-relay-log-info"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">(4)relay-log.info</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发送复制事件到其它slave"><span class="nav-number">1.3.4.</span> <span class="nav-text">发送复制事件到其它slave</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复制过滤-Replication-Filters"><span class="nav-number">1.3.5.</span> <span class="nav-text">复制过滤(Replication Filters)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复制的常用拓扑结构"><span class="nav-number">1.4.</span> <span class="nav-text">复制的常用拓扑结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单一master和多slave"><span class="nav-number">1.4.1.</span> <span class="nav-text">单一master和多slave</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主动模式的Master-Master-Master-Master-in-Active-Active-Mode"><span class="nav-number">1.4.2.</span> <span class="nav-text">主动模式的Master-Master(Master-Master in Active-Active Mode)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主动-被动模式的Master-Master-Master-Master-in-Active-Passive-Mode"><span class="nav-number">1.4.3.</span> <span class="nav-text">主动-被动模式的Master-Master(Master-Master in Active-Passive Mode)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#级联复制架构-Master-–Slaves-Slaves"><span class="nav-number">1.4.4.</span> <span class="nav-text">级联复制架构 Master –Slaves - Slaves</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#带从服务器的Master-Master结构-Master-Master-with-Slaves"><span class="nav-number">1.4.5.</span> <span class="nav-text">带从服务器的Master-Master结构(Master-Master with Slaves)</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
