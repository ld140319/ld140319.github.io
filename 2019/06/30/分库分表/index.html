<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="架构,数据库,数据库设计,分库分表,数据库优化,读写分离,">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="分库分表 需要重新做一个会员系统,一个会员表有30多个字段,有一半是不常用到的, 另外会员表里面有很多僵尸会员,啰嗦了那么多,开始正式话题: 会员表是按照办卡日期或ID进行水平分表好,还是按照常用字段和不常用字段进行垂直分割的好?    分表基本思想​    分区的思想，垂直分区和水平分区，水平分区是指将表的数据行存储在不同的partition中，垂直分区是指将table拆分成多个表，并通过PK">
<meta name="keywords" content="架构,数据库,数据库设计,分库分表,数据库优化,读写分离">
<meta property="og:type" content="article">
<meta property="og:title" content="分库分表">
<meta property="og:url" content="http://blog.com/2019/06/30/分库分表/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="分库分表 需要重新做一个会员系统,一个会员表有30多个字段,有一半是不常用到的, 另外会员表里面有很多僵尸会员,啰嗦了那么多,开始正式话题: 会员表是按照办卡日期或ID进行水平分表好,还是按照常用字段和不常用字段进行垂直分割的好?    分表基本思想​    分区的思想，垂直分区和水平分区，水平分区是指将表的数据行存储在不同的partition中，垂直分区是指将table拆分成多个表，并通过PK">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://blog.com/2019/06/30/分库分表/0_12958577041KqK.gif">
<meta property="og:image" content="http://blog.com/2019/06/30/分库分表/0_1295857710BUth.gif">
<meta property="og:image" content="http://blog.com/2019/06/30/分库分表/0_1295857852VJcX.gif">
<meta property="og:image" content="http://blog.com/2019/06/30/分库分表/67a6a651gw1ducq4lmzyzj.jpg">
<meta property="og:image" content="http://blog.com/2019/06/30/分库分表/67a6a651tw1dv5vr1tskuj.jpg">
<meta property="og:image" content="http://blog.com/2019/06/30/分库分表/67a6a651tw1dv5vpue9s3j.jpg">
<meta property="og:updated_time" content="2019-06-30T07:01:04.085Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="分库分表">
<meta name="twitter:description" content="分库分表 需要重新做一个会员系统,一个会员表有30多个字段,有一半是不常用到的, 另外会员表里面有很多僵尸会员,啰嗦了那么多,开始正式话题: 会员表是按照办卡日期或ID进行水平分表好,还是按照常用字段和不常用字段进行垂直分割的好?    分表基本思想​    分区的思想，垂直分区和水平分区，水平分区是指将表的数据行存储在不同的partition中，垂直分区是指将table拆分成多个表，并通过PK">
<meta name="twitter:image" content="http://blog.com/2019/06/30/分库分表/0_12958577041KqK.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/2019/06/30/分库分表/">





  <title>分库分表 | 搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/30/分库分表/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">分库分表</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-30T10:12:57+08:00">
                2019-06-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/数据库/" itemprop="url" rel="index">
                    <span itemprop="name">数据库</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/数据库/数据库优化/" itemprop="url" rel="index">
                    <span itemprop="name">数据库优化</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/数据库/数据库优化/数据库设计/" itemprop="url" rel="index">
                    <span itemprop="name">数据库设计</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/数据库/数据库优化/数据库设计/读写分离/" itemprop="url" rel="index">
                    <span itemprop="name">读写分离</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/数据库/数据库优化/数据库设计/读写分离/分库分表/" itemprop="url" rel="index">
                    <span itemprop="name">分库分表</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><blockquote>
<p>需要重新做一个会员系统,一个会员表有30多个字段,有一半是不常用到的, 另外会员表里面有很多僵尸会员,啰嗦了那么多,开始正式话题:</p>
<p>会员表是按照办卡日期或ID进行水平分表好,<br>还是按照常用字段和不常用字段进行垂直分割的好?  </p>
</blockquote>
<h2 id="分表基本思想"><a href="#分表基本思想" class="headerlink" title="分表基本思想"></a>分表基本思想</h2><p>​    分区的思想，垂直分区和水平分区，<strong>水平分区是指将表的数据行存储在不同的partition中，垂直分区是指将table拆分成多个表，并通过PK 链接在一起</strong></p>
<p>​    垂直分区的出发点是<strong>column 太宽</strong>，并且不常用，如果存在这样的column，垂直分区效果好；</p>
<p>​    水平分区的出发点是有些row 不常用，这样，<strong>将常用的rows 存储在一个partition中，使查询的范围缩小到一个partition中，减少query的时间消耗，提高性能</strong>    </p>
<p><strong>列太多 =》 垂直拆分</strong></p>
<p><strong>行太多 =》水平拆分</strong></p>
<h3 id="水平分表纬度"><a href="#水平分表纬度" class="headerlink" title="水平分表纬度"></a>水平分表纬度</h3><p>​    <strong>汇总表    =》 活跃度、时间、用户ID</strong></p>
<p>​    可以用<strong>表/缓存</strong>来保存<strong>分区键与常用查询条件的映射关系</strong></p>
<h3 id="垂直分表数据聚合"><a href="#垂直分表数据聚合" class="headerlink" title="垂直分表数据聚合"></a>垂直分表数据聚合</h3><p>​    <strong>视图</strong></p>
<h2 id="为什么要垂直分表？"><a href="#为什么要垂直分表？" class="headerlink" title="为什么要垂直分表？"></a>为什么要垂直分表？</h2><p>在这里我可能在个人的知识范畴内说几点，如果有不同的看法，或者发现错误，希望大家提出。</p>
<h3 id="行溢出"><a href="#行溢出" class="headerlink" title="行溢出"></a>行溢出</h3><p>​    这个主要是大字段的拆分，因为字段本身可能非常大，超出行的可变长度，这个是在使用varchar可变类型情况下，因为数据库的行格式会存储变长字段的长度，而这个存储的字段最多就2字节，这样的话可变长度最多就可以达到65535，达到这个长度的话，计算了一下，一行数据的可变长度的列总和不超过64k左右（没精准算），超过的话会溢出行到blob页，这里还衍生了个问题，因为<strong>页存储就16k，而一行数据就远远超出，这样就失去了b+树的意义了，所以一般mysql会拆分前缀存储额外数据到额外页，一页保持至少两行数据</strong></p>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>mysql的查询缓存具体是根据查询语句来的，这里具体可以去看《高性能MYSQL》一书，大概表达的意思是查询语句不能有变量或者函数，例如current_timestamp之类的，这样不会有缓存，有点跑偏了。这里的意思是，垂直拆分表后，有些字段是常修改的，例如用户的个性签名之类的，而更新操作会让查询缓存无效，所以垂直拆分会优化查询效率。</p>
<h3 id="数据页的影响"><a href="#数据页的影响" class="headerlink" title="数据页的影响"></a>数据页的影响</h3><p>​    页是什么呢？页应该算作数据库的存储最小单位，在mysql中例如，insert_buffer_pool，AIO，<strong>索引查找都是以页为单位，首先垂直拆分表的话，随着字段的减少，每页里面的数据行也会增多，理论上页里面的数据行越多性能越好</strong><br>例如图中所示假如未分表之前页分布是这样的，如果要查询id=1和id=9的话可能是需要两次索引查询，两次磁盘IO，这里为啥说页1和页3呢，因为异步IO的可能性，innodb不会去等待第一个扫描结果，而是先扫描，然后去取数据，例如如果是id=1和id=6，根据page判断数据是相邻页，因为页是顺序存储的，所以会合并也就一次磁盘IO取出两页数据。</p>
<p>像上面这样，<strong>页里的行数增多，就可以减少一部分磁盘的IO，这样也就增加了查询效率</strong></p>
<h3 id="对写入更新的影响"><a href="#对写入更新的影响" class="headerlink" title="对写入更新的影响"></a>对写入更新的影响</h3><p>​    写入和更新其实还是页的问题，同样的问题，页的减少，就会影响脏页的刷新，insert_buffer的mergy，这样都会影响iops，<strong>如果页的减少，数据也会存储更有顺序性，对于写入与读取的话，顺序读比离散读要快，性能也能得到提升</strong></p>
<h2 id="分库基本思想"><a href="#分库基本思想" class="headerlink" title="分库基本思想"></a>分库基本思想</h2><h3 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h3><p>​      Sharding的基本思想就要把一个数据库切分成多个部分放到不同的数据库(server)上，从而缓解单一数据库的性能问题。不太严格的讲，对于海量数据的数据库，如果是因为表多而数据多，这时候适合使用垂直切分，即把关系紧密（比如同一模块）的表切分出来放在一个server上。如果表并不多，但每张表的数据非常多，这时候适合水平切分，即<strong>把表的数据按某种规则（比如按ID散列）切分到多个数据库(server)上</strong>。当然，现实中更多是这两种情况混杂在一起，这时候需要根据实际情况做出选择，也可能会综合使用垂直与水平切分，从而将原有数据库切分成类似矩阵一样可以无限扩充的数据库(server)阵列。</p>
<h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>​      垂直切分的最大特点就是规则简单，实施也更为方便，尤其<strong>适合各业务之间的耦合度非常低，相互影响很小，业务逻辑非常清晰的系统</strong>。在这种系统中，可以很容易做到<strong>将不同业务模块所使用的表分拆到不同的数据库中。根据不同的表来进行拆分，对应用程序的影响也更小，拆分规则也会比较简单清晰</strong>。（这也就是所谓的”share nothing”）。</p>
<p><img src="//blog.com/2019/06/30/分库分表/0_12958577041KqK.gif" alt="img"></p>
<p>​      水平切分于垂直切分相比，相对来说稍微复杂一些。因为要将同一个表中的不同数据拆<br>分到不同的数据库中，对于应用程序来说，拆分规则本身就较根据表名来拆分更为复杂，后<br>期的数据维护也会更为复杂一些。</p>
<p><img src="//blog.com/2019/06/30/分库分表/0_1295857710BUth.gif" alt="img"></p>
<p>​      让我们从普遍的情况来考虑数据的切分：一方面，一个库的所有表通常不可能由某一张表全部串联起来，这句话暗含的意思是，水平切分几乎都是针对一小搓一小搓（实际上就是垂直切分出来的块）关系紧密的表进行的，而不可能是针对所有表进行的。另一方面，一些负载非常高的系统，即使仅仅只是单个表都无法通过单台数据库主机来承担其负载，这意味着单单是垂直切分也不能完全解决问明。因此多数系统会将垂直切分和水平切分联合使用，<strong>先对系统做垂直切分，再针对每一小搓表的情况选择性地做水平切分。从而将整个数据库切分成一个分布式矩阵</strong>。</p>
<p><img src="//blog.com/2019/06/30/分库分表/0_1295857852VJcX.gif" alt="img"></p>
<h3 id="切分策略"><a href="#切分策略" class="headerlink" title="切分策略"></a>切分策略</h3><p>​      <strong>切分是按先垂直切分再水平切分的步骤进行的。垂直切分的结果正好为水平切分做好了铺垫。垂直切分的思路就是分析表间的聚合关系，把关系紧密的表放在一起</strong>。多数情况下可能是同一个模块，或者是同一“聚集”。这里的“聚集”正是领域驱动设计里所说的聚集。在垂直切分出的表聚集内，找出“根元素”（这里的“根元素”就是领域驱动设计里的“聚合根”），按“根元素”进行水平切分，也就是从“根元素”开始，把所有和它直接与间接关联的数据放入一个shard里。这样出现跨shard关联的可能性就非常的小。应用程序就不必打断既有的表间关联。比如：对于社交网站，几乎所有数据最终都会关联到某个用户上，基于用户进行切分就是最好的选择。再比如论坛系统，用户和论坛两个模块应该在垂直切分时被分在了两个shard里，对于论坛模块来说，Forum显然是聚合根，因此按Forum进行水平切分，把Forum里所有的帖子和回帖都随Forum放在一个shard里是很自然的。</p>
<p>​      对于共享数据数据，如果是只读的字典表，每个shard里维护一份应该是一个不错的选择，这样不必打断关联关系。如果是一般数据间的跨节点的关联，就必须打断。</p>
<p>​      <strong>需要特别说明的是：当同时进行垂直和水平切分时，切分策略会发生一些微妙的变化。比如：在只考虑垂直切分的时候，被划分到一起的表之间可以保持任意的关联关系，因此你可以按“功能模块”划分表格，但是一旦引入水平切分之后，表间关联关系就会受到很大的制约，通常只能允许一个主表（以该表ID进行散列的表）和其多个次表之间保留关联关系，也就是说：当同时进行垂直和水平切分时，在垂直方向上的切分将不再以“功能模块”进行划分，而是需要更加细粒度的垂直切分，而这个粒度与领域驱动设计中的“聚合”概念不谋而合，甚至可以说是完全一致，每个shard的主表正是一个聚合中的聚合根！这样切分下来你会发现数据库分被切分地过于分散了（shard的数量会比较多，但是shard里的表却不多），为了避免管理过多的数据源，充分利用每一个数据库服务器的资源，可以考虑将业务上相近，并且具有相近数据增长速率（主表数据量在同一数量级上）的两个或多个shard放到同一个数据源里，每个shard依然是独立的，它们有各自的主表，并使用各自主表ID进行散列，不同的只是它们的散列取模（即节点数量）必需是一致的。</strong></p>
<h3 id="分库后存在的问题"><a href="#分库后存在的问题" class="headerlink" title="分库后存在的问题"></a>分库后存在的问题</h3><h4 id="1-分布式事务"><a href="#1-分布式事务" class="headerlink" title="1. 分布式事务"></a>1. 分布式事务</h4><blockquote>
<p>方案一：使用分布式事务</p>
</blockquote>
<p>​    优点：交由数据库管理，简单有效<br>​    缺点：性能代价高，特别是shard越来越多时</p>
<blockquote>
<p>方案二：由应用程序和数据库共同控制</p>
</blockquote>
<p>​     原理：将一个跨多个数据库的分布式事务分拆成多个仅处于单个数据库上面的小事务，并通过应用程序来总控<br>​           各个小事务。<br>​     优点：性能上有优势<br>​     缺点：需要应用程序在事务控制上做灵活设计。如果使用了spring的事务管理，改动起来会面临一定的困难。</p>
<blockquote>
<p>方案三：消息队列+补偿机制</p>
</blockquote>
<h4 id="2-跨节点Join的问题"><a href="#2-跨节点Join的问题" class="headerlink" title="2. 跨节点Join的问题"></a>2. 跨节点Join的问题</h4><p>​        只要是实行切分，跨节点Join的问明是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。</p>
<p>​    解决方案：<strong>分两次查询实现</strong>，在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。</p>
<h4 id="3-跨节点的count-order-by-group-by以及聚合函数问题"><a href="#3-跨节点的count-order-by-group-by以及聚合函数问题" class="headerlink" title="3. 跨节点的count,order by,group by以及聚合函数问题"></a>3. 跨节点的count,order by,group by以及聚合函数问题</h4><p>​      这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。</p>
<p>​    解决方案：与解决跨节点join问题的类似，<strong>分别在各个节点上得到结果后在应用程序端进行合并</strong>。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p>
<h2 id="水平分库分表策略"><a href="#水平分库分表策略" class="headerlink" title="水平分库分表策略"></a>水平分库分表策略</h2><p>介绍一种方案</p>
<p>预估行数：10亿<br>需要表数：10亿 / 500w = 200<br>分成10个库，每个库20张表<br>使用：<strong>客户端每个库对应一个主机，库 – scheme_(hash(id) % 10)（根据库名获取mysql主机配置），表名</strong></p>
<ul>
<li>.table_(hash(id) % 20)<br>扩展：以库为单位搭建主从，当主从无延迟时修改客户端配置；停止主从，观察一段时间后，删除原主库上的库即可</li>
<li>常用的hash算法<br>md5 + substr前多少位：缺点分库分表数只能是16的幂<br><strong>sprintf(%u, crc32(…)) % mod</strong></li>
</ul>
<h2 id="分库示例演示"><a href="#分库示例演示" class="headerlink" title="分库示例演示"></a>分库示例演示</h2><h4 id="第一部分：实施策略"><a href="#第一部分：实施策略" class="headerlink" title="第一部分：实施策略"></a>第一部分：实施策略</h4><p><img src="//blog.com/2019/06/30/分库分表/67a6a651gw1ducq4lmzyzj.jpg" alt="img"></p>
<h4 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h4><p>对数据库进行分库分表(Sharding化)前，需要开发人员充分了解系统业务逻辑和数据库schema.一个好的建议是绘制一张数据库ER图或领域模型图，以这类图为基础划分shard,直观易行，可以确保开发人员始终保持清醒思路。对于是选择数据库ER图还是领域模型图要根据项目自身情况进行选择。如果项目使用数据驱动的开发方式，团队以数据库ER图作为业务交流的基础，则自然会选择数据库ER图，如果项目使用的是领域驱动的开发方式，并通过OR-Mapping构建了一个良好的领域模型，那么领域模型图无疑是最好的选择。就我个人来说，更加倾向使用领域模型图，因为进行切分时更多的是以业务为依据进行分析判断，领域模型无疑更加清晰和直观。</p>
<h4 id="分析阶段"><a href="#分析阶段" class="headerlink" title="分析阶段"></a>分析阶段</h4><h5 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h5><p>垂直切分的依据原则是：将业务紧密，表间关联密切的表划分在一起，例如同一模块的表。结合已经准备好的数据库ER图或领域模型图，仿照活动图中的泳道概念，一个泳道代表一个shard，把所有表格划分到不同的泳道中。下面的分析示例会展示这种做法。当然，你也可以在打印出的ER图或模型图上直接用铅笔圈，一切取决于你自己的喜好。</p>
<h5 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h5><p>垂直切分后，需要对shard内表格的数据量和增速进一步分析，以确定是否需要进行水平切分。</p>
<p><strong>2.1</strong>若划分到一起的表格数据增长缓慢，在产品上线后可遇见的足够长的时期内均可以由单一数据库承载，则不需要进行水平切分，所有表格驻留同一shard,所有表间关联关系会得到最大限度的保留，同时保证了书写SQL的自由度，不易受join、group by、order by等子句限制。</p>
<p><strong>2.2</strong> 若划分到一起的表格数据量巨大，增速迅猛，需要进一步进行水平分割。进一步的水平分割就这样进行：</p>
<p><strong>2.2.1</strong>.结合业务逻辑和表间关系，将当前shard划分成多个更小的shard,通常情况下，这些更小的shard每一个都只包含一个主表（将以该表ID进行散列的表）和多个与其关联或间接关联的次表。这种一个shard一张主表多张次表的状况是水平切分的必然结果。这样切分下来，shard数量就会迅速增多。如果每一个shard代表一个独立的数据库，那么管理和维护数据库将会非常麻烦，而且这些小shard往往只有两三张表，为此而建立一个新库，利用率并不高，因此，<strong>在水平切分完成后可再进行一次“反向的Merge”,即：将业务上相近，并且具有相近数据增长速率（主表数据量在同一数量级上）的两个或多个shard放到同一个数据库上，在逻辑上它们依然是独立的shard，有各自的主表，并依据各自主表的ID进行散列，不同的只是它们的散列取模（即节点数量）必需是一致的。这样，每个数据库结点上的表格数量就相对平均了</strong></p>
<p><strong>2.2.2.</strong> <strong>所有表格均划分到合适的shard之后，所有跨越shard的表间关联都必须打断，在书写sql时，跨shard的join、group by、order by都将被禁止，需要在应用程序层面协调解决这些问题</strong></p>
<p>特别想提一点：经水平切分后，shard的粒度往往要比只做垂直切割的粒度要小，原单一垂直shard会被细分为一到多个以一个主表为中心关联或间接关联多个次表的shard，此时的shard粒度与领域驱动设计中的“聚合”概念不谋而合，甚至可以说是完全一致，每个shard的主表正是一个聚合中的聚合根！</p>
<h4 id="实施阶段"><a href="#实施阶段" class="headerlink" title="实施阶段"></a>实施阶段</h4><p>​    如果项目在开发伊始就决定进行分库分表，则严格按照分析设计方案推进即可。如果是在中期架构演进中实施，除搭建实现sharding逻辑的基础设施外(关于该话题会在下篇文章中进行阐述)，还需要对原有SQL逐一过滤分析，修改那些因为sharding而受到影响的sql.</p>
<h4 id="示例演示"><a href="#示例演示" class="headerlink" title="示例演示"></a>示例演示</h4><p>本文选择一个人尽皆知的应用：jpetstore来演示如何进行分库分表(sharding)在分析阶段的工作。由于一些个人原因，演示使用的jpetstore来自原ibatis官方的一个Demo版本，SVN地址为：<a href="http://mybatis.googlecode.com/svn/tags/java_release_2.3.4-726/jpetstore-5。关于jpetstore的业务逻辑这里不再介绍，这是一个非常简单的电商系统原型，其领域模型如下图：" target="_blank" rel="noopener">http://mybatis.googlecode.com/svn/tags/java_release_2.3.4-726/jpetstore-5。关于jpetstore的业务逻辑这里不再介绍，这是一个非常简单的电商系统原型，其领域模型如下图：</a></p>
<p><img src="//blog.com/2019/06/30/分库分表/67a6a651tw1dv5vr1tskuj.jpg" alt="img"></p>
<p><strong>图2. jpetstore领域模型</strong></p>
<p>由于系统较简单，我们很容易从模型上看出，其主要由三个模块组成：用户，产品和订单。那么垂直切分的方案也就出来了。接下来看水平切分，如果我们从一个实际的宠物店出发考虑，可能出现数据激增的单表应该是Account和Order,因此这两张表需要进行水平切分。对于Product模块来说，如果是一个实际的系统，Product和Item的数量都不会很大，因此只做垂直切分就足够了，也就是（Product，Category，Item，Iventory，Supplier）五张表在一个数据库结点上（没有水平切分，不会存在两个以上的数据库结点）。<strong>但是作为一个演示，我们假设产品模块也有大量的数据需要我们做水平切分</strong>，那么分析来看，这个模块要拆分出两个shard:一个是（Product（主），Category），另一个是（Item（主），Iventory，Supplier），<strong>同时，我们认为：这两个shard在数据增速上应该是相近的，且在业务上也很紧密</strong>，那么我们可以<strong>把这两个shard放在同一个数据库节点上，Item和Product数据在散列时取一样的模</strong>。根据前文介绍的图纸绘制方法，我们得到下面这张sharding示意图：</p>
<p><img src="//blog.com/2019/06/30/分库分表/67a6a651tw1dv5vpue9s3j.jpg" alt="img"></p>
<p><strong>图3. jpetstore sharding示意图</strong></p>
<p>对于这张图再说明几点：</p>
<p><strong>1.使用泳道表示物理shard（一个数据库结点）</strong></p>
<p><strong>2.若垂直切分出的shard进行了进一步的水平切分，但公用一个物理shard的话，则用虚线框住，表示其在逻辑上是一个独立的shard。</strong></p>
<p><strong>3.深色实体表示主表</strong></p>
<p><strong>4.X表示需要打断的表间关联</strong></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/架构/" rel="tag"># 架构</a>
          
            <a href="/tags/数据库/" rel="tag"># 数据库</a>
          
            <a href="/tags/数据库设计/" rel="tag"># 数据库设计</a>
          
            <a href="/tags/分库分表/" rel="tag"># 分库分表</a>
          
            <a href="/tags/数据库优化/" rel="tag"># 数据库优化</a>
          
            <a href="/tags/读写分离/" rel="tag"># 读写分离</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/30/数据库拆分过程及挑战/" rel="next" title="数据库拆分过程及挑战">
                <i class="fa fa-chevron-left"></i> 数据库拆分过程及挑战
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/30/数据库中间件详解/" rel="prev" title="数据库中间件详解">
                数据库中间件详解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#分库分表"><span class="nav-number">1.</span> <span class="nav-text">分库分表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分表基本思想"><span class="nav-number">1.1.</span> <span class="nav-text">分表基本思想</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#水平分表纬度"><span class="nav-number">1.1.1.</span> <span class="nav-text">水平分表纬度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垂直分表数据聚合"><span class="nav-number">1.1.2.</span> <span class="nav-text">垂直分表数据聚合</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么要垂直分表？"><span class="nav-number">1.2.</span> <span class="nav-text">为什么要垂直分表？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#行溢出"><span class="nav-number">1.2.1.</span> <span class="nav-text">行溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查询缓存"><span class="nav-number">1.2.2.</span> <span class="nav-text">查询缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据页的影响"><span class="nav-number">1.2.3.</span> <span class="nav-text">数据页的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对写入更新的影响"><span class="nav-number">1.2.4.</span> <span class="nav-text">对写入更新的影响</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分库基本思想"><span class="nav-number">1.3.</span> <span class="nav-text">分库基本思想</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#水平分库"><span class="nav-number">1.3.1.</span> <span class="nav-text">水平分库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垂直分库"><span class="nav-number">1.3.2.</span> <span class="nav-text">垂直分库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#切分策略"><span class="nav-number">1.3.3.</span> <span class="nav-text">切分策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分库后存在的问题"><span class="nav-number">1.3.4.</span> <span class="nav-text">分库后存在的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-分布式事务"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">1. 分布式事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-跨节点Join的问题"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">2. 跨节点Join的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-跨节点的count-order-by-group-by以及聚合函数问题"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">3. 跨节点的count,order by,group by以及聚合函数问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#水平分库分表策略"><span class="nav-number">1.4.</span> <span class="nav-text">水平分库分表策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分库示例演示"><span class="nav-number">1.5.</span> <span class="nav-text">分库示例演示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一部分：实施策略"><span class="nav-number">1.5.0.1.</span> <span class="nav-text">第一部分：实施策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#准备阶段"><span class="nav-number">1.5.0.2.</span> <span class="nav-text">准备阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分析阶段"><span class="nav-number">1.5.0.3.</span> <span class="nav-text">分析阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#垂直切分"><span class="nav-number">1.5.0.3.1.</span> <span class="nav-text">垂直切分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#水平切分"><span class="nav-number">1.5.0.3.2.</span> <span class="nav-text">水平切分</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实施阶段"><span class="nav-number">1.5.0.4.</span> <span class="nav-text">实施阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#示例演示"><span class="nav-number">1.5.0.5.</span> <span class="nav-text">示例演示</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
