<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="架构,分布式事务,">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="分布式事务概述  原文地址：http://www.tianshouzhi.com/api/tutorials/distributed_transaction   1、事务简介&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。在关系数据库中，一个事务由一组SQL语句组成。事务应该具有">
<meta name="keywords" content="架构,分布式事务">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式事务概述">
<meta property="og:url" content="http://blog.com/2019/06/15/分布式事务概述/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="分布式事务概述  原文地址：http://www.tianshouzhi.com/api/tutorials/distributed_transaction   1、事务简介&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。在关系数据库中，一个事务由一组SQL语句组成。事务应该具有">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://blog.com/2019/06/15/分布式事务概述/1517792718575090439.png">
<meta property="og:image" content="http://blog.com/2019/06/15/分布式事务概述/1517792759221000634.png">
<meta property="og:image" content="http://blog.com/2019/06/15/分布式事务概述/1517792803303066363.png">
<meta property="og:image" content="http://blog.com/2019/06/15/分布式事务概述/1517792870448000242.png">
<meta property="og:image" content="http://blog.com/2019/06/15/分布式事务概述/1517792913032061556.png">
<meta property="og:image" content="http://blog.com/2019/06/15/分布式事务概述/1517792940751035008.png">
<meta property="og:image" content="http://blog.com/2019/06/15/分布式事务概述/1517792972975019565.png">
<meta property="og:image" content="http://blog.com/2019/06/15/分布式事务概述/1517792996911019478.png">
<meta property="og:image" content="http://blog.com/2019/06/15/分布式事务概述/1517793019813081010.png">
<meta property="og:image" content="http://blog.com/2019/06/15/分布式事务概述/1517793071823063845.png">
<meta property="og:image" content="http://blog.com/2019/06/15/分布式事务概述/1517793087671016170.png">
<meta property="og:image" content="http://blog.com/2019/06/15/分布式事务概述/1517793103607040894.png">
<meta property="og:image" content="http://blog.com/2019/06/15/分布式事务概述/1517793127448076351.png">
<meta property="og:image" content="http://blog.com/2019/06/15/分布式事务概述/1517793175448046667.png">
<meta property="og:image" content="http://blog.com/2019/06/15/分布式事务概述/1517793186986086069.png">
<meta property="og:updated_time" content="2019-06-15T15:55:21.027Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="分布式事务概述">
<meta name="twitter:description" content="分布式事务概述  原文地址：http://www.tianshouzhi.com/api/tutorials/distributed_transaction   1、事务简介&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。在关系数据库中，一个事务由一组SQL语句组成。事务应该具有">
<meta name="twitter:image" content="http://blog.com/2019/06/15/分布式事务概述/1517792718575090439.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/2019/06/15/分布式事务概述/">





  <title>分布式事务概述 | 搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/15/分布式事务概述/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">分布式事务概述</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-15T12:12:57+08:00">
                2019-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/分布式事务/" itemprop="url" rel="index">
                    <span itemprop="name">分布式事务</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="分布式事务概述"><a href="#分布式事务概述" class="headerlink" title="分布式事务概述"></a>分布式事务概述</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="http://www.tianshouzhi.com/api/tutorials/distributed_transaction" target="_blank" rel="noopener">http://www.tianshouzhi.com/api/tutorials/distributed_transaction</a></p>
</blockquote>
<p><br></p>
<h2 id="1、事务简介"><a href="#1、事务简介" class="headerlink" title="1、事务简介"></a>1、事务简介</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;事务(<code>Transaction</code>)是访问并可能更新数据库中各种数据项的一个程序执行单元(<code>unit</code>)。在关系数据库中，一个事务由一组<code>SQL</code>语句组成。事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为<code>ACID</code>特性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>原子性（atomicity）</strong>：个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>一致性（consistency）</strong>：事务必须是使数据库从一个一致性状态变到另一个一致性状态，事务的中间状态不能被观察到的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>隔离性（isolation）</strong>：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。隔离性又分为四个级别：读未提交(<code>read uncommitted</code>)、读已提交(<code>read committed</code>，解决脏读)、可重复读(<code>repeatable read</code>，解决虚读)、串行化(<code>serializable</code>，解决幻读)。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>持久性（durability）</strong>：持久性也称永久性（<code>permanence</code>），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</p>
<p>​    任何事务机制在实现时，都应该考虑事务的<code>ACID</code>特性，包括：本地事务、分布式事务，及时不能都很好的满足，也要考虑支持到什么程度。</p>
<h2 id="2、本地事务"><a href="#2、本地事务" class="headerlink" title="2、本地事务"></a>2、本地事务</h2><p>​        大多数场景下，我们的应用都只需要操作单一的数据库，这种情况下的事务称之为本地事务(<code>Local Transaction</code>)。本地事务的<code>ACID</code>特性是数据库直接提供支持。本地事务应用架构如下所示：</p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517792718575090439.png" alt="0B73AA36-93FE-4F88-ADDF-940CF369FB95.png"></p>
<p>在<code>JDBC</code>编程中，我们通过<code>java.sql.Connection</code>对象来开启、关闭或者提交事务。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = ... <span class="comment">//获取数据库连接</span></span><br><span class="line">   conn.setAutoCommit(<span class="keyword">false</span>); <span class="comment">//开启事务</span></span><br><span class="line">   <span class="keyword">try</span>&#123;   </span><br><span class="line">       <span class="comment">//...执行增删改查sql </span></span><br><span class="line">       <span class="comment">//提交事务</span></span><br><span class="line">       conn.commit();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">       <span class="comment">//事务回滚</span></span><br><span class="line">       conn.rollback();</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">       <span class="comment">//关闭链接</span></span><br><span class="line">       conn.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>此外，很多<code>java</code>应用都整合了<code>spring</code>，并使用其声明式事务管理功能来完成事务功能。一般使用的步骤如下：</p>
<p>​    1、配置事务管理器。spring提供了一个<code>PlatformTransactionManager</code>接口，其有2个重要的实现类：</p>
<p>​        <code>DataSourceTransactionManager</code>：用于支持本地事务，事实上，其内部也是通过操作<code>java.sql.Connection</code>来开启、提交和回滚事务。</p>
<p>​        <code>JtaTransactionManager</code>：用于支持分布式事务，其实现了<code>JTA</code>规范，使用<code>XA</code>协议进行两阶段提交。需要注意的是，这只是一个代理，我们需要为其提供一个<code>JTA provider</code>，一般是<code>Java EE</code>容器提供的事务协调器(<code>Java EE server&#39;s transaction coordinato</code>)，也可以不依赖容器，配置一个本地的<code>JTA provider</code>。</p>
<p>​    2、 在需要开启的事务的bean的方法上添加<code>@Transitional</code>注解</p>
<p>​    可以看到，<code>spring</code>除了支持本地事务，也支持分布式事务，下面我们先对分布式事务的典型应用场景进行介绍。</p>
<h2 id="3、分布式事务典型场景"><a href="#3、分布式事务典型场景" class="headerlink" title="3、分布式事务典型场景"></a>3、分布式事务典型场景</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当下互联网发展如火如荼，绝大部分公司都进行了数据库拆分和服务化(<code>SOA</code>)。在这种情况下，完成某一个业务功能可能需要横跨多个服务，操作多个数据库。这就涉及到到了分布式事务，用需要操作的资源位于多个资源服务器上，而应用需要保证对于多个资源服务器的数据的操作，要么全部成功，要么全部失败。<strong>本质上来说，分布式事务就是为了保证不同资源服务器的数据一致性</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;典型的分布式事务场景：</p>
<h3 id="1、跨库事务"><a href="#1、跨库事务" class="headerlink" title="1、跨库事务"></a>1、跨库事务</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跨库事务指的是，一个应用某个功能需要操作多个库，不同的库中存储不同的业务数据。笔者见过一个相对比较复杂的业务，一个业务中同时操作了9个库。下图演示了一个服务同时操作2个库的情况： </p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517792759221000634.png" alt="9E8ADF29-420D-41F0-BC93-3B0BD5EB6A02.png"></p>
<h3 id="2、分库分表"><a href="#2、分库分表" class="headerlink" title="2、分库分表"></a>2、分库分表</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通常一个库数据量比较大或者预期未来的数据量比较大，都会进行水平拆分，也就是分库分表。如下图，将数据库B拆分成了2个库： </p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517792803303066363.png" alt="139B7837-4209-4B36-B0E8-446941C70708.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于分库分表的情况，一般开发人员都会使用一些数据库中间件来降低<code>sql</code>操作的复杂性。如，对于<code>sql：insert into user(id,name) values (1,&quot;tianshouzhi&quot;),(2,&quot;wangxiaoxiao&quot;)</code>。这条<code>sql</code>是操作单库的语法，单库情况下，可以保证事务的一致性。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是由于现在进行了分库分表，开发人员希望将1号记录插入分库1，2号记录插入分库2。所以数据库中间件要将其改写为2条<code>sql</code>，分别插入两个不同的分库，此时要保证两个库要不都成功，要不都失败，因此<strong>基本上所有的数据库中间件都面临着分布式事务的问题</strong>。</p>
<h3 id="3、服务化-SOA"><a href="#3、服务化-SOA" class="headerlink" title="3、服务化(SOA)"></a>3、服务化(SOA)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微服务架构是目前一个比较一个比较火的概念。例如上面笔者提到的一个案例，某个应用同时操作了9个库，这样的应用业务逻辑必然非常复杂，对于开发人员是极大的挑战，应该拆分成不同的独立服务，以简化业务逻辑。拆分后，独立服务之间通过<code>RPC</code>框架来进行远程调用，实现彼此的通信。下图演示了一个3个服务之间彼此调用的架构：</p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517792870448000242.png" alt="E5E5F08C-E57B-438C-A5B2-686DC5243254.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Service A</code>完成某个功能需要直接操作数据库，同时需要调用<code>Service B</code>和<code>Service C</code>，而<code>Service B</code>又同时操作了2个数据库，<code>Service C</code>也操作了一个库。需要<strong>保证这些跨服务的对多个数据库的操作要不都成功，要不都失败，实际上这可能是最典型的分布式事务场景</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小结：上述讨论的分布式事务场景中，无一例外的都直接或者间接的操作了多个数据库。如何保证事务的<code>ACID</code>特性，对于分布式事务实现方案而言，是非常大的挑战。同时，<strong>分布式事务实现方案还必须要考虑性能的问题，如果为了严格保证<code>ACID</code>特性，导致性能严重下降，那么对于一些要求快速响应的业务，是无法接受的</strong>。</p>
<h2 id="4、X-Open-DTP模型与XA规范"><a href="#4、X-Open-DTP模型与XA规范" class="headerlink" title="4、X/Open DTP模型与XA规范"></a>4、X/Open DTP模型与XA规范</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>X/Open</code>，即现在的<code>open group</code>，是一个独立的组织，主要负责制定各种行业技术标准。官网地址：<a href="http://www.opengroup.org/" target="_blank" rel="noopener">http://www.opengroup.org/</a>。<code>X/Open</code>组织主要由各大知名公司或者厂商进行支持，这些组织不光遵循<code>X/Open</code>组织定义的行业技术标准，也参与到标准的制定。下图展示了<code>open group</code>目前主要成员(官网截图)： </p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517792913032061556.png" alt="9A3AC451-E44F-47FB-A7D6-20FD18B65723.png"></p>
<p>可以看到，中国人的骄傲，华为，赫然在列！！！此处应该有掌声。</p>
<p>   就分布式事务处理(<code>Distributed Transaction Processing</code>,简称DTP)而言，<code>X/Open</code>主要提供了以下参考文档：</p>
<p>   <code>DTP</code>参考模型： <strong>&lt;<distributed transaction="" processing:="" reference="" model="">&gt;</distributed></strong></p>
<p>   <code>DTP XA</code>规范：<a href="http://pubs.opengroup.org/onlinepubs/009680699/toc.pdf" target="_blank" rel="noopener"> <strong>&lt;&lt; Distributed Transaction Processing: The XA Specification&gt;&gt;</strong></a></p>
<h3 id="4-1-DTP模型"><a href="#4-1-DTP模型" class="headerlink" title="4.1 DTP模型"></a>4.1 DTP模型</h3><h4 id="1、模型元素"><a href="#1、模型元素" class="headerlink" title="1、模型元素"></a>1、模型元素</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   在&lt;<distributed transaction="" processing:="" reference="" model="">&gt;第3版中，规定了构成DTP模型的5个基本元素：</distributed></p>
<p>   <strong>应用程序(Application Program ，简称AP)：</strong>用于定义事务边界(即定义事务的开始和结束)，并且在事务边界内对资源进行操作。</p>
<p>   <strong>资源管理器(Resource Manager，简称RM)：</strong>如数据库、文件系统等，并提供访问资源的方式。</p>
<p>   <strong>事务管理器(Transaction Manager ，简称TM)：</strong>负责分配事务唯一标识，监控事务的执行进度，并负责事务的提交、回滚等。</p>
<p>   <strong>通信资源管理器(Communication Resource Manager，简称CRM)：</strong>控制一个<code>TM</code>域(<code>TM domain</code>)内或者跨<code>TM</code>域的分布式应用之间的通信。</p>
<p>   <strong>通信协议(Communication Protocol，简称CP)：</strong>提供<code>CRM</code>提供的分布式应用节点之间的底层通信服务。</p>
<p>​    其中由于通信资源管理器(<code>Communication Resource Manager</code>)和通信协议(<code>Communication Protocol</code>)是一对好基友，从<code>Communication Protocol</code>的简称<code>CP</code>上就可以看出来，两个元素的关系不一般，因此有的文章在介绍<code>DTP</code>模型元素时，只提到了通信资源管理器….</p>
<h4 id="2、模型实例-Instance-of-the-Model"><a href="#2、模型实例-Instance-of-the-Model" class="headerlink" title="2、模型实例(Instance of the Model)"></a>2、模型实例(Instance of the Model)</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个<code>DTP</code>模型实例，至少有3个组成部分：<code>AP、RMs、TM</code>。如下所示： </p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517792940751035008.png" alt="F6921BEC-E492-4EB9-AC05-A7E79C6DE027.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这张图类似于我们之前提到的跨库事务的概念，即单个应用需要操作多个库。在这里就是一个<code>AP</code>需要操作多个<code>RM</code>上的资源。<code>AP</code>通过<code>TM</code>来声明一个全局事务，然后操作不同的<code>RM</code>上的资源，最后通知<code>TM</code>来提交或者回滚全局事务。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;特别的，<strong>如果分布式事务需要跨多个应用，类似于我们前面的提到的分布式事务场景中的服务化，那么每个模型实例中，还需要额外的加入一个通信资源管理器<code>CRM</code></strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下图中演示了2个模型实例，如何通过<code>CRM</code>来进行通信： </p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517792972975019565.png" alt="7B96339F-DF94-4A7F-8590-F81DB5BC7CDC.png"></p>
<p><code>CRM</code>作为多个模型实例之间通信的桥梁，主要作用如下：</p>
<ul>
<li><p>基本的通信能力：从这个角度，可以将<code>CRM</code>类比为<code>RPC</code>框架，模型实例之间通过<code>RPC</code>调用实现彼此的通信。这一点体现在<code>AP、CRM</code>之间的连线。</p>
</li>
<li><p>事务传播能力：与传统<code>RPC</code>框架不同的是，<code>CRM</code>底层采用<code>OSI TP(Open Systems Interconnection — Distributed Transaction Processing)</code>通信服务，因此<code>CRM</code>具备事务传播能力。这一点体现<code>TM、CRM</code>之间的连线。</p>
</li>
</ul>
<h4 id="3、事务管理器作用域-（TM-domain）"><a href="#3、事务管理器作用域-（TM-domain）" class="headerlink" title="3、事务管理器作用域 （TM domain）"></a>3、事务管理器作用域 （TM domain）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个<code>TM domain</code>中由一个或者多个模型实例组成，这些模型实例使用的都是同一个<code>TM</code>，但是操作的<code>RMs</code>各不相同，由<code>TM</code>来统一协调这些模型实例共同参与形成的全局事务(<code>global transaction</code>)。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;下图展示了一个由四个模型实例组成的<code>TM Domain</code>，这四个模型实例使用的都是同一个事务管理器<code>TM1</code>。 </p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517792996911019478.png" alt="28EC2E8D-220B-4E0D-BF4A-058F1AD76909.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TM domain</code>只是列出了最终参与到一个全局事务中，有哪些模型实例，并不关心这些模型实例之间的关系。这就好比，有一个班级，我们只是想知道这个班级中每位同学的名字，但是并不是关心谁是班长、谁是学习委员等。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过显然的，当一个<code>TM domain</code>中存在多个模型实例时，模型实例彼此之间存在一定的层级调用关系。这就是全局事务的树形结构。 </p>
<h4 id="4、全局事务树形结构-Global-Transaction-Tree-Structure"><a href="#4、全局事务树形结构-Global-Transaction-Tree-Structure" class="headerlink" title="4、全局事务树形结构(Global Transaction Tree Structure)"></a>4、全局事务树形结构(Global Transaction Tree Structure)</h4><p>   当一个<code>TM domain</code>中，存在多个模型实例时，会形成一种树形条用关系，如下图所示： </p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517793019813081010.png" alt="95F05F13-D75B-4638-9BA1-6FF36B5A5ADC.png"></p>
<p>其中：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发起分布式事务的模型实例称之为<code>root</code>节点，或者称之为事务的发起者，其他的模型实例可以统称为事务的参与者。事务发起者负责开启整个全局事务，事务参与者各自负责执行自己的事务分支。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而从模型实例之间的相互调用关系来说，调用方称之为上游节点(<code>Superior Node</code>)，被调用方称之为下游节点(<code>Subordinate Node</code>)。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小结：通过对<code>DTP</code>模型的介绍，我们可以看出来，之前提到的分布式事务的几种典型场景实际上在<code>DTP</code>模型中都包含了，甚至比我们考虑的还复杂。<code>DTP</code>模型从最早提出到现在已经有接近30年，到如今依然适用，不得不佩服模型的设计者是很有远见的。 </p>
<h3 id="4-2-XA规范"><a href="#4-2-XA规范" class="headerlink" title="4.2 XA规范"></a>4.2 XA规范</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>DTP</code>本地模型实例中，由<code>AP、RMs</code>和<code>TM</code>组成，不需要其他元素。<code>AP、RM</code>和<code>TM</code>之间，彼此都需要进行交互，如下图所示： </p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517793071823063845.png" alt="93DC1C17-7C88-40A4-8595-F15E89F4CAA1.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这张图中(1)表示<code>AP-RM</code>的交互接口，(2)表示<code>AP-TM</code>的交互接口，(3)表示<code>RM-TM</code>的交互接口。关于这张图，XA规范有以下描述：</p>
<blockquote>
<p>The subject of this X/Open specification is interface (3) in the diagram above, the XA interface by which TMs and RMs interact.</p>
<p>For more details on this model and diagram, including detailed definitions of each component, see the referenced <strong>DTP</strong> guide.</p>
</blockquote>
<p>​    也就是说<strong><code>XA</code>规范的最主要的作用是，就是定义了<code>RM-TM</code>的交互接口</strong>，下图更加清晰了演示了<code>XA</code>规范在<code>DTP</code>模型中发挥作用的位置，从下图中可以看出来，<strong><code>XA</code>仅仅出现在<code>RM</code>和<code>TM</code>的连线上</strong>。</p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517793087671016170.png" alt="1578CD5A-2EE1-4F41-8DE8-B2F615F79571.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>XA</code>规范除了定义的<code>RM-TM</code>交互的接口(<code>XA Interface</code>)之外，还对两阶段提交协议进行了优化。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一些读者可能会<strong>误认为两阶段提交协议是在<code>XA</code>规范中提出来的。事实上： 两阶段协议(<code>two-phase commit</code>)是在<code>OSI TP</code>标准中提出的</strong>；</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>DTP</code>参考模型(&lt;<distributed transaction="" processing:="" reference="" model="">&gt;)中，指定了全局事务的提交要使用<code>two-phase commit</code>协议；</distributed></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而<code>XA</code>规范(&lt;&lt; <code>Distributed Transaction Processing: The XA Specification</code>&gt;&gt;)只是定义了两阶段提交协议中需要使用到的接口，也就是上述提到的<code>RM-TM</code>交互的接口，因为两阶段提交过程中的参与方，只有<code>TM</code>和<code>RMs</code>。参见&lt;<distributed transaction="" processing:="" reference="" model="">&gt; 第3版 2.1节，原文如下： </distributed></p>
<blockquote>
<p><strong>Commitment Protocol</strong></p>
<p>A <em>commitment protocol</em> is the synchronisation that occurs at transaction completion. The X/Open DTP Model follows the <em>two-phase commit with presumed rollback</em>1 protocol defined in the referenced OSI TP standards. A description of the basic protocol is given in Section 3.4.3 on page 13. In certain cases, a global transaction may be completed <em>heuristically</em>. Heuristic transaction completion is described in Section 3.4.5 on page 14.</p>
</blockquote>
<h4 id="4-2-1-XA-Interface"><a href="#4-2-1-XA-Interface" class="headerlink" title="4.2.1  XA Interface"></a>4.2.1  XA Interface</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>XA</code>规范中定义的<code>RM</code> 和 <code>TM</code>交互的接口如下图所示： </p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517793103607040894.png" alt="72A58A31-EEA8-474B-B542-8A2928E3CD5C.png"></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于这些接口的详细解释，可以直接参考<code>XA</code>规范。后面在讲解到<code>mysql</code>对<code>XA</code>事务的支持时，我们也会使用到部分命令</p>
<h4 id="4-2-2-两阶段提交协议-2PC"><a href="#4-2-2-两阶段提交协议-2PC" class="headerlink" title="4.2.2 两阶段提交协议(2PC)"></a>4.2.2 两阶段提交协议(2PC)</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;两阶段提交协议（<code>Two Phase Commit</code>）不是在XA规范中提出，但是<code>XA</code>规范对其进行了优化，因此统一放到这里进行讲解。而从字面意思来理解，<strong><code>Two Phase Commit</code>，就是将提交(<code>commit</code>)过程划分为2个阶段(<code>Phase</code>)</strong>：</p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517793127448076351.png" alt="D7087D1B-1E4D-4C0E-8BA4-B2A8B36D0132.png"></p>
<blockquote>
<p>   In Phase 1, the TM asks all RMs to <em>prepare to commit</em> (or <em>prepare</em>) transaction branches. This asks whether the RM can guarantee its ability to commit the transaction branch. An RM may have to query other entities internal to that RM.</p>
<p>​    If an RM can commit its work, it records stably the information it needs to do so, then replies affirmatively. A negative reply reports failure for any reason. After making a negative reply and rolling back its work, the RM can discard any knowledge it has of the transaction branch.</p>
<p>   In Phase 2, the TM issues all RMs an actual request to commit or roll back the transaction branch, as the case may be. (Before issuing requests to commit, the TM stably records the fact that it decided to commit, as well as a list of all involved RMs.) All RMs commit or roll back changes to shared resources and then return status to the TM. The TM can then discard its knowledge of the global transaction.</p>
</blockquote>
<h6 id="阶段1"><a href="#阶段1" class="headerlink" title="阶段1"></a>阶段1</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TM</code>通知各个<code>RM</code>准备提交它们的事务分支。如果<code>RM</code>判断自己进行的工作可以被提交，那就就对工作内容进行持久化，再给<code>TM</code>肯定答复；要是发生了其他情况，那给<code>TM</code>的都是否定答复。在发送了否定答复并回滚了已经的工作后，<code>RM</code>就可以丢弃这个事务分支信息。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以<code>mysql</code>数据库为例，在第一阶段，事务管理器向所有涉及到的数据库服务器发出<code>prepare</code>“准备提交”请求，数据库收到请求后执行数据修改和日志记录等处理，处理完成后只是把事务的状态改成”可以提交”,然后把结果返回给事务管理器。</p>
<h6 id="阶段2"><a href="#阶段2" class="headerlink" title="阶段2"></a>阶段2</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TM</code>根据阶段1各个<code>RM prepare</code>的结果，决定是提交还是回滚事务。如果所有的<code>RM</code>都<code>prepare</code>成功，那么<code>TM</code>通知所有的<code>RM</code>进行提交；如果有<code>RM prepare</code>失败的话，则<code>TM</code>通知所有<code>RM</code>回滚自己的事务分支。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以<code>mysql</code>数据库为例，如果第一阶段中所有数据库都<code>prepare</code>成功，那么事务管理器向数据库服务器发出”确认提交”请求，数据库服务器把事务的”可以提交”状态改为”提交完成”状态，然后返回应答。如果在第一阶段内有任何一个数据库的操作发生了错误，或者事务管理器收不到某个数据库的回应，则认为事务失败，回撤所有数据库的事务。数据库服务器收不到第二阶段的确认提交请求，也会把”可以提交”的事务回撤。</p>
<h6 id="XA规范对两阶段提交协议的优化"><a href="#XA规范对两阶段提交协议的优化" class="headerlink" title="XA规范对两阶段提交协议的优化"></a>XA规范对两阶段提交协议的优化</h6><p><code>XA</code>规范对两阶段提交协议有2点优化：</p>
<blockquote>
<p>Protocol Optimisations</p>
<p>• Read-only</p>
<p>​       An RM can respond to the TM’s prepare request by asserting that the RM was not asked to update shared resources in this transaction branch. This response concludes the RM’s involvement in the transaction; the Phase 2 dialogue between the TM and this RM does not occur. The TM need not stably record, in its list of participating RMs, an RM that asserts a read-only role in the global transaction.</p>
<p>However, if the RM returns the read-only optimisation before all work on the global transaction is prepared, global serialisability1 cannot be guaranteed. This is because the RM may release transaction context, such as read locks, before all application activity for that global transaction is finished.</p>
<ol start="2">
<li>One-phase Commit</li>
</ol>
<p>​    A TM can use one-phase commit if it knows that there is only one RM anywhere in the DTP system that is making changes to shared resources. In this optimisation, the TM makes its Phase 2 commit request without having made a Phase 1 prepare request. Since the RM decides the outcome of the transaction branch and forgets about the transaction branch before returning to the TM, there is no need for the TM to record stably these global transactions and, in some failure cases, the TM may not know the outcome.</p>
</blockquote>
<p> <strong>只读断言</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>Phase 1</code>中，<code>RM</code>可以断言“我这边不涉及数据增删改”来答复<code>TM</code>的<code>prepare</code>请求，从而让这个<code>RM</code>脱离当前的全局事务，从而免去了<code>Phase 2</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种优化发生在其他<code>RM</code>都完成<code>prepare</code>之前的话，使用了只读断言的<code>RM</code>早于<code>AP</code>其他动作（比如说这个<code>RM</code>返回那些只读数据给<code>AP</code>）前，就释放了相关数据的上下文（比如读锁之类的），这时候<strong>其他全局事务或者本地事务就有机会去改变这些数据，结果就是无法保障整个系统的可序列化特性——通俗点说那就会有脏读的风险</strong>。</p>
<p><strong>一阶段提交</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果需要增删改的数据都在同一个<code>RM</code>上，<code>TM</code>可以使用一阶段提交——跳过两阶段提交中的<code>Phase 1</code>，直接执行<code>Phase 2</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这种优化的本质是跳过<code>Phase 1</code>，<code>RM</code>自行决定了事务分支的结果，并且在答复TM前就清除掉事务分支信息。对于这种优化的情况，<code>TM</code>实际上也没有必要去可靠的记录全局事务的信息，在一些异常的场景下，此时<code>TM</code>可能不知道事务分支的执行结果。 </p>
<h6 id="两阶段提交协议-2PC-存在的问题"><a href="#两阶段提交协议-2PC-存在的问题" class="headerlink" title="两阶段提交协议(2PC)存在的问题"></a>两阶段提交协议(2PC)存在的问题</h6><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;二阶段提交看起来确实能够提供原子性的操作，但是不幸的是，二阶段提交还是有几个缺点的：</p>
<p><strong>同步阻塞问题</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>两阶段提交方案下全局事务的<code>ACID</code>特性，是依赖于<code>RM</code>的</strong>。例如<code>mysql5.7</code>官方文档关于对<code>XA</code>分布式事务的支持有以下介绍：</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/xa.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/xa.html</a></p>
<blockquote>
<p> A global transaction involves several actions that are transactional in themselves, but that all must either complete successfully as a group, or all be rolled back as a group. In essence, this extends ACID properties “up a level” so that multiple ACID transactions can be executed in concert as components of a global operation that also has ACID properties. (As with nondistributed transactions, <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_serializable" target="_blank" rel="noopener">SERIALIZABLE</a> may be preferred if your applications are sensitive to read phenomena. <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_repeatable-read" target="_blank" rel="noopener">REPEATABLE READ</a> may not be sufficient for distributed transactions.)</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大致含义是说，一个全局事务内部包含了多个独立的事务分支，这一组事务分支要不都成功，要不都失败。各个事务分支的<code>ACID</code>特性共同构成了全局事务的<code>ACID</code>特性。也就是将单个事务分支的支持的<code>ACI</code>D特性提升一个层次(<code>up a level</code>)到分布式事务的范畴。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;括号中的内容的意思是： <strong>即使在非分布事务中(即本地事务)，如果对操作读很敏感，我们也需要将事务隔离级别设置为<code>SERIALIZABLE</code></strong>。<strong>而对于分布式事务来说，更是如此，可重复读隔离级别不足以保证分布式事务一致性</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;也就是说，如果我们使用<code>mysql</code>来支持<code>XA</code>分布式事务的话，那么最好将事务隔离级别设置为<code>SERIALIZABLE</code>。 地球人都知道，<code>SERIALIZABLE</code>(串行化)是四个事务隔离级别中最高的一个级别，也是执行效率最低的一个级别。</p>
<p><strong>单点故障</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>由于协调者的重要性，一旦协调者<code>TM</code>发生故障，参与者<code>RM</code>会一直阻塞下去</strong>。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</p>
<p><strong>数据不一致</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在二阶段提交的阶段二中，当协调者向参与者发送<code>commit</code>请求之后，发生了局部网络异常或者在发送<code>commit</code>请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了<code>commit</code>请求。而在这部分参与者接到<code>commit</code>请求之后就会执行<code>commit</code>操作。但是其他部分未接到<code>commit</code>请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致性的现象。【<strong>因为某些原因出现部分提交，导致数据不一致，缺少第二阶段的结果反馈处理</strong>】</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于二阶段提交存在着诸如同步阻塞、单点问题等缺陷，所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。 </p>
<h2 id="5、三阶段提交协议-Three-phase-commit"><a href="#5、三阶段提交协议-Three-phase-commit" class="headerlink" title="5、三阶段提交协议(Three-phase commit)"></a>5、三阶段提交协议(Three-phase commit)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;三阶段提交（<code>3PC</code>)，是二阶段提交（<code>2PC</code>）的改进版本。参考维基百科：<a href="https://en.wikipedia.org/wiki/Three-phase_commit_protocol" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Three-phase_commit_protocol</a></p>
<p>与两阶段提交不同的是，三阶段提交有两个改动点。</p>
<p>​    1、<strong>引入超时机制</strong>。同时在协调者和参与者中都引入超时机制。</p>
<p>​    2、<strong>在第一阶段和第二阶段中插入一个准备阶段</strong>。保证了在最后提交阶段之前各参与节点的状态是一致的。也就是说，除了引入超时机制之外，<code>3PC</code>把<code>2PC</code>的准备阶段再次一分为二，这样三阶段提交就有<code>CanCommit、PreCommit、DoCommit</code>三个阶段。</p>
<p><img src="//blog.com/2019/06/15/分布式事务概述/1517793175448046667.png" alt="9AFDC04C-016D-4CA6-8C04-AE7702264AFC.png"></p>
<h3 id="CanCommit阶段"><a href="#CanCommit阶段" class="headerlink" title="CanCommit阶段"></a>CanCommit阶段</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>3PC</code>的<code>CanCommit</code>阶段其实和<code>2PC</code>的准备阶段很像。协调者向参与者发送<code>commit</code>请求，参与者如果可以提交就返回<code>Yes</code>响应，否则返回<code>No</code>响应。</p>
<p>​    1.事务询问 协调者向参与者发送<code>CanCommit</code>请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</p>
<p>​    2.响应反馈 参与者接到<code>CanCommit</code>请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回<code>Yes</code>响应，并进入预备状态。否则反馈<code>No</code></p>
<h3 id="PreCommit阶段"><a href="#PreCommit阶段" class="headerlink" title="PreCommit阶段"></a>PreCommit阶段</h3><p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  协调者根据参与者的反应情况来决定是否可以进行事务的<code>PreCommit</code>操作。根据响应情况，有以下两种可能。</p>
<p>​    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如协调者从所有的参与者获得的反馈都是<code>Yes</code>响应，那么就会执行事务的预执行。</p>
<p>​    1.发送预提交请求 协调者向参与者发送<code>PreCommit</code>请求，并进入<code>Prepared</code>阶段。    </p>
<p>​    2.事务预提交 参与者接收到<code>PreCommit</code>请求后，会执行事务操作，并将<code>undo</code>和<code>redo</code>信息记录到事务日志中。</p>
<p>​    3.响应反馈 如果参与者成功的执行了事务操作，则返回<code>ACK</code>响应，同时开始等待最终指令。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假如有任何一个参与者向协调者<strong>发送了<code>No</code>响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断</strong>。</p>
<p>​    1.发送中断请求 协调者向所有参与者发送<code>abort</code>请求。</p>
<p>​    2.中断事务 <strong>参与者收到来自协调者的<code>abort</code>请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断</strong>。</p>
<h3 id="doCommit阶段"><a href="#doCommit阶段" class="headerlink" title="doCommit阶段"></a>doCommit阶段</h3><p>​    该阶段进行真正的事务提交，也可以分为以下两种情况。</p>
<p>​    <strong>Case 1：执行提交</strong></p>
<p>​    1.发送提交请求 协调接收到参与者发送的<code>ACK</code>响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送<code>doCommit</code>请求。</p>
<p>​    2.事务提交 参与者接收到<code>doCommit</code>请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</p>
<p>​    3.响应反馈 事务提交完之后，向协调者发送<code>Ack</code>响应。</p>
<p>​    4.完成事务 协调者接收到所有参与者的<code>ack</code>响应之后，完成事务。</p>
<p>   <strong>Case 2：中断事务</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 协调者没有接收到参与者发送的<code>ACK</code>响应（<strong>可能是接受者发送的不是<code>ACK</code>响应，也可能响应超时</strong>），那么就会执行中断事务。</p>
<p>​    1.发送中断请求 协调者向所有参与者发送<code>abort</code>请求</p>
<p>​    2.事务回滚 参与者接收到<code>abort</code>请求之后，利用其在阶段二记录的<code>undo</code>信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p>
<p>​    3.反馈结果 参与者完成事务回滚之后，向协调者发送<code>ACK</code>消息</p>
<p>​    4.中断事务 协调者接收到参与者反馈的<code>ACK</code>消息之后，执行事务的中断。 </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在<code>doCommit</code>阶段，如果参与者无法及时接收到来自协调者的<code>doCommit</code>或者<code>rebort</code>请求时，会在<strong>等待超时之后，会继续进行事务的提交</strong>。（其实这个应该是基于概率来决定的，当进入第三阶段时，说明参与者在第二阶段已经收到了<code>PreCommit</code>请求，那么<strong>协调者产生<code>PreCommit</code>请求的前提条件是他在第二阶段开始之前，收到所有参与者的<code>CanCommit</code>响应都是<code>Yes</code></strong>。（一旦参与者收到了<code>PreCommit</code>，意味他知道大家其实都同意修改了）所以，一句话概括就是，当进入第三阶段时，由于网络超时等原因，虽然参与者没有收到<code>commit</code>或者<code>abort</code>响应，但是他有理由相信：<strong>成功提交的几率很大</strong>。 ）</p>
<h3 id="小结：2PC与3PC的区别"><a href="#小结：2PC与3PC的区别" class="headerlink" title="小结：2PC与3PC的区别"></a>小结：2PC与3PC的区别</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相对于<code>2PC</code>，<code>3PC</code>主要解决的单点故障问题，<strong>并减少阻塞，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行<code>commit</code></strong>。而不会一直持有事务资源并处于阻塞状态。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是这种机制也会<strong>导致数据一致性问题，因为由于网络原因，协调者发送的<code>abort</code>响应没有及时被参与者接收到，那么参与者在等待超时之后执行了<code>commit</code>操作。这样就和其他接到<code>abort</code>命令并执行回滚的参与者之间存在数据不一致的情况</strong>。</p>
<p>​    了解了<code>2PC</code>和<code>3PC</code>之后，我们可以发现，<strong>无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题</strong>。<code>Google Chubby</code>的作者<code>Mike Burrows</code>说过，<code>there is only one consensus protocol, and that’s Paxos” – all other approaches are just broken versions of Paxos</code>. 意即世上只有一种一致性算法，那就是<code>Paxos</code>，所有其他一致性算法都是<code>Paxos</code>算法的不完整版。后面的文章会介绍这个公认为难于理解但是行之有效的<code>Paxos</code>算法。   </p>
<h2 id="6、经典的分布式系统理论-CAP"><a href="#6、经典的分布式系统理论-CAP" class="headerlink" title="6、经典的分布式系统理论-CAP"></a>6、经典的分布式系统理论-CAP</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出<code>CAP</code>猜想。Brewer认为在设计一个大规模的分布式系统时会遇到三个特性：<strong>一致性（<code>consistency</code>）、可用性（<code>Availability</code>）、分区容错（<code>partition-tolerance</code>），而一个分布式系统最多只能满足其中的2项</strong>。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了<code>CAP</code>。之后，<code>CAP</code>理论正式成为分布式计算领域的公认定理。 </p>
<p>​    <img src="//blog.com/2019/06/15/分布式事务概述/1517793186986086069.png" alt="Image.png"></p>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一致性指<code>“all nodes see the same data at the same time”</code>，即<strong>更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致，不能存在中间状态</strong>。例如对于电商系统用户下单操作，库存减少、用户资金账户扣减、积分增加等操作必须在用户下单操作完成后必须是一致的。不能出现类似于库存已经减少，而用户资金账户尚未扣减，积分也未增加的情况。如果出现了这种情况，那么就认为是不一致的。</p>
<blockquote>
<p>如果的确能像上面描述的那样时刻保证客户端看到的数据都是一致的，那么称之为<strong>强一致性</strong>。</p>
<p>如果允许存在中间状态，只要求经过一段时间后，数据最终是一致的，则称之为<strong>最终一致性</strong>。</p>
<p>如果允许存在部分数据不一致，那么就称之为<strong>弱一致性</strong>。</p>
</blockquote>
<h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可用性是指<strong>系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果</strong>。“有限的时间内”是指，对于用户的一个操作请求，系统必须能够在指定的时间内返回对应的处理结果，如果超过了这个时间范围，那么系统就被认为是不可用的。试想，如果一个下单操作，为了保证分布式事务的一致性，需要10分钟才能处理完，那么用户显然是无法忍受的。<strong>“返回结果”是可用性的另一个非常重要的指标，它要求系统在完成对用户请求的处理后，返回一个正常的响应结果，不论这个结果是成功还是失败</strong>。</p>
<h3 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障</strong>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;既然一个分布式系统无法同时满足一致性、可用性、分区容错性三个特点，我们就需要抛弃一个，需要明确的一点是，<strong>对于一个分布式系统而言，分区容错性是一个最基本的要求</strong>。<strong>因为既然是一个分布式系统，那么分布式系统中的组件必然需要被部署到不同的节点，否则也就无所谓分布式系统了</strong>。<strong>而对于分布式系统而言，网络问题又是一个必定会出现的异常情况，因此分区容错性也就成为了一个分布式系统必然需要面对和解决的问题</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此系统架构师往往需要把精力花在如何根据业务特点在C（一致性）和A（可用性）之间寻求平衡。而前面我们提到的<code>X/Open XA</code><strong>两阶段提交协议的分布式事务方案，强调的就是一致性</strong>；由于可用性较低，实际应用的并不多。而<strong>基于<code>BASE</code>理论的柔性事务，强调的是可用性</strong>，目前大行其道，大部分互联网公司采可能会优先采用这种方案。</p>
<h2 id="7、BASE理论与柔性事务"><a href="#7、BASE理论与柔性事务" class="headerlink" title="7、BASE理论与柔性事务"></a>7、BASE理论与柔性事务</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在<code>ACM</code>上发表文章提出<code>BASE</code>理论。文章链接：<a href="https://queue.acm.org/detail.cfm?id=1394128" target="_blank" rel="noopener">https://queue.acm.org/detail.cfm?id=1394128</a></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>BASE</code>理论是对<code>CAP</code>理论的延伸，核心思想是即使无法做到强一致性（<code>Strong Consistency</code>，<code>CAP</code>的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（<code>Eventual Consitency</code>）</strong>。    </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>BASE</code>是<code>Basically Available</code>（基本可用）、<code>Soft state</code>（软状态）和<code>Eventually consistent</code>（最终一致性）三个短语的缩写</strong>。</p>
<p>​    1.  基本可用（<code>Basically Available</code>）</p>
<p>​        指分布式系统在出现不可预知故障的时候，允许损失部分可用性。</p>
<p>​    2.  软状态（ <code>Soft State</code>）</p>
<p>​        指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性。</p>
<p>​    3.  最终一致（ <code>Eventual Consistency</code>）</p>
<p>​        强调的是所有的数据更新操作，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，<strong>最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>BASE</code>理论面向的是大型高可用可扩展的分布式系统，和传统的事物<code>ACID</code>特性是相反的。它完全不同于<code>ACID</code>的强一致性模型，而是<strong>通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态</strong>。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，<code>ACID</code>特性和<code>BASE</code>理论往往又会结合在一起。</p>
<p><strong>典型的柔性事务方案</strong></p>
<p>​     最大努力通知（非可靠消息、定期校对）</p>
<p>​     可靠消息最终一致性（异步确保型）</p>
<p>​     <code>TCC</code>（两阶段型、补偿型）</p>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="http://www.hollischuang.com/archives/666" target="_blank" rel="noopener">http://www.hollischuang.com/archives/666</a></p>
<p><a href="http://www.cnblogs.com/hxsyl/p/4381980.html" target="_blank" rel="noopener">http://www.cnblogs.com/hxsyl/p/4381980.html</a></p>
<p><a href="http://blog.csdn.net/hu_zhiting/article/details/77060582" target="_blank" rel="noopener">http://blog.csdn.net/hu_zhiting/article/details/77060582</a></p>
<p><a href="https://www.zhihu.com/question/31813039" target="_blank" rel="noopener">https://www.zhihu.com/question/31813039</a></p>
<p><a href="https://my.oschina.net/foodon/blog/372703" target="_blank" rel="noopener">https://my.oschina.net/foodon/blog/372703</a></p>
<p><a href="http://blog.jobbole.com/95632/" target="_blank" rel="noopener">http://blog.jobbole.com/95632/</a></p>
<p><a href="http://www.jianshu.com/p/6c1fd2420274" target="_blank" rel="noopener">http://www.jianshu.com/p/6c1fd2420274</a></p>
<p><a href="http://www.linuxidc.com/Linux/2015-11/124942.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2015-11/124942.htm</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/架构/" rel="tag"># 架构</a>
          
            <a href="/tags/分布式事务/" rel="tag"># 分布式事务</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/15/RPC框架原理/" rel="next" title="RPC框架原理">
                <i class="fa fa-chevron-left"></i> RPC框架原理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/15/柔性事务-TCC两阶段补偿型/" rel="prev" title="柔性事务-TCC两阶段补偿型">
                柔性事务-TCC两阶段补偿型 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#分布式事务概述"><span class="nav-number">1.</span> <span class="nav-text">分布式事务概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、事务简介"><span class="nav-number">1.1.</span> <span class="nav-text">1、事务简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2、本地事务"><span class="nav-number">1.2.</span> <span class="nav-text">2、本地事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3、分布式事务典型场景"><span class="nav-number">1.3.</span> <span class="nav-text">3、分布式事务典型场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1、跨库事务"><span class="nav-number">1.3.1.</span> <span class="nav-text">1、跨库事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2、分库分表"><span class="nav-number">1.3.2.</span> <span class="nav-text">2、分库分表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3、服务化-SOA"><span class="nav-number">1.3.3.</span> <span class="nav-text">3、服务化(SOA)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4、X-Open-DTP模型与XA规范"><span class="nav-number">1.4.</span> <span class="nav-text">4、X/Open DTP模型与XA规范</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-DTP模型"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1 DTP模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、模型元素"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">1、模型元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、模型实例-Instance-of-the-Model"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">2、模型实例(Instance of the Model)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、事务管理器作用域-（TM-domain）"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">3、事务管理器作用域 （TM domain）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、全局事务树形结构-Global-Transaction-Tree-Structure"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">4、全局事务树形结构(Global Transaction Tree Structure)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-XA规范"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2 XA规范</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-XA-Interface"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">4.2.1  XA Interface</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-两阶段提交协议-2PC"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">4.2.2 两阶段提交协议(2PC)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#阶段1"><span class="nav-number">1.4.2.2.0.1.</span> <span class="nav-text">阶段1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#阶段2"><span class="nav-number">1.4.2.2.0.2.</span> <span class="nav-text">阶段2</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#XA规范对两阶段提交协议的优化"><span class="nav-number">1.4.2.2.0.3.</span> <span class="nav-text">XA规范对两阶段提交协议的优化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#两阶段提交协议-2PC-存在的问题"><span class="nav-number">1.4.2.2.0.4.</span> <span class="nav-text">两阶段提交协议(2PC)存在的问题</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5、三阶段提交协议-Three-phase-commit"><span class="nav-number">1.5.</span> <span class="nav-text">5、三阶段提交协议(Three-phase commit)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CanCommit阶段"><span class="nav-number">1.5.1.</span> <span class="nav-text">CanCommit阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PreCommit阶段"><span class="nav-number">1.5.2.</span> <span class="nav-text">PreCommit阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#doCommit阶段"><span class="nav-number">1.5.3.</span> <span class="nav-text">doCommit阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结：2PC与3PC的区别"><span class="nav-number">1.5.4.</span> <span class="nav-text">小结：2PC与3PC的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6、经典的分布式系统理论-CAP"><span class="nav-number">1.6.</span> <span class="nav-text">6、经典的分布式系统理论-CAP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一致性"><span class="nav-number">1.6.1.</span> <span class="nav-text">一致性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可用性"><span class="nav-number">1.6.2.</span> <span class="nav-text">可用性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分区容错性"><span class="nav-number">1.6.3.</span> <span class="nav-text">分区容错性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小结"><span class="nav-number">1.6.4.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7、BASE理论与柔性事务"><span class="nav-number">1.7.</span> <span class="nav-text">7、BASE理论与柔性事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文档"><span class="nav-number">1.8.</span> <span class="nav-text">参考文档</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
