<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="架构,RPC,">





  <link rel="alternate" href="/atom.xml" title="搬运工 + 践行者" type="application/atom+xml">






<meta name="description" content="RPC框架原理  原文地址：https://mp.weixin.qq.com/s/UYL8yD9lusl3ELPSiIDk_A   RPC介绍&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC（Remote Procedure Call）：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想。  RPC 是一种技术思想而非一种规范或协">
<meta name="keywords" content="架构,RPC">
<meta property="og:type" content="article">
<meta property="og:title" content="RPC框架原理">
<meta property="og:url" content="http://blog.com/2019/06/15/RPC框架原理/index.html">
<meta property="og:site_name" content="搬运工 + 践行者">
<meta property="og:description" content="RPC框架原理  原文地址：https://mp.weixin.qq.com/s/UYL8yD9lusl3ELPSiIDk_A   RPC介绍&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC（Remote Procedure Call）：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想。  RPC 是一种技术思想而非一种规范或协">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpx42mlEaAXF7oP6cJhjq9fgwgkJb0Z50DpTib78uUID1DSfFEvVBT8d6VeXQpfb81HRvlc8OZHicicg.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9b4qWRmW1IAwq3Fq8dMUOqNeHic2oNewr5UQGUDYY9SwiaTEgJvMQvRicg.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9AricvYkj7V0jjho3xcDp2lUASDeR2t2ya8T3M0QWVJj9qUONia9SUu2A.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9GJVibU1E2DSyl5m61ughGiaMhMxwvvCd2RCgp1rBZIutwezeAuZ9ZmYA.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9ZMePFosJpPEia1fY364uZuAsz7SdLC6PLicMamWa8VgEpIbyeUt0LaeA.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9mBNXzmALQ3ickB8vkWtG23qaLqBWK8ebj7VndPBqtSelhUhYSqgzfbg.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9IEnicMicIWoaz7icwDeiawSI81VNp3y5XibIrV87fmicBTFHtgFVSVsBPdicw.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9pryvntMVU9Zyyia7Ut1mF2Ra5PRthpPxJKXVVuibLYdZWvsxa1CX9a0w.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9aONxt2iblUJPIYz09vUbx8DWY4E6QCcP5XH3V7iaKibTOOz1RJrnDbJng.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9ezYvAnHuQ1WmWw0QtBqcCn8hpkaZSjUwxn7Zx29ajlASxpjhNjY8wQ.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG96F49AwWFoHYbxoElGtnoNP6yxcXqWszq2jMdsFSY6BpYouhJYZoXbQ.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9YiaWa3O0o2Kj6e9qIp8p0OLMEzpSleEibLXyIO5YbnpJetfVKFFfD7Dg.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9LYtQicicAlAzS86WTmhKaoUBd3J2H6zPdSicTIia3nPRXPnRMiaibUcG5Gbg.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9eiaaJE6ZKgbSSfSr6VUhyEnwaXLAYsaSJoXsFibE2dynRg9MXEaogvibw.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9AGbpE5ayZm1tmJ9EtssrWOtKz7ibw1DBGCI4hnGaaUn91NXWh9jbZiag.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9obO6U81yU9WdPgtkPm8z6SXoYmYTZ8icW6o465IamWpn31MK9N3FXYw.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9AJTxxbp7Jyumc71AFPwficFGhrI69H2HtzrmdnUt5yqXDzIVuSKUVPQ.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9L3bGZXtVQZgvrjQzAmGDQXLCLHXibrP5zRleNkTybYhL0WiaDaZbktibA.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9u1N2GGY4adI2DMIAJBvhR5J6SDzuDFLeML6vahSFcHQWyibH4VXBlEQ.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9pfcZrhEq53vylD0EricBjadtIYyEMU0HbHroCoHTz04ia0lHFn5cUeBw.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG98jnSicmOIAyKeyemXzUyRP3uaOluibkFK5jzYsgmd6cRAXVvH8ObibyWQ.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG97qkiaIdTiaX1yORBW0T2aiah9TYEZfdbu9PzqXoVeJhPp2pqE2NkalrcA.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9gFu4q9zw8FALr6iawhf9otEEVBNzyDUicKho02dQHCYJ3Ez2iaxxrEdJQ.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9Hia4FsGJJN2d6RNDTvStloVXMxFCXtGWs5MDPxLvh80W7DfTfyjc2rQ.jpeg">
<meta property="og:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9ZyMHxa11kdWfQNibCMicicFRNvrmy0SI1uAe9adtibRHd1kXRvPzbx4ia3w.jpeg">
<meta property="og:updated_time" content="2019-06-15T08:23:38.861Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RPC框架原理">
<meta name="twitter:description" content="RPC框架原理  原文地址：https://mp.weixin.qq.com/s/UYL8yD9lusl3ELPSiIDk_A   RPC介绍&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;RPC（Remote Procedure Call）：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想。  RPC 是一种技术思想而非一种规范或协">
<meta name="twitter:image" content="http://blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpx42mlEaAXF7oP6cJhjq9fgwgkJb0Z50DpTib78uUID1DSfFEvVBT8d6VeXQpfb81HRvlc8OZHicicg.jpeg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.com/2019/06/15/RPC框架原理/">





  <title>RPC框架原理 | 搬运工 + 践行者</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">搬运工 + 践行者</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">记录学习的技能和遇到的问题</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.com/2019/06/15/RPC框架原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘泽明">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="搬运工 + 践行者">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">RPC框架原理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-15T12:12:57+08:00">
                2019-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/架构/RPC/" itemprop="url" rel="index">
                    <span itemprop="name">RPC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="RPC框架原理"><a href="#RPC框架原理" class="headerlink" title="RPC框架原理"></a>RPC框架原理</h1><p><br></p>
<blockquote>
<p>原文地址：<a href="https://mp.weixin.qq.com/s/UYL8yD9lusl3ELPSiIDk_A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/UYL8yD9lusl3ELPSiIDk_A</a></p>
</blockquote>
<p><br></p>
<h2 id="RPC介绍"><a href="#RPC介绍" class="headerlink" title="RPC介绍"></a>RPC介绍</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RPC（Remote Procedure Call）</code>：远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的思想。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpx42mlEaAXF7oP6cJhjq9fgwgkJb0Z50DpTib78uUID1DSfFEvVBT8d6VeXQpfb81HRvlc8OZHicicg.jpeg" alt="img"></p>
<p><strong>RPC 是一种技术思想而非一种规范或协议</strong>，常见 <code>RPC</code> 技术和框架有：</p>
<ul>
<li><strong>应用级的服务框架：</strong>阿里的 <code>Dubbo/Dubbox、Google gRPC、Spring Boot/Spring Cloud</code>。</li>
<li><strong>远程通信协议：</strong><code>RMI、Socket、SOAP(HTTP XML)、REST(HTTP JSON)</code>。</li>
<li><strong>通信框架：`</strong>MINA 和 Netty`。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前流行的开源 <code>RPC</code>框架还是比较多的，有阿里巴巴的 <code>Dubbo</code>、<code>Facebook</code> 的<code>Thrift</code>、<code>Google</code> 的 <code>gRPC</code>、<code>Twitter</code> 的 <code>Finagle</code>等。</p>
<p>下面重点介绍三种：</p>
<ul>
<li><p><strong>gRPC</strong>：是 <code>Google</code> 公布的开源软件，基于最新的 <code>HTTP 2.0</code>协议，并支持常见的众多编程语言。<code>RPC</code> 框架是基于<code>HTTP</code>协议实现的，底层使用到了 <code>Netty</code>框架的支持。</p>
</li>
<li><p><strong>Thrift</strong>：是 <code>Facebook</code> 的开源 <code>RPC</code>框架，主要是一个跨语言的服务开发框架。</p>
<p>用户只要在其之上进行二次开发就行，应用对于底层的 <code>RPC</code>通讯等都是透明的。不过这个对于用户来说需要学习特定领域语言这个特性，还是有一定成本的。</p>
</li>
<li><p><strong>Dubbo：</strong>是阿里集团开源的一个极为出名的<code>RPC</code> 框架，在很多互联网公司和企业应用中广泛使用。协议和序列化框架都可以插拔是极其鲜明的特色。</p>
</li>
</ul>
<h2 id="完整的-RPC-框架"><a href="#完整的-RPC-框架" class="headerlink" title="完整的 RPC 框架"></a>完整的 RPC 框架</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在一个典型<code>RPC</code>的使用场景中，包含了服务发现、负载、容错、网络传输、序列化等组件，其中“<code>RPC</code>协议”就指明了程序如何进行网络传输和序列化。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9b4qWRmW1IAwq3Fq8dMUOqNeHic2oNewr5UQGUDYY9SwiaTEgJvMQvRicg.jpeg" alt="img"></p>
<p><em>图 1：完整 RPC 架构图</em></p>
<p>如下是 <code>Dubbo</code> 的设计架构图，分层清晰，功能复杂：</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9AricvYkj7V0jjho3xcDp2lUASDeR2t2ya8T3M0QWVJj9qUONia9SUu2A.jpeg" alt="img"></p>
<p><em>图 2：Dubbo 架构图</em></p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9GJVibU1E2DSyl5m61ughGiaMhMxwvvCd2RCgp1rBZIutwezeAuZ9ZmYA.jpeg" alt="img"></p>
<h3 id="RPC-核心功能"><a href="#RPC-核心功能" class="headerlink" title="RPC 核心功能"></a>RPC 核心功能</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RPC</code> 的核心功能是指实现一个 <code>RPC</code>最重要的功能模块，就是上图中的”<code>RPC</code> 协议”部分：</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9ZMePFosJpPEia1fY364uZuAsz7SdLC6PLicMamWa8VgEpIbyeUt0LaeA.jpeg" alt="img"></p>
<p><em>图 3：RPC 核心功能</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>一个 RPC 的核心功能主要有 5 个部分组成，分别是：客户端、客户端 Stub、网络传输模块、服务端 Stub、服务端等</strong>。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9mBNXzmALQ3ickB8vkWtG23qaLqBWK8ebj7VndPBqtSelhUhYSqgzfbg.jpeg" alt="img"></p>
<p><em>图 4：RPC 核心功能图</em></p>
<p>下面分别介绍核心 RPC 框架的重要组成：</p>
<ul>
<li><strong>客户端（Client）：</strong>服务调用方。</li>
<li><strong>客户端存根（Client Stub）：</strong>存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端。</li>
<li><strong>服务端存根（Server Stub）：</strong>接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理。</li>
<li><strong>服务端（Server）：</strong>服务的真正提供者。</li>
<li><strong>Network Service：</strong>底层传输，可以是 <code>TCP</code>或<code>HTTP</code>。</li>
</ul>
<h3 id="Python-自带-RPC-Demo"><a href="#Python-自带-RPC-Demo" class="headerlink" title="Python 自带 RPC Demo"></a>Python 自带 RPC Demo</h3><p><strong>Server.py：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> SimpleXMLRPCServer <span class="keyword">import</span> SimpleXMLRPCServer   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun_add</span><span class="params">(a,b)</span>:</span></span><br><span class="line">    totle = a + b </span><br><span class="line">    <span class="keyword">return</span> totle</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = SimpleXMLRPCServer((<span class="string">'0.0.0.0'</span>, <span class="number">8080</span>))   <span class="comment">#开启xmlrpcserver</span></span><br><span class="line">    s.register_function(fun_add)                <span class="comment">#注册函数fun_add</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"server is online..."</span></span><br><span class="line">    s.serve_forever()                           <span class="comment">#开启循环等待</span></span><br></pre></td></tr></table></figure>
<p><strong>Client.py：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xmlrpclib <span class="keyword">import</span> ServerProxy            <span class="comment">#导入xmlrpclib的包</span></span><br><span class="line">s = ServerProxy(<span class="string">"http://172.171.5.205:8080"</span>) <span class="comment">#定义xmlrpc客户端</span></span><br><span class="line"><span class="keyword">print</span> s.fun_add(<span class="number">2</span>,<span class="number">3</span>)                            <span class="comment">#调用服务器端的函数</span></span><br></pre></td></tr></table></figure>
<p>开启服务端：</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9IEnicMicIWoaz7icwDeiawSI81VNp3y5XibIrV87fmicBTFHtgFVSVsBPdicw.jpeg" alt="img"></p>
<p>开启客户端：</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9pryvntMVU9Zyyia7Ut1mF2Ra5PRthpPxJKXVVuibLYdZWvsxa1CX9a0w.jpeg" alt="img"></p>
<h4 id="Wireshark-抓包分析过程"><a href="#Wireshark-抓包分析过程" class="headerlink" title="Wireshark 抓包分析过程"></a>Wireshark 抓包分析过程</h4><p>客户端去往服务端：</p>
<ul>
<li><strong>客户端 IP：</strong>172.171.4.176</li>
<li><strong>服务端 IP：</strong>172.171.5.95</li>
</ul>
<p>通信使用 <code>HTTP</code>协议，<code>XML</code>文件传输格式。传输的字段包括：方法名 <code>methodName</code>，两个参数 2，3。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9aONxt2iblUJPIYz09vUbx8DWY4E6QCcP5XH3V7iaKibTOOz1RJrnDbJng.jpeg" alt="img"></p>
<p><em>图 5：Request 抓包</em></p>
<p>服务端返回结果，字段返回值 Value，结果是 5：</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9ezYvAnHuQ1WmWw0QtBqcCn8hpkaZSjUwxn7Zx29ajlASxpjhNjY8wQ.jpeg" alt="img"></p>
<p><em>图 6：Response 抓包</em></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这两次网络传输中使用了 HTTP 协议，建立 HTTP 协议之间有 TCP 三次握手，断开 HTTP 协议时有 TCP 四次挥手。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG96F49AwWFoHYbxoElGtnoNP6yxcXqWszq2jMdsFSY6BpYouhJYZoXbQ.jpeg" alt="img"></p>
<p><em>图 7：基于 HTTP 协议的 RPC 连接过程</em></p>
<h4 id="详细调用过程"><a href="#详细调用过程" class="headerlink" title="详细调用过程"></a>详细调用过程</h4><p>Python 自带 RPC 的 Demo 小程序的实现过程，流程和分工角色可以用下图来表示：</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9YiaWa3O0o2Kj6e9qIp8p0OLMEzpSleEibLXyIO5YbnpJetfVKFFfD7Dg.jpeg" alt="img"></p>
<p><em>图 8：RPC 调用详细流程图</em></p>
<p>一次 <code>RPC</code>调用流程如下：</p>
<ul>
<li>服务消费者（<code>Client</code> 客户端）通过本地调用的方式调用服务。</li>
<li>客户端存根（<code>Client Stub</code>）接收到调用请求后负责将方法、入参等信息序列化（组装）成能够进行网络传输的消息体。</li>
<li>客户端存根（<code>Client Stub</code>）找到远程的服务地址，并且将消息通过网络发送给服务端。</li>
<li>服务端存根（<code>Server Stub</code>）收到消息后进行解码（反序列化操作）。</li>
<li>服务端存根（<code>Server Stub</code>）根据解码结果调用本地的服务进行相关处理</li>
<li>服务端(<code>Server</code>)本地服务业务处理。</li>
<li>处理结果返回给服务端存根（<code>Server Stub</code>）。</li>
<li>服务端存根（<code>Server Stub</code>）序列化结果。</li>
<li>服务端存根（<code>Server Stub</code>）将结果通过网络发送至消费方。</li>
<li>客户端存根（<code>Client Stub</code>）接收到消息，并进行解码（反序列化）。</li>
<li>服务消费方得到最终结果。</li>
</ul>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9LYtQicicAlAzS86WTmhKaoUBd3J2H6zPdSicTIia3nPRXPnRMiaibUcG5Gbg.jpeg" alt="img"></p>
<h2 id="RPC-核心之功能实现"><a href="#RPC-核心之功能实现" class="headerlink" title="RPC 核心之功能实现"></a>RPC 核心之功能实现</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RPC</code> 的核心功能主要由 5 个模块组成，如果想要自己实现一个 <code>RPC</code>，最简单的方式要实现三个技术点，分别是：</p>
<ul>
<li><strong>服务寻址</strong></li>
<li><strong>数据流的序列化和反序列化</strong></li>
<li><strong>网络传输</strong></li>
</ul>
<h3 id="服务寻址"><a href="#服务寻址" class="headerlink" title="服务寻址"></a>服务寻址</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;服务寻址可以使用 <code>Call ID</code> 映射。在本地调用中，函数体是直接通过函数指针来指定的，但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以<strong>在<code>RPC</code>中，所有的函数都必须有自己的一个 ID</strong>。<strong>这个 ID 在所有进程中都是唯一确定的</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端在做远程过程调用时，必须附上这个 <code>ID</code>。然后我们还需要在客户端和服务端分别维护一个函数和<code>Call ID</code>的对应表。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当客户端需要进行远程调用时，它就查一下这个表，找出相应的 <code>Call ID</code>，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</p>
<p><strong>实现方式：服务注册中心</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要调用服务，首先你需要一个服务注册中心去查询对方服务都有哪些实例。<code>Dubbo</code> 的服务注册中心是可以配置的，官方推荐使用 <code>Zookeeper</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>实现案例：</strong><code>RMI</code>（<code>Remote Method Invocation</code>，远程方法调用）也就是<code>RPC</code>本身的实现方式。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9eiaaJE6ZKgbSSfSr6VUhyEnwaXLAYsaSJoXsFibE2dynRg9MXEaogvibw.jpeg" alt="img"></p>
<p><em>图 9：RMI 架构图</em></p>
<p><strong>Registry(服务发现)：</strong>借助 <code>JNDI</code> 发布并调用了 <code>RMI</code> 服务。实际上，<strong><code>JNDI</code>就是一个注册表，服务端将服务对象放入到注册表中，客户端从注册表中获取服务对象</strong>。</p>
<p><code>RMI</code> 服务在服务端实现之后需要注册到 <code>RMI Server</code> 上，然后客户端从指定的<code>RMI</code> 地址上 <code>Lookup</code>服务，调用该服务对应的方法即可完成远程方法调用。</p>
<p><code>Registry</code>是个很重要的功能，当服务端开发完服务之后，要对外暴露，如果没有服务注册，则客户端是无从调用的，即使服务端的服务就在那里。</p>
<h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这时候就<strong>需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式</strong>。</p>
<p>只有二进制数据才能在网络中传输，序列化和反序列化的定义是：</p>
<ul>
<li><strong>将对象转换成二进制流的过程叫做序列化</strong></li>
<li><strong>将二进制流转换成对象的过程叫做反序列化</strong></li>
</ul>
<p>这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。</p>
<h3 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h3><p><strong>网络传输：</strong>远程调用往往用在网络上，客户端和服务端是通过网络连接的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把 <code>Call ID</code> 和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;只要能完成这两者的，都可以作为传输层使用。因此，它所<strong>使用的协议其实是不限的，能完成传输就行</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;尽管大部分 <code>RPC</code>框架都使用 TCP 协议，但其实<code>UDP</code>也可以，而 <code>gRPC</code> 干脆就用了 <code>HTTP2</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>TCP 的连接是最常见的，简要分析基于 TCP 的连接：</strong>通常 TCP 连接可以是按需连接（需要调用的时候就先建立连接，调用结束后就立马断掉），也可以是长连接（<strong>客户端和服务器建立起连接之后保持长期持有，不管此时有无数据包的发送，可以配合心跳检测机制定期检测建立的连接是否存活有效</strong>），多个远程过程调用共享同一个连接。</p>
<p>所以，要实现一个 RPC 框架，只需要把以下三点实现了就基本完成了：</p>
<ul>
<li><strong>Call ID 映射：</strong>可以直接使用函数字符串，也可以使用整数 ID。<strong>映射表一般就是一个哈希表</strong>。</li>
<li><strong>序列化反序列化：</strong>可以自己写，也可以使用<code>Protobuf</code> 或者 <code>FlatBuffers</code> 之类的。</li>
<li><strong>网络传输库：</strong>可以自己写 <code>Socket</code>，或者用 <code>Asio，ZeroMQ，Netty</code> 之类。</li>
</ul>
<h2 id="RPC-核心之网络传输协议"><a href="#RPC-核心之网络传输协议" class="headerlink" title="RPC 核心之网络传输协议"></a>RPC 核心之网络传输协议</h2><p>在第三节中说明了要实现一个 <code>RPC</code>，需要选择网络传输的方式。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9AGbpE5ayZm1tmJ9EtssrWOtKz7ibw1DBGCI4hnGaaUn91NXWh9jbZiag.jpeg" alt="img"></p>
<p><em>图 10：网络传输</em></p>
<p>在 RPC 中可选的网络传输方式有多种，可以选择 <code>TCP</code> 协议、<code>UDP</code> 协议、<code>HTTP</code> 协议。</p>
<p>每一种协议对整体的性能和效率都有不同的影响，如何选择一个正确的网络传输协议呢？首先要搞明白各种传输协议在 <code>RPC</code> 中的工作方式。</p>
<h3 id="基于-TCP-协议的-RPC-调用"><a href="#基于-TCP-协议的-RPC-调用" class="headerlink" title="基于 TCP 协议的 RPC 调用"></a>基于 TCP 协议的 RPC 调用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>由服务的调用方与服务的提供方建立 Socket 连接，并由服务的调用方通过 Socket 将需要调用的接口名称、方法名称和参数序列化后传递给服务的提供方，服务的提供方反序列化后再利用反射调用相关的方法</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最后将结果返回给服务的调用方，整个基于 <code>TCP</code> 协议的<code>RPC</code>调用大致如此。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是在实例应用中则会进行一系列的封装，如 <code>RMI</code>便是在<code>TCP</code> 协议上传递可序列化的 <code>Java</code>对象。</p>
<h3 id="基于-HTTP-协议的-RPC-调用"><a href="#基于-HTTP-协议的-RPC-调用" class="headerlink" title="基于 HTTP 协议的 RPC 调用"></a>基于 HTTP 协议的 RPC 调用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该方法更像是访问网页一样，只是它的返回结果更加单一简单。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>其大致流程为：</strong>由服务的调用者向服务的提供者发送请求，这种请求的方式可能是 <code>GET、POST、PUT、DELETE</code>等中的一种，服务的提供者可能会根据不同的请求方式做出不同的处理，或者某个方法只允许某种请求方式。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而调用的具体方法则是根据 <code>URL</code> 进行方法调用，而方法所需要的参数可能是对服务调用方传输过去的 <code>XML</code> 数据或者 <code>JSON</code>数据解析后的结果，最后返回<code>JOSN</code> 或者 <code>XML</code> 的数据结果。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于目前有很多开源的 <code>Web</code>服务器，如 <code>Tomcat</code>，所以其实现起来更加容易，就像做 <code>Web</code>项目一样。</p>
<p><strong>两种方式对比</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于 <code>TCP</code> 的协议实现的 <code>RPC</code>调用，由于 <code>TCP</code>协议处于协议栈的下层，能够更加<strong>灵活地对协议字段进行定制，减少网络开销，提高性能，实现更大的吞吐量和并发数</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是需要更多关注底层复杂的细节，实现的代价更高。同时对不同平台，如安卓，iOS 等，需要重新开发出不同的工具包来进行请求发送和相应解析，工作量大，难以快速响应和满足用户需求。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于 <code>HTTP</code> 协议实现的<code>RPC</code>则可以使用<code>JSON</code> 和 <code>XML</code> 格式的请求或响应数据。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而 <code>JSON</code> 和 <code>XML</code> 作为通用的格式标准（使用 <code>HTTP</code> 协议也需要序列化和反序列化，不过这不是该协议下关心的内容，成熟的 <code>Web</code>程序已经做好了序列化内容），开源的解析工具已经相当成熟，在其上进行二次开发会非常便捷和简单。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;但是由于<code>HTTP</code>协议是上层协议，发送包含同等内容的信息，使用<code>HTTP</code>协议传输所占用的字节数会比使用 TCP 协议传输所占用的字节数更高。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此<strong>在同等网络下，通过 <code>HTTP</code>协议传输相同内容，效率会比基于 <code>TCP</code>协议的数据效率要低，信息传输所占用的时间也会更长，当然压缩数据，能够缩小这一差距</strong>。</p>
<h3 id="使用-RabbitMQ-的-RPC-架构"><a href="#使用-RabbitMQ-的-RPC-架构" class="headerlink" title="使用 RabbitMQ 的 RPC 架构"></a>使用 RabbitMQ 的 RPC 架构</h3><p>在 <code>OpenStack</code>中服务与服务之间使用 <code>RESTful API</code>调用，而在服务内部则使用<code>RPC</code>调用各个功能模块。</p>
<p>正是由于使用了 <code>RPC</code> 来解耦服务内部功能模块，使得 <code>OpenStack</code> 的服务拥有扩展性强，耦合性低等优点。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>OpenStack</code> 的 <code>RPC</code> 架构中，加入了消息队列 RabbitMQ，这样做的目的是为了保证 <code>RPC</code> 在消息传递过程中的安全性和稳定性</strong>。</p>
<p>下面分析<code>OpenStack</code>中使用 <code>RabbitMQ</code>如何实现 <code>RPC</code>的调用。</p>
<h4 id="RabbitMQ-简介"><a href="#RabbitMQ-简介" class="headerlink" title="RabbitMQ 简介"></a>RabbitMQ 简介</h4><p>以下摘录自知乎：</p>
<p><em>对于初学者，举一个饭店的例子来解释这三个分别是什么吧。不是百分百恰当，但是应该足以解释这三者的区别。</em></p>
<p><strong>RPC：</strong> <em>假设你是一个饭店里的服务员，顾客向你点菜，但是你不会做菜，所以你采集了顾客要点什么之后告诉后厨去做顾客点的菜，这叫<code>RPC(remote procedure call)</code>，因为厨房的厨师相对于服务员而言是另外一个人(在计算机的世界里就是 Remote 的机器上的一个进程)。厨师做好了的菜就是RPC的返回值</em>。</p>
<p><strong>任务队列和消息队列：</strong> <em>本质都是队列，所以就只举一个任务队列的例子。假设这个饭店在高峰期顾客很多，而厨师只有很少的几个，所以服务员们不得不把单子按下单顺序放在厨房的桌子上，供厨师们一个一个做，这一堆单子就是任务队列，厨师们每做完一个菜，就从桌子上的订单里再取出一个单子继续做菜</em>。</p>
<p>角色分担如下图：</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9obO6U81yU9WdPgtkPm8z6SXoYmYTZ8icW6o465IamWpn31MK9N3FXYw.jpeg" alt="img"></p>
<p><em>图 11：RabbitMQ 在 RPC 中角色</em></p>
<p>使用 <code>RabbitMQ</code>的好处：</p>
<ul>
<li><p><strong>同步变异步：</strong>可以使用线程池将同步变成异步，但是缺点是要自己实现线程池，并且强耦合。使用消息队列可以轻松将同步请求变成异步请求。</p>
</li>
<li><p><strong>低内聚高耦合：</strong>解耦，减少强依赖。</p>
</li>
<li><p><strong>流量削峰：</strong>通过消息队列设置请求最大值，超过阀值的抛弃或者转到错误界面。</p>
</li>
<li><p><strong>网络通信性能提高：</strong><code>TCP</code> 的创建和销毁开销大，创建 3 次握手，销毁 4 次分手，高峰时成千上万条的链接会造成资源的巨大浪费，而且操作系统每秒处理 TCP 的数量也是有数量限制的，必定造成性能瓶颈。</p>
</li>
</ul>
<p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RabbitMQ</code> 采用信道通信，不采用 <code>TCP</code> 直接通信。<strong>一条线程一条信道，多条线程多条信道，公用一个 <code>TCP</code>连接</strong>。<strong>一条 <code>TCP</code> 连接可以容纳无限条信道（硬盘容量足够的话），不会造成性能瓶颈</strong>。</p>
<h4 id="RabbitMQ-的三种类型的交换器"><a href="#RabbitMQ-的三种类型的交换器" class="headerlink" title="RabbitMQ 的三种类型的交换器"></a>RabbitMQ 的三种类型的交换器</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RabbitMQ</code> 使用 <code>Exchange</code>（交换机）和 <code>Queue</code>（队列）来实现消息队列。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 <code>RabbitMQ</code> 中一共有三种交换机类型，每一种交换机类型都有很鲜明的特征。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;基于这三种交换机类型，<code>OpenStack</code> 完成两种 <code>RPC</code>的调用方式。首先简单介绍三种交换机。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9AJTxxbp7Jyumc71AFPwficFGhrI69H2HtzrmdnUt5yqXDzIVuSKUVPQ.jpeg" alt="img"></p>
<p><em>图 12：RabbitMQ 架构图</em></p>
<h5 id="①广播式交换器类型（Fanout）"><a href="#①广播式交换器类型（Fanout）" class="headerlink" title="①广播式交换器类型（Fanout）"></a>①广播式交换器类型（Fanout）</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该类交换器不分析所接收到消息中的<code>Routing Key</code>，<strong>默认将消息转发到所有与该交换器绑定的队列中去</strong>。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9L3bGZXtVQZgvrjQzAmGDQXLCLHXibrP5zRleNkTybYhL0WiaDaZbktibA.jpeg" alt="img"></p>
<p><em>图 13：广播式交换机</em></p>
<p><strong>②直接式交换器类型（Direct）</strong></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该类交换器<strong>需要精确匹配 <code>Routing Key</code> 与 <code>Binding Key</code></strong>，如消息的 <code>Routing Key = Cloud</code>，那么该条消息只能被转发至 <code>Binding Key = Cloud</code> 的消息队列中去。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9u1N2GGY4adI2DMIAJBvhR5J6SDzuDFLeML6vahSFcHQWyibH4VXBlEQ.jpeg" alt="img"></p>
<p><em>图 14：直接式交换机</em></p>
<h5 id="③主题式交换器（Topic-Exchange）"><a href="#③主题式交换器（Topic-Exchange）" class="headerlink" title="③主题式交换器（Topic Exchange）"></a>③主题式交换器（Topic Exchange）</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;该类交换器通过消息的 <code>Routing Key</code> 与<code>Binding Key</code> 的<strong>模式匹配，将消息转发至所有符合绑定规则的队列中</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Binding Key</code> 支持通配符，其中<strong><code>“*”</code>匹配一个词组，<code>“#”</code>匹配多个词组（包括零个）</strong>。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9pfcZrhEq53vylD0EricBjadtIYyEMU0HbHroCoHTz04ia0lHFn5cUeBw.jpeg" alt="img"></p>
<p><em>图 15：主题式交换机</em></p>
<blockquote>
<p>当生产者发送消息 <code>Routing Key=F.C.E</code>的时候，这时候只满足 <code>Queue1</code>，所以会被路由到<code>Queue1</code>中。</p>
<p>如果<code>Routing Key=A.C.E</code> 这时候会被同时路由到 <code>Queue1</code> 和<code>Queue2</code> 中，如果<code>Routing Key=A.F.B</code> 时，这里只会发送一条消息到 <code>Queue2</code>中。</p>
</blockquote>
<h4 id="基于-RabbitMQ实现两种-RPC-调用"><a href="#基于-RabbitMQ实现两种-RPC-调用" class="headerlink" title="基于 RabbitMQ实现两种 RPC 调用"></a>基于 RabbitMQ实现两种 RPC 调用</h4><p><code>Nova</code> 基于 <code>RabbitMQ</code> 实现两种 <code>RPC</code>调用：</p>
<ul>
<li><strong>RPC.CALL（调用）</strong></li>
<li><strong>RPC.CAST（通知）</strong></li>
</ul>
<p>其中 <code>RPC.CALL</code> 基于请求与响应方式，<code>RPC.CAST</code> 只是提供单向请求，两种 <code>RPC</code>调用方式在 <code>Nova</code>中均有典型的应用场景。</p>
<h5 id="RPC-CALL"><a href="#RPC-CALL" class="headerlink" title="RPC.CALL"></a>RPC.CALL</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RPC.CALL</code> 是一种双向通信流程，即 <code>RabbitMQ</code>接收消息生产者生成的系统请求消息，消息消费者经过处理之后<strong>将系统相应结果反馈给调用程序</strong>。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG98jnSicmOIAyKeyemXzUyRP3uaOluibkFK5jzYsgmd6cRAXVvH8ObibyWQ.jpeg" alt="img"></p>
<p><em>图 16：RPC.CALL 原理图</em></p>
<p>一个用户通过 <code>Dashboard</code>创建一个虚拟机，界面经过消息封装后发送给 <code>NOVA-API</code>。</p>
<p><strong><code>NOVA-API</code>作为消息生产者，将该消息以 <code>RPC.CALL</code> 方式通过 <code>Topic</code> 交换器转发至消息队列</strong>。</p>
<p>此时，<code>Nova-Compute</code> 作为消息消费者，接收该信息并通过底层虚拟化软件执行相应虚拟机的启动进程。</p>
<p><strong>待用户虚拟机成功启动之后，<code>Nova-Compute</code>作为消息生产者通过<code>Direct</code>交换器和响应的消息队列将虚拟机启动成功响应消息反馈给 <code>Nova-API</code></strong>。</p>
<p>此时<code>Nova-API</code>作为消息消费者接收该消息并通知用户虚拟机启动成功。</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG97qkiaIdTiaX1yORBW0T2aiah9TYEZfdbu9PzqXoVeJhPp2pqE2NkalrcA.jpeg" alt="img"></p>
<p><code>RPC.CALL</code> 工作原理如下图：</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9gFu4q9zw8FALr6iawhf9otEEVBNzyDUicKho02dQHCYJ3Ez2iaxxrEdJQ.jpeg" alt="img"></p>
<p><em>图 17：RPC.CALL 具体实现图</em></p>
<p>工作流程：</p>
<ul>
<li>客户端创建 <code>Message</code> 时指定<code>reply_to</code> 队列名、<code>correlation_id</code> 标记调用者。</li>
<li>通过队列，服务端收到消息。调用函数处理，然后返回。</li>
<li>返回的队列是 <code>reply_to</code>指定的队列，并携带 <code>correlation_id</code>。</li>
<li>返回消息到达客户端，客户端根据<code>correlation_id</code> 判断是哪一个函数的调用返回。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有多个线程同时进行远程方法调用，这时建立在 <code>Client Server</code> 之间的 <code>Socket</code>连接上会有很多双方发送的消息传递，前后顺序也可能是随机的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Server</code>处理完结果后，将结果消息发送给<code>Client，Client</code>收到很多消息，怎么知道哪个消息结果是原先哪个线程调用的？</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>Client</code>线程每次通过<code>Socket</code>调用一次远程接口前，生成一个唯一的<code>ID</code>，即 <code>Request ID</code>（<code>Request ID</code>必需保证在一个 <code>Socket</code> 连接里面是唯一的），一般常常使用<code>AtomicLong</code>从 0 开始累计数字生成唯一<code>ID</code></strong>。</p>
<h5 id="RPC-CAST"><a href="#RPC-CAST" class="headerlink" title="RPC.CAST"></a>RPC.CAST</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RPC.CAST</code> 的远程调用流程与 <code>RPC.CALL</code> 类似，只是<strong>缺少了系统消息响应流程</strong>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一个 <code>Topic</code> 消息生产者发送系统请求消息到<code>Topic</code> 交换器，<code>Topic</code> 交换器根据消息的<code>Routing Key</code>将消息转发至共享消息队列。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与共享消息队列相连的所有 <code>Topic</code>消费者接收该系统请求消息，并把它传递给响应的服务端进行处理。</p>
<p>其调用流程如图所示：</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9Hia4FsGJJN2d6RNDTvStloVXMxFCXtGWs5MDPxLvh80W7DfTfyjc2rQ.jpeg" alt="img"></p>
<p><em>图 18：RPC.CAST 原理图</em></p>
<h5 id="连接设计"><a href="#连接设计" class="headerlink" title="连接设计"></a>连接设计</h5><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>RabbitMQ</code> 实现的 <code>RPC</code> 对网络的一般设计思路：消费者是长连接，发送者是短连接</strong>。但可以自由控制长连接和短连接。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>一般消费者是长连接，随时准备接收处理消息</strong>；而且涉及到 <code>RabbitMQ Queues、Exchange 的 auto-deleted</code>等没特殊需求没必要做短连接。<strong>发送者可以使用短连接，不会长期占住端口号，节省端口资源</strong>。</p>
<p><code>Nova</code> 中 <code>RPC</code> 代码设计：</p>
<p><img src="//blog.com/2019/06/15/RPC框架原理/MOwlO0INfQpZNXFMFo4Q1cT6TaOiaicyG9ZyMHxa11kdWfQNibCMicicFRNvrmy0SI1uAe9adtibRHd1kXRvPzbx4ia3w.jpeg" alt="img"></p>
<h2 id="RESTful-API-架构"><a href="#RESTful-API-架构" class="headerlink" title="RESTful API 架构"></a>RESTful API 架构</h2><p><code>REST</code> 最大的几个特点为：<strong>资源、统一接口、URI 和无状态</strong>。</p>
<h3 id="①资源"><a href="#①资源" class="headerlink" title="①资源"></a>①资源</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，就是一个具体的实在。</p>
<h3 id="②统一接口"><a href="#②统一接口" class="headerlink" title="②统一接口"></a>②统一接口</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RESTful</code>架构风格规定，数据的元操作，即 <code>CRUD(Create，Read，Update 和 Delete</code>，即数据的增删查改)操作，分别对应于 HTTP 方法：GET 用来获取资源，POST 用来新建资源（也可以用于更新资源），PUT 用来更新资源，DELETE 用来删除资源，这样就统一了数据操作的接口，仅通过 HTTP 方法，就可以完成对数据的所有增删查改工作。</p>
<h3 id="③URL"><a href="#③URL" class="headerlink" title="③URL"></a>③URL</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以用一个 <code>URI</code>（统一资源定位符）指向资源，即每个 <code>URI</code> 都对应一个特定的资源。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;要获取这个资源，访问它的 <code>URI</code>就可以，因此<code>URI</code> 就成了每一个资源的地址或识别符。</p>
<h3 id="④无状态"><a href="#④无状态" class="headerlink" title="④无状态"></a>④无状态</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓无状态的，即所有的资源，都可以通过 <code>URI</code>定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而改变。有状态和无状态的区别，举个简单的例子说明一下。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如查询员工的工资，如果查询工资是需要登录系统，进入查询工资的页面，执行相关操作后，获取工资的多少，则这种情况是有状态的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为查询工资的每一步操作都依赖于前一步操作，只要前置操作不成功，后续操作就无法执行。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果输入一个 URI 即可得到指定员工的工资，则这种情况是无状态的，因为获取工资不依赖于其他资源或状态。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;且这种情况下，员工工资是一个资源，由一个 URI 与之对应，可以通过 HTTP 中的 GET 方法得到资源，这是典型的 <code>RESTful</code> 风格。</p>
<h2 id="RPC-和-Restful-API-对比"><a href="#RPC-和-Restful-API-对比" class="headerlink" title="RPC 和 Restful API 对比"></a>RPC 和 Restful API 对比</h2><h3 id="面对对象不同"><a href="#面对对象不同" class="headerlink" title="面对对象不同"></a>面对对象不同</h3><ul>
<li><code>RPC</code>更侧重于<strong>动作</strong>。</li>
<li><code>REST</code> 的主体是<strong>资源</strong>。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RESTful</code> 是面向资源的设计架构，但在系统中有很多对象不能抽象成资源，比如登录，修改密码等而 <code>RPC</code> 可以通过动作去操作资源。所以<strong>在操作的全面性上 RPC 大于 RESTful</strong>。</p>
<h3 id="传输效率"><a href="#传输效率" class="headerlink" title="传输效率"></a>传输效率</h3><ul>
<li><code>RPC</code> 效率更高。<code>RPC</code>，使用自定义的<code>TCP</code>协议，可以让请求报文体积更小，或者使用 <code>HTTP2</code> 协议，也可以很好的<strong>减少报文的体积，提高传输效率</strong>。</li>
</ul>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li><code>RPC</code> 实现复杂，流程繁琐。</li>
<li><code>REST</code> 调用及测试都很方便。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>RPC</code> 实现（参见第一节）需要实现编码，序列化，网络传输等。而<code>RESTful</code> 不要关注这些，<code>RESTful</code>实现更简单。</p>
<h3 id="灵活性"><a href="#灵活性" class="headerlink" title="灵活性"></a>灵活性</h3><ul>
<li><code>HTTP</code> 相对更规范，更标准，更通用，无论哪种语言都支持 <code>HTTP</code>协议。</li>
<li><code>RPC</code>可以实现跨语言调用，但整体灵活性不如 <code>RESTful</code>。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong><code>RPC</code> 主要用于公司内部的服务调用</strong>，性能消耗低，传输效率高，实现复杂。</p>
<p><strong><code>HTTP</code> 主要用于对外的异构环境</strong>，浏览器接口调用，App 接口调用，第三方接口调用等。</p>
<p><code>RPC</code> 使用场景（大型的网站，内部子系统较多、接口非常多的情况下适合使用 <code>RPC</code>）：</p>
<ul>
<li><strong>长链接。</strong>不必每次通信都要像 <code>HTTP</code> 一样去 3 次握手，减少了网络开销。</li>
<li><strong>注册发布机制。</strong>RPC 框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。</li>
<li><strong>安全性，</strong>没有暴露资源操作。</li>
<li><strong>微服务支持。</strong>就是最近流行的服务化架构、服务化治理，<code>RPC</code> 框架是一个强力的支撑。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/架构/" rel="tag"># 架构</a>
          
            <a href="/tags/RPC/" rel="tag"># RPC</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/15/柔性事务-最大努力通知/" rel="next" title="柔性事务-最大努力通知">
                <i class="fa fa-chevron-left"></i> 柔性事务-最大努力通知
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/15/分布式事务概述/" rel="prev" title="分布式事务概述">
                分布式事务概述 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">刘泽明</p>
              <p class="site-description motion-element" itemprop="description">做一个懂业务的程序员</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">731</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">394</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">237</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#RPC框架原理"><span class="nav-number">1.</span> <span class="nav-text">RPC框架原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#RPC介绍"><span class="nav-number">1.1.</span> <span class="nav-text">RPC介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#完整的-RPC-框架"><span class="nav-number">1.2.</span> <span class="nav-text">完整的 RPC 框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RPC-核心功能"><span class="nav-number">1.2.1.</span> <span class="nav-text">RPC 核心功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python-自带-RPC-Demo"><span class="nav-number">1.2.2.</span> <span class="nav-text">Python 自带 RPC Demo</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Wireshark-抓包分析过程"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">Wireshark 抓包分析过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#详细调用过程"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">详细调用过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RPC-核心之功能实现"><span class="nav-number">1.3.</span> <span class="nav-text">RPC 核心之功能实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#服务寻址"><span class="nav-number">1.3.1.</span> <span class="nav-text">服务寻址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#序列化和反序列化"><span class="nav-number">1.3.2.</span> <span class="nav-text">序列化和反序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络传输"><span class="nav-number">1.3.3.</span> <span class="nav-text">网络传输</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RPC-核心之网络传输协议"><span class="nav-number">1.4.</span> <span class="nav-text">RPC 核心之网络传输协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基于-TCP-协议的-RPC-调用"><span class="nav-number">1.4.1.</span> <span class="nav-text">基于 TCP 协议的 RPC 调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于-HTTP-协议的-RPC-调用"><span class="nav-number">1.4.2.</span> <span class="nav-text">基于 HTTP 协议的 RPC 调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-RabbitMQ-的-RPC-架构"><span class="nav-number">1.4.3.</span> <span class="nav-text">使用 RabbitMQ 的 RPC 架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RabbitMQ-简介"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">RabbitMQ 简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RabbitMQ-的三种类型的交换器"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">RabbitMQ 的三种类型的交换器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#①广播式交换器类型（Fanout）"><span class="nav-number">1.4.3.2.1.</span> <span class="nav-text">①广播式交换器类型（Fanout）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#③主题式交换器（Topic-Exchange）"><span class="nav-number">1.4.3.2.2.</span> <span class="nav-text">③主题式交换器（Topic Exchange）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于-RabbitMQ实现两种-RPC-调用"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">基于 RabbitMQ实现两种 RPC 调用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RPC-CALL"><span class="nav-number">1.4.3.3.1.</span> <span class="nav-text">RPC.CALL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RPC-CAST"><span class="nav-number">1.4.3.3.2.</span> <span class="nav-text">RPC.CAST</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#连接设计"><span class="nav-number">1.4.3.3.3.</span> <span class="nav-text">连接设计</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RESTful-API-架构"><span class="nav-number">1.5.</span> <span class="nav-text">RESTful API 架构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#①资源"><span class="nav-number">1.5.1.</span> <span class="nav-text">①资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#②统一接口"><span class="nav-number">1.5.2.</span> <span class="nav-text">②统一接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#③URL"><span class="nav-number">1.5.3.</span> <span class="nav-text">③URL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#④无状态"><span class="nav-number">1.5.4.</span> <span class="nav-text">④无状态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RPC-和-Restful-API-对比"><span class="nav-number">1.6.</span> <span class="nav-text">RPC 和 Restful API 对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#面对对象不同"><span class="nav-number">1.6.1.</span> <span class="nav-text">面对对象不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传输效率"><span class="nav-number">1.6.2.</span> <span class="nav-text">传输效率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复杂度"><span class="nav-number">1.6.3.</span> <span class="nav-text">复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#灵活性"><span class="nav-number">1.6.4.</span> <span class="nav-text">灵活性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">1.7.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘泽明</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
